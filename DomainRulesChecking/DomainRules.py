from tree_sitter_languages import get_parser
import tree_sitter



class DomainRules:
    def __init__(self, training_sample):
        self.training_sample = training_sample
        self.parser = get_parser("c")
        self.tree = None
    
    def making_tree(self):
        if isinstance(self.training_sample, str):
            self.training_sample = self.training_sample.encode()
        self.tree = self.parser.parse(self.training_sample)
        return self.tree

class PVS(DomainRules):
    def __init__(self, training_sample):
        super().__init__(training_sample)
        self.training_sample = training_sample
        
    def is_type(self, typename):
        def fn(n):
            return n.type == typename
        return fn

    def get_children(self, node, fn, reverse=False):
        it = node.children
        if reverse:
            it = reversed(it)
        if isinstance(fn, str):
            fn_str = str(fn)
            fn = lambda n: n.type == fn_str
        return [c for c in it if fn(c)]

    def get_child(self, node, fn, reverse=False):
        return next(iter(self.get_children(node, fn, reverse=reverse)), None)

    def get_child_at_index(self, node, i):
        c = node.children[i]
        while c.type == "comment":
            i += 1
            c = node.children[i]
        return c

    def serialize_node(self, node):
        return {
            "text": node.text.decode(),
            "start_point": node.start_point,
            "end_point": node.end_point,
            "id": node.id,
        }


    def mark_tokens(self, n, abstract=False):
        if n.type == "call_expression":
            ident = self.get_child(n, "identifier")
            args = self.get_child(n, "argument_list")
            assert args is not None, ("call", n, n.children)
            if ident is None:
                pass
            else:
                ident_name = ident.text.decode()
                alloc = [
                    "malloc",
                    "calloc",
                    "realloc",
                    "kalloc",
                    "kcalloc",
                    "krealloc",
                    "valloc",
                    "vcalloc",
                    "vrealloc",
                ]

                free = [
                    "free",
                    "kfree",
                    "free_sized",
                    "free_aligned_sized",
                ]

                bof = [
                    "gets",
                    "puts",
                    "scanf",
                    "sprintf",
                    "strlen",
                    "strcpy",
                    "strncpy",
                    "strcat",
                    "strncat",
                ]
                if ident_name in alloc:
                    return True
                elif ident_name in free:
                    return True
                elif ident_name in bof:
                    return True
                else:
                    return False
        # assignment expression
        elif n.type in ("init_declarator", "assignment_expression"):
            # get and mark '=' sign
            operator = self.get_child_at_index(n, 1)
            assert not operator.is_named, ("assignment", n, n.children)
            if operator.type in ("+=", "-="):
                return True
            if operator.type in ("/=", "%="):
                return True
        # binary operator expression
        elif n.type in ("update_expression",):
            operator = self.get_child(n, lambda c: c.type in ("++", "--"))
            assert not operator.is_named, ("update", n, n.children)
            return True
        elif n.type in ("binary_expression",):
            operator = self.get_child_at_index(n, 1)
            assert not operator.is_named, ("binary_operator", n, n.children)
            if operator.type in ("+", "-", "*"):
                return True
            if operator.type in ("/", "%"):
                return True
        # array/pointer operator expression (*, ->, [])
        elif n.type in ("pointer_expression"):
            operator = self.get_child_at_index(n, 0)
            if operator.type in ("pointer_expression", "&"):
                return False
            assert operator.type == "*", ("*", n, n.children)
            return True
        
        elif n.type in ("field_expression"):
            operator = self.get_child_at_index(n, 1)
            if operator.type in (".",):
                return False
            assert operator.type == "->", ("->", n, n.children)
            return True
        
        elif n.type in ("subscript_expression"):
            operator1 = self.get_child_at_index(n, 1)
            operator2 = self.get_child_at_index(n, 3)
            assert operator1.type == "[" and operator2.type == "]", ("index", n, n.children)
            return True
        
        else:
            return False
            
    def walk(self, tree, abstract=False, enter_compound=True):
        if isinstance(tree, tree_sitter.Tree):
            root = tree.root_node
        else:
            root = tree
        q = [(root, 0)]
        
        mark=[]
        while len(q) > 0:
            n, indent = q.pop()
            try:
                mt=self.mark_tokens(n, abstract=abstract)
            except AssertionError as e:
                if not any(c.has_error for c in n.children):
                    print("***AssertionError***", e)
                mt = None
            if mt is not None:
                mark.append(mt)
            if n.type not in ("string_literal", "char_literal"):
                if n.type == "compound_statement" and not enter_compound:
                    continue
                next_indent = [indent + 1] * len(n.children)
                q.extend(reversed(list(zip(n.children, next_indent))))
        return mark

    def get_pvs_v2(self, abstract=False):
        self.tree = self.making_tree()
        self.pvs = self.walk(self.tree, abstract=abstract, enter_compound=True)
        pvs_detected = any(self.pvs)  # Check if any mark is True in the list
        return pvs_detected
