from tree_sitter_languages import get_parser
import tree_sitter



class DomainRules:
    def __init__(self, training_sample):
        self.training_sample = training_sample
        self.parser = get_parser("c")
        self.tree = None
    
    def making_tree(self):
        if isinstance(self.training_sample, str):
            self.training_sample = self.training_sample.encode()
        self.tree = self.parser.parse(self.training_sample)
        return self.tree

class PVS(DomainRules):
    def __init__(self, training_sample):
        super().__init__(training_sample)
        self.training_sample = training_sample
        
    def is_type(self,typename):
        def fn(n):
            return n.type == typename
        return fn

    def get_children(self, node, fn, reverse=False):
        it = node.children
        if reverse:
            it = reversed(it)
        if isinstance(fn, str):
            fn_str = str(fn)
            fn = lambda n: n.type == fn_str
        return [c for c in it if fn(c)]

    def get_child(self,node, fn, reverse=False):
        return next(iter(self.get_children(node, fn, reverse=reverse)), None)

    def get_child_at_index(self, node, i):
        c = node.children[i]
        while c.type == "comment":
            i += 1
            c = node.children[i]
        return c

    def serialize_node(self, node):
        return {
            "text": node.text.decode(),
            "start_point": node.start_point,
            "end_point": node.end_point,
            "id": node.id,
        }

    def mark_tokens(self, n, abstract=False):
        # call expression
        if n.type == "call_expression":
            ident = self.get_child(n, "identifier")
            args =self.get_child(n, "argument_list")
            assert args is not None, ("call", n, n.children)
            # left_parens = get_child(args, "(")
            # assert left_parens is not None and left_parens.type == "(", ("call", n, n.children)
            # right_parens = get_child(args, ")")
            # assert right_parens is not None and right_parens.type == ")", ("call", n, n.children)
            if ident is None:
                # print("No identifier:", n.text.decode())
                pass
            else:
                ident_name = ident.text.decode()
                alloc = [
                    "malloc",
                    "calloc",
                    "realloc",
                    "kalloc",
                    "kcalloc",
                    "krealloc",
                    "valloc",
                    "vcalloc",
                    "vrealloc",
                ]

                free = [
                    "free",
                    "kfree",
                    "free_sized",
                    "free_aligned_sized",
                ]

                bof = [
                    "gets",
                    "puts",
                    "scanf",
                    "sprintf",
                    "strlen",
                    "strcpy",
                    "strncpy",
                    "strcat",
                    "strncat",
                ]
                if ident_name in alloc:
                    kind = "alloc"
                elif ident_name in free:
                    kind = "free"
                elif ident_name in bof:
                    kind = "overflow"
                else:
                    return
                return {
                    "kind": kind,
                    "parent": self.serialize_node(n),
                    "tokens": [
                        {
                            "kind": "identifier",
                            "token": self.serialize_node(ident),
                        },
                        # {
                        #     "kind": "lparens",
                        #     "token": serialize_node(left_parens),
                        # },
                        # {
                        #     "kind": "rparens",
                        #     "token": serialize_node(right_parens),
                        # },
                    ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
                }
        # assignment expression
        elif n.type in ("init_declarator", "assignment_expression"):
            # get and mark '=' sign
            operator = self.get_child_at_index(n, 1)
            assert not operator.is_named, ("assignment", n, n.children)
            if operator.type in ("+=", "-=",):
                return {
                    "kind": "overflow/underflow",
                    "parent": self.serialize_node(n),
                    "tokens": [
                        {
                            "kind": "operator",
                            "token": self.serialize_node(operator),
                        }
                    ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
                }
            if operator.type in ("/=", "%=",):
                return {
                    "kind": "divide by zero",
                    "parent": self.serialize_node(n),
                    "tokens": [
                        {
                            "kind": "operator",
                            "token": self.serialize_node(operator),
                        }
                    ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
                }
        # binary operator expression
        elif n.type in ("update_expression",):
            operator = self.get_child(n, lambda c: c.type in ("++", "--"))
            assert not operator.is_named, ("update", n, n.children)

            return {
                "kind": "overflow/underflow",
                "parent": self.serialize_node(n),
                "tokens": [
                    {
                        "kind": "operator",
                        "token": self.serialize_node(operator),
                    }
                ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
            }
        elif n.type in ("binary_expression",):
            operator = self.get_child_at_index(n, 1)
            assert not operator.is_named, ("binary_operator", n, n.children)
            if operator.type in ("+", "-", "*",):
                return {
                    "kind": "overflow/underflow",
                    "parent": self.serialize_node(n),
                    "tokens": [
                        {
                            "kind": "operator",
                            "token": self.serialize_node(operator),
                        }
                    ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
                }
            if operator.type in ("/", "%",):
                return {
                    "kind": "divide by zero",
                    "parent": self.serialize_node(n),
                    "tokens": [
                        {
                            "kind": "operator",
                            "token": self.serialize_node(operator),
                        }
                    ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
                }
        # array/pointer operator expression (*, ->, [])
        elif n.type in ("pointer_expression"):
            operator = self.get_child_at_index(n, 0)
            if operator.type in ("pointer_expression", "&"):
                return
            assert operator.type == "*", ("*", n, n.children)

            return {
                "kind": "dereference",
                "parent": self.serialize_node(n),
                "tokens": [
                    {
                        "kind": "star",
                        "token": self.serialize_node(operator),
                    }
                ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
            }
        elif n.type in ("field_expression"):
            operator = self.get_child_at_index(n, 1)
            if operator.type in (".",):
                return
            assert operator.type == "->", ("->", n, n.children)

            return {
                "kind": "field",
                "parent": self.serialize_node(n),
                "tokens": [
                    {
                        "kind": "arrow",
                        "token": self.serialize_node(operator),
                    }
                ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
            }
        elif n.type in ("subscript_expression"):
            operator1 = self.get_child_at_index(n, 1)
            operator2 = self.get_child_at_index(n, 3)
            assert operator1.type == "[" and operator2.type == "]", ("index", n, n.children)

            return {
                "kind": "index",
                "parent": self.serialize_node(n),
                "tokens": [
                    {
                        "kind": "lbracket",
                        "token": self.serialize_node(operator1),
                    },
                    {
                        "kind": "rbracket",
                        "token": self.serialize_node(operator2),
                    }
                ] if abstract else [{"kind": "child", "token": self.serialize_node(c)} for c in self.dfs(n)]
            }
            
    '''def dfs(self, node):
        stack = [node]
        while stack:
            current_node = stack.pop()
            yield current_node
            stack.extend(current_node.children)'''
            
    def dfs(self, node, visited=None):
        if visited is None:
            visited = set()

        if node.id in visited:
            return

        visited.add(node.id)
        
        # Only yield terminal nodes (tokens)
        if node.is_named:
            yield node

        for child in node.children:
            yield from self.dfs(child, visited)


    def walk(self, tree, abstract=False, enter_compound=True):
        if isinstance(tree, tree_sitter.Tree):
            root = tree.root_node
        else:
            root = tree
        marked_tokens = []
        q = [(root, 0)]
        while len(q) > 0:
            n, indent = q.pop()
            try:
                mt = self.mark_tokens(n, abstract=abstract)
            except AssertionError as e:
                if not any(c.has_error for c in n.children):
                    print("***AssertionError***", e)
                mt = None
            if mt is not None:
                # print("***Marked token***", mt)
                marked_tokens.append(mt)
            if n.type not in ("string_literal", "char_literal"):
                if n.type == "compound_statement" and not enter_compound:
                    continue
                next_indent = [indent+1] * len(n.children)
                q.extend(reversed(list(zip(n.children, next_indent))))
        return marked_tokens


    def to_marked_ids(self, pvs):
        for m in pvs:
            for tok in m["tokens"]:
                yield tok["token"]["id"]

    def get_pvs_v2(self, abstract=False):
        self.tree = self.making_tree()
        # print_tree(tree.root_node)
        self.root=self.tree.root_node
        ns = list(self.dfs(self.root))
        pvs = self.walk(self.tree, abstract=abstract, enter_compound=True)
        print(f"Printing pvs here: {pvs}")
        marked_ids = set(self.to_marked_ids(pvs))
        pvs_map = [1 if n.id in marked_ids else 0 for n in ns]
        ast_tokens = [n.text.decode() for n in ns]
        number_of_pvs_tokens=pvs_map.count(1)
        probability_PVS=number_of_pvs_tokens/len(ast_tokens)
        print(f"pvs: {pvs_map} and total tokens {len(ast_tokens)} and pvs tokens {pvs_map} and length of pvs tokens {len(pvs_map)}")
        return probability_PVS
    
    def get_pvs_lines(self, abstract=False):
        self.tree = self.making_tree()
        # print_tree(tree.root_node)
        self.root=self.tree.root_node
        ns = list(self.dfs(self.root))
        pvs = self.walk(self.tree, abstract=abstract, enter_compound=True)
        marked_ids = set(self.to_marked_ids(pvs))
        pvs_map = [1 if n.id in marked_ids else 0 for n in ns]
        
        training_sample_str=self.training_sample.decode()
        
        code_lines=training_sample_str.split("\n")
        
        pvs_lines=0
        
        for line, pvs_tokens in zip(code_lines, pvs_map):
            print(f"Printing Lines:{line}")
            print(f"Printing Tokens:{pvs_tokens}")
            print()
        
        print(pvs_lines)
        
