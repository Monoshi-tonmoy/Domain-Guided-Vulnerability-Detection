from DomainRules import DomainRules, PVS

def main():
    sample1="""int main(int argc, char **argv)
{
    int x = 10 + 100;       // immediate expression - easy to filter out
    int y = 10 + x;         // not immediate but known provenance
    int z = 10 + y + argc;  // unknown provenance
    char *s = (char *)malloc(z + y + x);
    s[10] = 'a';
    int result = (int)s[10];
    printf("%c\n", *s);
    free(s);
    free(s);
    s = 0;
    s += 1;
    s++;
    struct foo* ss;
    ss->bar = x;
    *ss.baz = y;
    return result;
}
"""
    sample="""int main()
        {
            int a;
            scanf("%d",&a);
            printf(a);
        }
    """
    
    code="""static av_cold int vdadec_init(AVCodecContext *avctx)\n\n{\n\n    VDADecoderContext *ctx = avctx->priv_data;\n\n    struct vda_context *vda_ctx = &ctx->vda_ctx;\n\n    OSStatus status;\n\n    int ret;\n\n\n\n    ctx->h264_initialized = 0;\n\n\n\n    /* init pix_fmts of codec */\n\n    if (!ff_h264_vda_decoder.pix_fmts) {\n\n        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;\n\n        else\n\n            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;\n\n    }\n\n\n\n    /* init vda */\n\n    memset(vda_ctx, 0, sizeof(struct vda_context));\n\n    vda_ctx->width = avctx->width;\n\n    vda_ctx->height = avctx->height;\n\n    vda_ctx->format = 'avc1';\n\n    vda_ctx->use_sync_decoding = 1;\n\n    vda_ctx->use_ref_buffer = 1;\n\n    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);\n\n    switch (ctx->pix_fmt) {\n\n    case AV_PIX_FMT_UYVY422:\n\n        vda_ctx->cv_pix_fmt_type = '2vuy';\n\n        break;\n\n    case AV_PIX_FMT_YUYV422:\n\n        vda_ctx->cv_pix_fmt_type = 'yuvs';\n\n        break;\n\n    case AV_PIX_FMT_NV12:\n\n        vda_ctx->cv_pix_fmt_type = '420v';\n\n        break;\n\n    case AV_PIX_FMT_YUV420P:\n\n        vda_ctx->cv_pix_fmt_type = 'y420';\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format: %d\\n\", avctx->pix_fmt);\n\n        goto failed;\n\n    }\n\n    status = ff_vda_create_decoder(vda_ctx,\n\n                                   avctx->extradata, avctx->extradata_size);\n\n    if (status != kVDADecoderNoErr) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n                \"Failed to init VDA decoder: %d.\\n\", status);\n\n        goto failed;\n\n    }\n\n    avctx->hwaccel_context = vda_ctx;\n\n\n\n    /* changes callback functions */\n\n    avctx->get_format = get_format;\n\n    avctx->get_buffer2 = get_buffer2;\n\n#if FF_API_GET_BUFFER\n\n    // force the old get_buffer to be empty\n\n    avctx->get_buffer = NULL;\n\n#endif\n\n\n\n    /* init H.264 decoder */\n\n    ret = ff_h264_decoder.init(avctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 decoder.\\n\");\n\n        goto failed;\n\n    }\n\n    ctx->h264_initialized = 1;\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    vdadec_close(avctx);\n\n    return -1;\n\n}\n"""
    
    code_snippet = """static av_cold int vdadec_init(AVCodecContext *avctx)
    {
        VDADecoderContext *ctx = avctx->priv_data;
        struct vda_context *vda_ctx = &ctx->vda_ctx;
        OSStatus status;
        int ret;

        ctx->h264_initialized = 0;

        /* init pix_fmts of codec */
        if (!ff_h264_vda_decoder.pix_fmts) {
            if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)
                ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;
            else
                ff_h264_vda_decoder.pix_fmts = vda_pixfmts;
        }

        /* init vda */
        memset(vda_ctx, 0, sizeof(struct vda_context));
        vda_ctx->width = avctx->width;
        vda_ctx->height = avctx->height;
        vda_ctx->format = 'avc1';
        vda_ctx->use_sync_decoding = 1;
        vda_ctx->use_ref_buffer = 1;
        ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);
        switch (ctx->pix_fmt) {
        case AV_PIX_FMT_UYVY422:
            vda_ctx->cv_pix_fmt_type = '2vuy';
            break;
        case AV_PIX_FMT_YUYV422:
            vda_ctx->cv_pix_fmt_type = 'yuvs';
            break;
        case AV_PIX_FMT_NV12:
            vda_ctx->cv_pix_fmt_type = '420v';
            break;
        case AV_PIX_FMT_YUV420P:
            vda_ctx->cv_pix_fmt_type = 'y420';
            break;
        default:
            av_log(avctx, AV_LOG_ERROR, "Unsupported pixel format: %d\n", avctx->pix_fmt);
            goto failed;
        }
        status = ff_vda_create_decoder(vda_ctx,
                                    avctx->extradata, avctx->extradata_size);
        if (status != kVDADecoderNoErr) {
            av_log(avctx, AV_LOG_ERROR,
                    "Failed to init VDA decoder: %d.\n", status);
            goto failed;
        }
        avctx->hwaccel_context = vda_ctx;

        /* changes callback functions */
        avctx->get_format = get_format;
        avctx->get_buffer2 = get_buffer2;
    #if FF_API_GET_BUFFER
        // force the old get_buffer to be empty
        avctx->get_buffer = NULL;
    #endif

        /* init H.264 decoder */
        ret = ff_h264_decoder.init(avctx);
        if (ret < 0) {
            av_log(avctx, AV_LOG_ERROR, "Failed to open H.264 decoder.\n");
            goto failed;
        }
        ctx->h264_initialized = 1;

        return 0;

    failed:
        vdadec_close(avctx);
        return -1;
    }"""
    
    
    code_3="""static void v4l2_free_buffer(void *opaque, uint8_t *unused)

{

    V4L2Buffer* avbuf = opaque;

    V4L2m2mContext *s = buf_to_m2mctx(avbuf);



    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {

        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);



        if (s->reinit) {

            if (!atomic_load(&s->refcount))

                sem_post(&s->refsync);

        } else if (avbuf->context->streamon)

            ff_v4l2_buffer_enqueue(avbuf);



        av_buffer_unref(&avbuf->context_ref);

    }

}"""
    print(sample1.split())
    sample2=' '.join(sample1.split())
    
    print(sample1)
    print(sample2)
    
    
    rules=PVS(sample2)

    
    result=rules.get_pvs_v2()
    #pvs_lines=rules.get_pvs_lines()
    
    #print(pvs_lines)
    print(result)
    
    #print(ast_tokens)
    #print(pvs_maps)

if __name__ == "__main__":
    main()

