code:static av_cold int vdadec_init(AVCodecContext *avctx)

{

    VDADecoderContext *ctx = avctx->priv_data;

    struct vda_context *vda_ctx = &ctx->vda_ctx;

    OSStatus status;

    int ret;



    ctx->h264_initialized = 0;



    /* init pix_fmts of codec */

    if (!ff_h264_vda_decoder.pix_fmts) {

        if (kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7)

            ff_h264_vda_decoder.pix_fmts = vda_pixfmts_prior_10_7;

        else

            ff_h264_vda_decoder.pix_fmts = vda_pixfmts;

    }



    /* init vda */

    memset(vda_ctx, 0, sizeof(struct vda_context));

    vda_ctx->width = avctx->width;

    vda_ctx->height = avctx->height;

    vda_ctx->format = 'avc1';

    vda_ctx->use_sync_decoding = 1;

    vda_ctx->use_ref_buffer = 1;

    ctx->pix_fmt = avctx->get_format(avctx, avctx->codec->pix_fmts);

    switch (ctx->pix_fmt) {

    case AV_PIX_FMT_UYVY422:

        vda_ctx->cv_pix_fmt_type = '2vuy';

        break;

    case AV_PIX_FMT_YUYV422:

        vda_ctx->cv_pix_fmt_type = 'yuvs';

        break;

    case AV_PIX_FMT_NV12:

        vda_ctx->cv_pix_fmt_type = '420v';

        break;

    case AV_PIX_FMT_YUV420P:

        vda_ctx->cv_pix_fmt_type = 'y420';

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, "Unsupported pixel format: %d\n", avctx->pix_fmt);

        goto failed;

    }

    status = ff_vda_create_decoder(vda_ctx,

                                   avctx->extradata, avctx->extradata_size);

    if (status != kVDADecoderNoErr) {

        av_log(avctx, AV_LOG_ERROR,

                "Failed to init VDA decoder: %d.\n", status);

        goto failed;

    }

    avctx->hwaccel_context = vda_ctx;



    /* changes callback functions */

    avctx->get_format = get_format;

    avctx->get_buffer2 = get_buffer2;

#if FF_API_GET_BUFFER

    // force the old get_buffer to be empty

    avctx->get_buffer = NULL;

#endif



    /* init H.264 decoder */

    ret = ff_h264_decoder.init(avctx);

    if (ret < 0) {

        av_log(avctx, AV_LOG_ERROR, "Failed to open H.264 decoder.\n");

        goto failed;

    }

    ctx->h264_initialized = 1;



    return 0;



failed:

    vdadec_close(avctx);

    return -1;

}
 and probability:0.3181818181818182
code:static int transcode(AVFormatContext **output_files,

                     int nb_output_files,

                     InputFile *input_files,

                     int nb_input_files,

                     StreamMap *stream_maps, int nb_stream_maps)

{

    int ret = 0, i, j, k, n, nb_ostreams = 0, step;



    AVFormatContext *is, *os;

    AVCodecContext *codec, *icodec;

    OutputStream *ost, **ost_table = NULL;

    InputStream *ist;

    char error[1024];

    int key;

    int want_sdp = 1;

    uint8_t no_packet[MAX_FILES]={0};

    int no_packet_count=0;

    int nb_frame_threshold[AVMEDIA_TYPE_NB]={0};

    int nb_streams[AVMEDIA_TYPE_NB]={0};



    if (rate_emu)

        for (i = 0; i < nb_input_streams; i++)

            input_streams[i].start = av_gettime();



    /* output stream init */

    nb_ostreams = 0;

    for(i=0;i<nb_output_files;i++) {

        os = output_files[i];

        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {

            av_dump_format(output_files[i], i, output_files[i]->filename, 1);

            fprintf(stderr, "Output file #%d does not contain any stream\n", i);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        nb_ostreams += os->nb_streams;

    }

    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {

        fprintf(stderr, "Number of stream maps must match number of output streams\n");

        ret = AVERROR(EINVAL);

        goto fail;

    }



    /* Sanity check the mapping args -- do the input files & streams exist? */

    for(i=0;i<nb_stream_maps;i++) {

        int fi = stream_maps[i].file_index;

        int si = stream_maps[i].stream_index;



        if (fi < 0 || fi > nb_input_files - 1 ||

            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {

            fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        fi = stream_maps[i].sync_file_index;

        si = stream_maps[i].sync_stream_index;

        if (fi < 0 || fi > nb_input_files - 1 ||

            si < 0 || si > input_files[fi].ctx->nb_streams - 1) {

            fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);

            ret = AVERROR(EINVAL);

            goto fail;

        }

    }



    ost_table = av_mallocz(sizeof(OutputStream *) * nb_ostreams);

    if (!ost_table)

        goto fail;



    for(k=0;k<nb_output_files;k++) {

        os = output_files[k];

        for(i=0;i<os->nb_streams;i++,n++) {

            nb_streams[os->streams[i]->codec->codec_type]++;

        }

    }

    for(step=1<<30; step; step>>=1){

        int found_streams[AVMEDIA_TYPE_NB]={0};

        for(j=0; j<AVMEDIA_TYPE_NB; j++)

            nb_frame_threshold[j] += step;



        for(j=0; j<nb_input_streams; j++) {

            int skip=0;

            ist = &input_streams[j];

            if(opt_programid){

                int pi,si;

                AVFormatContext *f= input_files[ ist->file_index ].ctx;

                skip=1;

                for(pi=0; pi<f->nb_programs; pi++){

                    AVProgram *p= f->programs[pi];

                    if(p->id == opt_programid)

                        for(si=0; si<p->nb_stream_indexes; si++){

                            if(f->streams[ p->stream_index[si] ] == ist->st)

                                skip=0;

                        }

                }

            }

            if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip

                && nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames){

                found_streams[ist->st->codec->codec_type]++;

            }

        }

        for(j=0; j<AVMEDIA_TYPE_NB; j++)

            if(found_streams[j] < nb_streams[j])

                nb_frame_threshold[j] -= step;

    }

    n = 0;

    for(k=0;k<nb_output_files;k++) {

        os = output_files[k];

        for(i=0;i<os->nb_streams;i++,n++) {

            int found;

            ost = ost_table[n] = output_streams_for_file[k][i];

            if (nb_stream_maps > 0) {

                ost->source_index = input_files[stream_maps[n].file_index].ist_index +

                    stream_maps[n].stream_index;



                /* Sanity check that the stream types match */

                if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {

                    int i= ost->file_index;

                    av_dump_format(output_files[i], i, output_files[i]->filename, 1);

                    fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",

                        stream_maps[n].file_index, stream_maps[n].stream_index,

                        ost->file_index, ost->index);

                    ffmpeg_exit(1);

                }



            } else {

                /* get corresponding input stream index : we select the first one with the right type */

                found = 0;

                for (j = 0; j < nb_input_streams; j++) {

                    int skip=0;

                    ist = &input_streams[j];

                    if(opt_programid){

                        int pi,si;

                        AVFormatContext *f = input_files[ist->file_index].ctx;

                        skip=1;

                        for(pi=0; pi<f->nb_programs; pi++){

                            AVProgram *p= f->programs[pi];

                            if(p->id == opt_programid)

                                for(si=0; si<p->nb_stream_indexes; si++){

                                    if(f->streams[ p->stream_index[si] ] == ist->st)

                                        skip=0;

                                }

                        }

                    }

                    if (ist->discard && ist->st->discard != AVDISCARD_ALL && !skip &&

                        ist->st->codec->codec_type == ost->st->codec->codec_type &&

                        nb_frame_threshold[ist->st->codec->codec_type] <= ist->st->codec_info_nb_frames) {

                            ost->source_index = j;

                            found = 1;

                            break;

                    }

                }



                if (!found) {

                    if(! opt_programid) {

                        /* try again and reuse existing stream */

                        for (j = 0; j < nb_input_streams; j++) {

                            ist = &input_streams[j];

                            if (   ist->st->codec->codec_type == ost->st->codec->codec_type

                                && ist->st->discard != AVDISCARD_ALL) {

                                ost->source_index = j;

                                found = 1;

                            }

                        }

                    }

                    if (!found) {

                        int i= ost->file_index;

                        av_dump_format(output_files[i], i, output_files[i]->filename, 1);

                        fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",

                                ost->file_index, ost->index);

                        ffmpeg_exit(1);

                    }

                }

            }

            ist = &input_streams[ost->source_index];

            ist->discard = 0;

            ost->sync_ist = (nb_stream_maps > 0) ?

                &input_streams[input_files[stream_maps[n].sync_file_index].ist_index +

                         stream_maps[n].sync_stream_index] : ist;

        }

    }



    /* for each output stream, we compute the right encoding parameters */

    for(i=0;i<nb_ostreams;i++) {

        ost = ost_table[i];

        os = output_files[ost->file_index];

        ist = &input_streams[ost->source_index];



        codec = ost->st->codec;

        icodec = ist->st->codec;



        if (metadata_streams_autocopy)

            av_dict_copy(&ost->st->metadata, ist->st->metadata,

                         AV_DICT_DONT_OVERWRITE);



        ost->st->disposition = ist->st->disposition;

        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;

        codec->chroma_sample_location = icodec->chroma_sample_location;



        if (ost->st->stream_copy) {

            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;



            if (extra_size > INT_MAX)

                goto fail;



            /* if stream_copy is selected, no need to decode or encode */

            codec->codec_id = icodec->codec_id;

            codec->codec_type = icodec->codec_type;



            if(!codec->codec_tag){

                if(   !os->oformat->codec_tag

                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id

                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)

                    codec->codec_tag = icodec->codec_tag;

            }



            codec->bit_rate = icodec->bit_rate;

            codec->rc_max_rate    = icodec->rc_max_rate;

            codec->rc_buffer_size = icodec->rc_buffer_size;

            codec->extradata= av_mallocz(extra_size);

            if (!codec->extradata)

                goto fail;

            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);

            codec->extradata_size= icodec->extradata_size;

            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){

                codec->time_base = icodec->time_base;

                codec->time_base.num *= icodec->ticks_per_frame;

                av_reduce(&codec->time_base.num, &codec->time_base.den,

                          codec->time_base.num, codec->time_base.den, INT_MAX);

            }else

                codec->time_base = ist->st->time_base;

            switch(codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                if(audio_volume != 256) {

                    fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");

                    ffmpeg_exit(1);

                }

                codec->channel_layout = icodec->channel_layout;

                codec->sample_rate = icodec->sample_rate;

                codec->channels = icodec->channels;

                codec->frame_size = icodec->frame_size;

                codec->audio_service_type = icodec->audio_service_type;

                codec->block_align= icodec->block_align;

                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)

                    codec->block_align= 0;

                if(codec->codec_id == CODEC_ID_AC3)

                    codec->block_align= 0;

                break;

            case AVMEDIA_TYPE_VIDEO:

                codec->pix_fmt = icodec->pix_fmt;

                codec->width = icodec->width;

                codec->height = icodec->height;

                codec->has_b_frames = icodec->has_b_frames;

                if (!codec->sample_aspect_ratio.num) {

                    codec->sample_aspect_ratio =

                    ost->st->sample_aspect_ratio =

                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :

                        ist->st->codec->sample_aspect_ratio.num ?

                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};

                }

                break;

            case AVMEDIA_TYPE_SUBTITLE:

                codec->width = icodec->width;

                codec->height = icodec->height;

                break;

            case AVMEDIA_TYPE_DATA:

                break;

            default:

                abort();

            }

        } else {

            if (!ost->enc)

                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);

            switch(codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                ost->fifo= av_fifo_alloc(1024);

                if(!ost->fifo)

                    goto fail;

                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);

                if (!codec->sample_rate) {

                    codec->sample_rate = icodec->sample_rate;

                    if (icodec->lowres)

                        codec->sample_rate >>= icodec->lowres;

                }

                choose_sample_rate(ost->st, ost->enc);

                codec->time_base = (AVRational){1, codec->sample_rate};

                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)

                    codec->sample_fmt = icodec->sample_fmt;

                choose_sample_fmt(ost->st, ost->enc);

                if (!codec->channels) {

                    codec->channels = icodec->channels;

                    codec->channel_layout = icodec->channel_layout;

                }

                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)

                    codec->channel_layout = 0;

                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;

                icodec->request_channels = codec->channels;

                ist->decoding_needed = 1;

                ost->encoding_needed = 1;

                ost->resample_sample_fmt  = icodec->sample_fmt;

                ost->resample_sample_rate = icodec->sample_rate;

                ost->resample_channels    = icodec->channels;

                break;

            case AVMEDIA_TYPE_VIDEO:

                if (codec->pix_fmt == PIX_FMT_NONE)

                    codec->pix_fmt = icodec->pix_fmt;

                choose_pixel_fmt(ost->st, ost->enc);



                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {

                    fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");

                    ffmpeg_exit(1);

                }

                ost->video_resample = codec->width   != icodec->width  ||

                                      codec->height  != icodec->height ||

                                      codec->pix_fmt != icodec->pix_fmt;

                if (ost->video_resample) {

                    codec->bits_per_raw_sample= frame_bits_per_raw_sample;

                }

                if (!codec->width || !codec->height) {

                    codec->width  = icodec->width;

                    codec->height = icodec->height;

                }

                ost->resample_height = icodec->height;

                ost->resample_width  = icodec->width;

                ost->resample_pix_fmt= icodec->pix_fmt;

                ost->encoding_needed = 1;

                ist->decoding_needed = 1;



                if (!ost->frame_rate.num)

                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};

                if (ost->enc && ost->enc->supported_framerates && !force_fps) {

                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);

                    ost->frame_rate = ost->enc->supported_framerates[idx];

                }

                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};

                if(   av_q2d(codec->time_base) < 0.001 && video_sync_method

                   && (video_sync_method==1 || (video_sync_method<0 && !(os->oformat->flags & AVFMT_VARIABLE_FPS)))){

                    av_log(os, AV_LOG_WARNING, "Frame rate very high for a muxer not effciciently supporting it.\n"

                                               "Please consider specifiying a lower framerate, a different muxer or -vsync 2\n");

                }



#if CONFIG_AVFILTER

                if (configure_video_filters(ist, ost)) {

                    fprintf(stderr, "Error opening filters!\n");

                    exit(1);

                }

#endif

                break;

            case AVMEDIA_TYPE_SUBTITLE:

                ost->encoding_needed = 1;

                ist->decoding_needed = 1;

                break;

            default:

                abort();

                break;

            }

            /* two pass mode */

            if (ost->encoding_needed && codec->codec_id != CODEC_ID_H264 &&

                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {

                char logfilename[1024];

                FILE *f;



                snprintf(logfilename, sizeof(logfilename), "%s-%d.log",

                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,

                         i);

                if (codec->flags & CODEC_FLAG_PASS1) {

                    f = fopen(logfilename, "wb");

                    if (!f) {

                        fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));

                        ffmpeg_exit(1);

                    }

                    ost->logfile = f;

                } else {

                    char  *logbuffer;

                    size_t logbuffer_size;

                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {

                        fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);

                        ffmpeg_exit(1);

                    }

                    codec->stats_in = logbuffer;

                }

            }

        }

        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){

            /* maximum video buffer size is 6-bytes per pixel, plus DPX header size */

            int size= codec->width * codec->height;

            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);

        }

    }



    if (!bit_buffer)

        bit_buffer = av_malloc(bit_buffer_size);

    if (!bit_buffer) {

        fprintf(stderr, "Cannot allocate %d bytes output buffer\n",

                bit_buffer_size);

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    /* open each encoder */

    for(i=0;i<nb_ostreams;i++) {

        ost = ost_table[i];

        if (ost->encoding_needed) {

            AVCodec *codec = ost->enc;

            AVCodecContext *dec = input_streams[ost->source_index].st->codec;

            if (!codec) {

                snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",

                         ost->st->codec->codec_id, ost->file_index, ost->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            if (dec->subtitle_header) {

                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);

                if (!ost->st->codec->subtitle_header) {

                    ret = AVERROR(ENOMEM);

                    goto dump_format;

                }

                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);

                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;

            }

            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {

                snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",

                        ost->file_index, ost->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            assert_codec_experimental(ost->st->codec, 1);

            assert_avoptions(ost->opts);

            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)

                av_log(NULL, AV_LOG_WARNING, "The bitrate parameter is set too low."

                                             "It takes bits/s as argument, not kbits/s\n");

            extra_size += ost->st->codec->extradata_size;

        }

    }



    /* open each decoder */

    for (i = 0; i < nb_input_streams; i++) {

        ist = &input_streams[i];

        if (ist->decoding_needed) {

            AVCodec *codec = ist->dec;

            if (!codec)

                codec = avcodec_find_decoder(ist->st->codec->codec_id);

            if (!codec) {

                snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",

                        ist->st->codec->codec_id, ist->file_index, ist->st->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {

                snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",

                        ist->file_index, ist->st->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            assert_codec_experimental(ist->st->codec, 0);

            assert_avoptions(ost->opts);

            //if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO)

            //    ist->st->codec->flags |= CODEC_FLAG_REPEAT_FIELD;

        }

    }



    /* init pts */

    for (i = 0; i < nb_input_streams; i++) {

        AVStream *st;

        ist = &input_streams[i];

        st= ist->st;

        ist->pts = st->avg_frame_rate.num ? - st->codec->has_b_frames*AV_TIME_BASE / av_q2d(st->avg_frame_rate) : 0;

        ist->next_pts = AV_NOPTS_VALUE;

        ist->is_start = 1;

    }



    /* set meta data information from input file if required */

    for (i=0;i<nb_meta_data_maps;i++) {

        AVFormatContext *files[2];

        AVDictionary    **meta[2];

        int j;



#define METADATA_CHECK_INDEX(index, nb_elems, desc)\

        if ((index) < 0 || (index) >= (nb_elems)) {\

            snprintf(error, sizeof(error), "Invalid %s index %d while processing metadata maps\n",\

                     (desc), (index));\

            ret = AVERROR(EINVAL);\

            goto dump_format;\

        }



        int out_file_index = meta_data_maps[i][0].file;

        int in_file_index = meta_data_maps[i][1].file;

        if (in_file_index < 0 || out_file_index < 0)

            continue;

        METADATA_CHECK_INDEX(out_file_index, nb_output_files, "output file")

        METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file")



        files[0] = output_files[out_file_index];

        files[1] = input_files[in_file_index].ctx;



        for (j = 0; j < 2; j++) {

            MetadataMap *map = &meta_data_maps[i][j];



            switch (map->type) {

            case 'g':

                meta[j] = &files[j]->metadata;

                break;

            case 's':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream")

                meta[j] = &files[j]->streams[map->index]->metadata;

                break;

            case 'c':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter")

                meta[j] = &files[j]->chapters[map->index]->metadata;

                break;

            case 'p':

                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program")

                meta[j] = &files[j]->programs[map->index]->metadata;

                break;

            }

        }



        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);

    }



    /* copy global metadata by default */

    if (metadata_global_autocopy) {



        for (i = 0; i < nb_output_files; i++)

            av_dict_copy(&output_files[i]->metadata, input_files[0].ctx->metadata,

                         AV_DICT_DONT_OVERWRITE);

    }



    /* copy chapters according to chapter maps */

    for (i = 0; i < nb_chapter_maps; i++) {

        int infile  = chapter_maps[i].in_file;

        int outfile = chapter_maps[i].out_file;



        if (infile < 0 || outfile < 0)

            continue;

        if (infile >= nb_input_files) {

            snprintf(error, sizeof(error), "Invalid input file index %d in chapter mapping.\n", infile);

            ret = AVERROR(EINVAL);

            goto dump_format;

        }

        if (outfile >= nb_output_files) {

            snprintf(error, sizeof(error), "Invalid output file index %d in chapter mapping.\n",outfile);

            ret = AVERROR(EINVAL);

            goto dump_format;

        }

        copy_chapters(infile, outfile);

    }



    /* copy chapters from the first input file that has them*/

    if (!nb_chapter_maps)

        for (i = 0; i < nb_input_files; i++) {

            if (!input_files[i].ctx->nb_chapters)

                continue;



            for (j = 0; j < nb_output_files; j++)

                if ((ret = copy_chapters(i, j)) < 0)

                    goto dump_format;

            break;

        }



    /* open files and write file headers */

    for(i=0;i<nb_output_files;i++) {

        os = output_files[i];

        if (avformat_write_header(os, &output_opts[i]) < 0) {

            snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);

            ret = AVERROR(EINVAL);

            goto dump_format;

        }

        assert_avoptions(output_opts[i]);

        if (strcmp(output_files[i]->oformat->name, "rtp")) {

            want_sdp = 0;

        }

    }



 dump_format:

    /* dump the file output parameters - cannot be done before in case

       of stream copy */

    for(i=0;i<nb_output_files;i++) {

        av_dump_format(output_files[i], i, output_files[i]->filename, 1);

    }



    /* dump the stream mapping */

    if (verbose >= 0) {

        fprintf(stderr, "Stream mapping:\n");

        for(i=0;i<nb_ostreams;i++) {

            ost = ost_table[i];

            fprintf(stderr, "  Stream #%d.%d -> #%d.%d",

                    input_streams[ost->source_index].file_index,

                    input_streams[ost->source_index].st->index,

                    ost->file_index,

                    ost->index);

            if (ost->sync_ist != &input_streams[ost->source_index])

                fprintf(stderr, " [sync #%d.%d]",

                        ost->sync_ist->file_index,

                        ost->sync_ist->st->index);

            fprintf(stderr, "\n");

        }

    }



    if (ret) {

        fprintf(stderr, "%s\n", error);

        goto fail;

    }



    if (want_sdp) {

        print_sdp(output_files, nb_output_files);

    }



    if (!using_stdin) {

        if(verbose >= 0)

            fprintf(stderr, "Press [q] to stop, [?] for help\n");

        avio_set_interrupt_cb(decode_interrupt_cb);

    }

    term_init();



    timer_start = av_gettime();



    for(; received_sigterm == 0;) {

        int file_index, ist_index;

        AVPacket pkt;

        double ipts_min;

        double opts_min;



    redo:

        ipts_min= 1e100;

        opts_min= 1e100;

        /* if 'q' pressed, exits */

        if (!using_stdin) {

            if (q_pressed)

                break;

            /* read_key() returns 0 on EOF */

            key = read_key();

            if (key == 'q')

                break;

            if (key == '+') verbose++;

            if (key == '-') verbose--;

            if (key == 's') qp_hist     ^= 1;

            if (key == 'h'){

                if (do_hex_dump){

                    do_hex_dump = do_pkt_dump = 0;

                } else if(do_pkt_dump){

                    do_hex_dump = 1;

                } else

                    do_pkt_dump = 1;

                av_log_set_level(AV_LOG_DEBUG);

            }

            if (key == 'd' || key == 'D'){

                int debug=0;

                if(key == 'D') {

                    debug = input_streams[0].st->codec->debug<<1;

                    if(!debug) debug = 1;

                    while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash

                        debug += debug;

                }else

                    scanf("%d", &debug);

                for(i=0;i<nb_input_streams;i++) {

                    input_streams[i].st->codec->debug = debug;

                }

                for(i=0;i<nb_ostreams;i++) {

                    ost = ost_table[i];

                    ost->st->codec->debug = debug;

                }

                if(debug) av_log_set_level(AV_LOG_DEBUG);

                fprintf(stderr,"debug=%d\n", debug);

            }

            if (key == '?'){

                fprintf(stderr, "key    function\n"

                                "?      show this help\n"

                                "+      increase verbosity\n"

                                "-      decrease verbosity\n"

                                "D      cycle through available debug modes\n"

                                "h      dump packets/hex press to cycle through the 3 states\n"

                                "q      quit\n"

                                "s      Show QP histogram\n"

                );

            }

        }



        /* select the stream that we must read now by looking at the

           smallest output pts */

        file_index = -1;

        for(i=0;i<nb_ostreams;i++) {

            double ipts, opts;

            ost = ost_table[i];

            os = output_files[ost->file_index];

            ist = &input_streams[ost->source_index];

            if(ist->is_past_recording_time || no_packet[ist->file_index])

                continue;

                opts = ost->st->pts.val * av_q2d(ost->st->time_base);

            ipts = (double)ist->pts;

            if (!input_files[ist->file_index].eof_reached){

                if(ipts < ipts_min) {

                    ipts_min = ipts;

                    if(input_sync ) file_index = ist->file_index;

                }

                if(opts < opts_min) {

                    opts_min = opts;

                    if(!input_sync) file_index = ist->file_index;

                }

            }

            if(ost->frame_number >= max_frames[ost->st->codec->codec_type]){

                file_index= -1;

                break;

            }

        }

        /* if none, if is finished */

        if (file_index < 0) {

            if(no_packet_count){

                no_packet_count=0;

                memset(no_packet, 0, sizeof(no_packet));

                usleep(10000);

                continue;

            }

            break;

        }



        /* finish if limit size exhausted */

        if (limit_filesize != 0 && limit_filesize <= avio_tell(output_files[0]->pb))

            break;



        /* read a frame from it and output it in the fifo */

        is = input_files[file_index].ctx;

        ret= av_read_frame(is, &pkt);

        if(ret == AVERROR(EAGAIN)){

            no_packet[file_index]=1;

            no_packet_count++;

            continue;

        }

        if (ret < 0) {

            input_files[file_index].eof_reached = 1;

            if (opt_shortest)

                break;

            else

                continue;

        }



        no_packet_count=0;

        memset(no_packet, 0, sizeof(no_packet));



        if (do_pkt_dump) {

            av_pkt_dump_log2(NULL, AV_LOG_DEBUG, &pkt, do_hex_dump,

                             is->streams[pkt.stream_index]);

        }

        /* the following test is needed in case new streams appear

           dynamically in stream : we ignore them */

        if (pkt.stream_index >= input_files[file_index].ctx->nb_streams)

            goto discard_packet;

        ist_index = input_files[file_index].ist_index + pkt.stream_index;

        ist = &input_streams[ist_index];

        if (ist->discard)

            goto discard_packet;



        if (pkt.dts != AV_NOPTS_VALUE)

            pkt.dts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);

        if (pkt.pts != AV_NOPTS_VALUE)

            pkt.pts += av_rescale_q(input_files[ist->file_index].ts_offset, AV_TIME_BASE_Q, ist->st->time_base);



        if (ist->ts_scale) {

            if(pkt.pts != AV_NOPTS_VALUE)

                pkt.pts *= ist->ts_scale;

            if(pkt.dts != AV_NOPTS_VALUE)

                pkt.dts *= ist->ts_scale;

        }



//        fprintf(stderr, "next:%"PRId64" dts:%"PRId64" off:%"PRId64" %d\n", ist->next_pts, pkt.dts, input_files[ist->file_index].ts_offset, ist->st->codec->codec_type);

        if (pkt.dts != AV_NOPTS_VALUE && ist->next_pts != AV_NOPTS_VALUE

            && (is->iformat->flags & AVFMT_TS_DISCONT)) {

            int64_t pkt_dts= av_rescale_q(pkt.dts, ist->st->time_base, AV_TIME_BASE_Q);

            int64_t delta= pkt_dts - ist->next_pts;

            if((FFABS(delta) > 1LL*dts_delta_threshold*AV_TIME_BASE || pkt_dts+1<ist->pts)&& !copy_ts){

                input_files[ist->file_index].ts_offset -= delta;

                if (verbose > 2)

                    fprintf(stderr, "timestamp discontinuity %"PRId64", new offset= %"PRId64"\n",

                            delta, input_files[ist->file_index].ts_offset);

                pkt.dts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);

                if(pkt.pts != AV_NOPTS_VALUE)

                    pkt.pts-= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);

            }

        }



        /* finish if recording time exhausted */

        if (recording_time != INT64_MAX &&

            (pkt.pts != AV_NOPTS_VALUE ?

                av_compare_ts(pkt.pts, ist->st->time_base, recording_time + start_time, (AVRational){1, 1000000})

                    :

                av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})

            )>= 0) {

            ist->is_past_recording_time = 1;

            goto discard_packet;

        }



        //fprintf(stderr,"read #%d.%d size=%d\n", ist->file_index, ist->st->index, pkt.size);

        if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {



            if (verbose >= 0)

                fprintf(stderr, "Error while decoding stream #%d.%d\n",

                        ist->file_index, ist->st->index);

            if (exit_on_error)

                ffmpeg_exit(1);

            av_free_packet(&pkt);

            goto redo;

        }



    discard_packet:

        av_free_packet(&pkt);



        /* dump report by using the output first video and audio streams */

        print_report(output_files, ost_table, nb_ostreams, 0);

    }



    /* at the end of stream, we must flush the decoder buffers */

    for (i = 0; i < nb_input_streams; i++) {

        ist = &input_streams[i];

        if (ist->decoding_needed) {

            output_packet(ist, i, ost_table, nb_ostreams, NULL);

        }

    }



    term_exit();



    /* write the trailer if needed and close file */

    for(i=0;i<nb_output_files;i++) {

        os = output_files[i];

        av_write_trailer(os);

    }



    /* dump report by using the first video and audio streams */

    print_report(output_files, ost_table, nb_ostreams, 1);



    /* close each encoder */

    for(i=0;i<nb_ostreams;i++) {

        ost = ost_table[i];

        if (ost->encoding_needed) {

            av_freep(&ost->st->codec->stats_in);

            avcodec_close(ost->st->codec);

        }

#if CONFIG_AVFILTER

        avfilter_graph_free(&ost->graph);

#endif

    }



    /* close each decoder */

    for (i = 0; i < nb_input_streams; i++) {

        ist = &input_streams[i];

        if (ist->decoding_needed) {

            avcodec_close(ist->st->codec);

        }

    }



    /* finished ! */

    ret = 0;



 fail:

    av_freep(&bit_buffer);



    if (ost_table) {

        for(i=0;i<nb_ostreams;i++) {

            ost = ost_table[i];

            if (ost) {

                if (ost->st->stream_copy)

                    av_freep(&ost->st->codec->extradata);

                if (ost->logfile) {

                    fclose(ost->logfile);

                    ost->logfile = NULL;

                }

                av_fifo_free(ost->fifo); /* works even if fifo is not

                                             initialized but set to zero */

                av_freep(&ost->st->codec->subtitle_header);

                av_free(ost->resample_frame.data[0]);

                av_free(ost->forced_kf_pts);

                if (ost->video_resample)

                    sws_freeContext(ost->img_resample_ctx);

                if (ost->resample)

                    audio_resample_close(ost->resample);

                if (ost->reformat_ctx)

                    av_audio_convert_free(ost->reformat_ctx);

                av_dict_free(&ost->opts);

                av_free(ost);

            }

        }

        av_free(ost_table);

    }

    return ret;

}
 and probability:0.42592592592592593
code:static void v4l2_free_buffer(void *opaque, uint8_t *unused)

{

    V4L2Buffer* avbuf = opaque;

    V4L2m2mContext *s = buf_to_m2mctx(avbuf);



    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {

        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);



        if (s->reinit) {

            if (!atomic_load(&s->refcount))

                sem_post(&s->refsync);

        } else if (avbuf->context->streamon)

            ff_v4l2_buffer_enqueue(avbuf);



        av_buffer_unref(&avbuf->context_ref);

    }

}
 and probability:0.5
code:int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,

                                      CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, "Could not map OpenCL buffer: %s\n", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(mapped, src_buf, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, "Could not unmap OpenCL buffer: %s\n", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
 and probability:0.05555555555555555
code:static int r3d_read_rdvo(AVFormatContext *s, Atom *atom)

{

    R3DContext *r3d = s->priv_data;

    AVStream *st = s->streams[0];

    int i;



    r3d->video_offsets_count = (atom->size - 8) / 4;

    r3d->video_offsets = av_malloc(atom->size);

    if (!r3d->video_offsets)

        return AVERROR(ENOMEM);



    for (i = 0; i < r3d->video_offsets_count; i++) {

        r3d->video_offsets[i] = avio_rb32(s->pb);

        if (!r3d->video_offsets[i]) {

            r3d->video_offsets_count = i;

            break;

        }

        av_dlog(s, "video offset %d: %#x\n", i, r3d->video_offsets[i]);

    }



    if (st->r_frame_rate.num)

        st->duration = av_rescale_q(r3d->video_offsets_count,

                                    (AVRational){st->r_frame_rate.den,

                                                 st->r_frame_rate.num},

                                    st->time_base);

    av_dlog(s, "duration %"PRId64"\n", st->duration);



    return 0;

}
 and probability:0.64
code:static int dds_decode(AVCodecContext *avctx, void *data,

                      int *got_frame, AVPacket *avpkt)

{

    DDSContext *ctx = avctx->priv_data;

    GetByteContext *gbc = &ctx->gbc;

    AVFrame *frame = data;

    int mipmap;

    int ret;



    ff_texturedsp_init(&ctx->texdsp);

    bytestream2_init(gbc, avpkt->data, avpkt->size);



    if (bytestream2_get_bytes_left(gbc) < 128) {

        av_log(avctx, AV_LOG_ERROR, "Frame is too small (%d).\n",

               bytestream2_get_bytes_left(gbc));

        return AVERROR_INVALIDDATA;

    }



    if (bytestream2_get_le32(gbc) != MKTAG('D', 'D', 'S', ' ') ||

        bytestream2_get_le32(gbc) != 124) { // header size

        av_log(avctx, AV_LOG_ERROR, "Invalid DDS header.\n");

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(gbc, 4); // flags



    avctx->height = bytestream2_get_le32(gbc);

    avctx->width  = bytestream2_get_le32(gbc);

    ret = av_image_check_size(avctx->width, avctx->height, 0, avctx);

    if (ret < 0) {

        av_log(avctx, AV_LOG_ERROR, "Invalid image size %dx%d.\n",

               avctx->width, avctx->height);

        return ret;

    }



    /* Since codec is based on 4x4 blocks, size is aligned to 4. */

    avctx->coded_width  = FFALIGN(avctx->width,  TEXTURE_BLOCK_W);

    avctx->coded_height = FFALIGN(avctx->height, TEXTURE_BLOCK_H);



    bytestream2_skip(gbc, 4); // pitch

    bytestream2_skip(gbc, 4); // depth

    mipmap = bytestream2_get_le32(gbc);

    if (mipmap != 0)

        av_log(avctx, AV_LOG_VERBOSE, "Found %d mipmaps (ignored).\n", mipmap);



    /* Extract pixel format information, considering additional elements

     * in reserved1 and reserved2. */

    ret = parse_pixel_format(avctx);

    if (ret < 0)

        return ret;



    ret = ff_get_buffer(avctx, frame, 0);

    if (ret < 0)

        return ret;



    if (ctx->compressed) {

        int size = (avctx->coded_height / TEXTURE_BLOCK_H) *

                   (avctx->coded_width / TEXTURE_BLOCK_W) * ctx->tex_ratio;

        ctx->slice_count = av_clip(avctx->thread_count, 1,

                                   avctx->coded_height / TEXTURE_BLOCK_H);



        if (bytestream2_get_bytes_left(gbc) < size) {

            av_log(avctx, AV_LOG_ERROR,

                   "Compressed Buffer is too small (%d < %d).\n",

                   bytestream2_get_bytes_left(gbc), size);

            return AVERROR_INVALIDDATA;

        }



        /* Use the decompress function on the texture, one block per thread. */

        ctx->tex_data = gbc->buffer;

        avctx->execute2(avctx, decompress_texture_thread, frame, NULL, ctx->slice_count);

    } else if (!ctx->paletted && ctx->bpp == 4 && avctx->pix_fmt == AV_PIX_FMT_PAL8) {

        uint8_t *dst = frame->data[0];

        int x, y, i;



        /* Use the first 64 bytes as palette, then copy the rest. */

        bytestream2_get_buffer(gbc, frame->data[1], 16 * 4);

        for (i = 0; i < 16; i++) {

            AV_WN32(frame->data[1] + i*4,

                    (frame->data[1][2+i*4]<<0)+

                    (frame->data[1][1+i*4]<<8)+

                    (frame->data[1][0+i*4]<<16)+

                    (frame->data[1][3+i*4]<<24)

            );

        }

        frame->palette_has_changed = 1;



        if (bytestream2_get_bytes_left(gbc) < frame->height * frame->width / 2) {

            av_log(avctx, AV_LOG_ERROR, "Buffer is too small (%d < %d).\n",

                   bytestream2_get_bytes_left(gbc), frame->height * frame->width / 2);

            return AVERROR_INVALIDDATA;

        }



        for (y = 0; y < frame->height; y++) {

            for (x = 0; x < frame->width; x += 2) {

                uint8_t val = bytestream2_get_byte(gbc);

                dst[x    ] = val & 0xF;

                dst[x + 1] = val >> 4;

            }

            dst += frame->linesize[0];

        }

    } else {

        int linesize = av_image_get_linesize(avctx->pix_fmt, frame->width, 0);



        if (ctx->paletted) {

            int i;

            /* Use the first 1024 bytes as palette, then copy the rest. */

            bytestream2_get_buffer(gbc, frame->data[1], 256 * 4);

            for (i = 0; i < 256; i++)

                AV_WN32(frame->data[1] + i*4,

                        (frame->data[1][2+i*4]<<0)+

                        (frame->data[1][1+i*4]<<8)+

                        (frame->data[1][0+i*4]<<16)+

                        (frame->data[1][3+i*4]<<24)

                );



            frame->palette_has_changed = 1;

        }



        if (bytestream2_get_bytes_left(gbc) < frame->height * linesize) {

            av_log(avctx, AV_LOG_ERROR, "Buffer is too small (%d < %d).\n",

                   bytestream2_get_bytes_left(gbc), frame->height * linesize);

            return AVERROR_INVALIDDATA;

        }



        av_image_copy_plane(frame->data[0], frame->linesize[0],

                            gbc->buffer, linesize,

                            linesize, frame->height);

    }



    /* Run any post processing here if needed. */

    if (ctx->postproc != DDS_NONE)

        run_postproc(avctx, frame);



    /* Frame is ready to be output. */

    frame->pict_type = AV_PICTURE_TYPE_I;

    frame->key_frame = 1;

    *got_frame = 1;



    return avpkt->size;

}
 and probability:0.453781512605042
code:static void check_lowpass_line(int depth){

    LOCAL_ALIGNED_32(uint8_t, src,     [SRC_SIZE]);

    LOCAL_ALIGNED_32(uint8_t, dst_ref, [WIDTH_PADDED]);

    LOCAL_ALIGNED_32(uint8_t, dst_new, [WIDTH_PADDED]);

    int w = WIDTH;

    int mref = WIDTH_PADDED * -1;

    int pref = WIDTH_PADDED;

    int i, depth_byte;

    InterlaceContext s;



    declare_func(void, uint8_t *dstp, ptrdiff_t linesize, const uint8_t *srcp,

                 ptrdiff_t mref, ptrdiff_t pref, int clip_max);



    s.lowpass = 1;

    s.lowpass = VLPF_LIN;

    depth_byte = depth >> 3;

    w /= depth_byte;



    memset(src,     0, SRC_SIZE);

    memset(dst_ref, 0, WIDTH_PADDED);

    memset(dst_new, 0, WIDTH_PADDED);

    randomize_buffers(src, SRC_SIZE);



    ff_interlace_init(&s, depth);



    if (check_func(s.lowpass_line, "lowpass_line_%d", depth)) {

        for (i = 0; i < 32; i++) { /* simulate crop */

            call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);

            call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);

            if (memcmp(dst_ref, dst_new, WIDTH - i))

                fail();

        }

        bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);

    }

}
 and probability:0.36666666666666664
code:static void test_init(TestData *d)

{

    QPCIBus *bus;

    QTestState *qs;

    char *s;



    s = g_strdup_printf("-machine q35 %s %s",

                        d->noreboot ? "" : "-global ICH9-LPC.noreboot=false",

                        !d->args ? "" : d->args);

    qs = qtest_start(s);

    qtest_irq_intercept_in(qs, "ioapic");

    g_free(s);



    bus = qpci_init_pc(NULL);

    d->dev = qpci_device_find(bus, QPCI_DEVFN(0x1f, 0x00));

    g_assert(d->dev != NULL);



    qpci_device_enable(d->dev);



    /* set ACPI PM I/O space base address */

    qpci_config_writel(d->dev, ICH9_LPC_PMBASE, PM_IO_BASE_ADDR | 0x1);

    /* enable ACPI I/O */

    qpci_config_writeb(d->dev, ICH9_LPC_ACPI_CTRL, 0x80);

    /* set Root Complex BAR */

    qpci_config_writel(d->dev, ICH9_LPC_RCBA, RCBA_BASE_ADDR | 0x1);



    d->tco_io_base = qpci_legacy_iomap(d->dev, PM_IO_BASE_ADDR + 0x60);

}
 and probability:0.391304347826087
code:void assert_avoptions(AVDictionary *m)

{

    AVDictionaryEntry *t;

    if ((t = av_dict_get(m, "", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_FATAL, "Option %s not found.\n", t->key);

        exit(1);

    }

}
 and probability:0.125
code:static void nbd_refresh_filename(BlockDriverState *bs, QDict *options)

{

    BDRVNBDState *s = bs->opaque;

    QDict *opts = qdict_new();

    QObject *saddr_qdict;

    Visitor *ov;

    const char *host = NULL, *port = NULL, *path = NULL;



    if (s->saddr->type == SOCKET_ADDRESS_KIND_INET) {

        const InetSocketAddress *inet = s->saddr->u.inet.data;

        if (!inet->has_ipv4 && !inet->has_ipv6 && !inet->has_to) {

            host = inet->host;

            port = inet->port;

        }

    } else if (s->saddr->type == SOCKET_ADDRESS_KIND_UNIX) {

        path = s->saddr->u.q_unix.data->path;

    }



    qdict_put(opts, "driver", qstring_from_str("nbd"));



    if (path && s->export) {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "nbd+unix:///%s?socket=%s", s->export, path);

    } else if (path && !s->export) {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "nbd+unix://?socket=%s", path);

    } else if (host && s->export) {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "nbd://%s:%s/%s", host, port, s->export);

    } else if (host && !s->export) {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "nbd://%s:%s", host, port);

    }



    ov = qobject_output_visitor_new(&saddr_qdict);

    visit_type_SocketAddress(ov, NULL, &s->saddr, &error_abort);

    visit_complete(ov, &saddr_qdict);


    assert(qobject_type(saddr_qdict) == QTYPE_QDICT);



    qdict_put_obj(opts, "server", saddr_qdict);



    if (s->export) {

        qdict_put(opts, "export", qstring_from_str(s->export));

    }

    if (s->tlscredsid) {

        qdict_put(opts, "tls-creds", qstring_from_str(s->tlscredsid));

    }



    qdict_flatten(opts);

    bs->full_open_options = opts;

} and probability:0.5454545454545454
code:int net_init_tap(QemuOpts *opts, const char *name, VLANState *vlan)

{

    const char *ifname;



    ifname = qemu_opt_get(opts, "ifname");



    if (!ifname) {

        error_report("tap: no interface name");

        return -1;

    }



    if (tap_win32_init(vlan, "tap", name, ifname) == -1) {

        return -1;

    }



    return 0;

}
 and probability:0.0
code:print_insn (bfd_vma pc, disassemble_info *info)

{

  const struct dis386 *dp;

  int i;

  char *op_txt[MAX_OPERANDS];

  int needcomma;

  unsigned char uses_DATA_prefix, uses_LOCK_prefix;

  unsigned char uses_REPNZ_prefix, uses_REPZ_prefix;

  int sizeflag;

  const char *p;

  struct dis_private priv;

  unsigned char op;

  unsigned char threebyte;



  if (info->mach == bfd_mach_x86_64_intel_syntax

      || info->mach == bfd_mach_x86_64)

    address_mode = mode_64bit;

  else

    address_mode = mode_32bit;



  if (intel_syntax == (char) -1)

    intel_syntax = (info->mach == bfd_mach_i386_i386_intel_syntax

		    || info->mach == bfd_mach_x86_64_intel_syntax);



  if (info->mach == bfd_mach_i386_i386

      || info->mach == bfd_mach_x86_64

      || info->mach == bfd_mach_i386_i386_intel_syntax

      || info->mach == bfd_mach_x86_64_intel_syntax)

    priv.orig_sizeflag = AFLAG | DFLAG;

  else if (info->mach == bfd_mach_i386_i8086)

    priv.orig_sizeflag = 0;

  else

    abort ();



  for (p = info->disassembler_options; p != NULL; )

    {

      if (strncmp (p, "x86-64", 6) == 0)

	{

	  address_mode = mode_64bit;

	  priv.orig_sizeflag = AFLAG | DFLAG;

	}

      else if (strncmp (p, "i386", 4) == 0)

	{

	  address_mode = mode_32bit;

	  priv.orig_sizeflag = AFLAG | DFLAG;

	}

      else if (strncmp (p, "i8086", 5) == 0)

	{

	  address_mode = mode_16bit;

	  priv.orig_sizeflag = 0;

	}

      else if (strncmp (p, "intel", 5) == 0)

	{

	  intel_syntax = 1;

	}

      else if (strncmp (p, "att", 3) == 0)

	{

	  intel_syntax = 0;

	}

      else if (strncmp (p, "addr", 4) == 0)

	{

	  if (address_mode == mode_64bit)

	    {

	      if (p[4] == '3' && p[5] == '2')

		priv.orig_sizeflag &= ~AFLAG;

	      else if (p[4] == '6' && p[5] == '4')

		priv.orig_sizeflag |= AFLAG;

	    }

	  else

	    {

	      if (p[4] == '1' && p[5] == '6')

		priv.orig_sizeflag &= ~AFLAG;

	      else if (p[4] == '3' && p[5] == '2')

		priv.orig_sizeflag |= AFLAG;

	    }

	}

      else if (strncmp (p, "data", 4) == 0)

	{

	  if (p[4] == '1' && p[5] == '6')

	    priv.orig_sizeflag &= ~DFLAG;

	  else if (p[4] == '3' && p[5] == '2')

	    priv.orig_sizeflag |= DFLAG;

	}

      else if (strncmp (p, "suffix", 6) == 0)

	priv.orig_sizeflag |= SUFFIX_ALWAYS;



      p = strchr (p, ',');

      if (p != NULL)

	p++;

    }



  if (intel_syntax)

    {

      names64 = intel_names64;

      names32 = intel_names32;

      names16 = intel_names16;

      names8 = intel_names8;

      names8rex = intel_names8rex;

      names_seg = intel_names_seg;

      index16 = intel_index16;

      open_char = '[';

      close_char = ']';

      separator_char = '+';

      scale_char = '*';

    }

  else

    {

      names64 = att_names64;

      names32 = att_names32;

      names16 = att_names16;

      names8 = att_names8;

      names8rex = att_names8rex;

      names_seg = att_names_seg;

      index16 = att_index16;

      open_char = '(';

      close_char =  ')';

      separator_char = ',';

      scale_char = ',';

    }



  /* The output looks better if we put 7 bytes on a line, since that

     puts most long word instructions on a single line.  */

  info->bytes_per_line = 7;



  info->private_data = &priv;

  priv.max_fetched = priv.the_buffer;

  priv.insn_start = pc;



  obuf[0] = 0;

  for (i = 0; i < MAX_OPERANDS; ++i)

    {

      op_out[i][0] = 0;

      op_index[i] = -1;

    }



  the_info = info;

  start_pc = pc;

  start_codep = priv.the_buffer;

  codep = priv.the_buffer;



  if (sigsetjmp(priv.bailout, 0) != 0)

    {

      const char *name;



      /* Getting here means we tried for data but didn't get it.  That

	 means we have an incomplete instruction of some sort.  Just

	 print the first byte as a prefix or a .byte pseudo-op.  */

      if (codep > priv.the_buffer)

	{

	  name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);

	  if (name != NULL)

	    (*info->fprintf_func) (info->stream, "%s", name);

	  else

	    {

	      /* Just print the first byte as a .byte instruction.  */

	      (*info->fprintf_func) (info->stream, ".byte 0x%x",

				     (unsigned int) priv.the_buffer[0]);

	    }



	  return 1;

	}



      return -1;

    }



  obufp = obuf;

  ckprefix ();

  ckvexprefix ();



  insn_codep = codep;

  sizeflag = priv.orig_sizeflag;



  fetch_data(info, codep + 1);

  two_source_ops = (*codep == 0x62) || (*codep == 0xc8);



  if (((prefixes & PREFIX_FWAIT)

       && ((*codep < 0xd8) || (*codep > 0xdf)))

      || (rex && rex_used))

    {

      const char *name;



      /* fwait not followed by floating point instruction, or rex followed

	 by other prefixes.  Print the first prefix.  */

      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);

      if (name == NULL)

	name = INTERNAL_DISASSEMBLER_ERROR;

      (*info->fprintf_func) (info->stream, "%s", name);

      return 1;

    }



  op = 0;

  if (prefixes & PREFIX_VEX_0F)

    {

      used_prefixes |= PREFIX_VEX_0F | PREFIX_VEX_0F38 | PREFIX_VEX_0F3A;

      if (prefixes & PREFIX_VEX_0F38)

        threebyte = 0x38;

      else if (prefixes & PREFIX_VEX_0F3A)

        threebyte = 0x3a;

      else

        threebyte = *codep++;

      goto vex_opcode;

    }

  if (*codep == 0x0f)

    {

      fetch_data(info, codep + 2);

      threebyte = codep[1];

      codep += 2;

    vex_opcode:

      dp = &dis386_twobyte[threebyte];

      need_modrm = twobyte_has_modrm[threebyte];

      uses_DATA_prefix = twobyte_uses_DATA_prefix[threebyte];

      uses_REPNZ_prefix = twobyte_uses_REPNZ_prefix[threebyte];

      uses_REPZ_prefix = twobyte_uses_REPZ_prefix[threebyte];

      uses_LOCK_prefix = (threebyte & ~0x02) == 0x20;

      if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)

	{

          fetch_data(info, codep + 2);

	  op = *codep++;

	  switch (threebyte)

	    {

	    case 0x38:

	      uses_DATA_prefix = threebyte_0x38_uses_DATA_prefix[op];

	      uses_REPNZ_prefix = threebyte_0x38_uses_REPNZ_prefix[op];

	      uses_REPZ_prefix = threebyte_0x38_uses_REPZ_prefix[op];

	      break;

	    case 0x3a:

	      uses_DATA_prefix = threebyte_0x3a_uses_DATA_prefix[op];

	      uses_REPNZ_prefix = threebyte_0x3a_uses_REPNZ_prefix[op];

	      uses_REPZ_prefix = threebyte_0x3a_uses_REPZ_prefix[op];

	      break;

	    default:

	      break;

	    }

	}

    }

  else

    {

      dp = &dis386[*codep];

      need_modrm = onebyte_has_modrm[*codep];

      uses_DATA_prefix = 0;

      uses_REPNZ_prefix = 0;

      /* pause is 0xf3 0x90.  */

      uses_REPZ_prefix = *codep == 0x90;

      uses_LOCK_prefix = 0;

      codep++;

    }



  if (!uses_REPZ_prefix && (prefixes & PREFIX_REPZ))

    {

      oappend ("repz ");

      used_prefixes |= PREFIX_REPZ;

    }

  if (!uses_REPNZ_prefix && (prefixes & PREFIX_REPNZ))

    {

      oappend ("repnz ");

      used_prefixes |= PREFIX_REPNZ;

    }



  if (!uses_LOCK_prefix && (prefixes & PREFIX_LOCK))

    {

      oappend ("lock ");

      used_prefixes |= PREFIX_LOCK;

    }



  if (prefixes & PREFIX_ADDR)

    {

      sizeflag ^= AFLAG;

      if (dp->op[2].bytemode != loop_jcxz_mode || intel_syntax)

	{

	  if ((sizeflag & AFLAG) || address_mode == mode_64bit)

	    oappend ("addr32 ");

	  else

	    oappend ("addr16 ");

	  used_prefixes |= PREFIX_ADDR;

	}

    }



  if (!uses_DATA_prefix && (prefixes & PREFIX_DATA))

    {

      sizeflag ^= DFLAG;

      if (dp->op[2].bytemode == cond_jump_mode

	  && dp->op[0].bytemode == v_mode

	  && !intel_syntax)

	{

	  if (sizeflag & DFLAG)

	    oappend ("data32 ");

	  else

	    oappend ("data16 ");

	  used_prefixes |= PREFIX_DATA;

	}

    }



  if (dp->name == NULL && dp->op[0].bytemode == IS_3BYTE_OPCODE)

    {

      dp = &three_byte_table[dp->op[1].bytemode][op];

      modrm.mod = (*codep >> 6) & 3;

      modrm.reg = (*codep >> 3) & 7;

      modrm.rm = *codep & 7;

    }

  else if (need_modrm)

    {

      fetch_data(info, codep + 1);

      modrm.mod = (*codep >> 6) & 3;

      modrm.reg = (*codep >> 3) & 7;

      modrm.rm = *codep & 7;

    }



  if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)

    {

      dofloat (sizeflag);

    }

  else

    {

      int index;

      if (dp->name == NULL)

	{

	  switch (dp->op[0].bytemode)

	    {

	    case USE_GROUPS:

	      dp = &grps[dp->op[1].bytemode][modrm.reg];

	      break;



	    case USE_PREFIX_USER_TABLE:

	      index = 0;

	      used_prefixes |= (prefixes & PREFIX_REPZ);

	      if (prefixes & PREFIX_REPZ)

		index = 1;

	      else

		{

		  /* We should check PREFIX_REPNZ and PREFIX_REPZ

		     before PREFIX_DATA.  */

		  used_prefixes |= (prefixes & PREFIX_REPNZ);

		  if (prefixes & PREFIX_REPNZ)

		    index = 3;

		  else

		    {

		      used_prefixes |= (prefixes & PREFIX_DATA);

		      if (prefixes & PREFIX_DATA)

			index = 2;

		    }

		}

	      dp = &prefix_user_table[dp->op[1].bytemode][index];

	      break;



	    case X86_64_SPECIAL:

	      index = address_mode == mode_64bit ? 1 : 0;

	      dp = &x86_64_table[dp->op[1].bytemode][index];

	      break;



	    default:

	      oappend (INTERNAL_DISASSEMBLER_ERROR);

	      break;

	    }

	}



      if (putop (dp->name, sizeflag) == 0)

        {

	  for (i = 0; i < MAX_OPERANDS; ++i)

	    {

	      obufp = op_out[i];

	      op_ad = MAX_OPERANDS - 1 - i;

	      if (dp->op[i].rtn)

		(*dp->op[i].rtn) (dp->op[i].bytemode, sizeflag);

	    }

	}

    }



  /* See if any prefixes were not used.  If so, print the first one

     separately.  If we don't do this, we'll wind up printing an

     instruction stream which does not precisely correspond to the

     bytes we are disassembling.  */

  if ((prefixes & ~used_prefixes) != 0)

    {

      const char *name;



      name = prefix_name (priv.the_buffer[0], priv.orig_sizeflag);

      if (name == NULL)

	name = INTERNAL_DISASSEMBLER_ERROR;

      (*info->fprintf_func) (info->stream, "%s", name);

      return 1;

    }

  if (rex & ~rex_used)

    {

      const char *name;

      name = prefix_name (rex | 0x40, priv.orig_sizeflag);

      if (name == NULL)

	name = INTERNAL_DISASSEMBLER_ERROR;

      (*info->fprintf_func) (info->stream, "%s ", name);

    }



  obufp = obuf + strlen (obuf);

  for (i = strlen (obuf); i < 6; i++)

    oappend (" ");

  oappend (" ");

  (*info->fprintf_func) (info->stream, "%s", obuf);



  /* The enter and bound instructions are printed with operands in the same

     order as the intel book; everything else is printed in reverse order.  */

  if (intel_syntax || two_source_ops)

    {

      bfd_vma riprel;



      for (i = 0; i < MAX_OPERANDS; ++i)

        op_txt[i] = op_out[i];



      for (i = 0; i < (MAX_OPERANDS >> 1); ++i)

	{

          op_ad = op_index[i];

          op_index[i] = op_index[MAX_OPERANDS - 1 - i];

          op_index[MAX_OPERANDS - 1 - i] = op_ad;

	  riprel = op_riprel[i];

	  op_riprel[i] = op_riprel [MAX_OPERANDS - 1 - i];

	  op_riprel[MAX_OPERANDS - 1 - i] = riprel;

	}

    }

  else

    {

      for (i = 0; i < MAX_OPERANDS; ++i)

        op_txt[MAX_OPERANDS - 1 - i] = op_out[i];

    }



  needcomma = 0;

  for (i = 0; i < MAX_OPERANDS; ++i)

    if (*op_txt[i])

      {

	if (needcomma)

	  (*info->fprintf_func) (info->stream, ",");

	if (op_index[i] != -1 && !op_riprel[i])

	  (*info->print_address_func) ((bfd_vma) op_address[op_index[i]], info);

	else

	  (*info->fprintf_func) (info->stream, "%s", op_txt[i]);

	needcomma = 1;

      }



  for (i = 0; i < MAX_OPERANDS; i++)

    if (op_index[i] != -1 && op_riprel[i])

      {

	(*info->fprintf_func) (info->stream, "        # ");

	(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep

						+ op_address[op_index[i]]), info);

	break;

      }

  return codep - priv.the_buffer;

}
 and probability:0.2684729064039409
code:static void vp6_parse_coeff_huffman(VP56Context *s)

{

    VP56Model *model = s->modelp;

    uint8_t *permute = s->scantable.permutated;

    VLC *vlc_coeff;

    int coeff, sign, coeff_idx;

    int b, cg, idx;

    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */



    for (b=0; b<6; b++) {

        int ct = 0;    /* code type */

        if (b > 3) pt = 1;

        vlc_coeff = &s->dccv_vlc[pt];



        for (coeff_idx=0; coeff_idx<64; ) {

            int run = 1;

            if (coeff_idx<2 && s->nb_null[coeff_idx][pt]) {

                s->nb_null[coeff_idx][pt]--;

                if (coeff_idx)

                    break;

            } else {

                if (get_bits_count(&s->gb) >= s->gb.size_in_bits)

                    return;

                coeff = get_vlc2(&s->gb, vlc_coeff->table, 9, 3);

                if (coeff == 0) {

                    if (coeff_idx) {

                        int pt = (coeff_idx >= 6);

                        run += get_vlc2(&s->gb, s->runv_vlc[pt].table, 9, 3);

                        if (run >= 9)

                            run += get_bits(&s->gb, 6);

                    } else

                        s->nb_null[0][pt] = vp6_get_nb_null(s);

                    ct = 0;

                } else if (coeff == 11) {  /* end of block */

                    if (coeff_idx == 1)    /* first AC coeff ? */

                        s->nb_null[1][pt] = vp6_get_nb_null(s);

                    break;

                } else {

                    int coeff2 = vp56_coeff_bias[coeff];

                    if (coeff > 4)

                        coeff2 += get_bits(&s->gb, coeff <= 9 ? coeff - 4 : 11);

                    ct = 1 + (coeff2 > 1);

                    sign = get_bits1(&s->gb);

                    coeff2 = (coeff2 ^ -sign) + sign;

                    if (coeff_idx)

                        coeff2 *= s->dequant_ac;

                    idx = model->coeff_index_to_pos[coeff_idx];

                    s->block_coeff[b][permute[idx]] = coeff2;

                }

            }

            coeff_idx+=run;

            cg = FFMIN(vp6_coeff_groups[coeff_idx], 3);

            vlc_coeff = &s->ract_vlc[pt][ct][cg];

        }

    }

}
 and probability:0.42592592592592593
code:static int vncws_start_tls_handshake(VncState *vs)

{

    int ret = gnutls_handshake(vs->tls.session);



    if (ret < 0) {

        if (!gnutls_error_is_fatal(ret)) {

            VNC_DEBUG("Handshake interrupted (blocking)\n");

            if (!gnutls_record_get_direction(vs->tls.session)) {

                qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io,

                                    NULL, vs);

            } else {

                qemu_set_fd_handler(vs->csock, NULL, vncws_tls_handshake_io,

                                    vs);

            }

            return 0;

        }

        VNC_DEBUG("Handshake failed %s\n", gnutls_strerror(ret));

        vnc_client_error(vs);

        return -1;

    }



    if (vs->vd->tls.x509verify) {

        if (vnc_tls_validate_certificate(vs) < 0) {

            VNC_DEBUG("Client verification failed\n");

            vnc_client_error(vs);

            return -1;

        } else {

            VNC_DEBUG("Client verification passed\n");

        }

    }



    VNC_DEBUG("Handshake done, switching to TLS data mode\n");

    qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);



    return 0;

}
 and probability:0.1875
code:av_cold void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
 and probability:0.625
code:static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)

{

    char *backing_file = NULL;

    char *backing_fmt = NULL;

    char *buf = NULL;

    uint64_t size = 0;

    int flags = 0;

    size_t cluster_size = DEFAULT_CLUSTER_SIZE;

    PreallocMode prealloc;

    int version;

    uint64_t refcount_bits;

    int refcount_order;

    const char *encryptfmt = NULL;

    Error *local_err = NULL;

    int ret;



    /* Read out options */

    size = ROUND_UP(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),

                    BDRV_SECTOR_SIZE);

    backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);

    backing_fmt = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FMT);

    encryptfmt = qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT_FORMAT);

    if (encryptfmt) {

        if (qemu_opt_get_del(opts, BLOCK_OPT_ENCRYPT)) {

            error_setg(errp, "Options " BLOCK_OPT_ENCRYPT " and "

                       BLOCK_OPT_ENCRYPT_FORMAT " are mutually exclusive");

            ret = -EINVAL;

            goto finish;

        }

    } else if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ENCRYPT, false)) {

        encryptfmt = "aes";

    }

    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto finish;

    }

    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);

    prealloc = qapi_enum_parse(PreallocMode_lookup, buf,

                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,

                               &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto finish;

    }



    version = qcow2_opt_get_version_del(opts, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto finish;

    }



    if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {

        flags |= BLOCK_FLAG_LAZY_REFCOUNTS;

    }



    if (backing_file && prealloc != PREALLOC_MODE_OFF) {

        error_setg(errp, "Backing file and preallocation cannot be used at "

                   "the same time");

        ret = -EINVAL;

        goto finish;

    }



    if (version < 3 && (flags & BLOCK_FLAG_LAZY_REFCOUNTS)) {

        error_setg(errp, "Lazy refcounts only supported with compatibility "

                   "level 1.1 and above (use compat=1.1 or greater)");

        ret = -EINVAL;

        goto finish;

    }



    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto finish;

    }



    refcount_order = ctz32(refcount_bits);



    ret = qcow2_create2(filename, size, backing_file, backing_fmt, flags,

                        cluster_size, prealloc, opts, version, refcount_order,

                        encryptfmt, &local_err);

    error_propagate(errp, local_err);



finish:

    g_free(backing_file);

    g_free(backing_fmt);

    g_free(buf);

    return ret;

}
 and probability:0.0
code:static void quantize_mantissas(AC3EncodeContext *s)

{

    int blk, ch;





    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {

        AC3Block *block = &s->blocks[blk];

        s->mant1_cnt  = s->mant2_cnt  = s->mant4_cnt  = 0;

        s->qmant1_ptr = s->qmant2_ptr = s->qmant4_ptr = NULL;



        for (ch = 0; ch < s->channels; ch++) {

            quantize_mantissas_blk_ch(s, block->fixed_coef[ch], block->exp_shift[ch],

                                      block->exp[ch], block->bap[ch],

                                      block->qmant[ch], s->nb_coefs[ch]);

        }

    }

}
 and probability:0.5714285714285714
code:static void dma_blk_cb(void *opaque, int ret)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;

    dma_addr_t cur_addr, cur_len;

    void *mem;



    trace_dma_blk_cb(dbs, ret);



    dbs->acb = NULL;

    dbs->sector_num += dbs->iov.size / 512;



    if (dbs->sg_cur_index == dbs->sg->nsg || ret < 0) {

        dma_complete(dbs, ret);

        return;

    }

    dma_blk_unmap(dbs);



    while (dbs->sg_cur_index < dbs->sg->nsg) {

        cur_addr = dbs->sg->sg[dbs->sg_cur_index].base + dbs->sg_cur_byte;

        cur_len = dbs->sg->sg[dbs->sg_cur_index].len - dbs->sg_cur_byte;

        mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);

        if (!mem)

            break;

        qemu_iovec_add(&dbs->iov, mem, cur_len);

        dbs->sg_cur_byte += cur_len;

        if (dbs->sg_cur_byte == dbs->sg->sg[dbs->sg_cur_index].len) {

            dbs->sg_cur_byte = 0;

            ++dbs->sg_cur_index;

        }

    }



    if (dbs->iov.size == 0) {

        trace_dma_map_wait(dbs);

        cpu_register_map_client(dbs, continue_after_map_failure);

        return;

    }



    if (dbs->iov.size & ~BDRV_SECTOR_MASK) {

        qemu_iovec_discard_back(&dbs->iov, dbs->iov.size & ~BDRV_SECTOR_MASK);

    }



    dbs->acb = dbs->io_func(dbs->blk, dbs->sector_num, &dbs->iov,

                            dbs->iov.size / 512, dma_blk_cb, dbs);

    assert(dbs->acb);

}
 and probability:0.47368421052631576
code:long do_sigreturn(CPUPPCState *env)

{

    struct target_sigcontext *sc = NULL;

    struct target_mcontext *sr = NULL;

    target_ulong sr_addr = 0, sc_addr;

    sigset_t blocked;

    target_sigset_t set;



    sc_addr = env->gpr[1] + SIGNAL_FRAMESIZE;

    if (!lock_user_struct(VERIFY_READ, sc, sc_addr, 1))

        goto sigsegv;



#if defined(TARGET_PPC64)

    set.sig[0] = sc->oldmask + ((uint64_t)(sc->_unused[3]) << 32);

#else

    __get_user(set.sig[0], &sc->oldmask);

    __get_user(set.sig[1], &sc->_unused[3]);

#endif

    target_to_host_sigset_internal(&blocked, &set);

    set_sigmask(&blocked);



    __get_user(sr_addr, &sc->regs);

    if (!lock_user_struct(VERIFY_READ, sr, sr_addr, 1))

        goto sigsegv;

    restore_user_regs(env, sr, 1);



    unlock_user_struct(sr, sr_addr, 1);

    unlock_user_struct(sc, sc_addr, 1);

    return -TARGET_QEMU_ESIGRETURN;



sigsegv:

    unlock_user_struct(sr, sr_addr, 1);

    unlock_user_struct(sc, sc_addr, 1);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
 and probability:0.16129032258064516
code:static int virtio_gpu_load(QEMUFile *f, void *opaque, size_t size)

{

    VirtIOGPU *g = opaque;

    struct virtio_gpu_simple_resource *res;

    struct virtio_gpu_scanout *scanout;

    uint32_t resource_id, pformat;

    int i;



    g->hostmem = 0;



    resource_id = qemu_get_be32(f);

    while (resource_id != 0) {

        res = g_new0(struct virtio_gpu_simple_resource, 1);

        res->resource_id = resource_id;

        res->width = qemu_get_be32(f);

        res->height = qemu_get_be32(f);

        res->format = qemu_get_be32(f);

        res->iov_cnt = qemu_get_be32(f);



        /* allocate */

        pformat = get_pixman_format(res->format);

        if (!pformat) {


            return -EINVAL;


        res->image = pixman_image_create_bits(pformat,

                                              res->width, res->height,

                                              NULL, 0);

        if (!res->image) {


            return -EINVAL;




        res->hostmem = PIXMAN_FORMAT_BPP(pformat) * res->width * res->height;



        res->addrs = g_new(uint64_t, res->iov_cnt);

        res->iov = g_new(struct iovec, res->iov_cnt);



        /* read data */

        for (i = 0; i < res->iov_cnt; i++) {

            res->addrs[i] = qemu_get_be64(f);

            res->iov[i].iov_len = qemu_get_be32(f);


        qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),

                        pixman_image_get_stride(res->image) * res->height);



        /* restore mapping */

        for (i = 0; i < res->iov_cnt; i++) {

            hwaddr len = res->iov[i].iov_len;

            res->iov[i].iov_base =

                cpu_physical_memory_map(res->addrs[i], &len, 1);

            if (!res->iov[i].iov_base || len != res->iov[i].iov_len) {











                return -EINVAL;





        QTAILQ_INSERT_HEAD(&g->reslist, res, next);

        g->hostmem += res->hostmem;



        resource_id = qemu_get_be32(f);




    /* load & apply scanout state */

    vmstate_load_state(f, &vmstate_virtio_gpu_scanouts, g, 1);

    for (i = 0; i < g->conf.max_outputs; i++) {

        scanout = &g->scanout[i];

        if (!scanout->resource_id) {

            continue;


        res = virtio_gpu_find_resource(g, scanout->resource_id);

        if (!res) {

            return -EINVAL;


        scanout->ds = qemu_create_displaysurface_pixman(res->image);

        if (!scanout->ds) {

            return -EINVAL;




        dpy_gfx_replace_surface(scanout->con, scanout->ds);

        dpy_gfx_update(scanout->con, 0, 0, scanout->width, scanout->height);

        update_cursor(g, &scanout->cursor);

        res->scanout_bitmask |= (1 << i);




    return 0;
 and probability:0.5737704918032787
code:static av_cold int iv_alloc_frames(Indeo3DecodeContext *s)

{

    int luma_width    = (s->width           + 3) & ~3,

        luma_height   = (s->height          + 3) & ~3,

        chroma_width  = ((luma_width  >> 2) + 3) & ~3,

        chroma_height = ((luma_height >> 2) + 3) & ~3,

        luma_pixels   = luma_width   * luma_height,

        chroma_pixels = chroma_width * chroma_height,

        i;

    unsigned int bufsize = luma_pixels * 2 + luma_width * 3 +

                          (chroma_pixels   + chroma_width) * 4;




    if(!(s->buf = av_malloc(bufsize)))

        return AVERROR(ENOMEM);

    s->iv_frame[0].y_w = s->iv_frame[1].y_w = luma_width;

    s->iv_frame[0].y_h = s->iv_frame[1].y_h = luma_height;

    s->iv_frame[0].uv_w = s->iv_frame[1].uv_w = chroma_width;

    s->iv_frame[0].uv_h = s->iv_frame[1].uv_h = chroma_height;



    s->iv_frame[0].Ybuf = s->buf + luma_width;

    i = luma_pixels + luma_width * 2;

    s->iv_frame[1].Ybuf = s->buf + i;

    i += (luma_pixels + luma_width);

    s->iv_frame[0].Ubuf = s->buf + i;

    i += (chroma_pixels + chroma_width);

    s->iv_frame[1].Ubuf = s->buf + i;

    i += (chroma_pixels + chroma_width);

    s->iv_frame[0].Vbuf = s->buf + i;

    i += (chroma_pixels + chroma_width);

    s->iv_frame[1].Vbuf = s->buf + i;



    for(i = 1; i <= luma_width; i++)

        s->iv_frame[0].Ybuf[-i] = s->iv_frame[1].Ybuf[-i] =

            s->iv_frame[0].Ubuf[-i] = 0x80;



    for(i = 1; i <= chroma_width; i++) {

        s->iv_frame[1].Ubuf[-i] = 0x80;

        s->iv_frame[0].Vbuf[-i] = 0x80;

        s->iv_frame[1].Vbuf[-i] = 0x80;

        s->iv_frame[1].Vbuf[chroma_pixels+i-1] = 0x80;

    }



    return 0;

} and probability:0.8205128205128205
code:static int mov_write_minf_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    int ret;



    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, "minf");

    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO)

        mov_write_vmhd_tag(pb);

    else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO)

        mov_write_smhd_tag(pb);

    else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {

        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {

            mov_write_gmhd_tag(pb, track);

        } else {

            mov_write_nmhd_tag(pb);

        }

    } else if (track->tag == MKTAG('r','t','p',' ')) {

        mov_write_hmhd_tag(pb);

    } else if (track->tag == MKTAG('t','m','c','d')) {

        mov_write_gmhd_tag(pb, track);

    }

    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */

        mov_write_hdlr_tag(pb, NULL);

    mov_write_dinf_tag(pb);

    if ((ret = mov_write_stbl_tag(pb, mov, track)) < 0)

        return ret;

    return update_size(pb, pos);

}
 and probability:0.25
code:int av_packet_ref(AVPacket *dst, AVPacket *src)

{

    int ret;



    ret = av_packet_copy_props(dst, src);

    if (ret < 0)

        return ret;



    if (!src->buf) {

        ret = packet_alloc(&dst->buf, src->size);

        if (ret < 0)

            goto fail;

        memcpy(dst->buf->data, src->data, src->size);

    } else

        dst->buf = av_buffer_ref(src->buf);



    dst->size = src->size;

    dst->data = dst->buf->data;

    return 0;

fail:

    av_packet_free_side_data(dst);

    return ret;

}
 and probability:0.3
code:av_cold void ff_float_dsp_init_ppc(AVFloatDSPContext *fdsp, int bit_exact)

{

#if HAVE_ALTIVEC

    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))

        return;



    fdsp->vector_fmul = ff_vector_fmul_altivec;

    fdsp->vector_fmul_add = ff_vector_fmul_add_altivec;

    fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_altivec;



    if (!bit_exact) {

        fdsp->vector_fmul_window = ff_vector_fmul_window_altivec;

    }

#endif

}
 and probability:0.3076923076923077
code:static int config_props(AVFilterLink *inlink)

{

    AVFilterContext *ctx = inlink->dst;

    LutContext *lut = ctx->priv;

    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];

    int min[4], max[4];

    int val, comp, ret;



    lut->hsub = desc->log2_chroma_w;

    lut->vsub = desc->log2_chroma_h;



    lut->var_values[VAR_W] = inlink->w;

    lut->var_values[VAR_H] = inlink->h;



    switch (inlink->format) {

    case PIX_FMT_YUV410P:

    case PIX_FMT_YUV411P:

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV440P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_YUVA420P:

        min[Y] = min[U] = min[V] = 16;

        max[Y] = 235;

        max[U] = max[V] = 240;

        min[A] = 0; max[A] = 255;

        break;

    default:

        min[0] = min[1] = min[2] = min[3] = 0;

        max[0] = max[1] = max[2] = max[3] = 255;

    }



    lut->is_yuv = lut->is_rgb = 0;

    if      (ff_fmt_is_in(inlink->format, yuv_pix_fmts)) lut->is_yuv = 1;

    else if (ff_fmt_is_in(inlink->format, rgb_pix_fmts)) lut->is_rgb = 1;



    if (lut->is_rgb) {

        switch (inlink->format) {

        case PIX_FMT_ARGB:  lut->rgba_map[A] = 0; lut->rgba_map[R] = 1; lut->rgba_map[G] = 2; lut->rgba_map[B] = 3; break;

        case PIX_FMT_ABGR:  lut->rgba_map[A] = 0; lut->rgba_map[B] = 1; lut->rgba_map[G] = 2; lut->rgba_map[R] = 3; break;

        case PIX_FMT_RGBA:

        case PIX_FMT_RGB24: lut->rgba_map[R] = 0; lut->rgba_map[G] = 1; lut->rgba_map[B] = 2; lut->rgba_map[A] = 3; break;

        case PIX_FMT_BGRA:

        case PIX_FMT_BGR24: lut->rgba_map[B] = 0; lut->rgba_map[G] = 1; lut->rgba_map[R] = 2; lut->rgba_map[A] = 3; break;

        }

        lut->step = av_get_bits_per_pixel(desc) >> 3;

    }



    for (comp = 0; comp < desc->nb_components; comp++) {

        double res;



        /* create the parsed expression */

        ret = av_expr_parse(&lut->comp_expr[comp], lut->comp_expr_str[comp],

                            var_names, funcs1_names, funcs1, NULL, NULL, 0, ctx);

        if (ret < 0) {

            av_log(ctx, AV_LOG_ERROR,

                   "Error when parsing the expression '%s' for the component %d.\n",

                   lut->comp_expr_str[comp], comp);

            return AVERROR(EINVAL);

        }



        /* compute the lut */

        lut->var_values[VAR_MAXVAL] = max[comp];

        lut->var_values[VAR_MINVAL] = min[comp];



        for (val = 0; val < 256; val++) {

            lut->var_values[VAR_VAL] = val;

            lut->var_values[VAR_CLIPVAL] = av_clip(val, min[comp], max[comp]);

            lut->var_values[VAR_NEGVAL] =

                av_clip(min[comp] + max[comp] - lut->var_values[VAR_VAL],

                        min[comp], max[comp]);



            res = av_expr_eval(lut->comp_expr[comp], lut->var_values, lut);

            if (isnan(res)) {

                av_log(ctx, AV_LOG_ERROR,

                       "Error when evaluating the expression '%s' for the value %d for the component #%d.\n",

                       lut->comp_expr_str[comp], val, comp);

                return AVERROR(EINVAL);

            }

            lut->lut[comp][val] = av_clip((int)res, min[comp], max[comp]);

            av_log(ctx, AV_LOG_DEBUG, "val[%d][%d] = %d\n", comp, val, lut->lut[comp][val]);

        }

    }



    return 0;

}
 and probability:0.52
code:static av_cold int rpza_decode_init(AVCodecContext *avctx)

{

    RpzaContext *s = avctx->priv_data;



    s->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_RGB555;



    s->frame.data[0] = NULL;



    return 0;

}
 and probability:0.5
code:static int huffman_decode(MPADecodeContext *s, GranuleDef *g,

                          int16_t *exponents, int end_pos2)

{

    int s_index;

    int i;

    int last_pos, bits_left;

    VLC *vlc;

    int end_pos = FFMIN(end_pos2, s->gb.size_in_bits);



    /* low frequencies (called big values) */

    s_index = 0;

    for (i = 0; i < 3; i++) {

        int j, k, l, linbits;

        j = g->region_size[i];

        if (j == 0)

            continue;

        /* select vlc table */

        k       = g->table_select[i];

        l       = mpa_huff_data[k][0];

        linbits = mpa_huff_data[k][1];

        vlc     = &huff_vlc[l];



        if (!l) {

            memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * 2 * j);

            s_index += 2 * j;

            continue;

        }



        /* read huffcode and compute each couple */

        for (; j > 0; j--) {

            int exponent, x, y;

            int v;

            int pos = get_bits_count(&s->gb);



            if (pos >= end_pos){

                switch_buffer(s, &pos, &end_pos, &end_pos2);

                if (pos >= end_pos)

                    break;

            }

            y = get_vlc2(&s->gb, vlc->table, 7, 3);



            if (!y) {

                g->sb_hybrid[s_index  ] =

                g->sb_hybrid[s_index+1] = 0;

                s_index += 2;

                continue;

            }



            exponent= exponents[s_index];



            ff_dlog(s->avctx, "region=%d n=%d x=%d y=%d exp=%d\n",

                    i, g->region_size[i] - j, x, y, exponent);

            if (y & 16) {

                x = y >> 5;

                y = y & 0x0f;

                if (x < 15) {

                    READ_FLIP_SIGN(g->sb_hybrid + s_index, RENAME(expval_table)[exponent] + x)

                } else {

                    x += get_bitsz(&s->gb, linbits);

                    v  = l3_unscale(x, exponent);

                    if (get_bits1(&s->gb))

                        v = -v;

                    g->sb_hybrid[s_index] = v;

                }

                if (y < 15) {

                    READ_FLIP_SIGN(g->sb_hybrid + s_index + 1, RENAME(expval_table)[exponent] + y)

                } else {

                    y += get_bitsz(&s->gb, linbits);

                    v  = l3_unscale(y, exponent);

                    if (get_bits1(&s->gb))

                        v = -v;

                    g->sb_hybrid[s_index+1] = v;

                }

            } else {

                x = y >> 5;

                y = y & 0x0f;

                x += y;

                if (x < 15) {

                    READ_FLIP_SIGN(g->sb_hybrid + s_index + !!y, RENAME(expval_table)[exponent] + x)

                } else {

                    x += get_bitsz(&s->gb, linbits);

                    v  = l3_unscale(x, exponent);

                    if (get_bits1(&s->gb))

                        v = -v;

                    g->sb_hybrid[s_index+!!y] = v;

                }

                g->sb_hybrid[s_index + !y] = 0;

            }

            s_index += 2;

        }

    }



    /* high frequencies */

    vlc = &huff_quad_vlc[g->count1table_select];

    last_pos = 0;

    while (s_index <= 572) {

        int pos, code;

        pos = get_bits_count(&s->gb);

        if (pos >= end_pos) {

            if (pos > end_pos2 && last_pos) {

                /* some encoders generate an incorrect size for this

                   part. We must go back into the data */

                s_index -= 4;

                skip_bits_long(&s->gb, last_pos - pos);

                av_log(s->avctx, AV_LOG_INFO, "overread, skip %d enddists: %d %d\n", last_pos - pos, end_pos-pos, end_pos2-pos);

                if(s->err_recognition & AV_EF_BITSTREAM)

                    s_index=0;

                break;

            }

            switch_buffer(s, &pos, &end_pos, &end_pos2);

            if (pos >= end_pos)

                break;

        }

        last_pos = pos;



        code = get_vlc2(&s->gb, vlc->table, vlc->bits, 1);

        ff_dlog(s->avctx, "t=%d code=%d\n", g->count1table_select, code);

        g->sb_hybrid[s_index+0] =

        g->sb_hybrid[s_index+1] =

        g->sb_hybrid[s_index+2] =

        g->sb_hybrid[s_index+3] = 0;

        while (code) {

            static const int idxtab[16] = { 3,3,2,2,1,1,1,1,0,0,0,0,0,0,0,0 };

            int v;

            int pos = s_index + idxtab[code];

            code   ^= 8 >> idxtab[code];

            READ_FLIP_SIGN(g->sb_hybrid + pos, RENAME(exp_table)+exponents[pos])

        }

        s_index += 4;

    }

    /* skip extension bits */

    bits_left = end_pos2 - get_bits_count(&s->gb);

    if (bits_left < 0 && (s->err_recognition & AV_EF_BUFFER)) {

        av_log(s->avctx, AV_LOG_ERROR, "bits_left=%d\n", bits_left);

        s_index=0;

    } else if (bits_left > 0 && (s->err_recognition & AV_EF_BUFFER)) {

        av_log(s->avctx, AV_LOG_ERROR, "bits_left=%d\n", bits_left);

        s_index = 0;

    }

    memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * (576 - s_index));

    skip_bits_long(&s->gb, bits_left);



    i = get_bits_count(&s->gb);

    switch_buffer(s, &i, &end_pos, &end_pos2);



    return 0;

}
 and probability:0.41911764705882354
code:void helper_slbie(CPUPPCState *env, target_ulong addr)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    ppc_slb_t *slb;



    slb = slb_lookup(cpu, addr);

    if (!slb) {

        return;

    }



    if (slb->esid & SLB_ESID_V) {

        slb->esid &= ~SLB_ESID_V;



        /* XXX: given the fact that segment size is 256 MB or 1TB,

         *      and we still don't have a tlb_flush_mask(env, n, mask)

         *      in QEMU, we just invalidate all TLBs

         */

        tlb_flush(CPU(cpu), 1);

    }

}
 and probability:0.11764705882352941
code:static inline void do_rfi(CPUPPCState *env, target_ulong nip, target_ulong msr)

{

    CPUState *cs = CPU(ppc_env_get_cpu(env));



    /* MSR:POW cannot be set by any form of rfi */

    msr &= ~(1ULL << MSR_POW);



#if defined(TARGET_PPC64)

    /* Switching to 32-bit ? Crop the nip */

    if (!msr_is_64bit(env, msr)) {

        nip = (uint32_t)nip;

    }

#else

    nip = (uint32_t)nip;

#endif

    /* XXX: beware: this is false if VLE is supported */

    env->nip = nip & ~((target_ulong)0x00000003);

    hreg_store_msr(env, msr, 1);

#if defined(DEBUG_OP)

    cpu_dump_rfi(env->nip, env->msr);

#endif

    /* No need to raise an exception here,

     * as rfi is always the last insn of a TB

     */

    cs->interrupt_request |= CPU_INTERRUPT_EXITTB;



    /* Context synchronizing: check if TCG TLB needs flush */

    check_tlb_flush(env);

}
 and probability:0.11538461538461539
code:static void d3d11va_device_uninit(AVHWDeviceContext *hwdev)

{

    AVD3D11VADeviceContext *device_hwctx = hwdev->hwctx;



    if (device_hwctx->device)

        ID3D11Device_Release(device_hwctx->device);



    if (device_hwctx->device_context)

        ID3D11DeviceContext_Release(device_hwctx->device_context);



    if (device_hwctx->video_device)

        ID3D11VideoDevice_Release(device_hwctx->video_device);



    if (device_hwctx->video_context)

        ID3D11VideoContext_Release(device_hwctx->video_context);



    if (device_hwctx->lock == d3d11va_default_lock)

        CloseHandle(device_hwctx->lock_ctx);

}
 and probability:0.7857142857142857
code:int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,

                      AVCodecContext *codec, int size, int big_endian)

{

    int id;

    uint64_t bitrate;



    if (size < 14) {

        avpriv_request_sample(codec, "wav header size < 14");

        return AVERROR_INVALIDDATA;

    }



    codec->codec_type  = AVMEDIA_TYPE_AUDIO;

    if (!big_endian) {

        id                 = avio_rl16(pb);

        codec->channels    = avio_rl16(pb);

        codec->sample_rate = avio_rl32(pb);

        bitrate            = avio_rl32(pb) * 8;

        codec->block_align = avio_rl16(pb);

    } else {

        id                 = avio_rb16(pb);

        codec->channels    = avio_rb16(pb);

        codec->sample_rate = avio_rb32(pb);

        bitrate            = avio_rb32(pb) * 8;

        codec->block_align = avio_rb16(pb);

    }

    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */

        codec->bits_per_coded_sample = 8;

    } else {

        if (!big_endian) {

            codec->bits_per_coded_sample = avio_rl16(pb);

        } else {

            codec->bits_per_coded_sample = avio_rb16(pb);

        }

    }

    if (id == 0xFFFE) {

        codec->codec_tag = 0;

    } else {

        codec->codec_tag = id;

        codec->codec_id  = ff_wav_codec_get_id(id,

                                               codec->bits_per_coded_sample);

    }

    if (size >= 18) {  /* We're obviously dealing with WAVEFORMATEX */

        int cbSize = avio_rl16(pb); /* cbSize */

        if (big_endian) {

            avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n");

            return AVERROR_PATCHWELCOME;

        }

        size  -= 18;

        cbSize = FFMIN(size, cbSize);

        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */

            parse_waveformatex(pb, codec);

            cbSize -= 22;

            size   -= 22;

        }

        if (cbSize > 0) {

            av_freep(&codec->extradata);

            if (ff_get_extradata(codec, pb, cbSize) < 0)

                return AVERROR(ENOMEM);

            size -= cbSize;

        }



        /* It is possible for the chunk to contain garbage at the end */

        if (size > 0)

            avio_skip(pb, size);

    }



    if (bitrate > INT_MAX) {

        if (s->error_recognition & AV_EF_EXPLODE) {

            av_log(s, AV_LOG_ERROR,

                   "The bitrate %"PRIu64" is too large.\n",

                    bitrate);

            return AVERROR_INVALIDDATA;

        } else {

            av_log(s, AV_LOG_WARNING,

                   "The bitrate %"PRIu64" is too large, resetting to 0.",

                   bitrate);

            codec->bit_rate = 0;

        }

    } else {

        codec->bit_rate = bitrate;

    }



    if (codec->sample_rate <= 0) {

        av_log(s, AV_LOG_ERROR,

               "Invalid sample rate: %d\n", codec->sample_rate);

        return AVERROR_INVALIDDATA;

    }

    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {

        /* Channels and sample_rate values are those prior to applying SBR

         * and/or PS. */

        codec->channels    = 0;

        codec->sample_rate = 0;

    }

    /* override bits_per_coded_sample for G.726 */

    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)

        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;



    return 0;

}
 and probability:0.3333333333333333
code:static void test_acpi_asl(test_data *data)

{

    int i;

    AcpiSdtTable *sdt, *exp_sdt;

    test_data exp_data;

    gboolean exp_err, err;



    memset(&exp_data, 0, sizeof(exp_data));

    exp_data.tables = load_expected_aml(data);

    dump_aml_files(data, false);

    for (i = 0; i < data->tables->len; ++i) {

        GString *asl, *exp_asl;



        sdt = &g_array_index(data->tables, AcpiSdtTable, i);

        exp_sdt = &g_array_index(exp_data.tables, AcpiSdtTable, i);



        err = load_asl(data->tables, sdt);

        asl = normalize_asl(sdt->asl);



        exp_err = load_asl(exp_data.tables, exp_sdt);

        exp_asl = normalize_asl(exp_sdt->asl);



        /* TODO: check for warnings */

        g_assert(!err || exp_err);



        if (g_strcmp0(asl->str, exp_asl->str)) {

            uint32_t signature = cpu_to_le32(exp_sdt->header.signature);

            sdt->tmp_files_retain = true;

            exp_sdt->tmp_files_retain = true;

            fprintf(stderr,

                    "acpi-test: Warning! %.4s mismatch. "

                    "Actual [asl:%s, aml:%s], Expected [asl:%s, aml:%s].\n",

                    (gchar *)&signature,

                    sdt->asl_file, sdt->aml_file,

                    exp_sdt->asl_file, exp_sdt->aml_file);

        }

        g_string_free(asl, true);

        g_string_free(exp_asl, true);

    }



    free_test_data(&exp_data);

}
 and probability:0.3142857142857143
code:static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,

                                int size, int type,

                                uint32_t **lace_buf, int *laces)

{

    int res = 0, n;

    uint8_t *data = *buf;

    uint32_t *lace_size;



    if (!type) {

        *laces = 1;

        *lace_buf = av_mallocz(sizeof(int));

        if (!*lace_buf)

            return AVERROR(ENOMEM);



        *lace_buf[0] = size;

        return 0;

    }



    assert(size > 0);

    *laces = *data + 1;

    data += 1;

    size -= 1;

    lace_size = av_mallocz(*laces * sizeof(int));

    if (!lace_size)

        return AVERROR(ENOMEM);



    switch (type) {

    case 0x1: /* Xiph lacing */ {

        uint8_t temp;

        uint32_t total = 0;

        for (n = 0; res == 0 && n < *laces - 1; n++) {

            while (1) {

                if (size == 0) {

                    res = AVERROR_EOF;

                    break;

                }

                temp = *data;

                lace_size[n] += temp;

                data += 1;

                size -= 1;

                if (temp != 0xff)

                    break;

            }

            total += lace_size[n];

        }

        if (size <= total) {

            res = AVERROR_INVALIDDATA;

            break;

        }



        lace_size[n] = size - total;

        break;

    }



    case 0x2: /* fixed-size lacing */

        if (size != (size / *laces) * size) {

            res = AVERROR_INVALIDDATA;

            break;

        }

        for (n = 0; n < *laces; n++)

            lace_size[n] = size / *laces;

        break;



    case 0x3: /* EBML lacing */ {

        uint64_t num;

        uint32_t total;

        n = matroska_ebmlnum_uint(matroska, data, size, &num);

        if (n < 0) {

            av_log(matroska->ctx, AV_LOG_INFO,

                   "EBML block data error\n");

            res = n;

            break;

        }

        data += n;

        size -= n;

        total = lace_size[0] = num;

        for (n = 1; res == 0 && n < *laces - 1; n++) {

            int64_t snum;

            int r;

            r = matroska_ebmlnum_sint(matroska, data, size, &snum);

            if (r < 0) {

                av_log(matroska->ctx, AV_LOG_INFO,

                       "EBML block data error\n");

                res = r;

                break;

            }

            data += r;

            size -= r;

            lace_size[n] = lace_size[n - 1] + snum;

            total += lace_size[n];

        }

        if (size <= total) {

            res = AVERROR_INVALIDDATA;

            break;

        }

        lace_size[*laces - 1] = size - total;

        break;

    }

    }



    *buf      = data;

    *lace_buf = lace_size;



    return res;

}
 and probability:0.3333333333333333
code:static int parse_picture_segment(AVCodecContext *avctx,

                                  const uint8_t *buf, int buf_size)

{

    PGSSubContext *ctx = avctx->priv_data;



    uint8_t sequence_desc;

    unsigned int rle_bitmap_len, width, height;



    if (buf_size <= 4)

        return -1;

    buf_size -= 4;



    /* skip 3 unknown bytes: Object ID (2 bytes), Version Number */

    buf += 3;



    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */

    sequence_desc = bytestream_get_byte(&buf);



    if (!(sequence_desc & 0x80)) {

        /* Additional RLE data */

        if (buf_size > ctx->picture.rle_remaining_len)

            return -1;



        memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);

        ctx->picture.rle_data_len += buf_size;

        ctx->picture.rle_remaining_len -= buf_size;



        return 0;

    }



    if (buf_size <= 7)

        return -1;

    buf_size -= 7;



    /* Decode rle bitmap length, stored size includes width/height data */

    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;



    /* Get bitmap dimensions from data */

    width  = bytestream_get_be16(&buf);

    height = bytestream_get_be16(&buf);



    /* Make sure the bitmap is not too large */

    if (avctx->width < width || avctx->height < height) {

        av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions larger than video.\n");

        return -1;

    }



    ctx->picture.w = width;

    ctx->picture.h = height;



    av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);



    if (!ctx->picture.rle)

        return -1;



    memcpy(ctx->picture.rle, buf, buf_size);

    ctx->picture.rle_data_len = buf_size;

    ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;



    return 0;

}
 and probability:0.37777777777777777
code:void hmp_info_io_apic(Monitor *mon, const QDict *qdict)

{

    if (kvm_irqchip_in_kernel()) {

        kvm_ioapic_dump_state(mon, qdict);

    } else {

        ioapic_dump_state(mon, qdict);

    }

}
 and probability:0.0
code:static av_cold int split_init(AVFilterContext *ctx)

{

    SplitContext *s = ctx->priv;

    int i;



    for (i = 0; i < s->nb_outputs; i++) {

        char name[32];

        AVFilterPad pad = { 0 };



        snprintf(name, sizeof(name), "output%d", i);

        pad.type = ctx->filter->inputs[0].type;

        pad.name = av_strdup(name);

        if (!pad.name)

            return AVERROR(ENOMEM);



        ff_insert_outpad(ctx, i, &pad);

    }



    return 0;

}
 and probability:0.1875
code:static void ide_set_signature(IDEState *s)

{

    s->select &= 0xf0; /* clear head */

    /* put signature */

    s->nsector = 1;

    s->sector = 1;

    if (s->drive_kind == IDE_CD) {

        s->lcyl = 0x14;

        s->hcyl = 0xeb;

    } else if (s->bs) {

        s->lcyl = 0;

        s->hcyl = 0;

    } else {

        s->lcyl = 0xff;

        s->hcyl = 0xff;

    }

}
 and probability:0.6470588235294118
code:void isa_mmio_init(target_phys_addr_t base, target_phys_addr_t size)

{

    MemoryRegion *mr = g_malloc(sizeof(*mr));



    isa_mmio_setup(mr, size);

    memory_region_add_subregion(get_system_memory(), base, mr);

}
 and probability:0.16666666666666666
code:static int find_allocation(BlockDriverState *bs, off_t start,

                           off_t *data, off_t *hole)

{

    BDRVGlusterState *s = bs->opaque;

    off_t offs;



    if (!s->supports_seek_data) {

        return -ENOTSUP;

    }



    /*

     * SEEK_DATA cases:

     * D1. offs == start: start is in data

     * D2. offs > start: start is in a hole, next data at offs

     * D3. offs < 0, errno = ENXIO: either start is in a trailing hole

     *                              or start is beyond EOF

     *     If the latter happens, the file has been truncated behind

     *     our back since we opened it.  All bets are off then.

     *     Treating like a trailing hole is simplest.

     * D4. offs < 0, errno != ENXIO: we learned nothing

     */

    offs = glfs_lseek(s->fd, start, SEEK_DATA);

    if (offs < 0) {

        return -errno;          /* D3 or D4 */

    }

    assert(offs >= start);



    if (offs > start) {

        /* D2: in hole, next data at offs */

        *hole = start;

        *data = offs;

        return 0;

    }



    /* D1: in data, end not yet known */



    /*

     * SEEK_HOLE cases:

     * H1. offs == start: start is in a hole

     *     If this happens here, a hole has been dug behind our back

     *     since the previous lseek().

     * H2. offs > start: either start is in data, next hole at offs,

     *                   or start is in trailing hole, EOF at offs

     *     Linux treats trailing holes like any other hole: offs ==

     *     start.  Solaris seeks to EOF instead: offs > start (blech).

     *     If that happens here, a hole has been dug behind our back

     *     since the previous lseek().

     * H3. offs < 0, errno = ENXIO: start is beyond EOF

     *     If this happens, the file has been truncated behind our

     *     back since we opened it.  Treat it like a trailing hole.

     * H4. offs < 0, errno != ENXIO: we learned nothing

     *     Pretend we know nothing at all, i.e. "forget" about D1.

     */

    offs = glfs_lseek(s->fd, start, SEEK_HOLE);

    if (offs < 0) {

        return -errno;          /* D1 and (H3 or H4) */

    }

    assert(offs >= start);



    if (offs > start) {

        /*

         * D1 and H2: either in data, next hole at offs, or it was in

         * data but is now in a trailing hole.  In the latter case,

         * all bets are off.  Treating it as if it there was data all

         * the way to EOF is safe, so simply do that.

         */

        *data = start;

        *hole = offs;

        return 0;

    }



    /* D1 and H1 */

    return -EBUSY;

}
 and probability:0.11940298507462686
code:static void test_validate_struct_nested(TestInputVisitorData *data,

                                         const void *unused)

{

    UserDefTwo *udp = NULL;

    Visitor *v;



    v = validate_test_init(data, "{ 'string0': 'string0', "

                           "'dict1': { 'string1': 'string1', "

                           "'dict2': { 'userdef': { 'integer': 42, "

                           "'string': 'string' }, 'string': 'string2'}}}");



    visit_type_UserDefTwo(v, NULL, &udp, &error_abort);

    qapi_free_UserDefTwo(udp);

}
 and probability:0.0
code:void v9fs_device_unrealize_common(V9fsState *s, Error **errp)

{

    g_free(s->ctx.fs_root);

    g_free(s->tag);

}
 and probability:0.4
code:static int copy_moof(AVFormatContext *s, const char* infile, const char *outfile, int64_t size)

{

    AVIOContext *in, *out;

    int ret = 0;

    if ((ret = avio_open2(&in, infile, AVIO_FLAG_READ, &s->interrupt_callback, NULL)) < 0)

        return ret;

    if ((ret = avio_open2(&out, outfile, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL)) < 0) {

        avio_close(in);

        return ret;

    }

    while (size > 0) {

        uint8_t buf[8192];

        int n = FFMIN(size, sizeof(buf));

        n = avio_read(in, buf, n);

        if (n <= 0) {

            ret = AVERROR(EIO);

            break;

        }

        avio_write(out, buf, n);

        size -= n;

    }

    avio_flush(out);

    avio_close(out);

    avio_close(in);

    return ret;

}
 and probability:0.11538461538461539
code:static int get_uint64_as_uint32(QEMUFile *f, void *pv, size_t size,

                                VMStateField *field)

{

    uint64_t *v = pv;

    *v = qemu_get_be32(f);

    return 0;

}
 and probability:0.14285714285714285
code:void acpi_memory_plug_cb(HotplugHandler *hotplug_dev, MemHotplugState *mem_st,

                         DeviceState *dev, Error **errp)

{

    MemStatus *mdev;

    DeviceClass *dc = DEVICE_GET_CLASS(dev);



    if (!dc->hotpluggable) {

        return;

    }



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    mdev->dimm = dev;

    mdev->is_enabled = true;

    if (dev->hotplugged) {

        mdev->is_inserting = true;

        acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);

    }

}
 and probability:0.2631578947368421
code:uint8_t *xen_map_cache(hwaddr phys_addr, hwaddr size,

                       uint8_t lock)

{

    MapCacheEntry *entry, *pentry = NULL;

    hwaddr address_index;

    hwaddr address_offset;

    hwaddr cache_size = size;

    hwaddr test_bit_size;

    bool translated = false;



tryagain:

    address_index  = phys_addr >> MCACHE_BUCKET_SHIFT;

    address_offset = phys_addr & (MCACHE_BUCKET_SIZE - 1);



    trace_xen_map_cache(phys_addr);



    /* test_bit_size is always a multiple of XC_PAGE_SIZE */

    if (size) {

        test_bit_size = size + (phys_addr & (XC_PAGE_SIZE - 1));



        if (test_bit_size % XC_PAGE_SIZE) {

            test_bit_size += XC_PAGE_SIZE - (test_bit_size % XC_PAGE_SIZE);

        }

    } else {

        test_bit_size = XC_PAGE_SIZE;

    }



    if (mapcache->last_entry != NULL &&

        mapcache->last_entry->paddr_index == address_index &&

        !lock && !size &&

        test_bits(address_offset >> XC_PAGE_SHIFT,

                  test_bit_size >> XC_PAGE_SHIFT,

                  mapcache->last_entry->valid_mapping)) {

        trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);

        return mapcache->last_entry->vaddr_base + address_offset;

    }



    /* size is always a multiple of MCACHE_BUCKET_SIZE */

    if (size) {

        cache_size = size + address_offset;

        if (cache_size % MCACHE_BUCKET_SIZE) {

            cache_size += MCACHE_BUCKET_SIZE - (cache_size % MCACHE_BUCKET_SIZE);

        }

    } else {

        cache_size = MCACHE_BUCKET_SIZE;

    }



    entry = &mapcache->entry[address_index % mapcache->nr_buckets];



    while (entry && entry->lock && entry->vaddr_base &&

            (entry->paddr_index != address_index || entry->size != cache_size ||

             !test_bits(address_offset >> XC_PAGE_SHIFT,

                 test_bit_size >> XC_PAGE_SHIFT,

                 entry->valid_mapping))) {

        pentry = entry;

        entry = entry->next;

    }

    if (!entry) {

        entry = g_malloc0(sizeof (MapCacheEntry));

        pentry->next = entry;

        xen_remap_bucket(entry, cache_size, address_index);

    } else if (!entry->lock) {

        if (!entry->vaddr_base || entry->paddr_index != address_index ||

                entry->size != cache_size ||

                !test_bits(address_offset >> XC_PAGE_SHIFT,

                    test_bit_size >> XC_PAGE_SHIFT,

                    entry->valid_mapping)) {

            xen_remap_bucket(entry, cache_size, address_index);

        }

    }



    if(!test_bits(address_offset >> XC_PAGE_SHIFT,

                test_bit_size >> XC_PAGE_SHIFT,

                entry->valid_mapping)) {

        mapcache->last_entry = NULL;

        if (!translated && mapcache->phys_offset_to_gaddr) {

            phys_addr = mapcache->phys_offset_to_gaddr(phys_addr, size, mapcache->opaque);

            translated = true;

            goto tryagain;

        }

        trace_xen_map_cache_return(NULL);

        return NULL;

    }



    mapcache->last_entry = entry;

    if (lock) {

        MapCacheRev *reventry = g_malloc0(sizeof(MapCacheRev));

        entry->lock++;

        reventry->vaddr_req = mapcache->last_entry->vaddr_base + address_offset;

        reventry->paddr_index = mapcache->last_entry->paddr_index;

        reventry->size = entry->size;

        QTAILQ_INSERT_HEAD(&mapcache->locked_entries, reventry, next);

    }



    trace_xen_map_cache_return(mapcache->last_entry->vaddr_base + address_offset);

    return mapcache->last_entry->vaddr_base + address_offset;

}
 and probability:0.3953488372093023
code:static void usb_hid_changed(HIDState *hs)

{

    USBHIDState *us = container_of(hs, USBHIDState, hid);



    us->changed = 1;



    if (us->datain) {

        us->datain(us->datain_opaque);

    }



    usb_wakeup(&us->dev);

}
 and probability:0.4444444444444444
code:static int nbd_errno_to_system_errno(int err)

{

    switch (err) {

    case NBD_SUCCESS:

        return 0;

    case NBD_EPERM:

        return EPERM;

    case NBD_EIO:

        return EIO;

    case NBD_ENOMEM:

        return ENOMEM;

    case NBD_ENOSPC:

        return ENOSPC;

    default:

        TRACE("Squashing unexpected error %d to EINVAL", err);

        /* fallthrough */

    case NBD_EINVAL:

        return EINVAL;

    }

}
 and probability:0.0
code:static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,

                               BdrvCheckMode fix, uint16_t **refcount_table,

                               int64_t *nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    int64_t i;

    QCowSnapshot *sn;

    int ret;



    *refcount_table = g_try_new0(uint16_t, *nb_clusters);

    if (*nb_clusters && *refcount_table == NULL) {

        res->check_errors++;

        return -ENOMEM;

    }



    /* header */

    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,

                        0, s->cluster_size);

    if (ret < 0) {

        return ret;

    }



    /* current L1 table */

    ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,

                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);

    if (ret < 0) {

        return ret;

    }



    /* snapshots */

    for (i = 0; i < s->nb_snapshots; i++) {

        sn = s->snapshots + i;

        ret = check_refcounts_l1(bs, res, *refcount_table, *nb_clusters,

                                 sn->l1_table_offset, sn->l1_size, 0);

        if (ret < 0) {

            return ret;

        }

    }

    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,

                        s->snapshots_offset, s->snapshots_size);

    if (ret < 0) {

        return ret;

    }



    /* refcount data */

    ret = inc_refcounts(bs, res, *refcount_table, *nb_clusters,

                        s->refcount_table_offset,

                        s->refcount_table_size * sizeof(uint64_t));

    if (ret < 0) {

        return ret;

    }



    return check_refblocks(bs, res, fix, refcount_table, nb_clusters);

}
 and probability:0.3541666666666667
code:void aio_context_setup(AioContext *ctx)

{

}
 and probability:0.0
code:static uint64_t timer_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    LM32TimerState *s = opaque;

    uint32_t r = 0;



    addr >>= 2;

    switch (addr) {

    case R_SR:

    case R_CR:

    case R_PERIOD:

        r = s->regs[addr];

        break;

    case R_SNAPSHOT:

        r = (uint32_t)ptimer_get_count(s->ptimer);

        break;

    default:

        error_report("lm32_timer: read access to unknown register 0x"

                TARGET_FMT_plx, addr << 2);

        break;

    }



    trace_lm32_timer_memory_read(addr << 2, r);

    return r;

}
 and probability:0.09090909090909091
code:void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)

{

    SCSIRequest *sreq = req->sreq;

    if (scsi_req_enqueue(sreq)) {

        scsi_req_continue(sreq);

    }

    bdrv_io_unplug(sreq->dev->conf.bs);

    scsi_req_unref(sreq);

}
 and probability:0.2222222222222222
code:static int truespeech_decode_frame(AVCodecContext *avctx,

                void *data, int *data_size,

                AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    TSContext *c = avctx->priv_data;



    int i, j;

    short *samples = data;

    int consumed = 0;

    int16_t out_buf[240];

    int iterations;



    if (!buf_size)

        return 0;



    if (buf_size < 32) {

        av_log(avctx, AV_LOG_ERROR,

               "Too small input buffer (%d bytes), need at least 32 bytes\n", buf_size);

        return -1;

    }

    iterations = FFMIN(buf_size / 32, *data_size / 480);

    for(j = 0; j < iterations; j++) {

        truespeech_read_frame(c, buf + consumed);

        consumed += 32;



        truespeech_correlate_filter(c);

        truespeech_filters_merge(c);



        memset(out_buf, 0, 240 * 2);

        for(i = 0; i < 4; i++) {

            truespeech_apply_twopoint_filter(c, i);

            truespeech_place_pulses(c, out_buf + i * 60, i);

            truespeech_update_filters(c, out_buf + i * 60, i);

            truespeech_synth(c, out_buf + i * 60, i);

        }



        truespeech_save_prevvec(c);



        /* finally output decoded frame */

        for(i = 0; i < 240; i++)

            *samples++ = out_buf[i];



    }



    *data_size = consumed * 15;



    return consumed;

}
 and probability:0.375
code:static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,

					    const uint8_t * src)

{

    uint8_t *dst;



    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);



    if (blit_is_unsafe(s, false))

        return 0;



    (*s->cirrus_rop) (s, dst, src,

                      s->cirrus_blt_dstpitch, 0,

                      s->cirrus_blt_width, s->cirrus_blt_height);

    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,

                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,

                             s->cirrus_blt_height);

    return 1;

}
 and probability:0.4666666666666667
code:static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,

                                 uint64_t end_offset, void **p_feature_table,

                                 int flags, Error **errp)

{

    BDRVQcow2State *s = bs->opaque;

    QCowExtension ext;

    uint64_t offset;

    int ret;



#ifdef DEBUG_EXT

    printf("qcow2_read_extensions: start=%ld end=%ld\n", start_offset, end_offset);

#endif

    offset = start_offset;

    while (offset < end_offset) {



#ifdef DEBUG_EXT

        /* Sanity check */

        if (offset > s->cluster_size)

            printf("qcow2_read_extension: suspicious offset %lu\n", offset);



        printf("attempting to read extended header in offset %lu\n", offset);

#endif



        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));

        if (ret < 0) {

            error_setg_errno(errp, -ret, "qcow2_read_extension: ERROR: "

                             "pread fail from offset %" PRIu64, offset);

            return 1;

        }

        be32_to_cpus(&ext.magic);

        be32_to_cpus(&ext.len);

        offset += sizeof(ext);

#ifdef DEBUG_EXT

        printf("ext.magic = 0x%x\n", ext.magic);

#endif

        if (offset > end_offset || ext.len > end_offset - offset) {

            error_setg(errp, "Header extension too large");

            return -EINVAL;

        }



        switch (ext.magic) {

        case QCOW2_EXT_MAGIC_END:

            return 0;



        case QCOW2_EXT_MAGIC_BACKING_FORMAT:

            if (ext.len >= sizeof(bs->backing_format)) {

                error_setg(errp, "ERROR: ext_backing_format: len=%" PRIu32

                           " too large (>=%zu)", ext.len,

                           sizeof(bs->backing_format));

                return 2;

            }

            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);

            if (ret < 0) {

                error_setg_errno(errp, -ret, "ERROR: ext_backing_format: "

                                 "Could not read format name");

                return 3;

            }

            bs->backing_format[ext.len] = '\0';

            s->image_backing_format = g_strdup(bs->backing_format);

#ifdef DEBUG_EXT

            printf("Qcow2: Got format extension %s\n", bs->backing_format);

#endif

            break;



        case QCOW2_EXT_MAGIC_FEATURE_TABLE:

            if (p_feature_table != NULL) {

                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));

                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);

                if (ret < 0) {

                    error_setg_errno(errp, -ret, "ERROR: ext_feature_table: "

                                     "Could not read table");

                    return ret;

                }



                *p_feature_table = feature_table;

            }

            break;



        case QCOW2_EXT_MAGIC_CRYPTO_HEADER: {

            unsigned int cflags = 0;

            if (s->crypt_method_header != QCOW_CRYPT_LUKS) {

                error_setg(errp, "CRYPTO header extension only "

                           "expected with LUKS encryption method");

                return -EINVAL;

            }

            if (ext.len != sizeof(Qcow2CryptoHeaderExtension)) {

                error_setg(errp, "CRYPTO header extension size %u, "

                           "but expected size %zu", ext.len,

                           sizeof(Qcow2CryptoHeaderExtension));

                return -EINVAL;

            }



            ret = bdrv_pread(bs->file, offset, &s->crypto_header, ext.len);

            if (ret < 0) {

                error_setg_errno(errp, -ret,

                                 "Unable to read CRYPTO header extension");

                return ret;

            }

            be64_to_cpus(&s->crypto_header.offset);

            be64_to_cpus(&s->crypto_header.length);



            if ((s->crypto_header.offset % s->cluster_size) != 0) {

                error_setg(errp, "Encryption header offset '%" PRIu64 "' is "

                           "not a multiple of cluster size '%u'",

                           s->crypto_header.offset, s->cluster_size);

                return -EINVAL;

            }



            if (flags & BDRV_O_NO_IO) {

                cflags |= QCRYPTO_BLOCK_OPEN_NO_IO;

            }

            s->crypto = qcrypto_block_open(s->crypto_opts, "encrypt.",

                                           qcow2_crypto_hdr_read_func,

                                           bs, cflags, errp);

            if (!s->crypto) {

                return -EINVAL;

            }

        }   break;



        default:

            /* unknown magic - save it in case we need to rewrite the header */

            {

                Qcow2UnknownHeaderExtension *uext;



                uext = g_malloc0(sizeof(*uext)  + ext.len);

                uext->magic = ext.magic;

                uext->len = ext.len;

                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);



                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);

                if (ret < 0) {

                    error_setg_errno(errp, -ret, "ERROR: unknown extension: "

                                     "Could not read data");

                    return ret;

                }

            }

            break;

        }



        offset += ((ext.len + 7) & ~7);

    }



    return 0;

}
 and probability:0.2204724409448819
code:static void listener_add_address_space(MemoryListener *listener,

                                       AddressSpace *as)

{

    FlatView *view;

    FlatRange *fr;



    if (listener->address_space_filter

        && listener->address_space_filter != as) {

        return;

    }



    if (global_dirty_log) {

        if (listener->log_global_start) {

            listener->log_global_start(listener);

        }

    }



    view = as->current_map;

    FOR_EACH_FLAT_RANGE(fr, view) {

        MemoryRegionSection section = {

            .mr = fr->mr,

            .address_space = as,

            .offset_within_region = fr->offset_in_region,

            .size = fr->addr.size,

            .offset_within_address_space = int128_get64(fr->addr.start),

            .readonly = fr->readonly,

        };

        if (listener->region_add) {

            listener->region_add(listener, &section);

        }

    }

}
 and probability:0.41379310344827586
code:long do_sigreturn(CPUM68KState *env)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr = env->aregs[7] - 4;

    target_sigset_t target_set;

    sigset_t set;

    int d0, i;



    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

        goto badframe;



    /* set blocked signals */



    if (__get_user(target_set.sig[0], &frame->sc.sc_mask))

        goto badframe;



    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

            goto badframe;

    }



    target_to_host_sigset_internal(&set, &target_set);

    sigprocmask(SIG_SETMASK, &set, NULL);



    /* restore registers */



    if (restore_sigcontext(env, &frame->sc, &d0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return d0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
 and probability:0.17857142857142858
code:static int tcg_match_cmpi(TCGType type, tcg_target_long val)

{

    if (facilities & FACILITY_EXT_IMM) {

        /* The COMPARE IMMEDIATE instruction is available.  */

        if (type == TCG_TYPE_I32) {

            /* We have a 32-bit immediate and can compare against anything.  */

            return 1;

        } else {

            /* ??? We have no insight here into whether the comparison is

               signed or unsigned.  The COMPARE IMMEDIATE insn uses a 32-bit

               signed immediate, and the COMPARE LOGICAL IMMEDIATE insn uses

               a 32-bit unsigned immediate.  If we were to use the (semi)

               obvious "val == (int32_t)val" we would be enabling unsigned

               comparisons vs very large numbers.  The only solution is to

               take the intersection of the ranges.  */

            /* ??? Another possible solution is to simply lie and allow all

               constants here and force the out-of-range values into a temp

               register in tgen_cmp when we have knowledge of the actual

               comparison code in use.  */

            return val >= 0 && val <= 0x7fffffff;

        }

    } else {

        /* Only the LOAD AND TEST instruction is available.  */

        return val == 0;

    }

}
 and probability:0.0
code:static inline bool vhost_needs_vring_endian(VirtIODevice *vdev)

{

    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {

        return false;

    }

#ifdef TARGET_IS_BIENDIAN

#ifdef HOST_WORDS_BIGENDIAN

    return !virtio_is_big_endian(vdev);

#else

    return virtio_is_big_endian(vdev);

#endif

#else

    return false;

#endif

}
 and probability:0.0
code:int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)

{

    QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);

    QXLCursor *cursor;

    QEMUCursor *c;



    if (!cmd) {

        return 1;

    }



    if (!dpy_cursor_define_supported(qxl->vga.con)) {

        return 0;

    }



    if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {

        fprintf(stderr, "%s", __FUNCTION__);

        qxl_log_cmd_cursor(qxl, cmd, ext->group_id);

        fprintf(stderr, "\n");

    }

    switch (cmd->type) {

    case QXL_CURSOR_SET:

        cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);

        if (!cursor) {

            return 1;

        }

        c = qxl_cursor(qxl, cursor, ext->group_id);

        if (c == NULL) {

            c = cursor_builtin_left_ptr();

        }

        qemu_mutex_lock(&qxl->ssd.lock);

        if (qxl->ssd.cursor) {

            cursor_put(qxl->ssd.cursor);

        }

        qxl->ssd.cursor = c;

        qxl->ssd.mouse_x = cmd->u.set.position.x;

        qxl->ssd.mouse_y = cmd->u.set.position.y;

        qemu_mutex_unlock(&qxl->ssd.lock);

        qemu_bh_schedule(qxl->ssd.cursor_bh);

        break;

    case QXL_CURSOR_MOVE:

        qemu_mutex_lock(&qxl->ssd.lock);

        qxl->ssd.mouse_x = cmd->u.position.x;

        qxl->ssd.mouse_y = cmd->u.position.y;

        qemu_mutex_unlock(&qxl->ssd.lock);

        qemu_bh_schedule(qxl->ssd.cursor_bh);

        break;

    }

    return 0;

}
 and probability:0.43478260869565216
code:static int decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)

{

    int compno, reslevelno, bandno;

    int x, y, *src[4];

    uint8_t *line;

    Jpeg2000T1Context t1;



    /* Loop on tile components */

    for (compno = 0; compno < s->ncomponents; compno++) {

        Jpeg2000Component *comp     = tile->comp + compno;

        Jpeg2000CodingStyle *codsty = tile->codsty + compno;



        /* Loop on resolution levels */

        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {

            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;

            /* Loop on bands */

            for (bandno = 0; bandno < rlevel->nbands; bandno++) {

                int nb_precincts, precno;

                Jpeg2000Band *band = rlevel->band + bandno;

                int cblkx, cblky, cblkno=0, bandpos;



                bandpos = bandno + (reslevelno > 0);



                if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1])

                    continue;



                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;

                /* Loop on precincts */

                for (precno = 0; precno < nb_precincts; precno++) {

                    Jpeg2000Prec *prec = band->prec + precno;



                    /* Loop on codeblocks */

                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {

                        int x, y;

                        int i, j;

                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;

                        decode_cblk(s, codsty, &t1, cblk,

                                    cblk->coord[0][1] - cblk->coord[0][0],

                                    cblk->coord[1][1] - cblk->coord[1][0],

                                    bandpos);



                        /* Manage band offsets */

                        x = cblk->coord[0][0];

                        y = cblk->coord[1][0];



                        dequantization_int(x, y, cblk, comp, &t1, band);

                   } /* end cblk */

                } /*end prec */

            } /* end band */

        } /* end reslevel */



        ff_dwt_decode(&comp->dwt, comp->data);

        src[compno] = comp->data;

    } /*end comp */



    /* inverse MCT transformation */

    if (tile->codsty[0].mct)

        mct_decode(s, tile);



    if (s->precision <= 8) {

        for (compno = 0; compno < s->ncomponents; compno++) {

            y = tile->comp[compno].coord[1][0] - s->image_offset_y;

            line = s->picture->data[0] + y * s->picture->linesize[0];

            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {

                uint8_t *dst;



                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;

                dst = line + x * s->ncomponents + compno;



                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s->cdx[compno]) {

                    int val = *src[compno]++ << (8 - s->cbps[compno]);

                    val += 1 << 7;

                    val = av_clip(val, 0, (1 << 8) - 1);

                    *dst = val;

                    dst += s->ncomponents;

                }

                line += s->picture->linesize[0];

            }

        }

    } else {

        for (compno = 0; compno < s->ncomponents; compno++) {

            y = tile->comp[compno].coord[1][0] - s->image_offset_y;

            line = s->picture->data[0] + y * s->picture->linesize[0];

            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {

                uint16_t *dst;



                x = tile->comp[compno].coord[0][0] - s->image_offset_x;

                dst = (uint16_t *)(line + (x * s->ncomponents + compno) * 2);

                for (; x < tile->comp[compno].coord[0][1] - s->image_offset_x; x += s-> cdx[compno]) {

                    int32_t val;



                    val = *src[compno]++ << (16 - s->cbps[compno]);

                    val += 1 << 15;

                    val = av_clip(val, 0, (1 << 16) - 1);

                    *dst = val;

                    dst += s->ncomponents;

                }

                line += s->picture->linesize[0];

            }

        }

    }

    return 0;

}
 and probability:0.5454545454545454
code:static void omap_pwl_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwl.base = base;

    omap_pwl_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwl_readfn,

                    omap_pwl_writefn, s);

    cpu_register_physical_memory(s->pwl.base, 0x800, iomemtype);



    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);

}
 and probability:0.2727272727272727
code:static void virt_acpi_build_update(void *build_opaque)

{

    AcpiBuildState *build_state = build_opaque;

    AcpiBuildTables tables;



    /* No state to update or already patched? Nothing to do. */

    if (!build_state || build_state->patched) {

        return;

    }

    build_state->patched = true;



    acpi_build_tables_init(&tables);



    virt_acpi_build(build_state->guest_info, &tables);



    acpi_ram_update(build_state->table_mr, tables.table_data);

    acpi_ram_update(build_state->rsdp_mr, tables.rsdp);

    acpi_ram_update(build_state->linker_mr, tables.linker);





    acpi_build_tables_cleanup(&tables, true);

}
 and probability:0.375
code:static void uart_rx_reset(UartState *s)

{

    s->rx_wpos = 0;

    s->rx_count = 0;

    qemu_chr_accept_input(s->chr);



    s->r[R_SR] |= UART_SR_INTR_REMPTY;

    s->r[R_SR] &= ~UART_SR_INTR_RFUL;

}
 and probability:0.625
code:static int rndis_set_response(USBNetState *s,

                rndis_set_msg_type *buf, unsigned int length)

{

    rndis_set_cmplt_type *resp =

            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));

    uint32_t bufoffs, buflen;

    int ret;



    if (!resp)

        return USB_RET_STALL;



    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;

    buflen = le32_to_cpu(buf->InformationBufferLength);

    if (bufoffs + buflen > length)

        return USB_RET_STALL;



    ret = ndis_set(s, le32_to_cpu(buf->OID),

                    bufoffs + (uint8_t *) buf, buflen);

    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);

    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */

    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));

    if (ret < 0) {

        /* OID not supported */

        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);

        return 0;

    }

    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);



    return 0;

}
 and probability:0.38461538461538464
code:SwsContext *sws_alloc_context(void)

{

    SwsContext *c = av_mallocz(sizeof(SwsContext));



    c->av_class = &sws_context_class;

    av_opt_set_defaults(c);



    return c;

}
 and probability:0.14285714285714285
code:static i2c_interface *musicpal_audio_init(qemu_irq irq)

{

    AudioState *audio;

    musicpal_audio_state *s;

    i2c_interface *i2c;

    int iomemtype;



    audio = AUD_init();

    if (!audio) {

        AUD_log(audio_name, "No audio state\n");

        return NULL;

    }



    s = qemu_mallocz(sizeof(musicpal_audio_state));

    s->irq = irq;



    i2c = qemu_mallocz(sizeof(i2c_interface));

    i2c->bus = i2c_init_bus();

    i2c->current_addr = -1;



    s->wm = wm8750_init(i2c->bus, audio);

    if (!s->wm)

        return NULL;

    i2c_set_slave_address(s->wm, MP_WM_ADDR);

    wm8750_data_req_set(s->wm, audio_callback, s);



    iomemtype = cpu_register_io_memory(0, musicpal_audio_readfn,

                       musicpal_audio_writefn, s);

    cpu_register_physical_memory(MP_AUDIO_BASE, MP_AUDIO_SIZE, iomemtype);



    qemu_register_reset(musicpal_audio_reset, s);



    return i2c;

}
 and probability:0.25925925925925924
code:void bdrv_error_action(BlockDriverState *bs, BlockErrorAction action,

                       bool is_read, int error)

{

    assert(error >= 0);

    bdrv_emit_qmp_error_event(bs, QEVENT_BLOCK_IO_ERROR, action, is_read);

    if (action == BDRV_ACTION_STOP) {

        vm_stop(RUN_STATE_IO_ERROR);

        bdrv_iostatus_set_err(bs, error);

    }

}
 and probability:0.0
code:static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,

                     uint64_t max_mem)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    if ((uint64_t)RAM_size > max_mem) {

        fprintf(stderr,

                "qemu: Too much memory for this machine: %d, maximum %d\n",

                (unsigned int)(RAM_size / (1024 * 1024)),

                (unsigned int)(max_mem / (1024 * 1024)));

        exit(1);

    }

    dev = qdev_create(NULL, "memory");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
 and probability:0.14285714285714285
code:int xics_alloc_block(XICSState *icp, int src, int num, bool lsi, bool align)

{

    int i, first = -1;

    ICSState *ics = &icp->ics[src];



    assert(src == 0);

    /*

     * MSIMesage::data is used for storing VIRQ so

     * it has to be aligned to num to support multiple

     * MSI vectors. MSI-X is not affected by this.

     * The hint is used for the first IRQ, the rest should

     * be allocated continuously.

     */

    if (align) {

        assert((num == 1) || (num == 2) || (num == 4) ||

               (num == 8) || (num == 16) || (num == 32));

        first = ics_find_free_block(ics, num, num);

    } else {

        first = ics_find_free_block(ics, num, 1);

    }



    if (first >= 0) {

        for (i = first; i < first + num; ++i) {

            ics_set_irq_type(ics, i, lsi);

        }

    }

    first += ics->offset;



    trace_xics_alloc_block(src, first, num, lsi, align);



    return first;

}
 and probability:0.10714285714285714
code:void object_property_get_uint16List(Object *obj, const char *name,

                                    uint16List **list, Error **errp)

{

    StringOutputVisitor *ov;

    StringInputVisitor *iv;



    ov = string_output_visitor_new(false);

    object_property_get(obj, string_output_get_visitor(ov),

                        name, errp);

    iv = string_input_visitor_new(string_output_get_string(ov));

    visit_type_uint16List(string_input_get_visitor(iv),

                          list, NULL, errp);

    string_output_visitor_cleanup(ov);

    string_input_visitor_cleanup(iv);

}
 and probability:0.0
code:static int raw_create(const char *filename, QEMUOptionParameter *options)

{

    int fd;

    int64_t total_size = 0;



    /* Read out options */

    while (options && options->name) {

        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {

            total_size = options->value.n / 512;

        }

        options++;

    }



    fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,

              0644);

    if (fd < 0)

        return -EIO;

    ftruncate(fd, total_size * 512);

    close(fd);

    return 0;

}
 and probability:0.2631578947368421
code:static inline void RENAME(rgb24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)

{

    int i;

    assert(src1==src2);

    for (i=0; i<width; i++) {

        int r= src1[6*i + 0] + src1[6*i + 3];

        int g= src1[6*i + 1] + src1[6*i + 4];

        int b= src1[6*i + 2] + src1[6*i + 5];



        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);

        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);

    }

}
 and probability:0.5
code:uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t offset,

                                    int n_start, int n_end,

                                    int *num, QCowL2Meta *m)

{

    BDRVQcowState *s = bs->opaque;

    int l2_index, ret;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);

    if (ret == 0)

        return 0;



    nb_clusters = size_to_clusters(s, n_end << 9);



    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    cluster_offset = be64_to_cpu(l2_table[l2_index]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        m->nb_clusters = 0;



        goto out;

    }



    /* for the moment, multiple compressed clusters are not managed */



    if (cluster_offset & QCOW_OFLAG_COMPRESSED)

        nb_clusters = 1;



    /* how many available clusters ? */



    while (i < nb_clusters) {

        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,

                &l2_table[l2_index], i, 0);



        if(be64_to_cpu(l2_table[l2_index + i]))

            break;



        i += count_contiguous_free_clusters(nb_clusters - i,

                &l2_table[l2_index + i]);



        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);



        if ((cluster_offset & QCOW_OFLAG_COPIED) ||

                (cluster_offset & QCOW_OFLAG_COMPRESSED))

            break;

    }

    nb_clusters = i;



    /*

     * Check if there already is an AIO write request in flight which allocates

     * the same cluster. In this case we need to wait until the previous

     * request has completed and updated the L2 table accordingly.

     */

    QLIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {



        uint64_t end_offset = offset + nb_clusters * s->cluster_size;

        uint64_t old_offset = old_alloc->offset;

        uint64_t old_end_offset = old_alloc->offset +

            old_alloc->nb_clusters * s->cluster_size;



        if (end_offset < old_offset || offset > old_end_offset) {

            /* No intersection */

        } else {

            if (offset < old_offset) {

                /* Stop at the start of a running allocation */

                nb_clusters = (old_offset - offset) >> s->cluster_bits;

            } else {

                nb_clusters = 0;

            }



            if (nb_clusters == 0) {

                /* Set dependency and wait for a callback */

                m->depends_on = old_alloc;

                m->nb_clusters = 0;

                *num = 0;

                return 0;

            }

        }

    }



    if (!nb_clusters) {

        abort();

    }



    QLIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);



    /* allocate a new cluster */



    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);



    /* save info needed for meta data update */

    m->offset = offset;

    m->n_start = n_start;

    m->nb_clusters = nb_clusters;



out:

    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);



    *num = m->nb_available - n_start;



    return cluster_offset;

}
 and probability:0.3333333333333333
code:void ff_xvmc_init_block(MpegEncContext *s)

{

    struct xvmc_render_state *render = (struct xvmc_render_state*)s->current_picture.data[2];

    assert(render);

    if (!render || render->magic != AV_XVMC_RENDER_MAGIC) {

        assert(0);

        return; // make sure that this is a render packet

    }

    s->block = (DCTELEM *)(render->data_blocks + render->next_free_data_block_num * 64);

}
 and probability:0.3
code:void do_adde (void)

{

    T2 = T0;

    T0 += T1 + xer_ca;

    if (likely(!(T0 < T2 || (xer_ca == 1 && T0 == T2)))) {

        xer_ca = 0;

    } else {

        xer_ca = 1;

    }

}
 and probability:0.1
code:static uint32_t ecc_mem_readl(void *opaque, target_phys_addr_t addr)

{

    ECCState *s = opaque;

    uint32_t ret = 0;



    switch (addr & ECC_ADDR_MASK) {

    case ECC_MER:

        ret = s->regs[0];

        DPRINTF("Read memory enable %08x\n", ret);

        break;

    case ECC_MDR:

        ret = s->regs[1];

        DPRINTF("Read memory delay %08x\n", ret);

        break;

    case ECC_MFSR:

        ret = s->regs[2];

        DPRINTF("Read memory fault status %08x\n", ret);

        break;

    case ECC_VCR:

        ret = s->regs[3];

        DPRINTF("Read slot configuration %08x\n", ret);

        break;

    case ECC_MFAR0:

        ret = s->regs[4];

        DPRINTF("Read memory fault address 0 %08x\n", ret);

        break;

    case ECC_MFAR1:

        ret = s->regs[5];

        DPRINTF("Read memory fault address 1 %08x\n", ret);

        break;

    case ECC_DR:

        ret = s->regs[6];

        DPRINTF("Read diagnostic %08x\n", ret);

        break;

    case ECC_ECR0:

        ret = s->regs[7];

        DPRINTF("Read event count 1 %08x\n", ret);

        break;

    case ECC_ECR1:

        ret = s->regs[7];

        DPRINTF("Read event count 2 %08x\n", ret);

        break;

    }

    return ret;

}
 and probability:0.20454545454545456
code:int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
                             int *got_sub_ptr,
                             AVPacket *avpkt)
{
    int i, ret = 0;
    if (!avpkt->data && avpkt->size) {
        av_log(avctx, AV_LOG_ERROR, "invalid packet: NULL data, size != 0\n");
        return AVERROR(EINVAL);
    if (!avctx->codec)
        return AVERROR(EINVAL);
    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {
        av_log(avctx, AV_LOG_ERROR, "Invalid media type for subtitles\n");
        return AVERROR(EINVAL);
    *got_sub_ptr = 0;
    avcodec_get_subtitle_defaults(sub);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size) {
        AVPacket pkt_recoded;
        AVPacket tmp = *avpkt;
        int did_split = av_packet_split_side_data(&tmp);
        //apply_param_change(avctx, &tmp);
        pkt_recoded = tmp;
        ret = recode_subtitle(avctx, &pkt_recoded, &tmp);
        if (ret < 0) {
            *got_sub_ptr = 0;
        } else {
            avctx->internal->pkt = &pkt_recoded;
            if (avctx->pkt_timebase.den && avpkt->pts != AV_NOPTS_VALUE)
                sub->pts = av_rescale_q(avpkt->pts,
                                        avctx->pkt_timebase, AV_TIME_BASE_Q);
            ret = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);
            av_assert1((ret >= 0) >= !!*got_sub_ptr &&
                       !!*got_sub_ptr >= !!sub->num_rects);
            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&
                avctx->pkt_timebase.num) {
                AVRational ms = { 1, 1000 };
                sub->end_display_time = av_rescale_q(avpkt->duration,
                                                     avctx->pkt_timebase, ms);
            for (i = 0; i < sub->num_rects; i++) {
                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {
                    av_log(avctx, AV_LOG_ERROR,
                           "Invalid UTF-8 in decoded subtitles text; "
                           "maybe missing -sub_charenc option\n");
                    avsubtitle_free(sub);
                    return AVERROR_INVALIDDATA;
            if (tmp.data != pkt_recoded.data) { // did we recode?
                /* prevent from destroying side data from original packet */
                pkt_recoded.side_data = NULL;
                pkt_recoded.side_data_elems = 0;
                av_free_packet(&pkt_recoded);
            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)
                sub->format = 0;
            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)
                sub->format = 1;
            avctx->internal->pkt = NULL;
            av_packet_free_side_data(&tmp);
            if(ret == tmp.size)
                ret = avpkt->size;
        if (*got_sub_ptr)
            avctx->frame_number++;
    return ret; and probability:0.4666666666666667
code:static int mp_decode_frame(MPADecodeContext *s, 

                           short *samples)

{

    int i, nb_frames, ch;

    short *samples_ptr;



    init_get_bits(&s->gb, s->inbuf + HEADER_SIZE, 

                  s->inbuf_ptr - s->inbuf - HEADER_SIZE);

    

    /* skip error protection field */

    if (s->error_protection)

        get_bits(&s->gb, 16);



    dprintf("frame %d:\n", s->frame_count);

    switch(s->layer) {

    case 1:

        nb_frames = mp_decode_layer1(s);

        break;

    case 2:

        nb_frames = mp_decode_layer2(s);

        break;

    case 3:

    default:

        nb_frames = mp_decode_layer3(s);

        break;

    }

#if defined(DEBUG)

    for(i=0;i<nb_frames;i++) {

        for(ch=0;ch<s->nb_channels;ch++) {

            int j;

            printf("%d-%d:", i, ch);

            for(j=0;j<SBLIMIT;j++)

                printf(" %0.6f", (double)s->sb_samples[ch][i][j] / FRAC_ONE);

            printf("\n");

        }

    }

#endif

    /* apply the synthesis filter */

    for(ch=0;ch<s->nb_channels;ch++) {

        samples_ptr = samples + ch;

        for(i=0;i<nb_frames;i++) {

            synth_filter(s, ch, samples_ptr, s->nb_channels,

                         s->sb_samples[ch][i]);

            samples_ptr += 32 * s->nb_channels;

        }

    }

#ifdef DEBUG

    s->frame_count++;        

#endif

    return nb_frames * 32 * sizeof(short) * s->nb_channels;

}
 and probability:0.375
code:static int pcm_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            const uint8_t *buf, int buf_size)

{

    PCMDecode *s = avctx->priv_data;

    int sample_size, c, n;

    short *samples;

    const uint8_t *src, *src8, *src2[MAX_CHANNELS];

    uint8_t *dstu8;

    int16_t *dst_int16_t;

    int32_t *dst_int32_t;

    int64_t *dst_int64_t;

    uint16_t *dst_uint16_t;

    uint32_t *dst_uint32_t;



    samples = data;

    src = buf;



    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {

        av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n");

        return -1;

    }



    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){

        av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n");

        return -1;

    }



    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;



    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */

    if (CODEC_ID_PCM_DVD == avctx->codec_id)

        /* 2 samples are interleaved per block in PCM_DVD */

        sample_size = avctx->bits_per_coded_sample * 2 / 8;



    n = avctx->channels * sample_size;



    if(n && buf_size % n){

        av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n");

        return -1;

    }



    buf_size= FFMIN(buf_size, *data_size/2);

    *data_size=0;



    n = buf_size/sample_size;



    switch(avctx->codec->id) {

    case CODEC_ID_PCM_U32LE:

        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)

        break;

    case CODEC_ID_PCM_U32BE:

        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)

        break;

    case CODEC_ID_PCM_S24LE:

        DECODE(int32_t, le24, src, samples, n, 8, 0)

        break;

    case CODEC_ID_PCM_S24BE:

        DECODE(int32_t, be24, src, samples, n, 8, 0)

        break;

    case CODEC_ID_PCM_U24LE:

        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)

        break;

    case CODEC_ID_PCM_U24BE:

        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)

        break;

    case CODEC_ID_PCM_S24DAUD:

        for(;n>0;n--) {

          uint32_t v = bytestream_get_be24(&src);

          v >>= 4; // sync flags are here

          *samples++ = ff_reverse[(v >> 8) & 0xff] +

                       (ff_reverse[v & 0xff] << 8);

        }

        break;

    case CODEC_ID_PCM_S16LE_PLANAR:

        n /= avctx->channels;

        for(c=0;c<avctx->channels;c++)

            src2[c] = &src[c*n*2];

        for(;n>0;n--)

            for(c=0;c<avctx->channels;c++)

                *samples++ = bytestream_get_le16(&src2[c]);

        src = src2[avctx->channels-1];

        break;

    case CODEC_ID_PCM_U16LE:

        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)

        break;

    case CODEC_ID_PCM_U16BE:

        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)

        break;

    case CODEC_ID_PCM_S8:

        dstu8= (uint8_t*)samples;

        for(;n>0;n--) {

            *dstu8++ = *src++ + 128;

        }

        samples= (short*)dstu8;

        break;

#if WORDS_BIGENDIAN

    case CODEC_ID_PCM_F64LE:

        DECODE(int64_t, le64, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S32LE:

    case CODEC_ID_PCM_F32LE:

        DECODE(int32_t, le32, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S16LE:

        DECODE(int16_t, le16, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F64BE:

    case CODEC_ID_PCM_F32BE:

    case CODEC_ID_PCM_S32BE:

    case CODEC_ID_PCM_S16BE:

#else

    case CODEC_ID_PCM_F64BE:

        DECODE(int64_t, be64, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F32BE:

    case CODEC_ID_PCM_S32BE:

        DECODE(int32_t, be32, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S16BE:

        DECODE(int16_t, be16, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F64LE:

    case CODEC_ID_PCM_F32LE:

    case CODEC_ID_PCM_S32LE:

    case CODEC_ID_PCM_S16LE:

#endif /* WORDS_BIGENDIAN */

    case CODEC_ID_PCM_U8:

        memcpy(samples, src, n*sample_size);

        src += n*sample_size;

        samples = (short*)((uint8_t*)data + n*sample_size);

        break;

    case CODEC_ID_PCM_ZORK:

        for(;n>0;n--) {

            int x= *src++;

            if(x&128) x-= 128;

            else      x = -x;

            *samples++ = x << 8;

        }

        break;

    case CODEC_ID_PCM_ALAW:

    case CODEC_ID_PCM_MULAW:

        for(;n>0;n--) {

            *samples++ = s->table[*src++];

        }

        break;

    case CODEC_ID_PCM_DVD:

        dst_int32_t = data;

        n /= avctx->channels;

        switch (avctx->bits_per_coded_sample) {

        case 20:

            while (n--) {

                c = avctx->channels;

                src8 = src + 4*c;

                while (c--) {

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);

                }

                src = src8;

            }

            break;

        case 24:

            while (n--) {

                c = avctx->channels;

                src8 = src + 4*c;

                while (c--) {

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);

                }

                src = src8;

            }

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n");

            return -1;

            break;

        }

        samples = (short *) dst_int32_t;

        break;

    default:

        return -1;

    }

    *data_size = (uint8_t *)samples - (uint8_t *)data;

    return src - buf;

}
 and probability:0.28
code:static int write_trailer(AVFormatContext *s)

{

    WVMuxContext *wc = s->priv_data;

    AVIOContext *pb = s->pb;



    ff_ape_write(s);



    if (pb->seekable) {

        avio_seek(pb, 12, SEEK_SET);

        avio_wl32(pb, wc->duration);

        avio_flush(pb);

    }



    return 0;

}
 and probability:0.3333333333333333
code:void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)

{

    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);



    /* virtio-1 compliant devices cannot change the alignment */

    if (virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {

        error_report("tried to modify queue alignment for virtio-1 device");

        return;

    }

    /* Check that the transport told us it was going to do this

     * (so a buggy transport will immediately assert rather than

     * silently failing to migrate this state)

     */

    assert(k->has_variable_vring_alignment);



    vdev->vq[n].vring.align = align;

    virtio_queue_update_rings(vdev, n);

}
 and probability:0.11764705882352941
code:static inline void RENAME(yuvPlanartouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                           long width, long height,

                                           long lumStride, long chromStride, long dstStride, long vertLumPerChroma)

{

    long y;

    const x86_reg chromWidth= width>>1;

    for (y=0; y<height; y++) {

#if COMPILE_TEMPLATE_MMX

        //FIXME handle 2 lines at once (fewer prefetches, reuse some chroma, but very likely memory-limited anyway)

        __asm__ volatile(

            "xor                %%"REG_a", %%"REG_a"    \n\t"

            ".p2align                   4               \n\t"

            "1:                                         \n\t"

            PREFETCH"   32(%1, %%"REG_a", 2)            \n\t"

            PREFETCH"   32(%2, %%"REG_a")               \n\t"

            PREFETCH"   32(%3, %%"REG_a")               \n\t"

            "movq         (%2, %%"REG_a"), %%mm0        \n\t" // U(0)

            "movq                   %%mm0, %%mm2        \n\t" // U(0)

            "movq         (%3, %%"REG_a"), %%mm1        \n\t" // V(0)

            "punpcklbw              %%mm1, %%mm0        \n\t" // UVUV UVUV(0)

            "punpckhbw              %%mm1, %%mm2        \n\t" // UVUV UVUV(8)



            "movq       (%1, %%"REG_a",2), %%mm3        \n\t" // Y(0)

            "movq      8(%1, %%"REG_a",2), %%mm5        \n\t" // Y(8)

            "movq                   %%mm0, %%mm4        \n\t" // Y(0)

            "movq                   %%mm2, %%mm6        \n\t" // Y(8)

            "punpcklbw              %%mm3, %%mm0        \n\t" // YUYV YUYV(0)

            "punpckhbw              %%mm3, %%mm4        \n\t" // YUYV YUYV(4)

            "punpcklbw              %%mm5, %%mm2        \n\t" // YUYV YUYV(8)

            "punpckhbw              %%mm5, %%mm6        \n\t" // YUYV YUYV(12)



            MOVNTQ"                 %%mm0,   (%0, %%"REG_a", 4)     \n\t"

            MOVNTQ"                 %%mm4,  8(%0, %%"REG_a", 4)     \n\t"

            MOVNTQ"                 %%mm2, 16(%0, %%"REG_a", 4)     \n\t"

            MOVNTQ"                 %%mm6, 24(%0, %%"REG_a", 4)     \n\t"



            "add                       $8, %%"REG_a"    \n\t"

            "cmp                       %4, %%"REG_a"    \n\t"

            " jb                       1b               \n\t"

            ::"r"(dst), "r"(ysrc), "r"(usrc), "r"(vsrc), "g" (chromWidth)

            : "%"REG_a

        );

#else

//FIXME adapt the Alpha ASM code from yv12->yuy2



#if HAVE_FAST_64BIT

        int i;

        uint64_t *ldst = (uint64_t *) dst;

        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;

        for (i = 0; i < chromWidth; i += 2) {

            uint64_t k, l;

            k = uc[0] + (yc[0] << 8) +

                (vc[0] << 16) + (yc[1] << 24);

            l = uc[1] + (yc[2] << 8) +

                (vc[1] << 16) + (yc[3] << 24);

            *ldst++ = k + (l << 32);

            yc += 4;

            uc += 2;

            vc += 2;

        }



#else

        int i, *idst = (int32_t *) dst;

        const uint8_t *yc = ysrc, *uc = usrc, *vc = vsrc;

        for (i = 0; i < chromWidth; i++) {

#if HAVE_BIGENDIAN

            *idst++ = (uc[0] << 24)+ (yc[0] << 16) +

                (vc[0] << 8) + (yc[1] << 0);

#else

            *idst++ = uc[0] + (yc[0] << 8) +

               (vc[0] << 16) + (yc[1] << 24);

#endif

            yc += 2;

            uc++;

            vc++;

        }

#endif

#endif

        if ((y&(vertLumPerChroma-1)) == vertLumPerChroma-1) {

            usrc += chromStride;

            vsrc += chromStride;

        }

        ysrc += lumStride;

        dst += dstStride;

    }

#if COMPILE_TEMPLATE_MMX

    __asm__(EMMS"       \n\t"

            SFENCE"     \n\t"

            :::"memory");

#endif

}
 and probability:0.26744186046511625
code:int qcrypto_init(Error **errp)

{

    int ret;

    ret = gnutls_global_init();

    if (ret < 0) {

        error_setg(errp,

                   "Unable to initialize GNUTLS library: %s",

                   gnutls_strerror(ret));

        return -1;

    }

#ifdef DEBUG_GNUTLS

    gnutls_global_set_log_level(10);

    gnutls_global_set_log_function(qcrypto_gnutls_log);

#endif



#ifdef CONFIG_GNUTLS_GCRYPT

    if (!gcry_check_version(GCRYPT_VERSION)) {

        error_setg(errp, "Unable to initialize gcrypt");

        return -1;

    }

#ifdef QCRYPTO_INIT_GCRYPT_THREADS

    gcry_control(GCRYCTL_SET_THREAD_CBS, &qcrypto_gcrypt_thread_impl);

#endif /* QCRYPTO_INIT_GCRYPT_THREADS */

    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

#endif



    return 0;

}
 and probability:0.0
code:static void read_vec_element_i32(DisasContext *s, TCGv_i32 tcg_dest, int srcidx,

                                 int element, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(srcidx, element, memop & MO_SIZE);

    switch (memop) {

    case MO_8:

        tcg_gen_ld8u_i32(tcg_dest, cpu_env, vect_off);

        break;

    case MO_16:

        tcg_gen_ld16u_i32(tcg_dest, cpu_env, vect_off);

        break;

    case MO_8|MO_SIGN:

        tcg_gen_ld8s_i32(tcg_dest, cpu_env, vect_off);

        break;

    case MO_16|MO_SIGN:

        tcg_gen_ld16s_i32(tcg_dest, cpu_env, vect_off);

        break;

    case MO_32:

    case MO_32|MO_SIGN:

        tcg_gen_ld_i32(tcg_dest, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
 and probability:0.0
code:static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,

                            hwaddr desc_pa, int i)

{

    address_space_read(&address_space_memory, desc_pa + i * sizeof(VRingDesc),

                       MEMTXATTRS_UNSPECIFIED, (void *)desc, sizeof(VRingDesc));

    virtio_tswap64s(vdev, &desc->addr);

    virtio_tswap32s(vdev, &desc->len);

    virtio_tswap16s(vdev, &desc->flags);

    virtio_tswap16s(vdev, &desc->next);

}
 and probability:0.5
code:static AddressSpace *q35_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    IntelIOMMUState *s = opaque;

    VTDAddressSpace **pvtd_as;

    int bus_num = pci_bus_num(bus);



    assert(0 <= bus_num && bus_num <= VTD_PCI_BUS_MAX);

    assert(0 <= devfn && devfn <= VTD_PCI_DEVFN_MAX);



    pvtd_as = s->address_spaces[bus_num];

    if (!pvtd_as) {

        /* No corresponding free() */

        pvtd_as = g_malloc0(sizeof(VTDAddressSpace *) * VTD_PCI_DEVFN_MAX);

        s->address_spaces[bus_num] = pvtd_as;

    }

    if (!pvtd_as[devfn]) {

        pvtd_as[devfn] = g_malloc0(sizeof(VTDAddressSpace));



        pvtd_as[devfn]->bus_num = (uint8_t)bus_num;

        pvtd_as[devfn]->devfn = (uint8_t)devfn;

        pvtd_as[devfn]->iommu_state = s;

        pvtd_as[devfn]->context_cache_entry.context_cache_gen = 0;

        memory_region_init_iommu(&pvtd_as[devfn]->iommu, OBJECT(s),

                                 &s->iommu_ops, "intel_iommu", UINT64_MAX);

        address_space_init(&pvtd_as[devfn]->as,

                           &pvtd_as[devfn]->iommu, "intel_iommu");

    }

    return &pvtd_as[devfn]->as;

}
 and probability:0.5384615384615384
code:static inline uint64_t vmdk_find_offset_in_cluster(VmdkExtent *extent,

                                                   int64_t offset)

{

    uint64_t offset_in_cluster, extent_begin_offset, extent_relative_offset;

    uint64_t cluster_size = extent->cluster_sectors * BDRV_SECTOR_SIZE;



    extent_begin_offset =

        (extent->end_sector - extent->sectors) * BDRV_SECTOR_SIZE;

    extent_relative_offset = offset - extent_begin_offset;

    offset_in_cluster = extent_relative_offset % cluster_size;



    return offset_in_cluster;

}
 and probability:0.36363636363636365
code:static unsigned int dec_move_pr(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, "move $p%u, $r%u\n", dc->op1, dc->op2));

	cris_cc_mask(dc, 0);



	if (dc->op2 == PR_CCS)

		cris_evaluate_flags(dc);



	t0 = tcg_temp_new(TCG_TYPE_TL);

	t_gen_mov_TN_preg(t0, dc->op2);

	cris_alu(dc, CC_OP_MOVE,

		 cpu_R[dc->op1], cpu_R[dc->op1], t0, preg_sizes[dc->op2]);

	tcg_temp_free(t0);

	return 2;

}
 and probability:0.2857142857142857
code:static void virtio_balloon_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->init = virtio_balloon_init_pci;

    k->exit = virtio_balloon_exit_pci;

    k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;

    k->device_id = PCI_DEVICE_ID_VIRTIO_BALLOON;

    k->revision = VIRTIO_PCI_ABI_VERSION;

    k->class_id = PCI_CLASS_MEMORY_RAM;

    dc->alias = "virtio-balloon";

    dc->reset = virtio_pci_reset;

    dc->props = virtio_balloon_properties;

}
 and probability:0.6428571428571429
code:static int fetch_active_ports_list(QEMUFile *f,

                                   VirtIOSerial *s, uint32_t nr_active_ports)

{

    uint32_t i;



    s->post_load = g_malloc0(sizeof(*s->post_load));

    s->post_load->nr_active_ports = nr_active_ports;

    s->post_load->connected =

        g_malloc0(sizeof(*s->post_load->connected) * nr_active_ports);



    s->post_load->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                                            virtio_serial_post_load_timer_cb,

                                            s);



    /* Items in struct VirtIOSerialPort */

    for (i = 0; i < nr_active_ports; i++) {

        VirtIOSerialPort *port;

        uint32_t elem_popped;

        uint32_t id;



        id = qemu_get_be32(f);

        port = find_port_by_id(s, id);

        if (!port) {

            return -EINVAL;

        }



        port->guest_connected = qemu_get_byte(f);

        s->post_load->connected[i].port = port;

        s->post_load->connected[i].host_connected = qemu_get_byte(f);



        qemu_get_be32s(f, &elem_popped);

        if (elem_popped) {

            qemu_get_be32s(f, &port->iov_idx);

            qemu_get_be64s(f, &port->iov_offset);



            port->elem =

                qemu_get_virtqueue_element(f, sizeof(VirtQueueElement));



            /*

             *  Port was throttled on source machine.  Let's

             *  unthrottle it here so data starts flowing again.

             */

            virtio_serial_throttle_port(port, false);

        }

    }

    timer_mod(s->post_load->timer, 1);

    return 0;

}
 and probability:0.325
code:void HELPER(ucf64_cmps)(float32 a, float32 b, uint32_t c, CPUUniCore32State *env)

{

    int flag;

    flag = float32_compare_quiet(a, b, &env->ucf64.fp_status);

    env->CF = 0;

    switch (c & 0x7) {

    case 0: /* F */

        break;

    case 1: /* UN */

        if (flag == 2) {

            env->CF = 1;

        }

        break;

    case 2: /* EQ */

        if (flag == 0) {

            env->CF = 1;

        }

        break;

    case 3: /* UEQ */

        if ((flag == 0) || (flag == 2)) {

            env->CF = 1;

        }

        break;

    case 4: /* OLT */

        if (flag == -1) {

            env->CF = 1;

        }

        break;

    case 5: /* ULT */

        if ((flag == -1) || (flag == 2)) {

            env->CF = 1;

        }

        break;

    case 6: /* OLE */

        if ((flag == -1) || (flag == 0)) {

            env->CF = 1;

        }

        break;

    case 7: /* ULE */

        if (flag != 1) {

            env->CF = 1;

        }

        break;

    }

    env->ucf64.xregs[UC32_UCF64_FPSCR] = (env->CF << 29)

                    | (env->ucf64.xregs[UC32_UCF64_FPSCR] & 0x0fffffff);

}
 and probability:0.23404255319148937
code:static void RENAME(yuv2yuyv422_2)(SwsContext *c, const uint16_t *buf0,

                                  const uint16_t *buf1, const uint16_t *ubuf0,

                                  const uint16_t *ubuf1, const uint16_t *vbuf0,

                                  const uint16_t *vbuf1, const uint16_t *abuf0,

                                  const uint16_t *abuf1, uint8_t *dest,

                                  int dstW, int yalpha, int uvalpha, int y)

{

    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(

    __asm__ volatile(

        "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"

        "mov %4, %%"REG_b"                        \n\t"

        "push %%"REG_BP"                        \n\t"

        YSCALEYUV2PACKED(%%REGBP, %5)

        WRITEYUY2(%%REGb, 8280(%5), %%REGBP)

        "pop %%"REG_BP"                         \n\t"

        "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"

        :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),

           "a" (&c->redDither)

    );

}
 and probability:0.05
code:static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)

{

    SCSIRequest *req = &r->req;

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    bool start = req->cmd.buf[4] & 1;

    bool loej = req->cmd.buf[4] & 2; /* load on start, eject on !start */



    if (s->qdev.type == TYPE_ROM && loej) {

        if (!start && !s->tray_open && s->tray_locked) {

            scsi_check_condition(r,

                                 bdrv_is_inserted(s->qdev.conf.bs)

                                 ? SENSE_CODE(ILLEGAL_REQ_REMOVAL_PREVENTED)

                                 : SENSE_CODE(NOT_READY_REMOVAL_PREVENTED));

            return -1;

        }



        if (s->tray_open != !start) {

            bdrv_eject(s->qdev.conf.bs, !start);

            s->tray_open = !start;

        }

    }

    return 0;

}
 and probability:0.47619047619047616
code:static void ecc_mem_writew(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    printf("ECC: Unsupported write 0x" TARGET_FMT_plx " %04x\n",

           addr, val & 0xffff);

}
 and probability:0.0
code:int kvm_arch_debug(struct kvm_debug_exit_arch *arch_info)

{

    int handle = 0;

    int n;



    if (arch_info->exception == 1) {

        if (arch_info->dr6 & (1 << 14)) {

            if (cpu_single_env->singlestep_enabled)

                handle = 1;

        } else {

            for (n = 0; n < 4; n++)

                if (arch_info->dr6 & (1 << n))

                    switch ((arch_info->dr7 >> (16 + n*4)) & 0x3) {

                    case 0x0:

                        handle = 1;

                        break;

                    case 0x1:

                        handle = 1;

                        cpu_single_env->watchpoint_hit = &hw_watchpoint;

                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;

                        hw_watchpoint.flags = BP_MEM_WRITE;

                        break;

                    case 0x3:

                        handle = 1;

                        cpu_single_env->watchpoint_hit = &hw_watchpoint;

                        hw_watchpoint.vaddr = hw_breakpoint[n].addr;

                        hw_watchpoint.flags = BP_MEM_ACCESS;

                        break;

                    }

        }

    } else if (kvm_find_sw_breakpoint(cpu_single_env, arch_info->pc))

        handle = 1;



    if (!handle) {

        cpu_synchronize_state(cpu_single_env);

        assert(cpu_single_env->exception_injected == -1);



        cpu_single_env->exception_injected = arch_info->exception;

        cpu_single_env->has_error_code = 0;

    }



    return handle;

}
 and probability:0.358974358974359
code:static void qemu_chr_parse_stdio(QemuOpts *opts, ChardevBackend *backend,

                                 Error **errp)

{

    ChardevStdio *stdio;



    stdio = backend->u.stdio = g_new0(ChardevStdio, 1);

    qemu_chr_parse_common(opts, qapi_ChardevStdio_base(stdio));

    stdio->has_signal = true;

    stdio->signal = qemu_opt_get_bool(opts, "signal", true);

}
 and probability:0.3333333333333333
code:static void mirror_complete(BlockJob *job, Error **errp)

{

    MirrorBlockJob *s = container_of(job, MirrorBlockJob, common);

    Error *local_err = NULL;

    int ret;



    ret = bdrv_open_backing_file(s->target, NULL, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        return;

    }

    if (!s->synced) {

        error_setg(errp, QERR_BLOCK_JOB_NOT_READY,

                   bdrv_get_device_name(job->bs));

        return;

    }



    /* check the target bs is not blocked and block all operations on it */

    if (s->replaces) {

        AioContext *replace_aio_context;



        s->to_replace = check_to_replace_node(s->replaces, &local_err);

        if (!s->to_replace) {

            error_propagate(errp, local_err);

            return;

        }



        replace_aio_context = bdrv_get_aio_context(s->to_replace);

        aio_context_acquire(replace_aio_context);



        error_setg(&s->replace_blocker,

                   "block device is in use by block-job-complete");

        bdrv_op_block_all(s->to_replace, s->replace_blocker);

        bdrv_ref(s->to_replace);



        aio_context_release(replace_aio_context);

    }



    s->should_complete = true;

    block_job_enter(&s->common);

}
 and probability:0.35294117647058826
code:static bool scsi_target_emulate_inquiry(SCSITargetReq *r)

{

    assert(r->req.dev->lun != r->req.lun);



    scsi_target_alloc_buf(&r->req, SCSI_INQUIRY_LEN);



    if (r->req.cmd.buf[1] & 0x2) {

        /* Command support data - optional, not implemented */

        return false;

    }



    if (r->req.cmd.buf[1] & 0x1) {

        /* Vital product data */

        uint8_t page_code = r->req.cmd.buf[2];

        r->buf[r->len++] = page_code ; /* this page */

        r->buf[r->len++] = 0x00;



        switch (page_code) {

        case 0x00: /* Supported page codes, mandatory */

        {

            int pages;

            pages = r->len++;

            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */

            r->buf[pages] = r->len - pages - 1; /* number of pages */

            break;

        }

        default:

            return false;

        }

        /* done with EVPD */

        assert(r->len < r->buf_len);

        r->len = MIN(r->req.cmd.xfer, r->len);

        return true;

    }



    /* Standard INQUIRY data */

    if (r->req.cmd.buf[2] != 0) {

        return false;

    }



    /* PAGE CODE == 0 */

    r->len = MIN(r->req.cmd.xfer, SCSI_INQUIRY_LEN);

    memset(r->buf, 0, r->len);

    if (r->req.lun != 0) {

        r->buf[0] = TYPE_NO_LUN;

    } else {

        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;

        r->buf[2] = 5; /* Version */

        r->buf[3] = 2 | 0x10; /* HiSup, response data format */

        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */

        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */

        memcpy(&r->buf[8], "QEMU    ", 8);

        memcpy(&r->buf[16], "QEMU TARGET     ", 16);

        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());

    }

    return true;

}
 and probability:0.49019607843137253
code:void OPPROTO op_movl_npc_T0(void)

{

    env->npc = T0;

}
 and probability:0.25
code:void ff_aac_search_for_tns(AACEncContext *s, SingleChannelElement *sce)

{

    TemporalNoiseShaping *tns = &sce->tns;

    int w, g, order, sfb_start, sfb_len, coef_start, shift[MAX_LPC_ORDER], count = 0;

    const int is8 = sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE;

    const int tns_max_order = is8 ? 7 : s->profile == FF_PROFILE_AAC_LOW ? 12 : TNS_MAX_ORDER;

    const float freq_mult = mpeg4audio_sample_rates[s->samplerate_index]/(1024.0f/sce->ics.num_windows)/2.0f;

    float max_coef = 0.0f;



    sce->tns.present = 0;

    return;



    for (coef_start = 0; coef_start < 1024; coef_start++)

        max_coef = FFMAX(max_coef, sce->pcoeffs[coef_start]);



    for (w = 0; w < sce->ics.num_windows; w++) {

        int filters = 1, start = 0, coef_len = 0;

        int32_t conv_coeff[1024] = {0};

        int32_t coefs_t[MAX_LPC_ORDER][MAX_LPC_ORDER] = {{0}};



        /* Determine start sfb + coef - excludes anything below threshold */

        for (g = 0;  g < sce->ics.num_swb; g++) {

            if (start*freq_mult > TNS_LOW_LIMIT) {

                sfb_start = w*16+g;

                sfb_len   = (w+1)*16 + g - sfb_start;

                coef_start = sce->ics.swb_offset[sfb_start];

                coef_len  = sce->ics.swb_offset[sfb_start + sfb_len] - coef_start;

                break;

            }

            start += sce->ics.swb_sizes[g];

        }



        if (coef_len <= 0)

            continue;



        conv_to_int32(conv_coeff, &sce->pcoeffs[coef_start], coef_len, max_coef);



        /* LPC */

        order = ff_lpc_calc_coefs(&s->lpc, conv_coeff, coef_len,

                                  TNS_MIN_PRED_ORDER, tns_max_order,

                                  32, coefs_t, shift,

                                  FF_LPC_TYPE_LEVINSON, 10,

                                  ORDER_METHOD_EST, MAX_LPC_SHIFT, 0) - 1;



        /* Works surprisingly well, remember to tweak MAX_LPC_SHIFT if you want to play around with this */

        if (shift[order] > 3) {

            int direction = 0;

            float tns_coefs_raw[TNS_MAX_ORDER];

            tns->n_filt[w] = filters++;

            conv_to_float(tns_coefs_raw, coefs_t[order], order);

            for (g = 0; g < tns->n_filt[w]; g++) {

                process_tns_coeffs(tns, tns_coefs_raw, order, w, g);

                apply_tns_filter(&sce->coeffs[coef_start], sce->pcoeffs, order, direction, tns->coef[w][g],

                                 sce->ics.ltp.present, w, g, coef_start, coef_len);

                tns->order[w][g]     = order;

                tns->length[w][g]    = sfb_len;

                tns->direction[w][g] = direction;

            }

            count++;

        }

    }



    sce->tns.present = !!count;

}
 and probability:0.509090909090909
code:int ff_lock_avcodec(AVCodecContext *log_ctx, const AVCodec *codec)

{

    _Bool exp = 0;

    if (codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE || !codec->init)

        return 0;



    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))

            return -1;

    }



    if (atomic_fetch_add(&entangled_thread_counter, 1)) {

        av_log(log_ctx, AV_LOG_ERROR,

               "Insufficient thread locking. At least %d threads are "

               "calling avcodec_open2() at the same time right now.\n",

               atomic_load(&entangled_thread_counter));

        if (!lockmgr_cb)

            av_log(log_ctx, AV_LOG_ERROR, "No lock manager is set, please see av_lockmgr_register()\n");

        atomic_store(&ff_avcodec_locked, 1);

        ff_unlock_avcodec(codec);

        return AVERROR(EINVAL);

    }

    av_assert0(atomic_compare_exchange_strong(&ff_avcodec_locked, &exp, 1));

    return 0;

}
 and probability:0.08695652173913043
code:void FUNCC(ff_h264_idct_add)(uint8_t *_dst, int16_t *_block, int stride)

{

    int i;

    pixel *dst = (pixel*)_dst;

    dctcoef *block = (dctcoef*)_block;

    stride >>= sizeof(pixel)-1;



    block[0] += 1 << 5;



    for(i=0; i<4; i++){

        const int z0=  block[i + 4*0]     +  block[i + 4*2];

        const int z1=  block[i + 4*0]     -  block[i + 4*2];

        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];

        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);



        block[i + 4*0]= z0 + z3;

        block[i + 4*1]= z1 + z2;

        block[i + 4*2]= z1 - z2;

        block[i + 4*3]= z0 - z3;

    }



    for(i=0; i<4; i++){

        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];

        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];

        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];

        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);



        dst[i + 0*stride]= av_clip_pixel(dst[i + 0*stride] + ((z0 + z3) >> 6));

        dst[i + 1*stride]= av_clip_pixel(dst[i + 1*stride] + ((z1 + z2) >> 6));

        dst[i + 2*stride]= av_clip_pixel(dst[i + 2*stride] + ((z1 - z2) >> 6));

        dst[i + 3*stride]= av_clip_pixel(dst[i + 3*stride] + ((z0 - z3) >> 6));

    }



    memset(block, 0, 16 * sizeof(dctcoef));

}
 and probability:0.7241379310344828
code:static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,

                                         uint64_t flags)

{

    RDMAControlHeader reg_resp = { .len = sizeof(RDMARegisterResult),

                               .type = RDMA_CONTROL_REGISTER_RESULT,

                               .repeat = 0,

                             };

    RDMAControlHeader unreg_resp = { .len = 0,

                               .type = RDMA_CONTROL_UNREGISTER_FINISHED,

                               .repeat = 0,

                             };

    RDMAControlHeader blocks = { .type = RDMA_CONTROL_RAM_BLOCKS_RESULT,

                                 .repeat = 1 };

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;

    RDMALocalBlocks *local = &rdma->local_ram_blocks;

    RDMAControlHeader head;

    RDMARegister *reg, *registers;

    RDMACompress *comp;

    RDMARegisterResult *reg_result;

    static RDMARegisterResult results[RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE];

    RDMALocalBlock *block;

    void *host_addr;

    int ret = 0;

    int idx = 0;

    int count = 0;

    int i = 0;



    CHECK_ERROR_STATE();



    do {

        DDDPRINTF("Waiting for next request %" PRIu64 "...\n", flags);



        ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);



        if (ret < 0) {

            break;

        }



        if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {

            fprintf(stderr, "rdma: Too many requests in this message (%d)."

                            "Bailing.\n", head.repeat);

            ret = -EIO;

            break;

        }



        switch (head.type) {

        case RDMA_CONTROL_COMPRESS:

            comp = (RDMACompress *) rdma->wr_data[idx].control_curr;

            network_to_compress(comp);



            DDPRINTF("Zapping zero chunk: %" PRId64

                    " bytes, index %d, offset %" PRId64 "\n",

                    comp->length, comp->block_idx, comp->offset);

            block = &(rdma->local_ram_blocks.block[comp->block_idx]);



            host_addr = block->local_host_addr +

                            (comp->offset - block->offset);



            ram_handle_compressed(host_addr, comp->value, comp->length);

            break;



        case RDMA_CONTROL_REGISTER_FINISHED:

            DDDPRINTF("Current registrations complete.\n");

            goto out;



        case RDMA_CONTROL_RAM_BLOCKS_REQUEST:

            DPRINTF("Initial setup info requested.\n");



            if (rdma->pin_all) {

                ret = qemu_rdma_reg_whole_ram_blocks(rdma);

                if (ret) {

                    fprintf(stderr, "rdma migration: error dest "

                                    "registering ram blocks!\n");

                    goto out;

                }

            }



            /*

             * Dest uses this to prepare to transmit the RAMBlock descriptions

             * to the source VM after connection setup.

             * Both sides use the "remote" structure to communicate and update

             * their "local" descriptions with what was sent.

             */

            for (i = 0; i < local->nb_blocks; i++) {

                rdma->block[i].remote_host_addr =

                    (uint64_t)(local->block[i].local_host_addr);



                if (rdma->pin_all) {

                    rdma->block[i].remote_rkey = local->block[i].mr->rkey;

                }



                rdma->block[i].offset = local->block[i].offset;

                rdma->block[i].length = local->block[i].length;



                remote_block_to_network(&rdma->block[i]);

            }



            blocks.len = rdma->local_ram_blocks.nb_blocks

                                                * sizeof(RDMARemoteBlock);





            ret = qemu_rdma_post_send_control(rdma,

                                        (uint8_t *) rdma->block, &blocks);



            if (ret < 0) {

                fprintf(stderr, "rdma migration: error sending remote info!\n");

                goto out;

            }



            break;

        case RDMA_CONTROL_REGISTER_REQUEST:

            DDPRINTF("There are %d registration requests\n", head.repeat);



            reg_resp.repeat = head.repeat;

            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;



            for (count = 0; count < head.repeat; count++) {

                uint64_t chunk;

                uint8_t *chunk_start, *chunk_end;



                reg = &registers[count];

                network_to_register(reg);



                reg_result = &results[count];



                DDPRINTF("Registration request (%d): index %d, current_addr %"

                         PRIu64 " chunks: %" PRIu64 "\n", count,

                         reg->current_index, reg->key.current_addr, reg->chunks);



                block = &(rdma->local_ram_blocks.block[reg->current_index]);

                if (block->is_ram_block) {

                    host_addr = (block->local_host_addr +

                                (reg->key.current_addr - block->offset));

                    chunk = ram_chunk_index(block->local_host_addr,

                                            (uint8_t *) host_addr);

                } else {

                    chunk = reg->key.chunk;

                    host_addr = block->local_host_addr +

                        (reg->key.chunk * (1UL << RDMA_REG_CHUNK_SHIFT));

                }

                chunk_start = ram_chunk_start(block, chunk);

                chunk_end = ram_chunk_end(block, chunk + reg->chunks);

                if (qemu_rdma_register_and_get_keys(rdma, block,

                            (uint8_t *)host_addr, NULL, &reg_result->rkey,

                            chunk, chunk_start, chunk_end)) {

                    fprintf(stderr, "cannot get rkey!\n");

                    ret = -EINVAL;

                    goto out;

                }



                reg_result->host_addr = (uint64_t) block->local_host_addr;



                DDPRINTF("Registered rkey for this request: %x\n",

                                reg_result->rkey);



                result_to_network(reg_result);

            }



            ret = qemu_rdma_post_send_control(rdma,

                            (uint8_t *) results, &reg_resp);



            if (ret < 0) {

                fprintf(stderr, "Failed to send control buffer!\n");

                goto out;

            }

            break;

        case RDMA_CONTROL_UNREGISTER_REQUEST:

            DDPRINTF("There are %d unregistration requests\n", head.repeat);

            unreg_resp.repeat = head.repeat;

            registers = (RDMARegister *) rdma->wr_data[idx].control_curr;



            for (count = 0; count < head.repeat; count++) {

                reg = &registers[count];

                network_to_register(reg);



                DDPRINTF("Unregistration request (%d): "

                         " index %d, chunk %" PRIu64 "\n",

                         count, reg->current_index, reg->key.chunk);



                block = &(rdma->local_ram_blocks.block[reg->current_index]);



                ret = ibv_dereg_mr(block->pmr[reg->key.chunk]);

                block->pmr[reg->key.chunk] = NULL;



                if (ret != 0) {

                    perror("rdma unregistration chunk failed");

                    ret = -ret;

                    goto out;

                }



                rdma->total_registrations--;



                DDPRINTF("Unregistered chunk %" PRIu64 " successfully.\n",

                            reg->key.chunk);

            }



            ret = qemu_rdma_post_send_control(rdma, NULL, &unreg_resp);



            if (ret < 0) {

                fprintf(stderr, "Failed to send control buffer!\n");

                goto out;

            }

            break;

        case RDMA_CONTROL_REGISTER_RESULT:

            fprintf(stderr, "Invalid RESULT message at dest.\n");

            ret = -EIO;

            goto out;

        default:

            fprintf(stderr, "Unknown control message %s\n",

                                control_desc[head.type]);

            ret = -EIO;

            goto out;

        }

    } while (1);

out:

    if (ret < 0) {

        rdma->error_state = ret;

    }

    return ret;

}
 and probability:0.2611111111111111
code:static int read_data(void *opaque, uint8_t *buf, int buf_size)

{

    struct playlist *v = opaque;

    HLSContext *c = v->parent->priv_data;

    int ret, i;

    int just_opened = 0;




restart:

    if (!v->needed)

        return AVERROR_EOF;



    if (!v->input) {

        int64_t reload_interval;

        struct segment *seg;



        /* Check that the playlist is still needed before opening a new

         * segment. */

        if (v->ctx && v->ctx->nb_streams) {

            v->needed = 0;

            for (i = 0; i < v->n_main_streams; i++) {

                if (v->main_streams[i]->discard < AVDISCARD_ALL) {

                    v->needed = 1;

                    break;

                }

            }

        }

        if (!v->needed) {

            av_log(v->parent, AV_LOG_INFO, "No longer receiving playlist %d\n",

                v->index);

            return AVERROR_EOF;

        }



        /* If this is a live stream and the reload interval has elapsed since

         * the last playlist reload, reload the playlists now. */

        reload_interval = default_reload_interval(v);



reload:

        reload_count++;

        if (reload_count > c->max_reload)

            return AVERROR_EOF;

        if (!v->finished &&

            av_gettime_relative() - v->last_load_time >= reload_interval) {

            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {

                av_log(v->parent, AV_LOG_WARNING, "Failed to reload playlist %d\n",

                       v->index);

                return ret;

            }

            /* If we need to reload the playlist again below (if

             * there's still no more segments), switch to a reload

             * interval of half the target duration. */

            reload_interval = v->target_duration / 2;

        }

        if (v->cur_seq_no < v->start_seq_no) {

            av_log(NULL, AV_LOG_WARNING,

                   "skipping %d segments ahead, expired from playlists\n",

                   v->start_seq_no - v->cur_seq_no);

            v->cur_seq_no = v->start_seq_no;

        }

        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {

            if (v->finished)

                return AVERROR_EOF;

            while (av_gettime_relative() - v->last_load_time < reload_interval) {

                if (ff_check_interrupt(c->interrupt_callback))

                    return AVERROR_EXIT;

                av_usleep(100*1000);

            }

            /* Enough time has elapsed since the last reload */

            goto reload;

        }



        seg = current_segment(v);



        /* load/update Media Initialization Section, if any */

        ret = update_init_section(v, seg);

        if (ret)

            return ret;



        ret = open_input(c, v, seg);

        if (ret < 0) {

            if (ff_check_interrupt(c->interrupt_callback))

                return AVERROR_EXIT;

            av_log(v->parent, AV_LOG_WARNING, "Failed to open segment of playlist %d\n",

                   v->index);

            v->cur_seq_no += 1;

            goto reload;

        }

        just_opened = 1;

    }



    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {

        /* Push init section out first before first actual segment */

        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);

        memcpy(buf, v->init_sec_buf, copy_size);

        v->init_sec_buf_read_offset += copy_size;

        return copy_size;

    }



    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);

    if (ret > 0) {

        if (just_opened && v->is_id3_timestamped != 0) {

            /* Intercept ID3 tags here, elementary audio streams are required

             * to convey timestamps using them in the beginning of each segment. */

            intercept_id3(v, buf, buf_size, &ret);

        }



        return ret;

    }

    ff_format_io_close(v->parent, &v->input);

    v->cur_seq_no++;



    c->cur_seq_no = v->cur_seq_no;



    goto restart;

} and probability:0.38613861386138615
code:static void put_swf_matrix(ByteIOContext *pb,

                           int a, int b, int c, int d, int tx, int ty)

{

    PutBitContext p;

    uint8_t buf[256];



    init_put_bits(&p, buf, sizeof(buf));

    

    put_bits(&p, 1, 1); /* a, d present */

    put_bits(&p, 5, 20); /* nb bits */

    put_bits(&p, 20, a);

    put_bits(&p, 20, d);

    

    put_bits(&p, 1, 1); /* b, c present */

    put_bits(&p, 5, 20); /* nb bits */

    put_bits(&p, 20, c);

    put_bits(&p, 20, b);



    put_bits(&p, 5, 20); /* nb bits */

    put_bits(&p, 20, tx);

    put_bits(&p, 20, ty);



    flush_put_bits(&p);

    put_buffer(pb, buf, pbBufPtr(&p) - p.buf);

}
 and probability:0.05
code:int ff_nvdec_start_frame(AVCodecContext *avctx, AVFrame *frame)

{

    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;

    FrameDecodeData *fdd = (FrameDecodeData*)frame->private_ref->data;

    NVDECFrame *cf = NULL;

    int ret;



    ctx->bitstream_len = 0;

    ctx->nb_slices     = 0;



    if (fdd->hwaccel_priv)

        return 0;



    cf = av_mallocz(sizeof(*cf));

    if (!cf)

        return AVERROR(ENOMEM);



    cf->decoder_ref = av_buffer_ref(ctx->decoder_ref);

    if (!cf->decoder_ref)

        goto fail;



    cf->idx_ref = av_buffer_pool_get(ctx->decoder_pool);

    if (!cf->idx_ref) {

        av_log(avctx, AV_LOG_ERROR, "No decoder surfaces left\n");

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    cf->idx = *(unsigned int*)cf->idx_ref->data;



    fdd->hwaccel_priv      = cf;

    fdd->hwaccel_priv_free = nvdec_fdd_priv_free;

    fdd->post_process      = nvdec_retrieve_data;



    return 0;

fail:

    nvdec_fdd_priv_free(cf);

    return ret;



}
 and probability:0.45161290322580644
code:static int mov_read_trun(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    MOVFragment *frag = &c->fragment;

    AVStream *st = c->fc->streams[frag->track_id-1];

    MOVStreamContext *sc = st->priv_data;

    uint64_t offset;

    int64_t dts;

    int data_offset = 0;

    unsigned entries, first_sample_flags = frag->flags;

    int flags, distance, i;



    if (sc->pseudo_stream_id+1 != frag->stsd_id)

        return 0;

    if (!st->nb_index_entries)

        return -1;

    get_byte(pb); /* version */

    flags = get_be24(pb);

    entries = get_be32(pb);

    dprintf(c->fc, "flags 0x%x entries %d\n", flags, entries);

    if (flags & 0x001) data_offset        = get_be32(pb);

    if (flags & 0x004) first_sample_flags = get_be32(pb);

    if (flags & 0x800) {

        if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))

            return -1;

        sc->ctts_data = av_realloc(sc->ctts_data,

                                   (entries+sc->ctts_count)*sizeof(*sc->ctts_data));

        if (!sc->ctts_data)

            return AVERROR(ENOMEM);

    }

    dts = st->duration;

    offset = frag->base_data_offset + data_offset;

    distance = 0;

    dprintf(c->fc, "first sample flags 0x%x\n", first_sample_flags);

    for (i = 0; i < entries; i++) {

        unsigned sample_size = frag->size;

        int sample_flags = i ? frag->flags : first_sample_flags;

        unsigned sample_duration = frag->duration;

        int keyframe;



        if (flags & 0x100) sample_duration = get_be32(pb);

        if (flags & 0x200) sample_size     = get_be32(pb);

        if (flags & 0x400) sample_flags    = get_be32(pb);

        if (flags & 0x800) {

            sc->ctts_data[sc->ctts_count].count = 1;

            sc->ctts_data[sc->ctts_count].duration = get_be32(pb);

            sc->ctts_count++;

        }

        if ((keyframe = st->codec->codec_type == CODEC_TYPE_AUDIO ||

             (flags & 0x004 && !i && !sample_flags) || sample_flags & 0x2000000))

            distance = 0;

        av_add_index_entry(st, offset, dts, sample_size, distance,

                           keyframe ? AVINDEX_KEYFRAME : 0);

        dprintf(c->fc, "AVIndex stream %d, sample %d, offset %"PRIx64", dts %"PRId64", "

                "size %d, distance %d, keyframe %d\n", st->index, sc->sample_count+i,

                offset, dts, sample_size, distance, keyframe);

        distance++;

        assert(sample_duration % sc->time_rate == 0);

        dts += sample_duration / sc->time_rate;

        offset += sample_size;

    }

    frag->moof_offset = offset;

    sc->sample_count = st->nb_index_entries;

    st->duration = dts;

    return 0;

}
 and probability:0.49206349206349204
code:void mpv_decode_mb_internal(MpegEncContext *s, int16_t block[12][64],

                            int is_mpeg12)

{

    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;



#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration){

        ff_xvmc_decode_mb(s);//xvmc uses pblocks

        return;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {

       /* print DCT coefficients */

       int i,j;

       av_log(s->avctx, AV_LOG_DEBUG, "DCT coeffs of MB at %dx%d:\n", s->mb_x, s->mb_y);

       for(i=0; i<6; i++){

           for(j=0; j<64; j++){

               av_log(s->avctx, AV_LOG_DEBUG, "%5d",

                      block[i][s->idsp.idct_permutation[j]]);

           }

           av_log(s->avctx, AV_LOG_DEBUG, "\n");

       }

    }



    s->current_picture.qscale_table[mb_xy] = s->qscale;



    /* update DC predictors for P macroblocks */

    if (!s->mb_intra) {

        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {

            if(s->mbintra_table[mb_xy])

                ff_clean_intra_table_entries(s);

        } else {

            s->last_dc[0] =

            s->last_dc[1] =

            s->last_dc[2] = 128 << s->intra_dc_precision;

        }

    }

    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))

        s->mbintra_table[mb_xy]=1;



    if ((s->avctx->flags & AV_CODEC_FLAG_PSNR) ||

        !(s->encoding && (s->intra_only || s->pict_type == AV_PICTURE_TYPE_B) &&

          s->avctx->mb_decision != FF_MB_DECISION_RD)) { // FIXME precalc

        uint8_t *dest_y, *dest_cb, *dest_cr;

        int dct_linesize, dct_offset;

        op_pixels_func (*op_pix)[4];

        qpel_mc_func (*op_qpix)[16];

        const int linesize   = s->current_picture.f->linesize[0]; //not s->linesize as this would be wrong for field pics

        const int uvlinesize = s->current_picture.f->linesize[1];

        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band;

        const int block_size = 8;



        /* avoid copy if macroblock skipped in last frame too */

        /* skip only during decoding as we might trash the buffers during encoding a bit */

        if(!s->encoding){

            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];



            if (s->mb_skipped) {

                s->mb_skipped= 0;

                assert(s->pict_type!=AV_PICTURE_TYPE_I);

                *mbskip_ptr = 1;

            } else if(!s->current_picture.reference) {

                *mbskip_ptr = 1;

            } else{

                *mbskip_ptr = 0; /* not skipped */

            }

        }



        dct_linesize = linesize << s->interlaced_dct;

        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;



        if(readable){

            dest_y=  s->dest[0];

            dest_cb= s->dest[1];

            dest_cr= s->dest[2];

        }else{

            dest_y = s->sc.b_scratchpad;

            dest_cb= s->sc.b_scratchpad+16*linesize;

            dest_cr= s->sc.b_scratchpad+32*linesize;

        }



        if (!s->mb_intra) {

            /* motion handling */

            /* decoding or more than one mb_type (MC was already done otherwise) */

            if(!s->encoding){



                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {

                    if (s->mv_dir & MV_DIR_FORWARD) {

                        ff_thread_await_progress(&s->last_picture_ptr->tf,

                                                 lowest_referenced_row(s, 0),

                                                 0);

                    }

                    if (s->mv_dir & MV_DIR_BACKWARD) {

                        ff_thread_await_progress(&s->next_picture_ptr->tf,

                                                 lowest_referenced_row(s, 1),

                                                 0);

                    }

                }



                op_qpix= s->me.qpel_put;

                if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){

                    op_pix = s->hdsp.put_pixels_tab;

                }else{

                    op_pix = s->hdsp.put_no_rnd_pixels_tab;

                }

                if (s->mv_dir & MV_DIR_FORWARD) {

                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix, op_qpix);

                    op_pix = s->hdsp.avg_pixels_tab;

                    op_qpix= s->me.qpel_avg;

                }

                if (s->mv_dir & MV_DIR_BACKWARD) {

                    ff_mpv_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f->data, op_pix, op_qpix);

                }

            }



            /* skip dequant / idct if we are really late ;) */

            if(s->avctx->skip_idct){

                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)

                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)

                   || s->avctx->skip_idct >= AVDISCARD_ALL)

                    goto skip_idct;

            }



            /* add dct residue */

            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO

                                || (s->codec_id==AV_CODEC_ID_MPEG4 && !s->mpeg_quant))){

                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);

                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);

                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);

                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);



                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {

                    if (s->chroma_y_shift){

                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);

                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);

                    }else{

                        dct_linesize >>= 1;

                        dct_offset >>=1;

                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);

                    }

                }

            } else if(is_mpeg12 || (s->codec_id != AV_CODEC_ID_WMV2)){

                add_dct(s, block[0], 0, dest_y                          , dct_linesize);

                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);

                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);

                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);



                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {

                    if(s->chroma_y_shift){//Chroma420

                        add_dct(s, block[4], 4, dest_cb, uvlinesize);

                        add_dct(s, block[5], 5, dest_cr, uvlinesize);

                    }else{

                        //chroma422

                        dct_linesize = uvlinesize << s->interlaced_dct;

                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;



                        add_dct(s, block[4], 4, dest_cb, dct_linesize);

                        add_dct(s, block[5], 5, dest_cr, dct_linesize);

                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);

                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);

                        if(!s->chroma_x_shift){//Chroma444

                            add_dct(s, block[8], 8, dest_cb+8, dct_linesize);

                            add_dct(s, block[9], 9, dest_cr+8, dct_linesize);

                            add_dct(s, block[10], 10, dest_cb+8+dct_offset, dct_linesize);

                            add_dct(s, block[11], 11, dest_cr+8+dct_offset, dct_linesize);

                        }

                    }

                }//fi gray

            }

            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {

                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);

            }

        } else {

            /* dct only in intra block */

            if(s->encoding || !(s->codec_id==AV_CODEC_ID_MPEG1VIDEO || s->codec_id==AV_CODEC_ID_MPEG2VIDEO)){

                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);

                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);

                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);

                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);



                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {

                    if(s->chroma_y_shift){

                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);

                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);

                    }else{

                        dct_offset >>=1;

                        dct_linesize >>=1;

                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);

                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);

                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);

                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);

                    }

                }

            }else{

                s->idsp.idct_put(dest_y,                           dct_linesize, block[0]);

                s->idsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);

                s->idsp.idct_put(dest_y + dct_offset,              dct_linesize, block[2]);

                s->idsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);



                if (!CONFIG_GRAY || !(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {

                    if(s->chroma_y_shift){

                        s->idsp.idct_put(dest_cb, uvlinesize, block[4]);

                        s->idsp.idct_put(dest_cr, uvlinesize, block[5]);

                    }else{



                        dct_linesize = uvlinesize << s->interlaced_dct;

                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize * 8;



                        s->idsp.idct_put(dest_cb,              dct_linesize, block[4]);

                        s->idsp.idct_put(dest_cr,              dct_linesize, block[5]);

                        s->idsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);

                        s->idsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);

                        if(!s->chroma_x_shift){//Chroma444

                            s->idsp.idct_put(dest_cb + 8,              dct_linesize, block[8]);

                            s->idsp.idct_put(dest_cr + 8,              dct_linesize, block[9]);

                            s->idsp.idct_put(dest_cb + 8 + dct_offset, dct_linesize, block[10]);

                            s->idsp.idct_put(dest_cr + 8 + dct_offset, dct_linesize, block[11]);

                        }

                    }

                }//gray

            }

        }

skip_idct:

        if(!readable){

            s->hdsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);

            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);

            s->hdsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);

        }

    }

}
 and probability:0.6139534883720931
code:static void sha256_transform(uint32_t *state, const uint8_t buffer[64])

{

    unsigned int i, a, b, c, d, e, f, g, h;

    uint32_t block[64];

    uint32_t T1;



    a = state[0];

    b = state[1];

    c = state[2];

    d = state[3];

    e = state[4];

    f = state[5];

    g = state[6];

    h = state[7];

#if CONFIG_SMALL

    for (i = 0; i < 64; i++) {

        uint32_t T2;

        if (i < 16)

            T1 = blk0(i);

        else

            T1 = blk(i);

        T1 += h + Sigma1_256(e) + Ch(e, f, g) + K256[i];

        T2 = Sigma0_256(a) + Maj(a, b, c);

        h = g;

        g = f;

        f = e;

        e = d + T1;

        d = c;

        c = b;

        b = a;

        a = T1 + T2;

    }

#else

    for (i = 0; i < 16;) {

        ROUND256_0_TO_15(a, b, c, d, e, f, g, h);

        ROUND256_0_TO_15(h, a, b, c, d, e, f, g);

        ROUND256_0_TO_15(g, h, a, b, c, d, e, f);

        ROUND256_0_TO_15(f, g, h, a, b, c, d, e);

        ROUND256_0_TO_15(e, f, g, h, a, b, c, d);

        ROUND256_0_TO_15(d, e, f, g, h, a, b, c);

        ROUND256_0_TO_15(c, d, e, f, g, h, a, b);

        ROUND256_0_TO_15(b, c, d, e, f, g, h, a);

    }



    for (; i < 64;) {

        ROUND256_16_TO_63(a, b, c, d, e, f, g, h);

        ROUND256_16_TO_63(h, a, b, c, d, e, f, g);

        ROUND256_16_TO_63(g, h, a, b, c, d, e, f);

        ROUND256_16_TO_63(f, g, h, a, b, c, d, e);

        ROUND256_16_TO_63(e, f, g, h, a, b, c, d);

        ROUND256_16_TO_63(d, e, f, g, h, a, b, c);

        ROUND256_16_TO_63(c, d, e, f, g, h, a, b);

        ROUND256_16_TO_63(b, c, d, e, f, g, h, a);

    }

#endif

    state[0] += a;

    state[1] += b;

    state[2] += c;

    state[3] += d;

    state[4] += e;

    state[5] += f;

    state[6] += g;

    state[7] += h;

}
 and probability:0.3387096774193548
code:static void device_finalize(Object *obj)

{

    NamedGPIOList *ngl, *next;



    DeviceState *dev = DEVICE(obj);

    qemu_opts_del(dev->opts);



    QLIST_FOREACH_SAFE(ngl, &dev->gpios, node, next) {

        QLIST_REMOVE(ngl, node);

        qemu_free_irqs(ngl->in, ngl->num_in);

        g_free(ngl->name);

        g_free(ngl);

        /* ngl->out irqs are owned by the other end and should not be freed

         * here

         */

    }

}
 and probability:0.26666666666666666
code:static int vdi_open(BlockDriverState *bs, QDict *options, int flags,

                    Error **errp)

{

    BDRVVdiState *s = bs->opaque;

    VdiHeader header;

    size_t bmap_size;

    int ret;



    logout("\n");



    ret = bdrv_read(bs->file, 0, (uint8_t *)&header, 1);

    if (ret < 0) {

        goto fail;

    }



    vdi_header_to_cpu(&header);

#if defined(CONFIG_VDI_DEBUG)

    vdi_header_print(&header);

#endif



    if (header.disk_size % SECTOR_SIZE != 0) {

        /* 'VBoxManage convertfromraw' can create images with odd disk sizes.

           We accept them but round the disk size to the next multiple of

           SECTOR_SIZE. */

        logout("odd disk size %" PRIu64 " B, round up\n", header.disk_size);

        header.disk_size += SECTOR_SIZE - 1;

        header.disk_size &= ~(SECTOR_SIZE - 1);

    }



    if (header.signature != VDI_SIGNATURE) {

        error_setg(errp, "Image not in VDI format (bad signature %08x)", header.signature);

        ret = -EINVAL;

        goto fail;

    } else if (header.version != VDI_VERSION_1_1) {

        error_setg(errp, "unsupported VDI image (version %u.%u)",

                   header.version >> 16, header.version & 0xffff);

        ret = -ENOTSUP;

        goto fail;

    } else if (header.offset_bmap % SECTOR_SIZE != 0) {

        /* We only support block maps which start on a sector boundary. */

        error_setg(errp, "unsupported VDI image (unaligned block map offset "

                   "0x%x)", header.offset_bmap);

        ret = -ENOTSUP;

        goto fail;

    } else if (header.offset_data % SECTOR_SIZE != 0) {

        /* We only support data blocks which start on a sector boundary. */

        error_setg(errp, "unsupported VDI image (unaligned data offset 0x%x)",

                   header.offset_data);

        ret = -ENOTSUP;

        goto fail;

    } else if (header.sector_size != SECTOR_SIZE) {

        error_setg(errp, "unsupported VDI image (sector size %u is not %u)",

                   header.sector_size, SECTOR_SIZE);

        ret = -ENOTSUP;

        goto fail;

    } else if (header.block_size != 1 * MiB) {

        error_setg(errp, "unsupported VDI image (sector size %u is not %u)",

                   header.block_size, 1 * MiB);

        ret = -ENOTSUP;

        goto fail;

    } else if (header.disk_size >

               (uint64_t)header.blocks_in_image * header.block_size) {

        error_setg(errp, "unsupported VDI image (disk size %" PRIu64 ", "

                   "image bitmap has room for %" PRIu64 ")",

                   header.disk_size,

                   (uint64_t)header.blocks_in_image * header.block_size);

        ret = -ENOTSUP;

        goto fail;

    } else if (!uuid_is_null(header.uuid_link)) {

        error_setg(errp, "unsupported VDI image (non-NULL link UUID)");

        ret = -ENOTSUP;

        goto fail;

    } else if (!uuid_is_null(header.uuid_parent)) {

        error_setg(errp, "unsupported VDI image (non-NULL parent UUID)");

        ret = -ENOTSUP;

        goto fail;

    }



    bs->total_sectors = header.disk_size / SECTOR_SIZE;



    s->block_size = header.block_size;

    s->block_sectors = header.block_size / SECTOR_SIZE;

    s->bmap_sector = header.offset_bmap / SECTOR_SIZE;

    s->header = header;



    bmap_size = header.blocks_in_image * sizeof(uint32_t);

    bmap_size = (bmap_size + SECTOR_SIZE - 1) / SECTOR_SIZE;

    s->bmap = g_malloc(bmap_size * SECTOR_SIZE);

    ret = bdrv_read(bs->file, s->bmap_sector, (uint8_t *)s->bmap, bmap_size);

    if (ret < 0) {

        goto fail_free_bmap;

    }



    /* Disable migration when vdi images are used */

    error_set(&s->migration_blocker,

              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,

              "vdi", bs->device_name, "live migration");

    migrate_add_blocker(s->migration_blocker);



    return 0;



 fail_free_bmap:

    g_free(s->bmap);



 fail:

    return ret;

}
 and probability:0.25263157894736843
code:static void i440fx_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->no_hotplug = 1;

    k->init = i440fx_initfn;

    k->config_write = i440fx_write_config;

    k->vendor_id = PCI_VENDOR_ID_INTEL;

    k->device_id = PCI_DEVICE_ID_INTEL_82441;

    k->revision = 0x02;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = "Host bridge";

    dc->no_user = 1;

    dc->vmsd = &vmstate_i440fx;

}
 and probability:0.6666666666666666
code:int yuv2rgb_c_init_tables (SwsContext *c, const int inv_table[4], int fullRange, int brightness, int contrast, int saturation)

{

    const int isRgb = isBGR(c->dstFormat);

    const int bpp = fmt_depth(c->dstFormat);

    int i;

    uint8_t table_Y[1024];

    uint32_t *table_32 = 0;

    uint16_t *table_16 = 0;

    uint8_t *table_8 = 0;

    uint8_t *table_332 = 0;

    uint8_t *table_121 = 0;

    uint8_t *table_1 = 0;

    int entry_size = 0;

    void *table_r = 0, *table_g = 0, *table_b = 0;

    void *table_start;



    int64_t crv =  inv_table[0];

    int64_t cbu =  inv_table[1];

    int64_t cgu = -inv_table[2];

    int64_t cgv = -inv_table[3];

    int64_t cy  = 1<<16;

    int64_t oy  = 0;



//printf("%lld %lld %lld %lld %lld\n", cy, crv, cbu, cgu, cgv);

    if(!fullRange){

	cy= (cy*255) / 219;

	oy= 16<<16;

    }else{

        crv= (crv*224) / 255;

        cbu= (cbu*224) / 255;

        cgu= (cgu*224) / 255;

        cgv= (cgv*224) / 255;

    }



    cy = (cy *contrast             )>>16;

    crv= (crv*contrast * saturation)>>32;

    cbu= (cbu*contrast * saturation)>>32;

    cgu= (cgu*contrast * saturation)>>32;

    cgv= (cgv*contrast * saturation)>>32;

//printf("%lld %lld %lld %lld %lld\n", cy, crv, cbu, cgu, cgv);

    oy -= 256*brightness;



    for (i = 0; i < 1024; i++) {

	int j;



	j= (cy*(((i - 384)<<16) - oy) + (1<<31))>>32;

	j = (j < 0) ? 0 : ((j > 255) ? 255 : j);

	table_Y[i] = j;

    }



    switch (bpp) {

    case 32:

	table_start= table_32 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint32_t));



	entry_size = sizeof (uint32_t);

	table_r = table_32 + 197;

	table_b = table_32 + 197 + 685;

	table_g = table_32 + 197 + 2*682;



	for (i = -197; i < 256+197; i++)

	    ((uint32_t *)table_r)[i] = table_Y[i+384] << (isRgb ? 16 : 0);

	for (i = -132; i < 256+132; i++)

	    ((uint32_t *)table_g)[i] = table_Y[i+384] << 8;

	for (i = -232; i < 256+232; i++)

	    ((uint32_t *)table_b)[i] = table_Y[i+384] << (isRgb ? 0 : 16);

	break;



    case 24:

	table_start= table_8 = av_malloc ((256 + 2*232) * sizeof (uint8_t));



	entry_size = sizeof (uint8_t);

	table_r = table_g = table_b = table_8 + 232;



	for (i = -232; i < 256+232; i++)

	    ((uint8_t * )table_b)[i] = table_Y[i+384];

	break;



    case 15:

    case 16:

	table_start= table_16 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint16_t));



	entry_size = sizeof (uint16_t);

	table_r = table_16 + 197;

	table_b = table_16 + 197 + 685;

	table_g = table_16 + 197 + 2*682;



	for (i = -197; i < 256+197; i++) {

	    int j = table_Y[i+384] >> 3;



	    if (isRgb)

		j <<= ((bpp==16) ? 11 : 10);



	    ((uint16_t *)table_r)[i] = j;

	}

	for (i = -132; i < 256+132; i++) {

	    int j = table_Y[i+384] >> ((bpp==16) ? 2 : 3);



	    ((uint16_t *)table_g)[i] = j << 5;

	}

	for (i = -232; i < 256+232; i++) {

	    int j = table_Y[i+384] >> 3;



	    if (!isRgb)

		j <<= ((bpp==16) ? 11 : 10);



	    ((uint16_t *)table_b)[i] = j;

	}

	break;



    case 8:

	table_start= table_332 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));



	entry_size = sizeof (uint8_t);

	table_r = table_332 + 197;

	table_b = table_332 + 197 + 685;

	table_g = table_332 + 197 + 2*682;



	for (i = -197; i < 256+197; i++) {

	    int j = (table_Y[i+384 - 16] + 18)/36;



	    if (isRgb)

		j <<= 5;



	    ((uint8_t *)table_r)[i] = j;

	}

	for (i = -132; i < 256+132; i++) {

	    int j = (table_Y[i+384 - 16] + 18)/36;



	    if (!isRgb)

		j <<= 1;



	    ((uint8_t *)table_g)[i] = j << 2;

	}

	for (i = -232; i < 256+232; i++) {

	    int j = (table_Y[i+384 - 37] + 43)/85;



	    if (!isRgb)

		j <<= 6;



	    ((uint8_t *)table_b)[i] = j;

	}

	break;

    case 4:

    case 4|128:

	table_start= table_121 = av_malloc ((197 + 2*682 + 256 + 132) * sizeof (uint8_t));



	entry_size = sizeof (uint8_t);

	table_r = table_121 + 197;

	table_b = table_121 + 197 + 685;

	table_g = table_121 + 197 + 2*682;



	for (i = -197; i < 256+197; i++) {

	    int j = table_Y[i+384 - 110] >> 7;



	    if (isRgb)

		j <<= 3;



	    ((uint8_t *)table_r)[i] = j;

	}

	for (i = -132; i < 256+132; i++) {

	    int j = (table_Y[i+384 - 37]+ 43)/85;



	    ((uint8_t *)table_g)[i] = j << 1;

	}

	for (i = -232; i < 256+232; i++) {

	    int j =table_Y[i+384 - 110] >> 7;



	    if (!isRgb)

		j <<= 3;



	    ((uint8_t *)table_b)[i] = j;

	}

	break;



    case 1:

	table_start= table_1 = av_malloc (256*2 * sizeof (uint8_t));



	entry_size = sizeof (uint8_t);

	table_g = table_1;

	table_r = table_b = NULL;



	for (i = 0; i < 256+256; i++) {

	    int j = table_Y[i + 384 - 110]>>7;



	    ((uint8_t *)table_g)[i] = j;

	}

	break;



    default:

	table_start= NULL;

	av_log(c, AV_LOG_ERROR, "%ibpp not supported by yuv2rgb\n", bpp);

	//free mem?

	return -1;

    }



    for (i = 0; i < 256; i++) {

	c->table_rV[i] = (uint8_t *)table_r + entry_size * div_round (crv * (i-128), 76309);

	c->table_gU[i] = (uint8_t *)table_g + entry_size * div_round (cgu * (i-128), 76309);

	c->table_gV[i] = entry_size * div_round (cgv * (i-128), 76309);

	c->table_bU[i] = (uint8_t *)table_b + entry_size * div_round (cbu * (i-128), 76309);

    }



    av_free(c->yuvTable);

    c->yuvTable= table_start;

    return 0;

}
 and probability:0.5121951219512195
code:target_ulong helper_udiv(target_ulong a, target_ulong b)

{

    uint64_t x0;

    uint32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if (x0 > 0xffffffff) {

        env->cc_src2 = 1;

        return 0xffffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
 and probability:0.2222222222222222
code:static direntry_t *create_short_filename(BDRVVVFATState *s,

                                         const char *filename,

                                         unsigned int directory_start)

{

    int i, j = 0;

    direntry_t *entry = array_get_next(&(s->directory));

    const gchar *p, *last_dot = NULL;

    gunichar c;

    bool lossy_conversion = false;

    char tail[11];



    if (!entry) {

        return NULL;

    }

    memset(entry->name, 0x20, sizeof(entry->name));



    /* copy filename and search last dot */

    for (p = filename; ; p = g_utf8_next_char(p)) {

        c = g_utf8_get_char(p);

        if (c == '\0') {

            break;

        } else if (c == '.') {

            if (j == 0) {

                /* '.' at start of filename */

                lossy_conversion = true;

            } else {

                if (last_dot) {

                    lossy_conversion = true;

                }

                last_dot = p;

            }

        } else if (!last_dot) {

            /* first part of the name; copy it */

            uint8_t v = to_valid_short_char(c);

            if (j < 8 && v) {

                entry->name[j++] = v;

            } else {

                lossy_conversion = true;

            }

        }

    }



    /* copy extension (if any) */

    if (last_dot) {

        j = 0;

        for (p = g_utf8_next_char(last_dot); ; p = g_utf8_next_char(p)) {

            c = g_utf8_get_char(p);

            if (c == '\0') {

                break;

            } else {

                /* extension; copy it */

                uint8_t v = to_valid_short_char(c);

                if (j < 3 && v) {

                    entry->name[8 + (j++)] = v;

                } else {

                    lossy_conversion = true;

                }

            }

        }

    }



    if (entry->name[0] == DIR_KANJI) {

        entry->name[0] = DIR_KANJI_FAKE;

    }



    /* numeric-tail generation */

    for (j = 0; j < 8; j++) {

        if (entry->name[j] == ' ') {

            break;

        }

    }

    for (i = lossy_conversion ? 1 : 0; i < 999999; i++) {

        direntry_t *entry1;

        if (i > 0) {

            int len = sprintf(tail, "~%d", i);

            memcpy(entry->name + MIN(j, 8 - len), tail, len);

        }

        for (entry1 = array_get(&(s->directory), directory_start);

             entry1 < entry; entry1++) {

            if (!is_long_name(entry1) &&

                !memcmp(entry1->name, entry->name, 11)) {

                break; /* found dupe */

            }

        }

        if (entry1 == entry) {

            /* no dupe found */

            return entry;

        }

    }

    return NULL;

}
 and probability:0.16279069767441862
code:void ff_print_debug_info(MpegEncContext *s, Picture *p)

{

    AVFrame *pict;

    if (s->avctx->hwaccel || !p || !p->mb_type)

        return;

    pict = &p->f;



    if (s->avctx->debug & (FF_DEBUG_SKIP | FF_DEBUG_QP | FF_DEBUG_MB_TYPE)) {

        int x,y;



        av_log(s->avctx,AV_LOG_DEBUG,"New frame, type: ");

        switch (pict->pict_type) {

        case AV_PICTURE_TYPE_I:

            av_log(s->avctx,AV_LOG_DEBUG,"I\n");

            break;

        case AV_PICTURE_TYPE_P:

            av_log(s->avctx,AV_LOG_DEBUG,"P\n");

            break;

        case AV_PICTURE_TYPE_B:

            av_log(s->avctx,AV_LOG_DEBUG,"B\n");

            break;

        case AV_PICTURE_TYPE_S:

            av_log(s->avctx,AV_LOG_DEBUG,"S\n");

            break;

        case AV_PICTURE_TYPE_SI:

            av_log(s->avctx,AV_LOG_DEBUG,"SI\n");

            break;

        case AV_PICTURE_TYPE_SP:

            av_log(s->avctx,AV_LOG_DEBUG,"SP\n");

            break;

        }

        for (y = 0; y < s->mb_height; y++) {

            for (x = 0; x < s->mb_width; x++) {

                if (s->avctx->debug & FF_DEBUG_SKIP) {

                    int count = s->mbskip_table[x + y * s->mb_stride];

                    if (count > 9)

                        count = 9;

                    av_log(s->avctx, AV_LOG_DEBUG, "%1d", count);

                }

                if (s->avctx->debug & FF_DEBUG_QP) {

                    av_log(s->avctx, AV_LOG_DEBUG, "%2d",

                           p->qscale_table[x + y * s->mb_stride]);

                }

                if (s->avctx->debug & FF_DEBUG_MB_TYPE) {

                    int mb_type = p->mb_type[x + y * s->mb_stride];

                    // Type & MV direction

                    if (IS_PCM(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "P");

                    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "A");

                    else if (IS_INTRA4x4(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "i");

                    else if (IS_INTRA16x16(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "I");

                    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "d");

                    else if (IS_DIRECT(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "D");

                    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "g");

                    else if (IS_GMC(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "G");

                    else if (IS_SKIP(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "S");

                    else if (!USES_LIST(mb_type, 1))

                        av_log(s->avctx, AV_LOG_DEBUG, ">");

                    else if (!USES_LIST(mb_type, 0))

                        av_log(s->avctx, AV_LOG_DEBUG, "<");

                    else {

                        assert(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));

                        av_log(s->avctx, AV_LOG_DEBUG, "X");

                    }



                    // segmentation

                    if (IS_8X8(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "+");

                    else if (IS_16X8(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "-");

                    else if (IS_8X16(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "|");

                    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, " ");

                    else

                        av_log(s->avctx, AV_LOG_DEBUG, "?");





                    if (IS_INTERLACED(mb_type))

                        av_log(s->avctx, AV_LOG_DEBUG, "=");

                    else

                        av_log(s->avctx, AV_LOG_DEBUG, " ");

                }

            }

            av_log(s->avctx, AV_LOG_DEBUG, "\n");

        }

    }

}
 and probability:0.45054945054945056
code:static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,

    int dest_len)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    const unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    unsigned char *dest_end = dest + dest_len;

    GetBitContext gb;



    init_get_bits(&gb, ptr, 0); // FIXME: no src size available



    while ( val != 0x16 ) {

        val = src[val - 0x17 + get_bits1(&gb) * byte];



        if ( val < 0x16 ) {

            if (dest + 1 > dest_end)

                return 0;

            *dest++ = val;

            val = ival;

        }

    }



    return 0;

}
 and probability:0.3333333333333333
code:static int kvm_log_stop(CPUPhysMemoryClient *client,

                        target_phys_addr_t phys_addr, ram_addr_t size)

{

    return kvm_dirty_pages_log_change(phys_addr, size, false);

}
 and probability:0.0
code:void MPV_common_end(MpegEncContext *s)

{

    int i;



    if (s->motion_val)

        free(s->motion_val);

    if (s->h263_pred) {

        free(s->dc_val[0]);

        free(s->ac_val[0]);

        free(s->coded_block);

        free(s->mbintra_table);

    }

    if (s->mbskip_table)

        free(s->mbskip_table);

    for(i=0;i<3;i++) {

        free(s->last_picture_base[i]);

        free(s->next_picture_base[i]);

        if (s->has_b_frames)

            free(s->aux_picture_base[i]);

    }

    s->context_initialized = 0;

}
 and probability:0.7142857142857143
code:static void blkdebug_refresh_filename(BlockDriverState *bs, QDict *options)

{

    BDRVBlkdebugState *s = bs->opaque;

    QDict *opts;

    const QDictEntry *e;

    bool force_json = false;



    for (e = qdict_first(options); e; e = qdict_next(options, e)) {

        if (strcmp(qdict_entry_key(e), "config") &&

            strcmp(qdict_entry_key(e), "x-image"))

        {

            force_json = true;

            break;

        }

    }



    if (force_json && !bs->file->bs->full_open_options) {

        /* The config file cannot be recreated, so creating a plain filename

         * is impossible */

        return;

    }



    if (!force_json && bs->file->bs->exact_filename[0]) {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "blkdebug:%s:%s", s->config_file ?: "",

                 bs->file->bs->exact_filename);

    }



    opts = qdict_new();

    qdict_put_str(opts, "driver", "blkdebug");



    QINCREF(bs->file->bs->full_open_options);

    qdict_put(opts, "image", bs->file->bs->full_open_options);



    for (e = qdict_first(options); e; e = qdict_next(options, e)) {

        if (strcmp(qdict_entry_key(e), "x-image")) {

            qobject_incref(qdict_entry_value(e));

            qdict_put_obj(opts, qdict_entry_key(e), qdict_entry_value(e));

        }

    }



    bs->full_open_options = opts;

}
 and probability:0.25
code:static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,

                USBPacket *p)

{

    int len;



    if (likely(!fifo->len))

        return USB_RET_STALL;



    len = MIN(p->len, fifo->fifo[fifo->start].len);

    memcpy(p->data, fifo->fifo[fifo->start].data, len);

    if (len == p->len) {

        fifo->fifo[fifo->start].len -= len;

        fifo->fifo[fifo->start].data += len;

    } else {

        fifo->start ++;

        fifo->start &= CFIFO_LEN_MASK;

        fifo->len --;

    }



    fifo->dstart += len;

    fifo->dlen -= len;

    if (fifo->dstart >= fifo->dsize) {

        fifo->dstart = 0;

        fifo->dsize = DFIFO_LEN_MASK + 1;

    }



    return len;

}
 and probability:0.5833333333333334
code:static int block_load(QEMUFile *f, void *opaque, int version_id)

{

    static int banner_printed;

    int len, flags;

    char device_name[256];

    int64_t addr;

    BlockDriverState *bs;

    uint8_t *buf;



    do {

        addr = qemu_get_be64(f);



        flags = addr & ~BDRV_SECTOR_MASK;

        addr >>= BDRV_SECTOR_BITS;



        if (flags & BLK_MIG_FLAG_DEVICE_BLOCK) {

            int ret;

            /* get device name */

            len = qemu_get_byte(f);

            qemu_get_buffer(f, (uint8_t *)device_name, len);

            device_name[len] = '\0';



            bs = bdrv_find(device_name);

            if (!bs) {

                fprintf(stderr, "Error unknown block device %s\n",

                        device_name);

                return -EINVAL;

            }



            buf = qemu_malloc(BLOCK_SIZE);



            qemu_get_buffer(f, buf, BLOCK_SIZE);

            ret = bdrv_write(bs, addr, buf, BDRV_SECTORS_PER_DIRTY_CHUNK);



            qemu_free(buf);

            if (ret < 0) {

                return ret;

            }

        } else if (flags & BLK_MIG_FLAG_PROGRESS) {

            if (!banner_printed) {

                printf("Receiving block device images\n");

                banner_printed = 1;

            }

            printf("Completed %d %%%c", (int)addr,

                   (addr == 100) ? '\n' : '\r');

            fflush(stdout);

        } else if (!(flags & BLK_MIG_FLAG_EOS)) {

            fprintf(stderr, "Unknown flags\n");

            return -EINVAL;

        }

        if (qemu_file_has_error(f)) {

            return -EIO;

        }

    } while (!(flags & BLK_MIG_FLAG_EOS));



    return 0;

}
 and probability:0.02040816326530612
code:static int alsa_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    ALSAVoiceIn *alsa = (ALSAVoiceIn *) hw;

    struct alsa_params_req req;

    struct alsa_params_obt obt;

    snd_pcm_t *handle;

    struct audsettings obt_as;



    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);

    req.freq = as->freq;

    req.nchannels = as->nchannels;

    req.period_size = conf.period_size_in;

    req.buffer_size = conf.buffer_size_in;

    req.size_in_usec = conf.size_in_usec_in;

    req.override_mask =

        (conf.period_size_in_overridden ? 1 : 0) |

        (conf.buffer_size_in_overridden ? 2 : 0);



    if (alsa_open (1, &req, &obt, &handle)) {

        return -1;

    }



    obt_as.freq = obt.freq;

    obt_as.nchannels = obt.nchannels;

    obt_as.fmt = obt.fmt;

    obt_as.endianness = obt.endianness;



    audio_pcm_init_info (&hw->info, &obt_as);

    hw->samples = obt.samples;



    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!alsa->pcm_buf) {

        dolog ("Could not allocate ADC buffer (%d samples, each %d bytes)\n",

               hw->samples, 1 << hw->info.shift);

        alsa_anal_close1 (&handle);

        return -1;

    }



    alsa->handle = handle;

    return 0;

}
 and probability:0.2571428571428571
code:static uint32_t m5206_mbar_readb(void *opaque, target_phys_addr_t offset)

{

    m5206_mbar_state *s = (m5206_mbar_state *)opaque;

    offset &= 0x3ff;

    if (offset > 0x200) {

        hw_error("Bad MBAR read offset 0x%x", (int)offset);

    }

    if (m5206_mbar_width[offset >> 2] > 1) {

        uint16_t val;

        val = m5206_mbar_readw(opaque, offset & ~1);

        if ((offset & 1) == 0) {

            val >>= 8;

        }

        return val & 0xff;

    }

    return m5206_mbar_read(s, offset, 1);

}
 and probability:0.058823529411764705
code:static int vnc_zlib_stop(VncState *vs, int stream_id)

{

    z_streamp zstream = &vs->zlib_stream[stream_id];

    int previous_out;



    // switch back to normal output/zlib buffers

    vs->zlib = vs->output;

    vs->output = vs->zlib_tmp;



    // compress the zlib buffer



    // initialize the stream

    // XXX need one stream per session

    if (zstream->opaque != vs) {

        int err;



        VNC_DEBUG("VNC: initializing zlib stream %d\n", stream_id);

        VNC_DEBUG("VNC: opaque = %p | vs = %p\n", zstream->opaque, vs);

        zstream->zalloc = Z_NULL;

        zstream->zfree = Z_NULL;



        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,

                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);



        if (err != Z_OK) {

            fprintf(stderr, "VNC: error initializing zlib\n");

            return -1;

        }



        zstream->opaque = vs;

    }



    // XXX what to do if tight_compression changed in between?



    // reserve memory in output buffer

    buffer_reserve(&vs->output, vs->zlib.offset + 64);



    // set pointers

    zstream->next_in = vs->zlib.buffer;

    zstream->avail_in = vs->zlib.offset;

    zstream->next_out = vs->output.buffer + vs->output.offset;

    zstream->avail_out = vs->output.capacity - vs->output.offset;

    zstream->data_type = Z_BINARY;

    previous_out = zstream->total_out;



    // start encoding

    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {

        fprintf(stderr, "VNC: error during zlib compression\n");

        return -1;

    }



    vs->output.offset = vs->output.capacity - zstream->avail_out;

    return zstream->total_out - previous_out;

}
 and probability:0.42857142857142855
code:static int flac_parse(AVCodecParserContext *s, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    FLACParseContext *fpc = s->priv_data;

    FLACHeaderMarker *curr;

    int nb_headers;

    const uint8_t *read_end   = buf;

    const uint8_t *read_start = buf;



    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {

        FLACFrameInfo fi;

        if (frame_header_is_valid(avctx, buf, &fi)) {

            s->duration = fi.blocksize;

            if (!avctx->sample_rate)

                avctx->sample_rate = fi.samplerate;

            if (fpc->pc->flags & PARSER_FLAG_USE_CODEC_TS){

                fpc->pc->pts = fi.frame_or_sample_num;

                if (!fi.is_var_size)

                  fpc->pc->pts *= fi.blocksize;

            }

        }

        *poutbuf      = buf;

        *poutbuf_size = buf_size;

        return buf_size;

    }



    fpc->avctx = avctx;

    if (fpc->best_header_valid)

        return get_best_header(fpc, poutbuf, poutbuf_size);



    /* If a best_header was found last call remove it with the buffer data. */

    if (fpc->best_header && fpc->best_header->best_child) {

        FLACHeaderMarker *temp;

        FLACHeaderMarker *best_child = fpc->best_header->best_child;



        /* Remove headers in list until the end of the best_header. */

        for (curr = fpc->headers; curr != best_child; curr = temp) {

            if (curr != fpc->best_header) {

                av_log(avctx, AV_LOG_DEBUG,

                       "dropping low score %i frame header from offset %i to %i\n",

                       curr->max_score, curr->offset, curr->next->offset);

            }

            temp = curr->next;

            av_freep(&curr->link_penalty);

            av_free(curr);


        }

        /* Release returned data from ring buffer. */

        av_fifo_drain(fpc->fifo_buf, best_child->offset);



        /* Fix the offset for the headers remaining to match the new buffer. */

        for (curr = best_child->next; curr; curr = curr->next)

            curr->offset -= best_child->offset;




        best_child->offset = 0;

        fpc->headers       = best_child;

        if (fpc->nb_headers_buffered >= FLAC_MIN_HEADERS) {

            fpc->best_header = best_child;

            return get_best_header(fpc, poutbuf, poutbuf_size);

        }

        fpc->best_header   = NULL;

    } else if (fpc->best_header) {

        /* No end frame no need to delete the buffer; probably eof */

        FLACHeaderMarker *temp;



        for (curr = fpc->headers; curr != fpc->best_header; curr = temp) {

            temp = curr->next;

            av_freep(&curr->link_penalty);

            av_free(curr);


        }

        fpc->headers = fpc->best_header->next;

        av_freep(&fpc->best_header->link_penalty);

        av_freep(&fpc->best_header);


    }



    /* Find and score new headers.                                     */

    /* buf_size is to zero when padding, so check for this since we do */

    /* not want to try to read more input once we have found the end.  */

    /* Note that as (non-modified) parameters, buf can be non-NULL,    */

    /* while buf_size is 0.                                            */

    while ((buf && buf_size && read_end < buf + buf_size &&

            fpc->nb_headers_buffered < FLAC_MIN_HEADERS)

           || ((!buf || !buf_size) && !fpc->end_padded)) {

        int start_offset;



        /* Pad the end once if EOF, to check the final region for headers. */

        if (!buf || !buf_size) {

            fpc->end_padded      = 1;

            buf_size = MAX_FRAME_HEADER_SIZE;

            read_end = read_start + MAX_FRAME_HEADER_SIZE;

        } else {

            /* The maximum read size is the upper-bound of what the parser

               needs to have the required number of frames buffered */

            int nb_desired = FLAC_MIN_HEADERS - fpc->nb_headers_buffered + 1;

            read_end       = read_end + FFMIN(buf + buf_size - read_end,

                                              nb_desired * FLAC_AVG_FRAME_SIZE);

        }



        if (!av_fifo_space(fpc->fifo_buf) &&

            av_fifo_size(fpc->fifo_buf) / FLAC_AVG_FRAME_SIZE >

            fpc->nb_headers_buffered * 20) {

            /* There is less than one valid flac header buffered for 20 headers

             * buffered. Therefore the fifo is most likely filled with invalid

             * data and the input is not a flac file. */

            goto handle_error;

        }



        /* Fill the buffer. */

        if (   av_fifo_space(fpc->fifo_buf) < read_end - read_start

            && av_fifo_realloc2(fpc->fifo_buf, (read_end - read_start) + 2*av_fifo_size(fpc->fifo_buf)) < 0) {

            av_log(avctx, AV_LOG_ERROR,

                   "couldn't reallocate buffer of size %"PTRDIFF_SPECIFIER"\n",

                   (read_end - read_start) + av_fifo_size(fpc->fifo_buf));

            goto handle_error;

        }



        if (buf && buf_size) {

            av_fifo_generic_write(fpc->fifo_buf, (void*) read_start,

                                  read_end - read_start, NULL);

        } else {

            int8_t pad[MAX_FRAME_HEADER_SIZE] = { 0 };

            av_fifo_generic_write(fpc->fifo_buf, (void*) pad, sizeof(pad), NULL);

        }



        /* Tag headers and update sequences. */

        start_offset = av_fifo_size(fpc->fifo_buf) -

                       ((read_end - read_start) + (MAX_FRAME_HEADER_SIZE - 1));

        start_offset = FFMAX(0, start_offset);

        nb_headers   = find_new_headers(fpc, start_offset);



        if (nb_headers < 0) {

            av_log(avctx, AV_LOG_ERROR,

                   "find_new_headers couldn't allocate FLAC header\n");

            goto handle_error;

        }



        fpc->nb_headers_buffered = nb_headers;

        /* Wait till FLAC_MIN_HEADERS to output a valid frame. */

        if (!fpc->end_padded && fpc->nb_headers_buffered < FLAC_MIN_HEADERS) {

            if (buf && read_end < buf + buf_size) {

                read_start = read_end;

                continue;

            } else {

                goto handle_error;

            }

        }



        /* If headers found, update the scores since we have longer chains. */

        if (fpc->end_padded || fpc->nb_headers_found)

            score_sequences(fpc);



        /* restore the state pre-padding */

        if (fpc->end_padded) {

            int warp = fpc->fifo_buf->wptr - fpc->fifo_buf->buffer < MAX_FRAME_HEADER_SIZE;

            /* HACK: drain the tail of the fifo */

            fpc->fifo_buf->wptr -= MAX_FRAME_HEADER_SIZE;

            fpc->fifo_buf->wndx -= MAX_FRAME_HEADER_SIZE;

            if (warp) {

                fpc->fifo_buf->wptr += fpc->fifo_buf->end -

                    fpc->fifo_buf->buffer;

            }

            buf_size = 0;

            read_start = read_end = NULL;

        }

    }



    for (curr = fpc->headers; curr; curr = curr->next) {

        if (curr->max_score > 0 &&

            (!fpc->best_header || curr->max_score > fpc->best_header->max_score)) {

            fpc->best_header = curr;

        }

    }



    if (fpc->best_header) {

        fpc->best_header_valid = 1;

        if (fpc->best_header->offset > 0) {

            /* Output a junk frame. */

            av_log(avctx, AV_LOG_DEBUG, "Junk frame till offset %i\n",

                   fpc->best_header->offset);



            /* Set duration to 0. It is unknown or invalid in a junk frame. */

            s->duration = 0;

            *poutbuf_size     = fpc->best_header->offset;

            *poutbuf          = flac_fifo_read_wrap(fpc, 0, *poutbuf_size,

                                                    &fpc->wrap_buf,

                                                    &fpc->wrap_buf_allocated_size);

            return buf_size ? (read_end - buf) : (fpc->best_header->offset -

                                           av_fifo_size(fpc->fifo_buf));

        }

        if (!buf_size)

            return get_best_header(fpc, poutbuf, poutbuf_size);

    }



handle_error:

    *poutbuf      = NULL;

    *poutbuf_size = 0;

    return buf_size ? read_end - buf : 0;

} and probability:0.4576271186440678
code:int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,

             const void *bits, int bits_wrap, int bits_size,

             const void *codes, int codes_wrap, int codes_size,

             const void *symbols, int symbols_wrap, int symbols_size,

             int flags)

{

    VLCcode *buf;

    int i, j, ret;



    vlc->bits = nb_bits;

    if(flags & INIT_VLC_USE_NEW_STATIC){

        VLC dyn_vlc = *vlc;



        if (vlc->table_size)

            return 0;



        ret = ff_init_vlc_sparse(&dyn_vlc, nb_bits, nb_codes,

                                 bits, bits_wrap, bits_size,

                                 codes, codes_wrap, codes_size,

                                 symbols, symbols_wrap, symbols_size,

                                 flags & ~INIT_VLC_USE_NEW_STATIC);

        av_assert0(ret >= 0);

        av_assert0(dyn_vlc.table_size <= vlc->table_allocated);

        if(dyn_vlc.table_size < vlc->table_allocated)

            av_log(NULL, AV_LOG_ERROR, "needed %d had %d\n", dyn_vlc.table_size, vlc->table_allocated);

        memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));

        vlc->table_size = dyn_vlc.table_size;

        ff_free_vlc(&dyn_vlc);

        return 0;

    }else {

        vlc->table = NULL;

        vlc->table_allocated = 0;

        vlc->table_size = 0;

    }



    av_dlog(NULL, "build table nb_codes=%d\n", nb_codes);



    buf = av_malloc((nb_codes+1)*sizeof(VLCcode));



    av_assert0(symbols_size <= 2 || !symbols);

    j = 0;

#define COPY(condition)\

    for (i = 0; i < nb_codes; i++) {\

        GET_DATA(buf[j].bits, bits, i, bits_wrap, bits_size);\

        if (!(condition))\

            continue;\

        if (buf[j].bits > 3*nb_bits || buf[j].bits>32) {\

            av_log(NULL, AV_LOG_ERROR, "Too long VLC in init_vlc\n");\


            return -1;\

        }\

        GET_DATA(buf[j].code, codes, i, codes_wrap, codes_size);\

        if (buf[j].code >= (1LL<<buf[j].bits)) {\

            av_log(NULL, AV_LOG_ERROR, "Invalid code in init_vlc\n");\


            return -1;\

        }\

        if (flags & INIT_VLC_LE)\

            buf[j].code = bitswap_32(buf[j].code);\

        else\

            buf[j].code <<= 32 - buf[j].bits;\

        if (symbols)\

            GET_DATA(buf[j].symbol, symbols, i, symbols_wrap, symbols_size)\

        else\

            buf[j].symbol = i;\

        j++;\

    }

    COPY(buf[j].bits > nb_bits);

    // qsort is the slowest part of init_vlc, and could probably be improved or avoided

    qsort(buf, j, sizeof(VLCcode), compare_vlcspec);

    COPY(buf[j].bits && buf[j].bits <= nb_bits);

    nb_codes = j;



    ret = build_table(vlc, nb_bits, nb_codes, buf, flags);



    av_free(buf);

    if (ret < 0) {

        av_freep(&vlc->table);

        return -1;

    }

    return 0;

} and probability:0.3194444444444444
code:static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= 0;

    h->prev_frame_num_offset= 0;

    h->prev_poc_msb=

    h->prev_poc_lsb= 0;

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)

        h->last_pocs[i] = INT_MIN;

}
 and probability:0.6
code:static void cg3_initfn(Object *obj)

{

    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);

    CG3State *s = CG3(obj);



    memory_region_init_ram(&s->rom, NULL, "cg3.prom", FCODE_MAX_ROM_SIZE,

                           &error_abort);

    memory_region_set_readonly(&s->rom, true);

    sysbus_init_mmio(sbd, &s->rom);



    memory_region_init_io(&s->reg, NULL, &cg3_reg_ops, s, "cg3.reg",

                          CG3_REG_SIZE);

    sysbus_init_mmio(sbd, &s->reg);

}
 and probability:0.4166666666666667
code:int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)

{

    int id, sr, ch, ba, tag, bps;



    id  = avctx->codec_id;

    sr  = avctx->sample_rate;

    ch  = avctx->channels;

    ba  = avctx->block_align;

    tag = avctx->codec_tag;

    bps = av_get_exact_bits_per_sample(avctx->codec_id);



    /* codecs with an exact constant bits per sample */

    if (bps > 0 && ch > 0 && frame_bytes > 0)

        return (frame_bytes * 8) / (bps * ch);

    bps = avctx->bits_per_coded_sample;



    /* codecs with a fixed packet duration */

    switch (id) {

    case CODEC_ID_ADPCM_ADX:    return   32;

    case CODEC_ID_ADPCM_IMA_QT: return   64;

    case CODEC_ID_ADPCM_EA_XAS: return  128;

    case CODEC_ID_AMR_NB:

    case CODEC_ID_GSM:

    case CODEC_ID_QCELP:

    case CODEC_ID_RA_144:

    case CODEC_ID_RA_288:       return  160;

    case CODEC_ID_IMC:          return  256;

    case CODEC_ID_AMR_WB:

    case CODEC_ID_GSM_MS:       return  320;

    case CODEC_ID_MP1:          return  384;

    case CODEC_ID_ATRAC1:       return  512;

    case CODEC_ID_ATRAC3:       return 1024;

    case CODEC_ID_MP2:

    case CODEC_ID_MUSEPACK7:    return 1152;

    case CODEC_ID_AC3:          return 1536;

    }



    if (sr > 0) {

        /* calc from sample rate */

        if (id == CODEC_ID_TTA)

            return 256 * sr / 245;



        if (ch > 0) {

            /* calc from sample rate and channels */

            if (id == CODEC_ID_BINKAUDIO_DCT)

                return (480 << (sr / 22050)) / ch;

        }

    }



    if (ba > 0) {

        /* calc from block_align */

        if (id == CODEC_ID_SIPR) {

            switch (ba) {

            case 20: return 160;

            case 19: return 144;

            case 29: return 288;

            case 37: return 480;

            }

        }

    }



    if (frame_bytes > 0) {

        /* calc from frame_bytes only */

        if (id == CODEC_ID_TRUESPEECH)

            return 240 * (frame_bytes / 32);

        if (id == CODEC_ID_NELLYMOSER)

            return 256 * (frame_bytes / 64);



        if (bps > 0) {

            /* calc from frame_bytes and bits_per_coded_sample */

            if (id == CODEC_ID_ADPCM_G726)

                return frame_bytes * 8 / bps;

        }



        if (ch > 0) {

            /* calc from frame_bytes and channels */

            switch (id) {

            case CODEC_ID_ADPCM_4XM:

            case CODEC_ID_ADPCM_IMA_ISS:

                return (frame_bytes - 4 * ch) * 2 / ch;

            case CODEC_ID_ADPCM_IMA_SMJPEG:

                return (frame_bytes - 4) * 2 / ch;

            case CODEC_ID_ADPCM_IMA_AMV:

                return (frame_bytes - 8) * 2 / ch;

            case CODEC_ID_ADPCM_XA:

                return (frame_bytes / 128) * 224 / ch;

            case CODEC_ID_INTERPLAY_DPCM:

                return (frame_bytes - 6 - ch) / ch;

            case CODEC_ID_ROQ_DPCM:

                return (frame_bytes - 8) / ch;

            case CODEC_ID_XAN_DPCM:

                return (frame_bytes - 2 * ch) / ch;

            case CODEC_ID_MACE3:

                return 3 * frame_bytes / ch;

            case CODEC_ID_MACE6:

                return 6 * frame_bytes / ch;

            case CODEC_ID_PCM_LXF:

                return 2 * (frame_bytes / (5 * ch));

            }



            if (tag) {

                /* calc from frame_bytes, channels, and codec_tag */

                if (id == CODEC_ID_SOL_DPCM) {

                    if (tag == 3)

                        return frame_bytes / ch;

                    else

                        return frame_bytes * 2 / ch;

                }

            }



            if (ba > 0) {

                /* calc from frame_bytes, channels, and block_align */

                int blocks = frame_bytes / ba;

                switch (avctx->codec_id) {

                case CODEC_ID_ADPCM_IMA_WAV:

                    return blocks * (1 + (ba - 4 * ch) / (4 * ch) * 8);

                case CODEC_ID_ADPCM_IMA_DK3:

                    return blocks * (((ba - 16) * 2 / 3 * 4) / ch);

                case CODEC_ID_ADPCM_IMA_DK4:

                    return blocks * (1 + (ba - 4 * ch) * 2 / ch);

                case CODEC_ID_ADPCM_MS:

                    return blocks * (2 + (ba - 7 * ch) * 2 / ch);

                }

            }



            if (bps > 0) {

                /* calc from frame_bytes, channels, and bits_per_coded_sample */

                switch (avctx->codec_id) {

                case CODEC_ID_PCM_DVD:

                    return 2 * (frame_bytes / ((bps * 2 / 8) * ch));

                case CODEC_ID_PCM_BLURAY:

                    return frame_bytes / ((FFALIGN(ch, 2) * bps) / 8);

                case CODEC_ID_S302M:

                    return 2 * (frame_bytes / ((bps + 4) / 4)) / ch;

                }

            }

        }

    }



    return 0;

}
 and probability:0.2734375
code:static void parse_context_init(SchroParseUnitContext *parse_ctx,

                               const uint8_t *buf, int buf_size)

{

    parse_ctx->buf           = buf;

    parse_ctx->buf_size      = buf_size;

}
 and probability:0.3333333333333333
code:static int update_size(AVCodecContext *ctx, int w, int h)

{

    VP9Context *s = ctx->priv_data;

    uint8_t *p;



    if (s->above_partition_ctx && w == ctx->width && h == ctx->height)

        return 0;



    ctx->width  = w;

    ctx->height = h;

    s->sb_cols  = (w + 63) >> 6;

    s->sb_rows  = (h + 63) >> 6;

    s->cols     = (w + 7) >> 3;

    s->rows     = (h + 7) >> 3;



#define assign(var, type, n) var = (type) p; p += s->sb_cols * n * sizeof(*var)

    av_free(s->above_partition_ctx);

    p = av_malloc(s->sb_cols * (240 + sizeof(*s->lflvl) + 16 * sizeof(*s->above_mv_ctx) +

                                64 * s->sb_rows * (1 + sizeof(*s->mv[0]) * 2)));

    if (!p)

        return AVERROR(ENOMEM);

    assign(s->above_partition_ctx, uint8_t *,              8);

    assign(s->above_skip_ctx,      uint8_t *,              8);

    assign(s->above_txfm_ctx,      uint8_t *,              8);

    assign(s->above_mode_ctx,      uint8_t *,             16);

    assign(s->above_y_nnz_ctx,     uint8_t *,             16);

    assign(s->above_uv_nnz_ctx[0], uint8_t *,              8);

    assign(s->above_uv_nnz_ctx[1], uint8_t *,              8);

    assign(s->intra_pred_data[0],  uint8_t *,             64);

    assign(s->intra_pred_data[1],  uint8_t *,             32);

    assign(s->intra_pred_data[2],  uint8_t *,             32);

    assign(s->above_segpred_ctx,   uint8_t *,              8);

    assign(s->above_intra_ctx,     uint8_t *,              8);

    assign(s->above_comp_ctx,      uint8_t *,              8);

    assign(s->above_ref_ctx,       uint8_t *,              8);

    assign(s->above_filter_ctx,    uint8_t *,              8);

    assign(s->lflvl,               struct VP9Filter *,     1);

    assign(s->above_mv_ctx,        VP56mv(*)[2],          16);

    assign(s->segmentation_map,    uint8_t *,             64 * s->sb_rows);

    assign(s->mv[0],               struct VP9mvrefPair *, 64 * s->sb_rows);

    assign(s->mv[1],               struct VP9mvrefPair *, 64 * s->sb_rows);

#undef assign



    return 0;

}
 and probability:0.7560975609756098
code:static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    SmackerContext *smk = s->priv_data;

    int flags;

    int ret;

    int i;

    int frame_size = 0;

    int palchange = 0;



    if (s->pb->eof_reached || smk->cur_frame >= smk->frames)

        return AVERROR_EOF;



    /* if we demuxed all streams, pass another frame */

    if(smk->curstream < 0) {

        avio_seek(s->pb, smk->nextpos, 0);

        frame_size = smk->frm_size[smk->cur_frame] & (~3);

        flags = smk->frm_flags[smk->cur_frame];

        /* handle palette change event */

        if(flags & SMACKER_PAL){

            int size, sz, t, off, j, pos;

            uint8_t *pal = smk->pal;

            uint8_t oldpal[768];



            memcpy(oldpal, pal, 768);

            size = avio_r8(s->pb);

            size = size * 4 - 1;

            frame_size -= size;

            frame_size--;

            sz = 0;

            pos = avio_tell(s->pb) + size;

            while(sz < 256){

                t = avio_r8(s->pb);

                if(t & 0x80){ /* skip palette entries */

                    sz += (t & 0x7F) + 1;

                    pal += ((t & 0x7F) + 1) * 3;

                } else if(t & 0x40){ /* copy with offset */

                    off = avio_r8(s->pb);

                    j = (t & 0x3F) + 1;

                    if (off + j > 0x100) {

                        av_log(s, AV_LOG_ERROR,

                               "Invalid palette update, offset=%d length=%d extends beyond palette size\n",

                               off, j);

                        return AVERROR_INVALIDDATA;

                    }

                    off *= 3;

                    while(j-- && sz < 256) {

                        *pal++ = oldpal[off + 0];

                        *pal++ = oldpal[off + 1];

                        *pal++ = oldpal[off + 2];

                        sz++;

                        off += 3;

                    }

                } else { /* new entries */

                    *pal++ = smk_pal[t];

                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];

                    *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];

                    sz++;

                }

            }

            avio_seek(s->pb, pos, 0);

            palchange |= 1;

        }

        flags >>= 1;

        smk->curstream = -1;

        /* if audio chunks are present, put them to stack and retrieve later */

        for(i = 0; i < 7; i++) {

            if(flags & 1) {

                uint32_t size;

                uint8_t *tmpbuf;



                size = avio_rl32(s->pb) - 4;

                if (!size || size > frame_size) {

                    av_log(s, AV_LOG_ERROR, "Invalid audio part size\n");

                    return AVERROR_INVALIDDATA;

                }

                frame_size -= size;

                frame_size -= 4;

                smk->curstream++;

                tmpbuf = av_realloc(smk->bufs[smk->curstream], size);

                if (!tmpbuf)

                    return AVERROR(ENOMEM);

                smk->bufs[smk->curstream] = tmpbuf;

                smk->buf_sizes[smk->curstream] = size;

                ret = avio_read(s->pb, smk->bufs[smk->curstream], size);

                if(ret != size)

                    return AVERROR(EIO);

                smk->stream_id[smk->curstream] = smk->indexes[i];

            }

            flags >>= 1;

        }

        if (frame_size < 0)

            return AVERROR_INVALIDDATA;

        if (av_new_packet(pkt, frame_size + 769))

            return AVERROR(ENOMEM);

        if(smk->frm_size[smk->cur_frame] & 1)

            palchange |= 2;

        pkt->data[0] = palchange;

        memcpy(pkt->data + 1, smk->pal, 768);

        ret = avio_read(s->pb, pkt->data + 769, frame_size);

        if(ret != frame_size)

            return AVERROR(EIO);

        pkt->stream_index = smk->videoindex;

        pkt->pts          = smk->cur_frame;

        pkt->size = ret + 769;

        smk->cur_frame++;

        smk->nextpos = avio_tell(s->pb);

    } else {

        if (smk->stream_id[smk->curstream] < 0)

            return AVERROR_INVALIDDATA;

        if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))

            return AVERROR(ENOMEM);

        memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);

        pkt->size = smk->buf_sizes[smk->curstream];

        pkt->stream_index = smk->stream_id[smk->curstream];

        pkt->pts = smk->aud_pts[smk->curstream];

        smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);

        smk->curstream--;

    }



    return 0;

}
 and probability:0.5
code:static void wm8750_audio_out_cb(void *opaque, int free_b)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;

    wm8750_out_flush(s);



    s->req_out = free_b;

    s->data_req(s->opaque, free_b >> 2, s->req_in >> 2);

}
 and probability:0.2857142857142857
code:static void unix_process_msgfd(CharDriverState *chr, struct msghdr *msg)
{
    TCPCharDriver *s = chr->opaque;
    struct cmsghdr *cmsg;
    for (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {
        int fd;
        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||
            cmsg->cmsg_level != SOL_SOCKET ||
            cmsg->cmsg_type != SCM_RIGHTS)
            continue;
        fd = *((int *)CMSG_DATA(cmsg));
        if (fd < 0)
            continue;
#ifndef MSG_CMSG_CLOEXEC
        qemu_set_cloexec(fd);
#endif
        if (s->msgfd != -1)
            close(s->msgfd);
        s->msgfd = fd;
    }
} and probability:0.38095238095238093
code:void ga_channel_free(GAChannel *c)

{

    if (c->method == GA_CHANNEL_UNIX_LISTEN

        && c->listen_channel) {

        ga_channel_listen_close(c);

    }

    if (c->client_channel) {

        ga_channel_client_close(c);

    }

    g_free(c);

}
 and probability:0.2727272727272727
code:ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,

                                   MemoryRegion *mr, Error **errp)

{

    RAMBlock *new_block;

    ram_addr_t addr;

    Error *local_err = NULL;



    size = TARGET_PAGE_ALIGN(size);

    new_block = g_malloc0(sizeof(*new_block));

    new_block->mr = mr;

    new_block->used_length = size;

    new_block->max_length = max_size;

    new_block->fd = -1;

    new_block->host = host;

    if (host) {

        new_block->flags |= RAM_PREALLOC;

    }

    addr = ram_block_add(new_block, &local_err);

    if (local_err) {

        g_free(new_block);

        error_propagate(errp, local_err);

        return -1;

    }

    return addr;

}
 and probability:0.2916666666666667
code:void kvm_s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,

                           uint16_t subchannel_nr, uint32_t io_int_parm,

                           uint32_t io_int_word)

{

    uint32_t type;



    if (io_int_word & IO_INT_WORD_AI) {

        type = KVM_S390_INT_IO(1, 0, 0, 0);

    } else {

        type = ((subchannel_id & 0xff00) << 24) |

            ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);

    }

    kvm_s390_interrupt_internal(cpu, type,

                                ((uint32_t)subchannel_id << 16) | subchannel_nr,

                                ((uint64_t)io_int_parm << 32) | io_int_word, 1);

}
 and probability:0.0
code:static void elcr_ioport_write(void *opaque, target_phys_addr_t addr,

                              uint64_t val, unsigned size)

{

    PICCommonState *s = opaque;

    s->elcr = val & s->elcr_mask;

}
 and probability:0.16666666666666666
code:void nonono(const char* file, int line, const char* msg) {

    fprintf(stderr, "Nonono! %s:%d %s\n", file, line, msg);

    exit(-5);

}
 and probability:0.0
code:static void spitz_i2c_setup(PXA2xxState *cpu)

{

    /* Attach the CPU on one end of our I2C bus.  */

    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);



#ifdef HAS_AUDIO

    DeviceState *wm;



    /* Attach a WM8750 to the bus */

    wm = i2c_create_slave(bus, "wm8750", 0);



    spitz_wm8750_addr(wm, 0, 0);

    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,

                    qemu_allocate_irqs(spitz_wm8750_addr, wm, 1)[0]);

    /* .. and to the sound interface.  */

    cpu->i2s->opaque = wm;

    cpu->i2s->codec_out = wm8750_dac_dat;

    cpu->i2s->codec_in = wm8750_adc_dat;

    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);

#endif

}
 and probability:0.3888888888888889
code:static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter, AVFilterInOut *out)

{

    OutputStream *ost = ofilter->ost;

    AVCodecContext *codec  = ost->st->codec;

    AVFilterContext *last_filter = out->filter_ctx;

    int pad_idx = out->pad_idx;

    char *sample_fmts, *sample_rates, *channel_layouts;

    char name[255];

    int ret;





    snprintf(name, sizeof(name), "output stream %d:%d", ost->file_index, ost->index);

    ret = avfilter_graph_create_filter(&ofilter->filter,

                                       avfilter_get_by_name("ffabuffersink"),

                                       name, NULL, NULL, fg->graph);

    if (ret < 0)

        return ret;



#define AUTO_INSERT_FILTER(opt_name, filter_name, arg) do {                 \

    AVFilterContext *filt_ctx;                                              \

                                                                            \

    av_log(NULL, AV_LOG_INFO, opt_name " is forwarded to lavfi "            \

           "similarly to -af " filter_name "=%s.\n", arg);                  \

                                                                            \

    ret = avfilter_graph_create_filter(&filt_ctx,                           \

                                       avfilter_get_by_name(filter_name),   \

                                       filter_name, arg, NULL, fg->graph);  \

    if (ret < 0)                                                            \

        return ret;                                                         \

                                                                            \

    ret = avfilter_link(last_filter, pad_idx, filt_ctx, 0);                 \

    if (ret < 0)                                                            \

        return ret;                                                         \

                                                                            \

    last_filter = filt_ctx;                                                 \

    pad_idx = 0;                                                            \

} while (0)

    if (ost->audio_channels_mapped) {

        int i;

        AVBPrint pan_buf;

        av_bprint_init(&pan_buf, 256, 8192);

        av_bprintf(&pan_buf, "0x%"PRIx64,

                   av_get_default_channel_layout(ost->audio_channels_mapped));

        for (i = 0; i < ost->audio_channels_mapped; i++)

            if (ost->audio_channels_map[i] != -1)

                av_bprintf(&pan_buf, ":c%d=c%d", i, ost->audio_channels_map[i]);



        AUTO_INSERT_FILTER("-map_channel", "pan", pan_buf.str);

        av_bprint_finalize(&pan_buf, NULL);

    }



    if (codec->channels && !codec->channel_layout)

        codec->channel_layout = av_get_default_channel_layout(codec->channels);



    sample_fmts     = choose_sample_fmts(ost);

    sample_rates    = choose_sample_rates(ost);

    channel_layouts = choose_channel_layouts(ost);

    if (sample_fmts || sample_rates || channel_layouts) {

        AVFilterContext *format;

        char args[256];

        int len = 0;



        if (sample_fmts)

            len += snprintf(args + len, sizeof(args) - len, "sample_fmts=%s:",

                            sample_fmts);

        if (sample_rates)

            len += snprintf(args + len, sizeof(args) - len, "sample_rates=%s:",

                            sample_rates);

        if (channel_layouts)

            len += snprintf(args + len, sizeof(args) - len, "channel_layouts=%s:",

                            channel_layouts);

        args[len - 1] = 0;



        av_freep(&sample_fmts);

        av_freep(&sample_rates);

        av_freep(&channel_layouts);



        snprintf(name, sizeof(name), "audio format for output stream %d:%d",

                 ost->file_index, ost->index);

        ret = avfilter_graph_create_filter(&format,

                                           avfilter_get_by_name("aformat"),

                                           name, args, NULL, fg->graph);

        if (ret < 0)

            return ret;



        ret = avfilter_link(last_filter, pad_idx, format, 0);

        if (ret < 0)

            return ret;



        last_filter = format;

        pad_idx = 0;

    }



    if (audio_volume != 256 && 0) {

        char args[256];



        snprintf(args, sizeof(args), "%f", audio_volume / 256.);

        AUTO_INSERT_FILTER("-vol", "volume", args);

    }



    if ((ret = avfilter_link(last_filter, pad_idx, ofilter->filter, 0)) < 0)

        return ret;



    return 0;

}
 and probability:0.25555555555555554
code:void restore_boot_order(void *opaque)

{

    char *normal_boot_order = opaque;

    static int first = 1;



    /* Restore boot order and remove ourselves after the first boot */

    if (first) {

        first = 0;

        return;

    }



    qemu_boot_set(normal_boot_order);



    qemu_unregister_reset(restore_boot_order, normal_boot_order);

    g_free(normal_boot_order);

}
 and probability:0.0
code:static int virtser_port_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    VirtIOSerialPort *port = DO_UPCAST(VirtIOSerialPort, dev, qdev);

    VirtIOSerialPortInfo *info = DO_UPCAST(VirtIOSerialPortInfo, qdev, base);

    VirtIOSerialBus *bus = DO_UPCAST(VirtIOSerialBus, qbus, qdev->parent_bus);

    int ret, max_nr_ports;

    bool plugging_port0;



    port->vser = bus->vser;

    port->bh = qemu_bh_new(flush_queued_data_bh, port);



    /*

     * Is the first console port we're seeing? If so, put it up at

     * location 0. This is done for backward compatibility (old

     * kernel, new qemu).

     */

    plugging_port0 = port->is_console && !find_port_by_id(port->vser, 0);



    if (find_port_by_id(port->vser, port->id)) {

        error_report("virtio-serial-bus: A port already exists at id %u\n",

                     port->id);

        return -1;

    }



    if (port->id == VIRTIO_CONSOLE_BAD_ID) {

        if (plugging_port0) {

            port->id = 0;

        } else {

            port->id = find_free_port_id(port->vser);

            if (port->id == VIRTIO_CONSOLE_BAD_ID) {

                error_report("virtio-serial-bus: Maximum port limit for this device reached\n");

                return -1;

            }

        }

    }



    max_nr_ports = tswap32(port->vser->config.max_nr_ports);

    if (port->id >= max_nr_ports) {

        error_report("virtio-serial-bus: Out-of-range port id specified, max. allowed: %u\n",

                     max_nr_ports - 1);

        return -1;

    }



    port->info = info;

    ret = info->init(port);

    if (ret) {

        return ret;

    }



    if (!use_multiport(port->vser)) {

        /*

         * Allow writes to guest in this case; we have no way of

         * knowing if a guest port is connected.

         */

        port->guest_connected = true;

    }



    port->elem.out_num = 0;



    QTAILQ_INSERT_TAIL(&port->vser->ports, port, next);

    port->ivq = port->vser->ivqs[port->id];

    port->ovq = port->vser->ovqs[port->id];



    add_port(port->vser, port->id);



    /* Send an update to the guest about this new port added */

    virtio_notify_config(&port->vser->vdev);



    return ret;

}
 and probability:0.39655172413793105
code:void block_job_pause(BlockJob *job)

{

    job->paused = true;

}
 and probability:0.25
code:static void prop_get_fdt(Object *obj, Visitor *v, const char *name,

                         void *opaque, Error **errp)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(obj);

    Error *err = NULL;

    int fdt_offset_next, fdt_offset, fdt_depth;

    void *fdt;



    if (!drc->fdt) {

        visit_type_null(v, NULL, errp);

        return;

    }



    fdt = drc->fdt;

    fdt_offset = drc->fdt_start_offset;

    fdt_depth = 0;



    do {

        const char *name = NULL;

        const struct fdt_property *prop = NULL;

        int prop_len = 0, name_len = 0;

        uint32_t tag;



        tag = fdt_next_tag(fdt, fdt_offset, &fdt_offset_next);

        switch (tag) {

        case FDT_BEGIN_NODE:

            fdt_depth++;

            name = fdt_get_name(fdt, fdt_offset, &name_len);

            visit_start_struct(v, name, NULL, 0, &err);

            if (err) {

                error_propagate(errp, err);

                return;

            }

            break;

        case FDT_END_NODE:

            /* shouldn't ever see an FDT_END_NODE before FDT_BEGIN_NODE */

            g_assert(fdt_depth > 0);

            visit_check_struct(v, &err);

            visit_end_struct(v);

            if (err) {

                error_propagate(errp, err);

                return;

            }

            fdt_depth--;

            break;

        case FDT_PROP: {

            int i;

            prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);

            name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));

            visit_start_list(v, name, &err);

            if (err) {

                error_propagate(errp, err);

                return;

            }

            for (i = 0; i < prop_len; i++) {

                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);

                if (err) {

                    error_propagate(errp, err);

                    return;

                }

            }

            visit_end_list(v);

            break;

        }

        default:

            error_setg(&error_abort, "device FDT in unexpected state: %d", tag);

        }

        fdt_offset = fdt_offset_next;

    } while (fdt_depth != 0);

}
 and probability:0.12121212121212122
code:int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf, int bytes)

{

    QEMUIOVector qiov;

    struct iovec iov = {

        .iov_base   = (void *) buf,

        .iov_len    = bytes,

    };



    if (bytes < 0) {

        return -EINVAL;

    }



    qemu_iovec_init_external(&qiov, &iov, 1);

    return bdrv_pwritev(bs, offset, &qiov);

}
 and probability:0.0
code:static int ppc_fixup_cpu(PowerPCCPU *cpu)

{

    CPUPPCState *env = &cpu->env;



    /* TCG doesn't (yet) emulate some groups of instructions that

     * are implemented on some otherwise supported CPUs (e.g. VSX

     * and decimal floating point instructions on POWER7).  We

     * remove unsupported instruction groups from the cpu state's

     * instruction masks and hope the guest can cope.  For at

     * least the pseries machine, the unavailability of these

     * instructions can be advertised to the guest via the device

     * tree. */

    if ((env->insns_flags & ~PPC_TCG_INSNS)

        || (env->insns_flags2 & ~PPC_TCG_INSNS2)) {

        fprintf(stderr, "Warning: Disabling some instructions which are not "

                "emulated by TCG (0x%" PRIx64 ", 0x%" PRIx64 ")\n",

                env->insns_flags & ~PPC_TCG_INSNS,

                env->insns_flags2 & ~PPC_TCG_INSNS2);

    }

    env->insns_flags &= PPC_TCG_INSNS;

    env->insns_flags2 &= PPC_TCG_INSNS2;

    return 0;

}
 and probability:0.3181818181818182
code:void main_loop_wait(int timeout)

{

    IOHandlerRecord *ioh;

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;



    qemu_bh_update_timeout(&timeout);



    host_main_loop_wait(&timeout);



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {

        if (ioh->deleted)

            continue;

        if (ioh->fd_read &&

            (!ioh->fd_read_poll ||

             ioh->fd_read_poll(ioh->opaque) != 0)) {

            FD_SET(ioh->fd, &rfds);

            if (ioh->fd > nfds)

                nfds = ioh->fd;

        }

        if (ioh->fd_write) {

            FD_SET(ioh->fd, &wfds);

            if (ioh->fd > nfds)

                nfds = ioh->fd;

        }

    }



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();

    if (ret > 0) {

        IOHandlerRecord **pioh;



        for(ioh = first_io_handler; ioh != NULL; ioh = ioh->next) {

            if (!ioh->deleted && ioh->fd_read && FD_ISSET(ioh->fd, &rfds)) {

                ioh->fd_read(ioh->opaque);

            }

            if (!ioh->deleted && ioh->fd_write && FD_ISSET(ioh->fd, &wfds)) {

                ioh->fd_write(ioh->opaque);

            }

        }



	/* remove deleted IO handlers */

	pioh = &first_io_handler;

	while (*pioh) {

            ioh = *pioh;

            if (ioh->deleted) {

                *pioh = ioh->next;

                qemu_free(ioh);

            } else

                pioh = &ioh->next;

        }

    }



    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    /* rearm timer, if not periodic */

    if (alarm_timer->flags & ALARM_FLAG_EXPIRED) {

        alarm_timer->flags &= ~ALARM_FLAG_EXPIRED;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    if (vm_running) {

        if (!cur_cpu || likely(!(cur_cpu->singlestep_enabled & SSTEP_NOTIMER)))

            qemu_run_timers(&active_timers[QEMU_TIMER_VIRTUAL],

                qemu_get_clock(vm_clock));

    }



    /* real time timers */

    qemu_run_timers(&active_timers[QEMU_TIMER_REALTIME],

                    qemu_get_clock(rt_clock));



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
 and probability:0.39473684210526316
code:av_cold int ff_rate_control_init(MpegEncContext *s)

{

    RateControlContext *rcc = &s->rc_context;

    int i, res;

    static const char * const const_names[] = {

        "PI",

        "E",

        "iTex",

        "pTex",

        "tex",

        "mv",

        "fCode",

        "iCount",

        "mcVar",

        "var",

        "isI",

        "isP",

        "isB",

        "avgQP",

        "qComp",

#if 0

        "lastIQP",

        "lastPQP",

        "lastBQP",

        "nextNonBQP",

#endif

        "avgIITex",

        "avgPITex",

        "avgPPTex",

        "avgBPTex",

        "avgTex",

        NULL

    };

    static double (* const func1[])(void *, double) = {

        (void *)bits2qp,

        (void *)qp2bits,

        NULL

    };

    static const char * const func1_names[] = {

        "bits2qp",

        "qp2bits",

        NULL

    };

    emms_c();



    res = av_expr_parse(&rcc->rc_eq_eval,

                        s->rc_eq ? s->rc_eq : "tex^qComp",

                        const_names, func1_names, func1,

                        NULL, NULL, 0, s->avctx);

    if (res < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "Error parsing rc_eq \"%s\"\n", s->rc_eq);

        return res;

    }



    for (i = 0; i < 5; i++) {

        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;

        rcc->pred[i].count = 1.0;

        rcc->pred[i].decay = 0.4;



        rcc->i_cplx_sum [i] =

        rcc->p_cplx_sum [i] =

        rcc->mv_bits_sum[i] =

        rcc->qscale_sum [i] =

        rcc->frame_count[i] = 1; // 1 is better because of 1/0 and such



        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;

    }

    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;



    if (s->avctx->flags & CODEC_FLAG_PASS2) {

        int i;

        char *p;



        /* find number of pics */

        p = s->avctx->stats_in;

        for (i = -1; p; i++)

            p = strchr(p + 1, ';');

        i += s->max_b_frames;

        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))

            return -1;

        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));

        rcc->num_entries = i;



        /* init all to skipped p frames

         * (with b frames we might have a not encoded frame at the end FIXME) */

        for (i = 0; i < rcc->num_entries; i++) {

            RateControlEntry *rce = &rcc->entry[i];



            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;

            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;

            rce->misc_bits  = s->mb_num + 10;

            rce->mb_var_sum = s->mb_num * 100;

        }



        /* read stats */

        p = s->avctx->stats_in;

        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {

            RateControlEntry *rce;

            int picture_number;

            int e;

            char *next;



            next = strchr(p, ';');

            if (next) {

                (*next) = 0; // sscanf in unbelievably slow on looong strings // FIXME copy / do not write

                next++;

            }

            e = sscanf(p, " in:%d ", &picture_number);



            assert(picture_number >= 0);

            assert(picture_number < rcc->num_entries);

            rce = &rcc->entry[picture_number];



            e += sscanf(p, " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d",

                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,

                        &rce->mv_bits, &rce->misc_bits,

                        &rce->f_code, &rce->b_code,

                        &rce->mc_mb_var_sum, &rce->mb_var_sum,

                        &rce->i_count, &rce->skip_count, &rce->header_bits);

            if (e != 14) {

                av_log(s->avctx, AV_LOG_ERROR,

                       "statistics are damaged at line %d, parser out=%d\n",

                       i, e);

                return -1;

            }



            p = next;

        }



        if (init_pass2(s) < 0)

            return -1;



        // FIXME maybe move to end

        if ((s->avctx->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {

#if CONFIG_LIBXVID

            return ff_xvid_rate_control_init(s);

#else

            av_log(s->avctx, AV_LOG_ERROR,

                   "Xvid ratecontrol requires libavcodec compiled with Xvid support.\n");

            return -1;

#endif

        }

    }



    if (!(s->avctx->flags & CODEC_FLAG_PASS2)) {

        rcc->short_term_qsum   = 0.001;

        rcc->short_term_qcount = 0.001;



        rcc->pass1_rc_eq_output_sum = 0.001;

        rcc->pass1_wanted_bits      = 0.001;



        if (s->avctx->qblur > 1.0) {

            av_log(s->avctx, AV_LOG_ERROR, "qblur too large\n");

            return -1;

        }

        /* init stuff with the user specified complexity */

        if (s->rc_initial_cplx) {

            for (i = 0; i < 60 * 30; i++) {

                double bits = s->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;

                RateControlEntry rce;



                if (i % ((s->gop_size + 3) / 4) == 0)

                    rce.pict_type = AV_PICTURE_TYPE_I;

                else if (i % (s->max_b_frames + 1))

                    rce.pict_type = AV_PICTURE_TYPE_B;

                else

                    rce.pict_type = AV_PICTURE_TYPE_P;



                rce.new_pict_type = rce.pict_type;

                rce.mc_mb_var_sum = bits * s->mb_num / 100000;

                rce.mb_var_sum    = s->mb_num;



                rce.qscale    = FF_QP2LAMBDA * 2;

                rce.f_code    = 2;

                rce.b_code    = 1;

                rce.misc_bits = 1;



                if (s->pict_type == AV_PICTURE_TYPE_I) {

                    rce.i_count    = s->mb_num;

                    rce.i_tex_bits = bits;

                    rce.p_tex_bits = 0;

                    rce.mv_bits    = 0;

                } else {

                    rce.i_count    = 0; // FIXME we do know this approx

                    rce.i_tex_bits = 0;

                    rce.p_tex_bits = bits * 0.9;

                    rce.mv_bits    = bits * 0.1;

                }

                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;

                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;

                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;

                rcc->frame_count[rce.pict_type]++;



                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);



                // FIXME misbehaves a little for variable fps

                rcc->pass1_wanted_bits += s->bit_rate / (1 / av_q2d(s->avctx->time_base));

            }

        }

    }



    return 0;

}
 and probability:0.39325842696629215
code:av_cold void ff_sws_init_swscale_x86(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_MMX_INLINE

    if (INLINE_MMX(cpu_flags))

        sws_init_swscale_mmx(c);

#endif

#if HAVE_MMXEXT_INLINE

    if (INLINE_MMXEXT(cpu_flags))

        sws_init_swscale_mmxext(c);

#endif



#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case AV_PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (EXTERNAL_MMX(cpu_flags)) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmxext, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case AV_PIX_FMT_YA8:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case AV_PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case AV_PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case AV_PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case AV_PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (EXTERNAL_MMXEXT(cpu_flags)) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmxext, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (EXTERNAL_SSE2(cpu_flags)) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case AV_PIX_FMT_YA8:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case AV_PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case AV_PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case AV_PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case AV_PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (EXTERNAL_SSSE3(cpu_flags)) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (EXTERNAL_SSE4(cpu_flags)) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (EXTERNAL_AVX(cpu_flags)) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case AV_PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case AV_PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case AV_PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case AV_PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

}
 and probability:0.32786885245901637
code:static void libopus_write_header(AVCodecContext *avctx, int stream_count,

                                 int coupled_stream_count,

                                 const uint8_t *channel_mapping)

{

    uint8_t *p   = avctx->extradata;

    int channels = avctx->channels;



    bytestream_put_buffer(&p, "OpusHead", 8);

    bytestream_put_byte(&p, 1); /* Version */

    bytestream_put_byte(&p, channels);

    bytestream_put_le16(&p, avctx->delay); /* Lookahead samples at 48kHz */

    bytestream_put_le32(&p, avctx->sample_rate); /* Original sample rate */

    bytestream_put_le16(&p, 0); /* Gain of 0dB is recommended. */



    /* Channel mapping */

    if (channels > 2) {

        bytestream_put_byte(&p, channels <= 8 ? 1 : 255);

        bytestream_put_byte(&p, stream_count);

        bytestream_put_byte(&p, coupled_stream_count);

        bytestream_put_buffer(&p, channel_mapping, channels);

    } else {

        bytestream_put_byte(&p, 0);

    }

}
 and probability:0.18181818181818182
code:static int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

#if 1

    int frame_duration = av_rescale(track->timescale, track->enc->time_base.num, track->enc->time_base.den);

    int nb_frames = ROUNDED_DIV(track->enc->time_base.den, track->enc->time_base.num);

    AVDictionaryEntry *t = NULL;



    if (nb_frames > 255) {

        av_log(NULL, AV_LOG_ERROR, "fps %d is too large\n", nb_frames);

        return AVERROR(EINVAL);

    }



    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, "tmcd");               /* Data format */

    avio_wb32(pb, 0);                       /* Reserved */

    avio_wb32(pb, 1);                       /* Data reference index */

    avio_wb32(pb, 0);                       /* Flags */

    avio_wb32(pb, track->timecode_flags);   /* Flags (timecode) */

    avio_wb32(pb, track->timescale);        /* Timescale */

    avio_wb32(pb, frame_duration);          /* Frame duration */

    avio_w8(pb, nb_frames);                 /* Number of frames */

    avio_w8(pb, 0);                         /* Reserved */



    if (track->st)

        t = av_dict_get(track->st->metadata, "reel_name", NULL, 0);



    if (t && utf8len(t->value))

        mov_write_source_reference_tag(pb, track, t->value);

    else

        avio_wb16(pb, 0); /* zero size */

#else



    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, "tmcd");               /* Data format */

    avio_wb32(pb, 0);                       /* Reserved */

    avio_wb32(pb, 1);                       /* Data reference index */

    if (track->enc->extradata_size)

        avio_write(pb, track->enc->extradata, track->enc->extradata_size);

#endif

    return update_size(pb, pos);

}
 and probability:0.2702702702702703
code:static void dv_decode_ac(DVVideoDecodeContext *s, 

                         BlockInfo *mb, DCTELEM *block, int last_index)

{

    int last_re_index;

    int shift_offset = mb->shift_offset;

    const UINT8 *scan_table = mb->scan_table;

    const UINT8 *shift_table = mb->shift_table;

    int pos = mb->pos;

    int level, pos1, sign, run;

    int partial_bit_count;



    OPEN_READER(re, &s->gb);

    

#ifdef VLC_DEBUG

    printf("start\n");

#endif



    /* if we must parse a partial vlc, we do it here */

    partial_bit_count = mb->partial_bit_count;

    if (partial_bit_count > 0) {

        UINT8 buf[4];

        UINT32 v;

        int l, l1;

        GetBitContext gb1;



        /* build the dummy bit buffer */

        l = 16 - partial_bit_count;

        UPDATE_CACHE(re, &s->gb);

#ifdef VLC_DEBUG

        printf("show=%04x\n", SHOW_UBITS(re, &s->gb, 16));

#endif

        v = (mb->partial_bit_buffer << l) | SHOW_UBITS(re, &s->gb, l);

        buf[0] = v >> 8;

        buf[1] = v;

#ifdef VLC_DEBUG

        printf("v=%04x cnt=%d %04x\n", 

               v, partial_bit_count, (mb->partial_bit_buffer << l));

#endif

        /* try to read the codeword */

        init_get_bits(&gb1, buf, 4);

        {

            OPEN_READER(re1, &gb1);

            UPDATE_CACHE(re1, &gb1);

            GET_RL_VLC(level, run, re1, &gb1, dv_rl_vlc[0], 

                       TEX_VLC_BITS, 2);

            l = re1_index;

            CLOSE_READER(re1, &gb1);

        }

#ifdef VLC_DEBUG

        printf("****run=%d level=%d size=%d\n", run, level, l);

#endif

        /* compute codeword length */

        l1 = (level != 256 && level != 0);

        /* if too long, we cannot parse */

        l -= partial_bit_count;

        if ((re_index + l + l1) > last_index)

            return;

        /* skip read bits */

        last_re_index = 0; /* avoid warning */

        re_index += l;

        /* by definition, if we can read the vlc, all partial bits

           will be read (otherwise we could have read the vlc before) */

        mb->partial_bit_count = 0;

        UPDATE_CACHE(re, &s->gb);

        goto handle_vlc;

    }



    /* get the AC coefficients until last_index is reached */

    for(;;) {

        UPDATE_CACHE(re, &s->gb);

#ifdef VLC_DEBUG

        printf("%2d: bits=%04x index=%d\n", 

               pos, SHOW_UBITS(re, &s->gb, 16), re_index);

#endif

        last_re_index = re_index;

        GET_RL_VLC(level, run, re, &s->gb, dv_rl_vlc[0], 

                   TEX_VLC_BITS, 2);

    handle_vlc:

#ifdef VLC_DEBUG

        printf("run=%d level=%d\n", run, level);

#endif

        if (level == 256) {

            if (re_index > last_index) {

            cannot_read:

                /* put position before read code */

                re_index = last_re_index;

                mb->eob_reached = 0;

                break;

            }

            /* EOB */

            mb->eob_reached = 1;

            break;

        } else if (level != 0) {

            if ((re_index + 1) > last_index)

                goto cannot_read;

            sign = SHOW_SBITS(re, &s->gb, 1);

            level = (level ^ sign) - sign;

            LAST_SKIP_BITS(re, &s->gb, 1);

            pos += run;

            /* error */

            if (pos >= 64) {

                goto read_error;

            }

            pos1 = scan_table[pos];

            level = level << (shift_table[pos1] + shift_offset);

            block[pos1] = level;

            //            printf("run=%d level=%d shift=%d\n", run, level, shift_table[pos1]);

        } else {

            if (re_index > last_index)

                goto cannot_read;

            /* level is zero: means run without coding. No

               sign is coded */

            pos += run;

            /* error */

            if (pos >= 64) {

            read_error:

#if defined(VLC_DEBUG) || 1

                printf("error pos=%d\n", pos);

#endif

                /* for errors, we consider the eob is reached */

                mb->eob_reached = 1;

                break;

            }

        }

    }

    CLOSE_READER(re, &s->gb);

    mb->pos = pos;

}
 and probability:0.2926829268292683
code:static int expand_rle_row16(SgiState *s, uint16_t *out_buf,

                            int len, int pixelstride)

{

    unsigned short pixel;

    unsigned char count;

    unsigned short *orig = out_buf;

    uint16_t *out_end = out_buf + len;



    while (out_buf < out_end) {

        if (bytestream2_get_bytes_left(&s->g) < 2)

            return AVERROR_INVALIDDATA;

        pixel = bytestream2_get_be16u(&s->g);

        if (!(count = (pixel & 0x7f)))

            break;



        /* Check for buffer overflow. */

        if (pixelstride * (count - 1) >= len) {

            av_log(s->avctx, AV_LOG_ERROR, "Invalid pixel count.\n");

            return AVERROR_INVALIDDATA;

        }



        if (pixel & 0x80) {

            while (count--) {

                pixel = bytestream2_get_ne16(&s->g);

                AV_WN16A(out_buf, pixel);

                out_buf += pixelstride;

            }

        } else {

            pixel = bytestream2_get_ne16(&s->g);



            while (count--) {

                AV_WN16A(out_buf, pixel);

                out_buf += pixelstride;

            }

        }

    }

    return (out_buf - orig) / pixelstride;

}
 and probability:0.35294117647058826
code:void tlb_fill(CPUState *env1, target_ulong addr, int is_write, int mmu_idx,

              void *retaddr)

{

    TranslationBlock *tb;

    CPUState *saved_env;

    unsigned long pc;

    int ret;



    saved_env = env;


    ret = cpu_arm_handle_mmu_fault(env, addr, is_write, mmu_idx);

    if (unlikely(ret)) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc);

            }

        }

        raise_exception(env->exception_index);

    }

    env = saved_env;

} and probability:0.041666666666666664
code:static int webvtt_read_header(AVFormatContext *s)

{

    WebVTTContext *webvtt = s->priv_data;

    AVBPrint header, cue;

    int res = 0;

    AVStream *st = avformat_new_stream(s, NULL);



    if (!st)

        return AVERROR(ENOMEM);

    avpriv_set_pts_info(st, 64, 1, 1000);

    st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;

    st->codec->codec_id   = AV_CODEC_ID_WEBVTT;

    st->disposition |= webvtt->kind;



    av_bprint_init(&header, 0, AV_BPRINT_SIZE_UNLIMITED);

    av_bprint_init(&cue,    0, AV_BPRINT_SIZE_UNLIMITED);



    for (;;) {

        int i;

        int64_t pos;

        AVPacket *sub;

        const char *p, *identifier, *settings;

        int identifier_len, settings_len;

        int64_t ts_start, ts_end;



        ff_subtitles_read_chunk(s->pb, &cue);



        if (!cue.len)

            break;



        p = identifier = cue.str;

        pos = avio_tell(s->pb);



        /* ignore header chunk */

        if (!strncmp(p, "\xEF\xBB\xBFWEBVTT", 9) ||

            !strncmp(p, "WEBVTT", 6))

            continue;



        /* optional cue identifier (can be a number like in SRT or some kind of

         * chaptering id) */

        for (i = 0; p[i] && p[i] != '\n' && p[i] != '\r'; i++) {

            if (!strncmp(p + i, "-->", 3)) {

                identifier = NULL;

                break;

            }

        }

        if (!identifier)

            identifier_len = 0;

        else {

            identifier_len = strcspn(p, "\r\n");

            p += identifier_len;

            if (*p == '\r')

                p++;

            if (*p == '\n')

                p++;

        }



        /* cue timestamps */

        if ((ts_start = read_ts(p)) == AV_NOPTS_VALUE)

            break;

        if (!(p = strstr(p, "-->")))

            break;

        p += 3;

        do p++; while (*p == ' ' || *p == '\t');

        if ((ts_end = read_ts(p)) == AV_NOPTS_VALUE)

            break;



        /* optional cue settings */

        p += strcspn(p, "\n\t ");

        while (*p == '\t' || *p == ' ')

            p++;

        settings = p;

        settings_len = strcspn(p, "\r\n");

        p += settings_len;

        if (*p == '\r')

            p++;

        if (*p == '\n')

            p++;



        /* create packet */

        sub = ff_subtitles_queue_insert(&webvtt->q, p, strlen(p), 0);

        if (!sub) {

            res = AVERROR(ENOMEM);

            goto end;

        }

        sub->pos = pos;

        sub->pts = ts_start;

        sub->duration = ts_end - ts_start;



#define SET_SIDE_DATA(name, type) do {                                  \

    if (name##_len) {                                                   \

        uint8_t *buf = av_packet_new_side_data(sub, type, name##_len);  \

        if (!buf) {                                                     \

            res = AVERROR(ENOMEM);                                      \

            goto end;                                                   \

        }                                                               \

        memcpy(buf, name, name##_len);                                  \

    }                                                                   \

} while (0)



        SET_SIDE_DATA(identifier, AV_PKT_DATA_WEBVTT_IDENTIFIER);

        SET_SIDE_DATA(settings,   AV_PKT_DATA_WEBVTT_SETTINGS);

    }



    ff_subtitles_queue_finalize(&webvtt->q);



end:

    av_bprint_finalize(&cue,    NULL);

    av_bprint_finalize(&header, NULL);

    return res;

}
 and probability:0.2916666666666667
code:int ff_h264_decode_picture_parameter_set(H264Context *h, int bit_length){

    MpegEncContext * const s = &h->s;

    unsigned int pps_id= get_ue_golomb(&s->gb);

    PPS *pps;

    const int qp_bd_offset = 6*(h->sps.bit_depth_luma-8);

    int bits_left;



    if(pps_id >= MAX_PPS_COUNT) {

        av_log(h->s.avctx, AV_LOG_ERROR, "pps_id (%d) out of range\n", pps_id);

        return -1;

    }



    pps= av_mallocz(sizeof(PPS));

    if(pps == NULL)

        return -1;

    pps->sps_id= get_ue_golomb_31(&s->gb);

    if((unsigned)pps->sps_id>=MAX_SPS_COUNT || h->sps_buffers[pps->sps_id] == NULL){

        av_log(h->s.avctx, AV_LOG_ERROR, "sps_id out of range\n");

        goto fail;

    }



    pps->cabac= get_bits1(&s->gb);

    pps->pic_order_present= get_bits1(&s->gb);

    pps->slice_group_count= get_ue_golomb(&s->gb) + 1;

    if(pps->slice_group_count > 1 ){

        pps->mb_slice_group_map_type= get_ue_golomb(&s->gb);

        av_log(h->s.avctx, AV_LOG_ERROR, "FMO not supported\n");

        switch(pps->mb_slice_group_map_type){

        case 0:

#if 0

|   for( i = 0; i <= num_slice_groups_minus1; i++ ) |   |        |

|    run_length[ i ]                                |1  |ue(v)   |

#endif

            break;

        case 2:

#if 0

|   for( i = 0; i < num_slice_groups_minus1; i++ )  |   |        |

|{                                                  |   |        |

|    top_left_mb[ i ]                               |1  |ue(v)   |

|    bottom_right_mb[ i ]                           |1  |ue(v)   |

|   }                                               |   |        |

#endif

            break;

        case 3:

        case 4:

        case 5:

#if 0

|   slice_group_change_direction_flag               |1  |u(1)    |

|   slice_group_change_rate_minus1                  |1  |ue(v)   |

#endif

            break;

        case 6:

#if 0

|   slice_group_id_cnt_minus1                       |1  |ue(v)   |

|   for( i = 0; i <= slice_group_id_cnt_minus1; i++ |   |        |

|)                                                  |   |        |

|    slice_group_id[ i ]                            |1  |u(v)    |

#endif

            break;

        }

    }

    pps->ref_count[0]= get_ue_golomb(&s->gb) + 1;

    pps->ref_count[1]= get_ue_golomb(&s->gb) + 1;

    if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){

        av_log(h->s.avctx, AV_LOG_ERROR, "reference overflow (pps)\n");

        goto fail;

    }



    pps->weighted_pred= get_bits1(&s->gb);

    pps->weighted_bipred_idc= get_bits(&s->gb, 2);

    pps->init_qp= get_se_golomb(&s->gb) + 26 + qp_bd_offset;

    pps->init_qs= get_se_golomb(&s->gb) + 26 + qp_bd_offset;

    pps->chroma_qp_index_offset[0]= get_se_golomb(&s->gb);

    pps->deblocking_filter_parameters_present= get_bits1(&s->gb);

    pps->constrained_intra_pred= get_bits1(&s->gb);

    pps->redundant_pic_cnt_present = get_bits1(&s->gb);



    pps->transform_8x8_mode= 0;

    h->dequant_coeff_pps= -1; //contents of sps/pps can change even if id doesn't, so reinit

    memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));

    memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));



    bits_left = bit_length - get_bits_count(&s->gb);

    if(bits_left > 0){

        pps->transform_8x8_mode= get_bits1(&s->gb);

        decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);

        pps->chroma_qp_index_offset[1]= get_se_golomb(&s->gb); //second_chroma_qp_index_offset

    } else {

        pps->chroma_qp_index_offset[1]= pps->chroma_qp_index_offset[0];

    }



    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], h->sps.bit_depth_luma);

    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], h->sps.bit_depth_luma);

    if(pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])

        pps->chroma_qp_diff= 1;



    if(s->avctx->debug&FF_DEBUG_PICT_INFO){

        av_log(h->s.avctx, AV_LOG_DEBUG, "pps:%u sps:%u %s slice_groups:%d ref:%d/%d %s qp:%d/%d/%d/%d %s %s %s %s\n",

               pps_id, pps->sps_id,

               pps->cabac ? "CABAC" : "CAVLC",

               pps->slice_group_count,

               pps->ref_count[0], pps->ref_count[1],

               pps->weighted_pred ? "weighted" : "",

               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],

               pps->deblocking_filter_parameters_present ? "LPAR" : "",

               pps->constrained_intra_pred ? "CONSTR" : "",

               pps->redundant_pic_cnt_present ? "REDU" : "",

               pps->transform_8x8_mode ? "8x8DCT" : ""

               );

    }



    av_free(h->pps_buffers[pps_id]);

    h->pps_buffers[pps_id]= pps;

    return 0;

fail:

    av_free(pps);

    return -1;

}
 and probability:0.5504587155963303
code:static int load_input_picture(MpegEncContext *s, AVFrame *pic_arg){

    AVFrame *pic=NULL;

    int i;

    const int encoding_delay= s->max_b_frames;

    int direct=1;

    

  if(pic_arg){

    if(encoding_delay && !(s->flags&CODEC_FLAG_INPUT_PRESERVED)) direct=0;

    if(pic_arg->linesize[0] != s->linesize) direct=0;

    if(pic_arg->linesize[1] != s->uvlinesize) direct=0;

    if(pic_arg->linesize[2] != s->uvlinesize) direct=0;

  

//    printf("%d %d %d %d\n",pic_arg->linesize[0], pic_arg->linesize[1], s->linesize, s->uvlinesize);

    

    if(direct){

        i= find_unused_picture(s, 1);



        pic= (AVFrame*)&s->picture[i];

        pic->reference= 3;

    

        for(i=0; i<4; i++){

            pic->data[i]= pic_arg->data[i];

            pic->linesize[i]= pic_arg->linesize[i];

        }

        alloc_picture(s, (Picture*)pic, 1);

    }else{

        i= find_unused_picture(s, 0);



        pic= (AVFrame*)&s->picture[i];

        pic->reference= 3;



        alloc_picture(s, (Picture*)pic, 0);

        for(i=0; i<4; i++){

            /* the input will be 16 pixels to the right relative to the actual buffer start

             * and the current_pic, so the buffer can be reused, yes its not beatifull 

             */

            pic->data[i]+= 16; 

        }



        if(   pic->data[0] == pic_arg->data[0] 

           && pic->data[1] == pic_arg->data[1]

           && pic->data[2] == pic_arg->data[2]){

       // empty

        }else{

            int h_chroma_shift, v_chroma_shift;

            avcodec_get_chroma_sub_sample(s->avctx->pix_fmt, &h_chroma_shift, &v_chroma_shift);

        

            for(i=0; i<3; i++){

                int src_stride= pic_arg->linesize[i];

                int dst_stride= i ? s->uvlinesize : s->linesize;

                int h_shift= i ? h_chroma_shift : 0;

                int v_shift= i ? v_chroma_shift : 0;

                int w= s->width >>h_shift;

                int h= s->height>>v_shift;

                uint8_t *src= pic_arg->data[i];

                uint8_t *dst= pic->data[i];

            

                if(src_stride==dst_stride)

                    memcpy(dst, src, src_stride*h);

                else{

                    while(h--){

                        memcpy(dst, src, w);

                        dst += dst_stride;

                        src += src_stride;

                    }

                }

            }

        }

    }

    pic->quality= pic_arg->quality;

    pic->pict_type= pic_arg->pict_type;

    pic->pts = pic_arg->pts;

    

    if(s->input_picture[encoding_delay])

        pic->display_picture_number= s->input_picture[encoding_delay]->display_picture_number + 1;

    

  }



    /* shift buffer entries */

    for(i=1; i<MAX_PICTURE_COUNT /*s->encoding_delay+1*/; i++)

        s->input_picture[i-1]= s->input_picture[i];

        

    s->input_picture[encoding_delay]= (Picture*)pic;



    return 0;

}
 and probability:0.5211267605633803
code:int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)

{

    BufferSinkContext *s    = ctx->priv;

    AVFilterLink      *link = ctx->inputs[0];

    int ret;



    if ((ret = ff_request_frame(link)) < 0)

        return ret;



    if (!s->cur_frame)

        return AVERROR(EINVAL);



    av_frame_move_ref(frame, s->cur_frame);

    av_frame_free(&s->cur_frame);



    return 0;

}
 and probability:0.38461538461538464
code:static void nvic_writel(NVICState *s, uint32_t offset, uint32_t value,

                        MemTxAttrs attrs)

{

    ARMCPU *cpu = s->cpu;



    switch (offset) {

    case 0x380 ... 0x3bf: /* NVIC_ITNS<n> */

    {

        int startvec = 32 * (offset - 0x380) + NVIC_FIRST_IRQ;

        int i;



        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            break;

        }

        for (i = 0; i < 32 && startvec + i < s->num_irq; i++) {

            s->itns[startvec + i] = (value >> i) & 1;

        }

        nvic_irq_update(s);

        break;

    }

    case 0xd04: /* Interrupt Control State (ICSR) */

        if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {

            if (value & (1 << 31)) {

                armv7m_nvic_set_pending(s, ARMV7M_EXCP_NMI, false);

            } else if (value & (1 << 30) &&

                       arm_feature(&cpu->env, ARM_FEATURE_V8)) {

                /* PENDNMICLR didn't exist in v7M */

                armv7m_nvic_clear_pending(s, ARMV7M_EXCP_NMI, false);

            }

        }

        if (value & (1 << 28)) {

            armv7m_nvic_set_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);

        } else if (value & (1 << 27)) {

            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_PENDSV, attrs.secure);

        }

        if (value & (1 << 26)) {

            armv7m_nvic_set_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);

        } else if (value & (1 << 25)) {

            armv7m_nvic_clear_pending(s, ARMV7M_EXCP_SYSTICK, attrs.secure);

        }

        break;

    case 0xd08: /* Vector Table Offset.  */

        cpu->env.v7m.vecbase[attrs.secure] = value & 0xffffff80;

        break;

    case 0xd0c: /* Application Interrupt/Reset Control (AIRCR) */

        if ((value >> R_V7M_AIRCR_VECTKEY_SHIFT) == 0x05fa) {

            if (value & R_V7M_AIRCR_SYSRESETREQ_MASK) {

                if (attrs.secure ||

                    !(cpu->env.v7m.aircr & R_V7M_AIRCR_SYSRESETREQS_MASK)) {

                    qemu_irq_pulse(s->sysresetreq);

                }

            }

            if (value & R_V7M_AIRCR_VECTCLRACTIVE_MASK) {

                qemu_log_mask(LOG_GUEST_ERROR,

                              "Setting VECTCLRACTIVE when not in DEBUG mode "

                              "is UNPREDICTABLE\n");

            }

            if (value & R_V7M_AIRCR_VECTRESET_MASK) {

                /* NB: this bit is RES0 in v8M */

                qemu_log_mask(LOG_GUEST_ERROR,

                              "Setting VECTRESET when not in DEBUG mode "

                              "is UNPREDICTABLE\n");

            }

            s->prigroup[attrs.secure] = extract32(value,

                                                  R_V7M_AIRCR_PRIGROUP_SHIFT,

                                                  R_V7M_AIRCR_PRIGROUP_LENGTH);

            if (attrs.secure) {

                /* These bits are only writable by secure */

                cpu->env.v7m.aircr = value &

                    (R_V7M_AIRCR_SYSRESETREQS_MASK |

                     R_V7M_AIRCR_BFHFNMINS_MASK |

                     R_V7M_AIRCR_PRIS_MASK);

                /* BFHFNMINS changes the priority of Secure HardFault, and

                 * allows a pending Non-secure HardFault to preempt (which

                 * we implement by marking it enabled).

                 */

                if (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) {

                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -3;

                    s->vectors[ARMV7M_EXCP_HARD].enabled = 1;

                } else {

                    s->sec_vectors[ARMV7M_EXCP_HARD].prio = -1;

                    s->vectors[ARMV7M_EXCP_HARD].enabled = 0;

                }

            }

            nvic_irq_update(s);

        }

        break;

    case 0xd10: /* System Control.  */

        /* TODO: Implement control registers.  */

        qemu_log_mask(LOG_UNIMP, "NVIC: SCR unimplemented\n");

        break;

    case 0xd14: /* Configuration Control.  */

        /* Enforce RAZ/WI on reserved and must-RAZ/WI bits */

        value &= (R_V7M_CCR_STKALIGN_MASK |

                  R_V7M_CCR_BFHFNMIGN_MASK |

                  R_V7M_CCR_DIV_0_TRP_MASK |

                  R_V7M_CCR_UNALIGN_TRP_MASK |

                  R_V7M_CCR_USERSETMPEND_MASK |

                  R_V7M_CCR_NONBASETHRDENA_MASK);



        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            /* v8M makes NONBASETHRDENA and STKALIGN be RES1 */

            value |= R_V7M_CCR_NONBASETHRDENA_MASK

                | R_V7M_CCR_STKALIGN_MASK;

        }

        if (attrs.secure) {

            /* the BFHFNMIGN bit is not banked; keep that in the NS copy */

            cpu->env.v7m.ccr[M_REG_NS] =

                (cpu->env.v7m.ccr[M_REG_NS] & ~R_V7M_CCR_BFHFNMIGN_MASK)

                | (value & R_V7M_CCR_BFHFNMIGN_MASK);

            value &= ~R_V7M_CCR_BFHFNMIGN_MASK;

        }



        cpu->env.v7m.ccr[attrs.secure] = value;

        break;

    case 0xd24: /* System Handler Control and State (SHCSR) */

        if (attrs.secure) {

            s->sec_vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;

            /* Secure HardFault active bit cannot be written */

            s->sec_vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;

            s->sec_vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;

            s->sec_vectors[ARMV7M_EXCP_PENDSV].active =

                (value & (1 << 10)) != 0;

            s->sec_vectors[ARMV7M_EXCP_SYSTICK].active =

                (value & (1 << 11)) != 0;

            s->sec_vectors[ARMV7M_EXCP_USAGE].pending =

                (value & (1 << 12)) != 0;

            s->sec_vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;

            s->sec_vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;

            s->sec_vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;

            s->sec_vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;

            s->sec_vectors[ARMV7M_EXCP_USAGE].enabled =

                (value & (1 << 18)) != 0;

            s->sec_vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;

            /* SecureFault not banked, but RAZ/WI to NS */

            s->vectors[ARMV7M_EXCP_SECURE].active = (value & (1 << 4)) != 0;

            s->vectors[ARMV7M_EXCP_SECURE].enabled = (value & (1 << 19)) != 0;

            s->vectors[ARMV7M_EXCP_SECURE].pending = (value & (1 << 20)) != 0;

        } else {

            s->vectors[ARMV7M_EXCP_MEM].active = (value & (1 << 0)) != 0;

            if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {

                /* HARDFAULTPENDED is not present in v7M */

                s->vectors[ARMV7M_EXCP_HARD].pending = (value & (1 << 21)) != 0;

            }

            s->vectors[ARMV7M_EXCP_USAGE].active = (value & (1 << 3)) != 0;

            s->vectors[ARMV7M_EXCP_SVC].active = (value & (1 << 7)) != 0;

            s->vectors[ARMV7M_EXCP_PENDSV].active = (value & (1 << 10)) != 0;

            s->vectors[ARMV7M_EXCP_SYSTICK].active = (value & (1 << 11)) != 0;

            s->vectors[ARMV7M_EXCP_USAGE].pending = (value & (1 << 12)) != 0;

            s->vectors[ARMV7M_EXCP_MEM].pending = (value & (1 << 13)) != 0;

            s->vectors[ARMV7M_EXCP_SVC].pending = (value & (1 << 15)) != 0;

            s->vectors[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;

            s->vectors[ARMV7M_EXCP_USAGE].enabled = (value & (1 << 18)) != 0;

        }

        if (attrs.secure || (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK)) {

            s->vectors[ARMV7M_EXCP_BUS].active = (value & (1 << 1)) != 0;

            s->vectors[ARMV7M_EXCP_BUS].pending = (value & (1 << 14)) != 0;

            s->vectors[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;

        }

        /* NMIACT can only be written if the write is of a zero, with

         * BFHFNMINS 1, and by the CPU in secure state via the NS alias.

         */

        if (!attrs.secure && cpu->env.v7m.secure &&

            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&

            (value & (1 << 5)) == 0) {

            s->vectors[ARMV7M_EXCP_NMI].active = 0;

        }

        /* HARDFAULTACT can only be written if the write is of a zero

         * to the non-secure HardFault state by the CPU in secure state.

         * The only case where we can be targeting the non-secure HF state

         * when in secure state is if this is a write via the NS alias

         * and BFHFNMINS is 1.

         */

        if (!attrs.secure && cpu->env.v7m.secure &&

            (cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK) &&

            (value & (1 << 2)) == 0) {

            s->vectors[ARMV7M_EXCP_HARD].active = 0;

        }



        /* TODO: this is RAZ/WI from NS if DEMCR.SDME is set */

        s->vectors[ARMV7M_EXCP_DEBUG].active = (value & (1 << 8)) != 0;

        nvic_irq_update(s);

        break;

    case 0xd28: /* Configurable Fault Status.  */

        cpu->env.v7m.cfsr[attrs.secure] &= ~value; /* W1C */

        if (attrs.secure) {

            /* The BFSR bits [15:8] are shared between security states

             * and we store them in the NS copy.

             */

            cpu->env.v7m.cfsr[M_REG_NS] &= ~(value & R_V7M_CFSR_BFSR_MASK);

        }

        break;

    case 0xd2c: /* Hard Fault Status.  */

        cpu->env.v7m.hfsr &= ~value; /* W1C */

        break;

    case 0xd30: /* Debug Fault Status.  */

        cpu->env.v7m.dfsr &= ~value; /* W1C */

        break;

    case 0xd34: /* Mem Manage Address.  */

        cpu->env.v7m.mmfar[attrs.secure] = value;

        return;

    case 0xd38: /* Bus Fault Address.  */

        cpu->env.v7m.bfar = value;

        return;

    case 0xd3c: /* Aux Fault Status.  */

        qemu_log_mask(LOG_UNIMP,

                      "NVIC: Aux fault status registers unimplemented\n");

        break;

    case 0xd90: /* MPU_TYPE */

        return; /* RO */

    case 0xd94: /* MPU_CTRL */

        if ((value &

             (R_V7M_MPU_CTRL_HFNMIENA_MASK | R_V7M_MPU_CTRL_ENABLE_MASK))

            == R_V7M_MPU_CTRL_HFNMIENA_MASK) {

            qemu_log_mask(LOG_GUEST_ERROR, "MPU_CTRL: HFNMIENA and !ENABLE is "

                          "UNPREDICTABLE\n");

        }

        cpu->env.v7m.mpu_ctrl[attrs.secure]

            = value & (R_V7M_MPU_CTRL_ENABLE_MASK |

                       R_V7M_MPU_CTRL_HFNMIENA_MASK |

                       R_V7M_MPU_CTRL_PRIVDEFENA_MASK);

        tlb_flush(CPU(cpu));

        break;

    case 0xd98: /* MPU_RNR */

        if (value >= cpu->pmsav7_dregion) {

            qemu_log_mask(LOG_GUEST_ERROR, "MPU region out of range %"

                          PRIu32 "/%" PRIu32 "\n",

                          value, cpu->pmsav7_dregion);

        } else {

            cpu->env.pmsav7.rnr[attrs.secure] = value;

        }

        break;

    case 0xd9c: /* MPU_RBAR */

    case 0xda4: /* MPU_RBAR_A1 */

    case 0xdac: /* MPU_RBAR_A2 */

    case 0xdb4: /* MPU_RBAR_A3 */

    {

        int region;



        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            /* PMSAv8M handling of the aliases is different from v7M:

             * aliases A1, A2, A3 override the low two bits of the region

             * number in MPU_RNR, and there is no 'region' field in the

             * RBAR register.

             */

            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */



            region = cpu->env.pmsav7.rnr[attrs.secure];

            if (aliasno) {

                region = deposit32(region, 0, 2, aliasno);

            }

            if (region >= cpu->pmsav7_dregion) {

                return;

            }

            cpu->env.pmsav8.rbar[attrs.secure][region] = value;

            tlb_flush(CPU(cpu));

            return;

        }



        if (value & (1 << 4)) {

            /* VALID bit means use the region number specified in this

             * value and also update MPU_RNR.REGION with that value.

             */

            region = extract32(value, 0, 4);

            if (region >= cpu->pmsav7_dregion) {

                qemu_log_mask(LOG_GUEST_ERROR,

                              "MPU region out of range %u/%" PRIu32 "\n",

                              region, cpu->pmsav7_dregion);

                return;

            }

            cpu->env.pmsav7.rnr[attrs.secure] = region;

        } else {

            region = cpu->env.pmsav7.rnr[attrs.secure];

        }



        if (region >= cpu->pmsav7_dregion) {

            return;

        }



        cpu->env.pmsav7.drbar[region] = value & ~0x1f;

        tlb_flush(CPU(cpu));

        break;

    }

    case 0xda0: /* MPU_RASR (v7M), MPU_RLAR (v8M) */

    case 0xda8: /* MPU_RASR_A1 (v7M), MPU_RLAR_A1 (v8M) */

    case 0xdb0: /* MPU_RASR_A2 (v7M), MPU_RLAR_A2 (v8M) */

    case 0xdb8: /* MPU_RASR_A3 (v7M), MPU_RLAR_A3 (v8M) */

    {

        int region = cpu->env.pmsav7.rnr[attrs.secure];



        if (arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            /* PMSAv8M handling of the aliases is different from v7M:

             * aliases A1, A2, A3 override the low two bits of the region

             * number in MPU_RNR.

             */

            int aliasno = (offset - 0xd9c) / 8; /* 0..3 */



            region = cpu->env.pmsav7.rnr[attrs.secure];

            if (aliasno) {

                region = deposit32(region, 0, 2, aliasno);

            }

            if (region >= cpu->pmsav7_dregion) {

                return;

            }

            cpu->env.pmsav8.rlar[attrs.secure][region] = value;

            tlb_flush(CPU(cpu));

            return;

        }



        if (region >= cpu->pmsav7_dregion) {

            return;

        }



        cpu->env.pmsav7.drsr[region] = value & 0xff3f;

        cpu->env.pmsav7.dracr[region] = (value >> 16) & 0x173f;

        tlb_flush(CPU(cpu));

        break;

    }

    case 0xdc0: /* MPU_MAIR0 */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (cpu->pmsav7_dregion) {

            /* Register is RES0 if no MPU regions are implemented */

            cpu->env.pmsav8.mair0[attrs.secure] = value;

        }

        /* We don't need to do anything else because memory attributes

         * only affect cacheability, and we don't implement caching.

         */

        break;

    case 0xdc4: /* MPU_MAIR1 */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (cpu->pmsav7_dregion) {

            /* Register is RES0 if no MPU regions are implemented */

            cpu->env.pmsav8.mair1[attrs.secure] = value;

        }

        /* We don't need to do anything else because memory attributes

         * only affect cacheability, and we don't implement caching.

         */

        break;

    case 0xdd0: /* SAU_CTRL */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        cpu->env.sau.ctrl = value & 3;

        break;

    case 0xdd4: /* SAU_TYPE */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        break;

    case 0xdd8: /* SAU_RNR */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        if (value >= cpu->sau_sregion) {

            qemu_log_mask(LOG_GUEST_ERROR, "SAU region out of range %"

                          PRIu32 "/%" PRIu32 "\n",

                          value, cpu->sau_sregion);

        } else {

            cpu->env.sau.rnr = value;

        }

        break;

    case 0xddc: /* SAU_RBAR */

    {

        int region = cpu->env.sau.rnr;



        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        if (region >= cpu->sau_sregion) {

            return;

        }

        cpu->env.sau.rbar[region] = value & ~0x1f;

        tlb_flush(CPU(cpu));

        break;

    }

    case 0xde0: /* SAU_RLAR */

    {

        int region = cpu->env.sau.rnr;



        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        if (region >= cpu->sau_sregion) {

            return;

        }

        cpu->env.sau.rlar[region] = value & ~0x1c;

        tlb_flush(CPU(cpu));

        break;

    }

    case 0xde4: /* SFSR */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        cpu->env.v7m.sfsr &= ~value; /* W1C */

        break;

    case 0xde8: /* SFAR */

        if (!arm_feature(&cpu->env, ARM_FEATURE_V8)) {

            goto bad_offset;

        }

        if (!attrs.secure) {

            return;

        }

        cpu->env.v7m.sfsr = value;

        break;

    case 0xf00: /* Software Triggered Interrupt Register */

    {

        int excnum = (value & 0x1ff) + NVIC_FIRST_IRQ;

        if (excnum < s->num_irq) {

            armv7m_nvic_set_pending(s, excnum, false);

        }

        break;

    }

    default:

    bad_offset:

        qemu_log_mask(LOG_GUEST_ERROR,

                      "NVIC: Bad write offset 0x%x\n", offset);

    }

}
 and probability:0.27358490566037735
code:static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    sPAPRTCE *tcep;



    if (ioba >= tcet->window_size) {

        hcall_dprintf("spapr_vio_put_tce on out-of-boards IOBA 0x"

                      TARGET_FMT_lx "\n", ioba);

        return H_PARAMETER;

    }



    tcep = tcet->table + (ioba >> SPAPR_TCE_PAGE_SHIFT);

    tcep->tce = tce;



    return H_SUCCESS;

}
 and probability:0.23076923076923078
code:static void gen_lq(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    int ra, rd;

    TCGv EA;



    /* Restore CPU state */

    if (unlikely(ctx->mem_idx == 0)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    ra = rA(ctx->opcode);

    rd = rD(ctx->opcode);

    if (unlikely((rd & 1) || rd == ra)) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);

        return;

    }

    if (unlikely(ctx->le_mode)) {

        /* Little-endian mode is not handled */

        gen_exception_err(ctx, POWERPC_EXCP_ALIGN, POWERPC_EXCP_ALIGN_LE);

        return;

    }

    gen_set_access_type(ctx, ACCESS_INT);

    EA = tcg_temp_new();

    gen_addr_imm_index(ctx, EA, 0x0F);

    gen_qemu_ld64(ctx, cpu_gpr[rd], EA);

    gen_addr_add(ctx, EA, EA, 8);

    gen_qemu_ld64(ctx, cpu_gpr[rd+1], EA);

    tcg_temp_free(EA);

#endif

}
 and probability:0.1875
code:static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)

{

    ESPState *s = opaque;

    uint32_t saddr;



    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);

    DPRINTF("read reg[%d]: 0x%2.2x\n", saddr, s->rregs[saddr]);

    switch (saddr) {

    case ESP_FIFO:

        if (s->ti_size > 0) {

            s->ti_size--;

            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {

                /* Data in/out.  */

                fprintf(stderr, "esp: PIO data read not implemented\n");

                s->rregs[ESP_FIFO] = 0;

            } else {

                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];

            }

            esp_raise_irq(s);

        }

        if (s->ti_size == 0) {

            s->ti_rptr = 0;

            s->ti_wptr = 0;

        }

        break;

    case ESP_RINTR:

        // Clear interrupt/error status bits

        s->rregs[ESP_RSTAT] &= ~(STAT_GE | STAT_PE);

        esp_lower_irq(s);

        break;

    default:

        break;

    }

    return s->rregs[saddr];

}
 and probability:0.35294117647058826
code:int av_vsrc_buffer_add_frame2(AVFilterContext *buffer_filter, AVFrame *frame,

                              int64_t pts, AVRational pixel_aspect, int width,

                              int height, enum PixelFormat  pix_fmt,

                              const char *sws_param)

{

    BufferSourceContext *c = buffer_filter->priv;

    int ret;



    if (c->has_frame) {

        av_log(buffer_filter, AV_LOG_ERROR,

               "Buffering several frames is not supported. "

               "Please consume all available frames before adding a new one.\n"

            );

        //return -1;

    }



    if(width != c->w || height != c->h || pix_fmt != c->pix_fmt){

        AVFilterContext *scale= buffer_filter->outputs[0]->dst;

        AVFilterLink *link;



        av_log(buffer_filter, AV_LOG_INFO, "Changing filter graph input to accept %dx%d %d (%d %d)\n",

               width,height,pix_fmt, c->pix_fmt, scale->outputs[0]->format);



        if(!scale || strcmp(scale->filter->name,"scale")){

            AVFilter *f= avfilter_get_by_name("scale");



            av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n");

            if(avfilter_open(&scale, f, "Input equalizer") < 0)

                return -1;



            if((ret=avfilter_init_filter(scale, sws_param, NULL))<0){

                avfilter_free(scale);

                return ret;

            }



            if((ret=avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0))<0){

                avfilter_free(scale);

                return ret;

            }



            scale->outputs[0]->format= c->pix_fmt;

        }



        c->pix_fmt= scale->inputs[0]->format= pix_fmt;

        c->w= scale->inputs[0]->w= width;

        c->h= scale->inputs[0]->h= height;



        link= scale->outputs[0];

        if ((ret =  link->srcpad->config_props(link)) < 0)

            return ret;

    }



    memcpy(c->frame.data    , frame->data    , sizeof(frame->data));

    memcpy(c->frame.linesize, frame->linesize, sizeof(frame->linesize));

    c->frame.interlaced_frame= frame->interlaced_frame;

    c->frame.top_field_first = frame->top_field_first;

    c->frame.key_frame = frame->key_frame;

    c->frame.pict_type = frame->pict_type;

    c->pts = pts;

    c->pixel_aspect = pixel_aspect;

    c->has_frame = 1;



    return 0;

}
 and probability:0.4230769230769231
code:static void pcie_cap_slot_hotplug_common(PCIDevice *hotplug_dev,

                                         DeviceState *dev,

                                         uint8_t **exp_cap, Error **errp)

{

    *exp_cap = hotplug_dev->config + hotplug_dev->exp.exp_cap;

    uint16_t sltsta = pci_get_word(*exp_cap + PCI_EXP_SLTSTA);



    PCIE_DEV_PRINTF(PCI_DEVICE(dev), "hotplug state: 0x%x\n", sltsta);

    if (sltsta & PCI_EXP_SLTSTA_EIS) {

        /* the slot is electromechanically locked.

         * This error is propagated up to qdev and then to HMP/QMP.

         */

        error_setg_errno(errp, -EBUSY, "slot is electromechanically locked");

    }

}
 and probability:0.14285714285714285
code:void qmp_getfd(const char *fdname, Error **errp)

{

    mon_fd_t *monfd;

    int fd;



    fd = qemu_chr_fe_get_msgfd(cur_mon->chr);

    if (fd == -1) {

        error_set(errp, QERR_FD_NOT_SUPPLIED);

        return;

    }



    if (qemu_isdigit(fdname[0])) {


        error_set(errp, QERR_INVALID_PARAMETER_VALUE, "fdname",

                  "a name not starting with a digit");

        return;

    }



    QLIST_FOREACH(monfd, &cur_mon->fds, next) {

        if (strcmp(monfd->name, fdname) != 0) {

            continue;

        }



        close(monfd->fd);

        monfd->fd = fd;

        return;

    }



    monfd = g_malloc0(sizeof(mon_fd_t));

    monfd->name = g_strdup(fdname);

    monfd->fd = fd;



    QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);

} and probability:0.3333333333333333
code:static void qmp_deserialize(void **native_out, void *datap,

                            VisitorFunc visit, Error **errp)

{

    QmpSerializeData *d = datap;

    QString *output_json = qobject_to_json(qmp_output_get_qobject(d->qov));

    QObject *obj = qobject_from_json(qstring_get_str(output_json));



    QDECREF(output_json);

    d->qiv = qmp_input_visitor_new(obj);

    qobject_decref(obj);

    visit(qmp_input_get_visitor(d->qiv), native_out, errp);

}
 and probability:0.2727272727272727
code:static bool coroutine_fn yield_and_check(BackupBlockJob *job)

{

    if (block_job_is_cancelled(&job->common)) {

        return true;

    }



    /* we need to yield so that bdrv_drain_all() returns.

     * (without, VM does not reboot)

     */

    if (job->common.speed) {

        uint64_t delay_ns = ratelimit_calculate_delay(&job->limit,

                                                      job->sectors_read);

        job->sectors_read = 0;

        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, delay_ns);

    } else {

        block_job_sleep_ns(&job->common, QEMU_CLOCK_REALTIME, 0);

    }



    if (block_job_is_cancelled(&job->common)) {

        return true;

    }



    return false;

}
 and probability:0.38095238095238093
code:static int virtio_scsi_do_tmf(VirtIOSCSI *s, VirtIOSCSIReq *req)

{

    SCSIDevice *d = virtio_scsi_device_find(s, req->req.tmf.lun);

    SCSIRequest *r, *next;

    BusChild *kid;

    int target;

    int ret = 0;



    if (s->dataplane_started) {

        assert(blk_get_aio_context(d->conf.blk) == s->ctx);

    }

    /* Here VIRTIO_SCSI_S_OK means "FUNCTION COMPLETE".  */

    req->resp.tmf.response = VIRTIO_SCSI_S_OK;



    virtio_tswap32s(VIRTIO_DEVICE(s), &req->req.tmf.subtype);

    switch (req->req.tmf.subtype) {

    case VIRTIO_SCSI_T_TMF_ABORT_TASK:

    case VIRTIO_SCSI_T_TMF_QUERY_TASK:

        if (!d) {

            goto fail;

        }

        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {

            goto incorrect_lun;

        }

        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {

            VirtIOSCSIReq *cmd_req = r->hba_private;

            if (cmd_req && cmd_req->req.cmd.tag == req->req.tmf.tag) {

                break;

            }

        }

        if (r) {

            /*

             * Assert that the request has not been completed yet, we

             * check for it in the loop above.

             */

            assert(r->hba_private);

            if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK) {

                /* "If the specified command is present in the task set, then

                 * return a service response set to FUNCTION SUCCEEDED".

                 */

                req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;

            } else {

                VirtIOSCSICancelNotifier *notifier;



                req->remaining = 1;

                notifier = g_new(VirtIOSCSICancelNotifier, 1);

                notifier->tmf_req = req;

                notifier->notifier.notify = virtio_scsi_cancel_notify;

                scsi_req_cancel_async(r, &notifier->notifier);

                ret = -EINPROGRESS;

            }

        }

        break;



    case VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET:

        if (!d) {

            goto fail;

        }

        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {

            goto incorrect_lun;

        }

        s->resetting++;

        qdev_reset_all(&d->qdev);

        s->resetting--;

        break;



    case VIRTIO_SCSI_T_TMF_ABORT_TASK_SET:

    case VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET:

    case VIRTIO_SCSI_T_TMF_QUERY_TASK_SET:

        if (!d) {

            goto fail;

        }

        if (d->lun != virtio_scsi_get_lun(req->req.tmf.lun)) {

            goto incorrect_lun;

        }



        /* Add 1 to "remaining" until virtio_scsi_do_tmf returns.

         * This way, if the bus starts calling back to the notifiers

         * even before we finish the loop, virtio_scsi_cancel_notify

         * will not complete the TMF too early.

         */

        req->remaining = 1;

        QTAILQ_FOREACH_SAFE(r, &d->requests, next, next) {

            if (r->hba_private) {

                if (req->req.tmf.subtype == VIRTIO_SCSI_T_TMF_QUERY_TASK_SET) {

                    /* "If there is any command present in the task set, then

                     * return a service response set to FUNCTION SUCCEEDED".

                     */

                    req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;

                    break;

                } else {

                    VirtIOSCSICancelNotifier *notifier;



                    req->remaining++;

                    notifier = g_new(VirtIOSCSICancelNotifier, 1);

                    notifier->notifier.notify = virtio_scsi_cancel_notify;

                    notifier->tmf_req = req;

                    scsi_req_cancel_async(r, &notifier->notifier);

                }

            }

        }

        if (--req->remaining > 0) {

            ret = -EINPROGRESS;

        }

        break;



    case VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET:

        target = req->req.tmf.lun[1];

        s->resetting++;

        QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {

             d = DO_UPCAST(SCSIDevice, qdev, kid->child);

             if (d->channel == 0 && d->id == target) {

                qdev_reset_all(&d->qdev);

             }

        }

        s->resetting--;

        break;



    case VIRTIO_SCSI_T_TMF_CLEAR_ACA:

    default:

        req->resp.tmf.response = VIRTIO_SCSI_S_FUNCTION_REJECTED;

        break;

    }



    return ret;



incorrect_lun:

    req->resp.tmf.response = VIRTIO_SCSI_S_INCORRECT_LUN;

    return ret;



fail:

    req->resp.tmf.response = VIRTIO_SCSI_S_BAD_TARGET;

    return ret;

}
 and probability:0.3442622950819672
code:int ffurl_read_complete(URLContext *h, unsigned char *buf, int size)

{

    if (h->flags & AVIO_FLAG_WRITE)

        return AVERROR(EIO);

    return retry_transfer_wrapper(h, buf, size, size, h->prot->url_read);

}
 and probability:0.3333333333333333
code:int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,

                            uint8_t bar_nr)

{

    int ret;

    char *name;

    uint32_t bar_size = 4096;

    uint32_t bar_pba_offset = bar_size / 2;

    uint32_t bar_pba_size = (nentries / 8 + 1) * 8;



    /*

     * Migration compatibility dictates that this remains a 4k

     * BAR with the vector table in the lower half and PBA in

     * the upper half for nentries which is lower or equal to 128.

     * No need to care about using more than 65 entries for legacy

     * machine types who has at most 64 queues.

     */

    if (nentries * PCI_MSIX_ENTRY_SIZE > bar_pba_offset) {

        bar_pba_offset = nentries * PCI_MSIX_ENTRY_SIZE;

    }



    if (bar_pba_offset + bar_pba_size > 4096) {

        bar_size = bar_pba_offset + bar_pba_size;

    }



    if (bar_size & (bar_size - 1)) {

        bar_size = 1 << qemu_fls(bar_size);

    }



    name = g_strdup_printf("%s-msix", dev->name);

    memory_region_init(&dev->msix_exclusive_bar, OBJECT(dev), name, bar_size);

    g_free(name);



    ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,

                    0, &dev->msix_exclusive_bar,

                    bar_nr, bar_pba_offset,

                    0);

    if (ret) {

        return ret;

    }



    pci_register_bar(dev, bar_nr, PCI_BASE_ADDRESS_SPACE_MEMORY,

                     &dev->msix_exclusive_bar);



    return 0;

}
 and probability:0.3157894736842105
code:void qemu_del_timer(QEMUTimer *ts)

{

}
 and probability:0.0
code:static void restore_native_fp_frstor(CPUState *env)

{

    int fptag, i, j;

    struct fpstate fp1, *fp = &fp1;



    fp->fpuc = env->fpuc;

    fp->fpus = (env->fpus & ~0x3800) | (env->fpstt & 0x7) << 11;

    fptag = 0;

    for (i=7; i>=0; i--) {

	fptag <<= 2;

	if (env->fptags[i]) {

            fptag |= 3;

        } else {

            /* the FPU automatically computes it */

        }

    }

    fp->fptag = fptag;

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);

        j = (j + 1) & 7;

    }

    asm volatile ("frstor %0" : "=m" (*fp));

}
 and probability:0.43478260869565216
code:static void cpu_exec_nocache(int max_cycles, TranslationBlock *orig_tb)

{

    unsigned long next_tb;

    TranslationBlock *tb;



    /* Should never happen.

       We only end up here when an existing TB is too long.  */

    if (max_cycles > CF_COUNT_MASK)

        max_cycles = CF_COUNT_MASK;



    tb = tb_gen_code(env, orig_tb->pc, orig_tb->cs_base, orig_tb->flags,

                     max_cycles);

    env->current_tb = tb;

    /* execute the generated code */

    next_tb = tcg_qemu_tb_exec(tb->tc_ptr);

    env->current_tb = NULL;



    if ((next_tb & 3) == 2) {

        /* Restore PC.  This may happen if async event occurs before

           the TB starts executing.  */

        cpu_pc_from_tb(env, tb);

    }

    tb_phys_invalidate(tb, -1);

    tb_free(tb);

}
 and probability:0.18181818181818182
code:static char *regname(uint32_t addr)

{

    static char buf[16];

    if (addr < PCI_IO_SIZE) {

        const char *r = reg[addr / 4];

        if (r != 0) {

            sprintf(buf, "%s+%u", r, addr % 4);

        } else {

            sprintf(buf, "0x%02x", addr);

        }

    } else {

        sprintf(buf, "??? 0x%08x", addr);

    }

    return buf;

}
 and probability:0.26666666666666666
code:static void handle_2misc_fcmp_zero(DisasContext *s, int opcode,

                                   bool is_scalar, bool is_u, bool is_q,

                                   int size, int rn, int rd)

{

    bool is_double = (size == 3);

    TCGv_ptr fpst = get_fpstatus_ptr();



    if (is_double) {

        TCGv_i64 tcg_op = tcg_temp_new_i64();

        TCGv_i64 tcg_zero = tcg_const_i64(0);

        TCGv_i64 tcg_res = tcg_temp_new_i64();

        NeonGenTwoDoubleOPFn *genfn;

        bool swap = false;

        int pass;



        switch (opcode) {

        case 0x2e: /* FCMLT (zero) */

            swap = true;

            /* fallthrough */

        case 0x2c: /* FCMGT (zero) */

            genfn = gen_helper_neon_cgt_f64;

            break;

        case 0x2d: /* FCMEQ (zero) */

            genfn = gen_helper_neon_ceq_f64;

            break;

        case 0x6d: /* FCMLE (zero) */

            swap = true;

            /* fall through */

        case 0x6c: /* FCMGE (zero) */

            genfn = gen_helper_neon_cge_f64;

            break;

        default:

            g_assert_not_reached();

        }



        for (pass = 0; pass < (is_scalar ? 1 : 2); pass++) {

            read_vec_element(s, tcg_op, rn, pass, MO_64);

            if (swap) {

                genfn(tcg_res, tcg_zero, tcg_op, fpst);

            } else {

                genfn(tcg_res, tcg_op, tcg_zero, fpst);

            }

            write_vec_element(s, tcg_res, rd, pass, MO_64);

        }

        if (is_scalar) {

            clear_vec_high(s, rd);

        }



        tcg_temp_free_i64(tcg_res);

        tcg_temp_free_i64(tcg_zero);

        tcg_temp_free_i64(tcg_op);

    } else {

        TCGv_i32 tcg_op = tcg_temp_new_i32();

        TCGv_i32 tcg_zero = tcg_const_i32(0);

        TCGv_i32 tcg_res = tcg_temp_new_i32();

        NeonGenTwoSingleOPFn *genfn;

        bool swap = false;

        int pass, maxpasses;



        switch (opcode) {

        case 0x2e: /* FCMLT (zero) */

            swap = true;

            /* fall through */

        case 0x2c: /* FCMGT (zero) */

            genfn = gen_helper_neon_cgt_f32;

            break;

        case 0x2d: /* FCMEQ (zero) */

            genfn = gen_helper_neon_ceq_f32;

            break;

        case 0x6d: /* FCMLE (zero) */

            swap = true;

            /* fall through */

        case 0x6c: /* FCMGE (zero) */

            genfn = gen_helper_neon_cge_f32;

            break;

        default:

            g_assert_not_reached();

        }



        if (is_scalar) {

            maxpasses = 1;

        } else {

            maxpasses = is_q ? 4 : 2;

        }



        for (pass = 0; pass < maxpasses; pass++) {

            read_vec_element_i32(s, tcg_op, rn, pass, MO_32);

            if (swap) {

                genfn(tcg_res, tcg_zero, tcg_op, fpst);

            } else {

                genfn(tcg_res, tcg_op, tcg_zero, fpst);

            }

            if (is_scalar) {

                write_fp_sreg(s, rd, tcg_res);

            } else {

                write_vec_element_i32(s, tcg_res, rd, pass, MO_32);

            }

        }

        tcg_temp_free_i32(tcg_res);

        tcg_temp_free_i32(tcg_zero);

        tcg_temp_free_i32(tcg_op);

        if (!is_q && !is_scalar) {

            clear_vec_high(s, rd);

        }

    }



    tcg_temp_free_ptr(fpst);

}
 and probability:0.02
code:static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)

{

    int w, w2, b, scale, first = 1;

    int band_off = 0;



    for (w = 0; w < c->num_windows; w++) {

        if (!c->grouping[w]) {

            memcpy(c->band_scales + band_off,

                   c->band_scales + band_off - c->num_bands,

                   c->num_bands * sizeof(*c->band_scales));

            band_off += c->num_bands;

            continue;

        }

        for (b = 0; b < c->num_bands; b++) {

            if (!c->band_type[band_off]) {

                int all_zero = 1;

                for (w2 = w + 1; w2 < c->num_windows; w2++) {

                    if (c->grouping[w2])

                        break;

                    if (c->band_type[w2 * c->num_bands + b]) {

                        all_zero = 0;

                        break;

                    }

                }

                if (all_zero) {

                    c->band_scales[band_off++] = 0;

                    continue;

                }

            }

            if (first) {

                scale = get_bits(gb, 7);

                first = 0;

            } else {

                scale += get_vlc2(gb, c->scale_diff.table, 9, 3) - 60;

            }

            if (scale < 0 || scale > 128) {

                av_log(c->avctx, AV_LOG_ERROR, "Invalid scale value %d\n",

                       scale);

                return AVERROR_INVALIDDATA;

            }

            c->band_scales[band_off++] = c->scale_tab[scale];

        }

    }



    return 0;

}
 and probability:0.3409090909090909
code:static inline void writer_print_rational(WriterContext *wctx,

                                         const char *key, AVRational q, char sep)

{

    AVBPrint buf;

    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);

    av_bprintf(&buf, "%d%c%d", q.num, sep, q.den);

    wctx->writer->print_string(wctx, key, buf.str);

    wctx->nb_item++;

}
 and probability:0.2222222222222222
code:int cpu_watchpoint_insert(CPUState *env, target_ulong addr, target_ulong len,

                          int flags, CPUWatchpoint **watchpoint)

{

    target_ulong len_mask = ~(len - 1);

    CPUWatchpoint *wp;



    /* sanity checks: allow power-of-2 lengths, deny unaligned watchpoints */

    if ((len != 1 && len != 2 && len != 4 && len != 8) || (addr & ~len_mask)) {

        fprintf(stderr, "qemu: tried to set invalid watchpoint at "

                TARGET_FMT_lx ", len=" TARGET_FMT_lu "\n", addr, len);

        return -EINVAL;

    }

    wp = qemu_malloc(sizeof(*wp));



    wp->vaddr = addr;

    wp->len_mask = len_mask;

    wp->flags = flags;



    /* keep all GDB-injected watchpoints in front */

    if (flags & BP_GDB)

        TAILQ_INSERT_HEAD(&env->watchpoints, wp, entry);

    else

        TAILQ_INSERT_TAIL(&env->watchpoints, wp, entry);



    tlb_flush_page(env, addr);



    if (watchpoint)

        *watchpoint = wp;

    return 0;

}
 and probability:0.32
code:static off_t read_off(int fd, int64_t offset)

{

	uint64_t buffer;

	if (pread(fd, &buffer, 8, offset) < 8)

		return 0;

	return be64_to_cpu(buffer);

}
 and probability:0.0
code:void pc_machine_done(Notifier *notifier, void *data)

{

    PCMachineState *pcms = container_of(notifier,

                                        PCMachineState, machine_done);

    PCIBus *bus = pcms->bus;



    /* set the number of CPUs */

    rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);



    if (bus) {

        int extra_hosts = 0;



        QLIST_FOREACH(bus, &bus->child, sibling) {

            /* look for expander root buses */

            if (pci_bus_is_root(bus)) {

                extra_hosts++;

            }

        }

        if (extra_hosts && pcms->fw_cfg) {

            uint64_t *val = g_malloc(sizeof(*val));

            *val = cpu_to_le64(extra_hosts);

            fw_cfg_add_file(pcms->fw_cfg,

                    "etc/extra-pci-roots", val, sizeof(*val));

        }

    }



    acpi_setup();

    if (pcms->fw_cfg) {

        pc_build_smbios(pcms);

        pc_build_feature_control_file(pcms);

        /* update FW_CFG_NB_CPUS to account for -device added CPUs */

        fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);

    }



    if (pcms->apic_id_limit > 255) {

        IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());



        if (!iommu || !iommu->x86_iommu.intr_supported ||

            iommu->intr_eim != ON_OFF_AUTO_ON) {

            error_report("current -smp configuration requires "

                         "Extended Interrupt Mode enabled. "

                         "You can add an IOMMU using: "

                         "-device intel-iommu,intremap=on,eim=on");

            exit(EXIT_FAILURE);

        }

    }

}
 and probability:0.34146341463414637
code:static void spapr_machine_reset(void)

{

    MachineState *machine = MACHINE(qdev_get_machine());

    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);

    PowerPCCPU *first_ppc_cpu;

    uint32_t rtas_limit;

    hwaddr rtas_addr, fdt_addr;

    void *fdt;

    int rc;



    /* Check for unknown sysbus devices */

    foreach_dynamic_sysbus_device(find_unknown_sysbus_device, NULL);



    spapr_caps_reset(spapr);



    first_ppc_cpu = POWERPC_CPU(first_cpu);

    if (kvm_enabled() && kvmppc_has_cap_mmu_radix() &&

        ppc_check_compat(first_ppc_cpu, CPU_POWERPC_LOGICAL_3_00, 0,

                         spapr->max_compat_pvr)) {

        /* If using KVM with radix mode available, VCPUs can be started

         * without a HPT because KVM will start them in radix mode.

         * Set the GR bit in PATB so that we know there is no HPT. */

        spapr->patb_entry = PATBE1_GR;

    } else {

        spapr_setup_hpt_and_vrma(spapr);

    }



    qemu_devices_reset();



    /* DRC reset may cause a device to be unplugged. This will cause troubles

     * if this device is used by another device (eg, a running vhost backend

     * will crash QEMU if the DIMM holding the vring goes away). To avoid such

     * situations, we reset DRCs after all devices have been reset.

     */

    object_child_foreach_recursive(object_get_root(), spapr_reset_drcs, NULL);



    spapr_clear_pending_events(spapr);



    /*

     * We place the device tree and RTAS just below either the top of the RMA,

     * or just below 2GB, whichever is lowere, so that it can be

     * processed with 32-bit real mode code if necessary

     */

    rtas_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR);

    rtas_addr = rtas_limit - RTAS_MAX_SIZE;

    fdt_addr = rtas_addr - FDT_MAX_SIZE;



    /* if this reset wasn't generated by CAS, we should reset our

     * negotiated options and start from scratch */

    if (!spapr->cas_reboot) {

        spapr_ovec_cleanup(spapr->ov5_cas);

        spapr->ov5_cas = spapr_ovec_new();



        ppc_set_compat(first_ppc_cpu, spapr->max_compat_pvr, &error_fatal);

    }



    fdt = spapr_build_fdt(spapr, rtas_addr, spapr->rtas_size);



    spapr_load_rtas(spapr, fdt, rtas_addr);



    rc = fdt_pack(fdt);



    /* Should only fail if we've built a corrupted tree */

    assert(rc == 0);



    if (fdt_totalsize(fdt) > FDT_MAX_SIZE) {

        error_report("FDT too big ! 0x%x bytes (max is 0x%x)",

                     fdt_totalsize(fdt), FDT_MAX_SIZE);

        exit(1);

    }



    /* Load the fdt */

    qemu_fdt_dumpdtb(fdt, fdt_totalsize(fdt));

    cpu_physical_memory_write(fdt_addr, fdt, fdt_totalsize(fdt));

    g_free(fdt);



    /* Set up the entry state */

    first_ppc_cpu->env.gpr[3] = fdt_addr;

    first_ppc_cpu->env.gpr[5] = 0;

    first_cpu->halted = 0;

    first_ppc_cpu->env.nip = SPAPR_ENTRY_POINT;



    spapr->cas_reboot = false;

}
 and probability:0.22388059701492538
code:bool replay_next_event_is(int event)

{

    bool res = false;



    /* nothing to skip - not all instructions used */

    if (replay_state.instructions_count != 0) {

        assert(replay_data_kind == EVENT_INSTRUCTION);

        return event == EVENT_INSTRUCTION;

    }



    while (true) {

        if (event == replay_data_kind) {

            res = true;

        }

        switch (replay_data_kind) {

        case EVENT_SHUTDOWN:

            replay_finish_event();

            qemu_system_shutdown_request();

            break;

        default:

            /* clock, time_t, checkpoint and other events */

            return res;

        }

    }

    return res;

}
 and probability:0.0
code:void kvm_init_irq_routing(KVMState *s)

{

    int gsi_count, i;



    gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING);

    if (gsi_count > 0) {

        unsigned int gsi_bits, i;



        /* Round up so we can search ints using ffs */

        gsi_bits = ALIGN(gsi_count, 32);

        s->used_gsi_bitmap = g_malloc0(gsi_bits / 8);

        s->gsi_count = gsi_count;



        /* Mark any over-allocated bits as already in use */

        for (i = gsi_count; i < gsi_bits; i++) {

            set_gsi(s, i);

        }

    }



    s->irq_routes = g_malloc0(sizeof(*s->irq_routes));

    s->nr_allocated_irq_routes = 0;



    if (!s->direct_msi) {

        for (i = 0; i < KVM_MSI_HASHTAB_SIZE; i++) {

            QTAILQ_INIT(&s->msi_hashtab[i]);

        }

    }



    kvm_arch_init_irq_routing(s);

}
 and probability:0.3333333333333333
code:static uint16_t *phys_page_find_alloc(target_phys_addr_t index, int alloc)

{

    PhysPageEntry *lp, *p;

    int i, j;



    lp = &phys_map;



    /* Level 1..N.  */

    for (i = P_L2_LEVELS - 1; i >= 0; i--) {

        if (lp->u.node == NULL) {

            if (!alloc) {

                return NULL;

            }

            lp->u.node = p = g_malloc0(sizeof(PhysPageEntry) * L2_SIZE);

            if (i == 0) {

                for (j = 0; j < L2_SIZE; j++) {

                    p[j].u.leaf = phys_section_unassigned;

                }

            }

        }

        lp = &lp->u.node[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];

    }



    return &lp->u.leaf;

}
 and probability:0.3181818181818182
code:void qemu_cpu_kick(void *_env)

{

    CPUState *env = _env;



    qemu_cond_broadcast(env->halt_cond);

    if (!env->thread_kicked) {

        qemu_cpu_kick_thread(env);

        env->thread_kicked = true;

    }

}
 and probability:0.3333333333333333
code:static int http_proxy_open(URLContext *h, const char *uri, int flags)

{

    HTTPContext *s = h->priv_data;

    char hostname[1024], hoststr[1024];

    char auth[1024], pathbuf[1024], *path;

    char lower_url[100];

    int port, ret = 0, attempts = 0;

    HTTPAuthType cur_auth_type;

    char *authstr;

    int new_loc;



    h->is_streamed = 1;



    av_url_split(NULL, 0, auth, sizeof(auth), hostname, sizeof(hostname), &port,

                 pathbuf, sizeof(pathbuf), uri);

    ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);

    path = pathbuf;

    if (*path == '/')

        path++;



    ff_url_join(lower_url, sizeof(lower_url), "tcp", NULL, hostname, port,

                NULL);

redo:

    ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,

                     &h->interrupt_callback, NULL);

    if (ret < 0)

        return ret;



    authstr = ff_http_auth_create_response(&s->proxy_auth_state, auth,

                                           path, "CONNECT");

    snprintf(s->buffer, sizeof(s->buffer),

             "CONNECT %s HTTP/1.1\r\n"

             "Host: %s\r\n"

             "Connection: close\r\n"

             "%s%s"

             "\r\n",

             path,

             hoststr,

             authstr ? "Proxy-" : "", authstr ? authstr : "");

    av_freep(&authstr);



    if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)

        goto fail;



    s->buf_ptr = s->buffer;

    s->buf_end = s->buffer;

    s->line_count = 0;

    s->filesize = -1;

    cur_auth_type = s->proxy_auth_state.auth_type;



    /* Note: This uses buffering, potentially reading more than the

     * HTTP header. If tunneling a protocol where the server starts

     * the conversation, we might buffer part of that here, too.

     * Reading that requires using the proper ffurl_read() function

     * on this URLContext, not using the fd directly (as the tls

     * protocol does). This shouldn't be an issue for tls though,

     * since the client starts the conversation there, so there

     * is no extra data that we might buffer up here.

     */

    ret = http_read_header(h, &new_loc);

    if (ret < 0)

        goto fail;



    attempts++;

    if (s->http_code == 407 &&

        (cur_auth_type == HTTP_AUTH_NONE || s->proxy_auth_state.stale) &&

        s->proxy_auth_state.auth_type != HTTP_AUTH_NONE && attempts < 2) {

        ffurl_closep(&s->hd);

        goto redo;

    }



    if (s->http_code < 400)

        return 0;

    ret = AVERROR(EIO);



fail:

    http_proxy_close(h);

    return ret;

}
 and probability:0.2898550724637681
code:static int get_physical_address_data(CPUState *env,

                                     target_phys_addr_t *physical, int *prot,

                                     target_ulong address, int rw, int is_user)

{

    target_ulong mask;

    unsigned int i;



    if ((env->lsu & DMMU_E) == 0) { /* DMMU disabled */

        *physical = address;

        *prot = PAGE_READ | PAGE_WRITE;

        return 0;

    }



    for (i = 0; i < 64; i++) {

        switch ((env->dtlb_tte[i] >> 61) & 3) {

        default:

        case 0x0: // 8k

            mask = 0xffffffffffffe000ULL;

            break;

        case 0x1: // 64k

            mask = 0xffffffffffff0000ULL;

            break;

        case 0x2: // 512k

            mask = 0xfffffffffff80000ULL;

            break;

        case 0x3: // 4M

            mask = 0xffffffffffc00000ULL;

            break;

        }

        // ctx match, vaddr match, valid?

        if (env->dmmuregs[1] == (env->dtlb_tag[i] & 0x1fff) &&

            (address & mask) == (env->dtlb_tag[i] & mask) &&

            (env->dtlb_tte[i] & 0x8000000000000000ULL)) {

            // access ok?

            if (((env->dtlb_tte[i] & 0x4) && is_user) ||

                (!(env->dtlb_tte[i] & 0x2) && (rw == 1))) {

                if (env->dmmuregs[3]) /* Fault status register */

                    env->dmmuregs[3] = 2; /* overflow (not read before

                                             another fault) */

                env->dmmuregs[3] |= (is_user << 3) | ((rw == 1) << 2) | 1;

                env->dmmuregs[4] = address; /* Fault address register */

                env->exception_index = TT_DFAULT;

#ifdef DEBUG_MMU

                printf("DFAULT at 0x%" PRIx64 "\n", address);

#endif

                return 1;

            }

            *physical = ((env->dtlb_tte[i] & mask) | (address & ~mask)) &

                        0x1ffffffe000ULL;

            *prot = PAGE_READ;

            if (env->dtlb_tte[i] & 0x2)

                *prot |= PAGE_WRITE;

            return 0;

        }

    }

#ifdef DEBUG_MMU

    printf("DMISS at 0x%" PRIx64 "\n", address);

#endif

    env->dmmuregs[6] = (address & ~0x1fffULL) | (env->dmmuregs[1] & 0x1fff);

    env->exception_index = TT_DMISS;

    return 1;

}
 and probability:0.35
code:static int local_create_mapped_attr_dir(FsContext *ctx, const char *path)

{

    int err;

    char attr_dir[PATH_MAX];

    char *tmp_path = g_strdup(path);



    snprintf(attr_dir, PATH_MAX, "%s/%s/%s",

             ctx->fs_root, dirname(tmp_path), VIRTFS_META_DIR);



    err = mkdir(attr_dir, 0700);

    if (err < 0 && errno == EEXIST) {

        err = 0;

    }

    g_free(tmp_path);

    return err;

}
 and probability:0.07142857142857142
code:static inline void sync_jmpstate(DisasContext *dc)

{

    if (dc->jmp == JMP_DIRECT) {

            dc->jmp = JMP_INDIRECT;

            tcg_gen_movi_tl(env_btaken, 1);

            tcg_gen_movi_tl(env_btarget, dc->jmp_pc);

    }

}
 and probability:0.375
code:void register_device_unmigratable(DeviceState *dev, const char *idstr,

                                                            void *opaque)

{

    SaveStateEntry *se;

    char id[256] = "";



    if (dev && dev->parent_bus && dev->parent_bus->info->get_dev_path) {

        char *path = dev->parent_bus->info->get_dev_path(dev);

        if (path) {

            pstrcpy(id, sizeof(id), path);

            pstrcat(id, sizeof(id), "/");

            g_free(path);

        }

    }

    pstrcat(id, sizeof(id), idstr);



    QTAILQ_FOREACH(se, &savevm_handlers, entry) {

        if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {

            se->no_migrate = 1;

        }

    }

}
 and probability:0.2
code:int css_do_rsch(SubchDev *sch)

{

    SCSW *s = &sch->curr_status.scsw;

    PMCW *p = &sch->curr_status.pmcw;

    int ret;



    if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {

        ret = -ENODEV;

        goto out;

    }



    if (s->ctrl & SCSW_STCTL_STATUS_PEND) {

        ret = -EINPROGRESS;

        goto out;

    }



    if (((s->ctrl & SCSW_CTRL_MASK_FCTL) != SCSW_FCTL_START_FUNC) ||

        (s->ctrl & SCSW_ACTL_RESUME_PEND) ||

        (!(s->ctrl & SCSW_ACTL_SUSP))) {

        ret = -EINVAL;

        goto out;

    }



    /* If monitoring is active, update counter. */

    if (channel_subsys.chnmon_active) {

        css_update_chnmon(sch);

    }



    s->ctrl |= SCSW_ACTL_RESUME_PEND;

    do_subchannel_work(sch, NULL);

    ret = 0;



out:

    return ret;

}
 and probability:0.27586206896551724
code:CPUState *cpu_copy(CPUState *env)

{

    CPUState *new_env = cpu_init(env->cpu_model_str);

    CPUState *next_cpu = new_env->next_cpu;

    int cpu_index = new_env->cpu_index;

#if defined(TARGET_HAS_ICE)

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;

#endif



    memcpy(new_env, env, sizeof(CPUState));



    /* Preserve chaining and index. */

    new_env->next_cpu = next_cpu;

    new_env->cpu_index = cpu_index;



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    TAILQ_INIT(&env->breakpoints);

    TAILQ_INIT(&env->watchpoints);

#if defined(TARGET_HAS_ICE)

    TAILQ_FOREACH(bp, &env->breakpoints, entry) {

        cpu_breakpoint_insert(new_env, bp->pc, bp->flags, NULL);

    }

    TAILQ_FOREACH(wp, &env->watchpoints, entry) {

        cpu_watchpoint_insert(new_env, wp->vaddr, (~wp->len_mask) + 1,

                              wp->flags, NULL);

    }

#endif



    return new_env;

}
 and probability:0.41379310344827586
code:xilinx_axidma_data_stream_push(StreamSlave *obj, unsigned char *buf, size_t len,

                               uint32_t *app)

{

    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(obj);

    struct Stream *s = &ds->dma->streams[1];

    size_t ret;



    if (!app) {

        hw_error("No stream app data!\n");

    }

    ret = stream_process_s2mem(s, buf, len, app);

    stream_update_irq(s);

    return ret;

}
 and probability:0.23076923076923078
code:void *av_realloc(void *ptr, unsigned int size)

{

#ifdef MEMALIGN_HACK

    int diff;

#endif



    /* let's disallow possible ambiguous cases */

    if(size > INT_MAX)

        return NULL;



#ifdef MEMALIGN_HACK

    //FIXME this isn't aligned correctly, though it probably isn't needed

    if(!ptr) return av_malloc(size);

    diff= ((char*)ptr)[-1];

    return realloc(ptr - diff, size + diff) + diff;

#else

    return realloc(ptr, size);

#endif

}
 and probability:0.17647058823529413
code:static int mmf_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 32)

        return 0;

    if (p->buf[0] == 'M' && p->buf[1] == 'M' &&

        p->buf[2] == 'M' && p->buf[3] == 'D' &&

        p->buf[8] == 'C' && p->buf[9] == 'N' &&

        p->buf[10] == 'T' && p->buf[11] == 'I')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
 and probability:0.38461538461538464
code:static XICSState *try_create_xics(const char *type, int nr_servers,

                                  int nr_irqs)

{

    DeviceState *dev;



    dev = qdev_create(NULL, type);

    qdev_prop_set_uint32(dev, "nr_servers", nr_servers);

    qdev_prop_set_uint32(dev, "nr_irqs", nr_irqs);

    if (qdev_init(dev) < 0) {

        return NULL;

    }



    return XICS_COMMON(dev);

}
 and probability:0.0
code:static VncServerInfo *vnc_server_info_get(VncDisplay *vd)

{

    VncServerInfo *info;

    Error *err = NULL;



    info = g_malloc(sizeof(*info));

    vnc_init_basic_info_from_server_addr(vd->lsock,

                                         qapi_VncServerInfo_base(info), &err);

    info->has_auth = true;

    info->auth = g_strdup(vnc_auth_name(vd));

    if (err) {

        qapi_free_VncServerInfo(info);

        info = NULL;

        error_free(err);

    }

    return info;

}
 and probability:0.25
code:static int vm_request_pending(void)

{

    return powerdown_requested ||

           reset_requested ||

           shutdown_requested ||

           debug_requested ||

           vmstop_requested;

}
 and probability:0.0
code:static int adpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                              const AVFrame *frame, int *got_packet_ptr)

{

    int n, i, ch, st, pkt_size, ret;

    const int16_t *samples;

    int16_t **samples_p;

    uint8_t *dst;

    ADPCMEncodeContext *c = avctx->priv_data;

    uint8_t *buf;



    samples = (const int16_t *)frame->data[0];

    samples_p = (int16_t **)frame->extended_data;

    st = avctx->channels == 2;



    if (avctx->codec_id == AV_CODEC_ID_ADPCM_SWF)

        pkt_size = (2 + avctx->channels * (22 + 4 * (frame->nb_samples - 1)) + 7) / 8;

    else

        pkt_size = avctx->block_align;

    if ((ret = ff_alloc_packet(avpkt, pkt_size))) {

        av_log(avctx, AV_LOG_ERROR, "Error getting output packet\n");

        return ret;

    }

    dst = avpkt->data;



    switch(avctx->codec->id) {

    case AV_CODEC_ID_ADPCM_IMA_WAV:

    {

        int blocks, j;



        blocks = (frame->nb_samples - 1) / 8;



        for (ch = 0; ch < avctx->channels; ch++) {

            ADPCMChannelStatus *status = &c->status[ch];

            status->prev_sample = samples_p[ch][0];

            /* status->step_index = 0;

               XXX: not sure how to init the state machine */

            bytestream_put_le16(&dst, status->prev_sample);

            *dst++ = status->step_index;

            *dst++ = 0; /* unknown */

        }



        /* stereo: 4 bytes (8 samples) for left, 4 bytes for right */

        if (avctx->trellis > 0) {

            FF_ALLOC_OR_GOTO(avctx, buf, avctx->channels * blocks * 8, error);

            for (ch = 0; ch < avctx->channels; ch++) {

                adpcm_compress_trellis(avctx, &samples_p[ch][1],

                                       buf + ch * blocks * 8, &c->status[ch],

                                       blocks * 8, 1);

            }

            for (i = 0; i < blocks; i++) {

                for (ch = 0; ch < avctx->channels; ch++) {

                    uint8_t *buf1 = buf + ch * blocks * 8 + i * 8;

                    for (j = 0; j < 8; j += 2)

                        *dst++ = buf1[j] | (buf1[j + 1] << 4);

                }

            }

            av_free(buf);

        } else {

            for (i = 0; i < blocks; i++) {

                for (ch = 0; ch < avctx->channels; ch++) {

                    ADPCMChannelStatus *status = &c->status[ch];

                    const int16_t *smp = &samples_p[ch][1 + i * 8];

                    for (j = 0; j < 8; j += 2) {

                        uint8_t v = adpcm_ima_compress_sample(status, smp[j    ]);

                        v        |= adpcm_ima_compress_sample(status, smp[j + 1]) << 4;

                        *dst++ = v;

                    }

                }

            }

        }

        break;

    }

    case AV_CODEC_ID_ADPCM_IMA_QT:

    {

        PutBitContext pb;

        init_put_bits(&pb, dst, pkt_size * 8);



        for (ch = 0; ch < avctx->channels; ch++) {

            ADPCMChannelStatus *status = &c->status[ch];

            put_bits(&pb, 9, (status->prev_sample & 0xFFFF) >> 7);

            put_bits(&pb, 7,  status->step_index);

            if (avctx->trellis > 0) {

                uint8_t buf[64];

                adpcm_compress_trellis(avctx, &samples_p[ch][1], buf, status,

                                       64, 1);

                for (i = 0; i < 64; i++)

                    put_bits(&pb, 4, buf[i ^ 1]);

            } else {

                for (i = 0; i < 64; i += 2) {

                    int t1, t2;

                    t1 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i    ]);

                    t2 = adpcm_ima_qt_compress_sample(status, samples_p[ch][i + 1]);

                    put_bits(&pb, 4, t2);

                    put_bits(&pb, 4, t1);

                }

            }

        }



        flush_put_bits(&pb);

        break;

    }

    case AV_CODEC_ID_ADPCM_SWF:

    {

        PutBitContext pb;

        init_put_bits(&pb, dst, pkt_size * 8);



        n = frame->nb_samples - 1;



        // store AdpcmCodeSize

        put_bits(&pb, 2, 2);    // set 4-bit flash adpcm format



        // init the encoder state

        for (i = 0; i < avctx->channels; i++) {

            // clip step so it fits 6 bits

            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 63);

            put_sbits(&pb, 16, samples[i]);

            put_bits(&pb, 6, c->status[i].step_index);

            c->status[i].prev_sample = samples[i];

        }



        if (avctx->trellis > 0) {

            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);

            adpcm_compress_trellis(avctx, samples + avctx->channels, buf,

                                   &c->status[0], n, avctx->channels);

            if (avctx->channels == 2)

                adpcm_compress_trellis(avctx, samples + avctx->channels + 1,

                                       buf + n, &c->status[1], n,

                                       avctx->channels);

            for (i = 0; i < n; i++) {

                put_bits(&pb, 4, buf[i]);

                if (avctx->channels == 2)

                    put_bits(&pb, 4, buf[n + i]);

            }

            av_free(buf);

        } else {

            for (i = 1; i < frame->nb_samples; i++) {

                put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[0],

                         samples[avctx->channels * i]));

                if (avctx->channels == 2)

                    put_bits(&pb, 4, adpcm_ima_compress_sample(&c->status[1],

                             samples[2 * i + 1]));

            }

        }

        flush_put_bits(&pb);

        break;

    }

    case AV_CODEC_ID_ADPCM_MS:

        for (i = 0; i < avctx->channels; i++) {

            int predictor = 0;

            *dst++ = predictor;

            c->status[i].coeff1 = ff_adpcm_AdaptCoeff1[predictor];

            c->status[i].coeff2 = ff_adpcm_AdaptCoeff2[predictor];

        }

        for (i = 0; i < avctx->channels; i++) {

            if (c->status[i].idelta < 16)

                c->status[i].idelta = 16;

            bytestream_put_le16(&dst, c->status[i].idelta);

        }

        for (i = 0; i < avctx->channels; i++)

            c->status[i].sample2= *samples++;

        for (i = 0; i < avctx->channels; i++) {

            c->status[i].sample1 = *samples++;

            bytestream_put_le16(&dst, c->status[i].sample1);

        }

        for (i = 0; i < avctx->channels; i++)

            bytestream_put_le16(&dst, c->status[i].sample2);



        if (avctx->trellis > 0) {

            n = avctx->block_align - 7 * avctx->channels;

            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n, error);

            if (avctx->channels == 1) {

                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,

                                       avctx->channels);

                for (i = 0; i < n; i += 2)

                    *dst++ = (buf[i] << 4) | buf[i + 1];

            } else {

                adpcm_compress_trellis(avctx, samples,     buf,

                                       &c->status[0], n, avctx->channels);

                adpcm_compress_trellis(avctx, samples + 1, buf + n,

                                       &c->status[1], n, avctx->channels);

                for (i = 0; i < n; i++)

                    *dst++ = (buf[i] << 4) | buf[n + i];

            }

            av_free(buf);

        } else {

            for (i = 7 * avctx->channels; i < avctx->block_align; i++) {

                int nibble;

                nibble  = adpcm_ms_compress_sample(&c->status[ 0], *samples++) << 4;

                nibble |= adpcm_ms_compress_sample(&c->status[st], *samples++);

                *dst++  = nibble;

            }

        }

        break;

    case AV_CODEC_ID_ADPCM_YAMAHA:

        n = frame->nb_samples / 2;

        if (avctx->trellis > 0) {

            FF_ALLOC_OR_GOTO(avctx, buf, 2 * n * 2, error);

            n *= 2;

            if (avctx->channels == 1) {

                adpcm_compress_trellis(avctx, samples, buf, &c->status[0], n,

                                       avctx->channels);

                for (i = 0; i < n; i += 2)

                    *dst++ = buf[i] | (buf[i + 1] << 4);

            } else {

                adpcm_compress_trellis(avctx, samples,     buf,

                                       &c->status[0], n, avctx->channels);

                adpcm_compress_trellis(avctx, samples + 1, buf + n,

                                       &c->status[1], n, avctx->channels);

                for (i = 0; i < n; i++)

                    *dst++ = buf[i] | (buf[n + i] << 4);

            }

            av_free(buf);

        } else

            for (n *= avctx->channels; n > 0; n--) {

                int nibble;

                nibble  = adpcm_yamaha_compress_sample(&c->status[ 0], *samples++);

                nibble |= adpcm_yamaha_compress_sample(&c->status[st], *samples++) << 4;

                *dst++  = nibble;

            }

        break;

    default:

        return AVERROR(EINVAL);

    }



    avpkt->size = pkt_size;

    *got_packet_ptr = 1;

    return 0;

error:

    return AVERROR(ENOMEM);

}
 and probability:0.5694444444444444
code:yuv2rgb_full_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum AVPixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int uvalpha1 = 4096 - uvalpha;

    int i;

    int step = (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) ? 3 : 4;

    int err[4] = {0};



    if(   target == AV_PIX_FMT_BGR4_BYTE || target == AV_PIX_FMT_RGB4_BYTE

       || target == AV_PIX_FMT_BGR8      || target == AV_PIX_FMT_RGB8)

        step = 1;



    for (i = 0; i < dstW; i++) {

        int Y = ( buf0[i] * yalpha1  +  buf1[i] * yalpha             ) >> 10; //FIXME rounding

        int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha-(128 << 19)) >> 10;

        int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha-(128 << 19)) >> 10;

        int A;



        if (hasAlpha) {

            A = (abuf0[i] * yalpha1 + abuf1[i] * yalpha + (1<<18)) >> 19;

            if (A & 0x100)

                A = av_clip_uint8(A);

        }



        yuv2rgb_write_full(c, dest, i, Y, A, U, V, y, target, hasAlpha, err);

        dest += step;

    }

    c->dither_error[0][i] = err[0];

    c->dither_error[1][i] = err[1];

    c->dither_error[2][i] = err[2];

}
 and probability:0.5277777777777778
code:static void clone_slice(H264Context *dst, H264Context *src)

{

    memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));

    dst->s.current_picture_ptr = src->s.current_picture_ptr;

    dst->s.current_picture     = src->s.current_picture;

    dst->s.linesize            = src->s.linesize;

    dst->s.uvlinesize          = src->s.uvlinesize;

    dst->s.first_field         = src->s.first_field;



    dst->prev_poc_msb          = src->prev_poc_msb;

    dst->prev_poc_lsb          = src->prev_poc_lsb;

    dst->prev_frame_num_offset = src->prev_frame_num_offset;

    dst->prev_frame_num        = src->prev_frame_num;

    dst->short_ref_count       = src->short_ref_count;



    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));

    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));

    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));

    memcpy(dst->ref_list,         src->ref_list,         sizeof(dst->ref_list));



    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));

    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));

}
 and probability:0.85
code:static inline void gen_op_arith_subf(DisasContext *ctx, TCGv ret, TCGv arg1,

                                     TCGv arg2, int add_ca, int compute_ca,

                                     int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret, arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    if (add_ca) {

        tcg_gen_not_tl(t0, arg1);

        tcg_gen_add_tl(t0, t0, arg2);

        gen_op_arith_compute_ca(ctx, t0, arg2, 0);

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    } else {

        tcg_gen_sub_tl(t0, arg2, arg1);

        if (compute_ca) {

            gen_op_arith_compute_ca(ctx, t0, arg2, 1);

        }

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 1);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
 and probability:0.020833333333333332
code:static void mxf_packet_timestamps(MXFContext *mxf, AVPacket *pkt)

{

    int64_t last_ofs = -1, next_ofs;

    MXFIndexTable *t = &mxf->index_tables[0];



    /* this is called from the OP1a demuxing logic, which means there

     * may be no index tables */

    if (mxf->nb_index_tables <= 0)

        return;



    /* find mxf->current_edit_unit so that the next edit unit starts ahead of pkt->pos */

    for (;;) {

        if (mxf_edit_unit_absolute_offset(mxf, t, mxf->current_edit_unit + 1, NULL, &next_ofs, 0) < 0)

            break;



        if (next_ofs <= last_ofs) {

            /* large next_ofs didn't change or current_edit_unit wrapped

             * around this fixes the infinite loop on zzuf3.mxf */

            av_log(mxf->fc, AV_LOG_ERROR,

                   "next_ofs didn't change. not deriving packet timestamps\n");

            return;

        }



        if (next_ofs > pkt->pos)

            break;



        last_ofs = next_ofs;

        mxf->current_edit_unit++;

    }



    if (mxf->current_edit_unit >= t->nb_ptses)

        return;



    pkt->dts = mxf->current_edit_unit + t->first_dts;

    pkt->pts = t->ptses[mxf->current_edit_unit];

}
 and probability:0.3103448275862069
code:static void ff_h264_idct_add16intra_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){

    int i;

    for(i=0; i<16; i++){

        if(nnzc[ scan8[i] ] || block[i*16])

            ff_h264_idct_add_mmx(dst + block_offset[i], block + i*16, stride);

    }

}
 and probability:0.5714285714285714
code:static void process_subpacket_9 (QDM2Context *q, QDM2SubPNode *node)

{

    GetBitContext gb;

    int i, j, k, n, ch, run, level, diff;



    init_get_bits(&gb, node->packet->data, node->packet->size*8);



    n = coeff_per_sb_for_avg[q->coeff_per_sb_select][QDM2_SB_USED(q->sub_sampling) - 1] + 1; // same as averagesomething function



    for (i = 1; i < n; i++)

        for (ch=0; ch < q->nb_channels; ch++) {

            level = qdm2_get_vlc(&gb, &vlc_tab_level, 0, 2);

            q->quantized_coeffs[ch][i][0] = level;



            for (j = 0; j < (8 - 1); ) {

                run = qdm2_get_vlc(&gb, &vlc_tab_run, 0, 1) + 1;

                diff = qdm2_get_se_vlc(&vlc_tab_diff, &gb, 2);



                for (k = 1; k <= run; k++)

                    q->quantized_coeffs[ch][i][j + k] = (level + ((k*diff) / run));



                level += diff;

                j += run;

            }

        }



    for (ch = 0; ch < q->nb_channels; ch++)

        for (i = 0; i < 8; i++)

            q->quantized_coeffs[ch][0][i] = 0;

}
 and probability:0.6086956521739131
code:static inline void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)

{

    int i, d;

    for( i = 0; i < 4; i++ ) {

        const int tc = tc0[i];

        if( tc <= 0 ) {

            pix += 2*ystride;

            continue;

        }

        for( d = 0; d < 2; d++ ) {

            const int p0 = pix[-1*xstride];

            const int p1 = pix[-2*xstride];

            const int q0 = pix[0];

            const int q1 = pix[1*xstride];



            if( FFABS( p0 - q0 ) < alpha &&

                FFABS( p1 - p0 ) < beta &&

                FFABS( q1 - q0 ) < beta ) {



                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );



                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */

                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */

            }

            pix += ystride;

        }

    }

}
 and probability:0.6
code:static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,
                                    const uint8_t *src, const uint8_t *src_end,
                                    int width, int esc_count)
{
    int i = 0;
    int count;
    uint8_t zero_run = 0;
    const uint8_t *src_start = src;
    uint8_t mask1 = -(esc_count < 2);
    uint8_t mask2 = -(esc_count < 3);
    uint8_t *end = dst + (width - 2);
output_zeros:
    if (l->zeros_rem) {
        count = FFMIN(l->zeros_rem, width - i);
        if (end - dst < count) {
            av_log(l->avctx, AV_LOG_ERROR, "Too many zeros remaining.\n");
            return AVERROR_INVALIDDATA;
        }
        memset(dst, 0, count);
        l->zeros_rem -= count;
        dst += count;
    }
    while (dst < end) {
        i = 0;
        while (!zero_run && dst + i < end) {
            i++;
            if (i+2 >= src_end - src)
                return AVERROR_INVALIDDATA;
            zero_run =
                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));
        }
        if (zero_run) {
            zero_run = 0;
            i += esc_count;
            memcpy(dst, src, i);
            dst += i;
            l->zeros_rem = lag_calc_zero_run(src[i]);
            src += i + 1;
            goto output_zeros;
        } else {
            memcpy(dst, src, i);
            src += i;
            dst += i;
        }
    }
    return  src - src_start;
} and probability:0.3829787234042553
code:static int ffmmal_read_frame(AVCodecContext *avctx, AVFrame *frame, int *got_frame)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    MMAL_BUFFER_HEADER_T *buffer = NULL;

    MMAL_STATUS_T status = 0;

    int ret = 0;



    if (ctx->eos_received)

        goto done;



    while (1) {

        // To ensure decoding in lockstep with a constant delay between fed packets

        // and output frames, we always wait until an output buffer is available.

        // Except during start we don't know after how many input packets the decoder

        // is going to return the first buffer, and we can't distinguish decoder

        // being busy from decoder waiting for input. So just poll at the start and

        // keep feeding new data to the buffer.

        // We are pretty sure the decoder will produce output if we sent more input

        // frames than what a h264 decoder could logically delay. This avoids too

        // excessive buffering.

        // We also wait if we sent eos, but didn't receive it yet (think of decoding

        // stream with a very low number of frames).

        if (ctx->frames_output || ctx->packets_sent > MAX_DELAYED_FRAMES ||

            (ctx->packets_sent && ctx->eos_sent)) {

            // MMAL will ignore broken input packets, which means the frame we

            // expect here may never arrive. Dealing with this correctly is

            // complicated, so here's a hack to avoid that it freezes forever

            // in this unlikely situation.

            buffer = mmal_queue_timedwait(ctx->queue_decoded_frames, 100);

            if (!buffer) {

                av_log(avctx, AV_LOG_ERROR, "Did not get output frame from MMAL.\n");

                ret = AVERROR_UNKNOWN;

                goto done;

            }

        } else {

            buffer = mmal_queue_get(ctx->queue_decoded_frames);

            if (!buffer)

                goto done;

        }



        ctx->eos_received |= !!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS);

        if (ctx->eos_received)

            goto done;



        if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {

            MMAL_COMPONENT_T *decoder = ctx->decoder;

            MMAL_EVENT_FORMAT_CHANGED_T *ev = mmal_event_format_changed_get(buffer);

            MMAL_BUFFER_HEADER_T *stale_buffer;



            av_log(avctx, AV_LOG_INFO, "Changing output format.\n");



            if ((status = mmal_port_disable(decoder->output[0])))

                goto done;



            while ((stale_buffer = mmal_queue_get(ctx->queue_decoded_frames)))

                mmal_buffer_header_release(stale_buffer);



            mmal_format_copy(decoder->output[0]->format, ev->format);



            if ((ret = ffmal_update_format(avctx)) < 0)

                goto done;



            if ((status = mmal_port_enable(decoder->output[0], output_callback)))

                goto done;



            if ((ret = ffmmal_fill_output_port(avctx)) < 0)

                goto done;



            if ((ret = ffmmal_fill_input_port(avctx)) < 0)

                goto done;



            mmal_buffer_header_release(buffer);

            continue;

        } else if (buffer->cmd) {

            char s[20];

            av_get_codec_tag_string(s, sizeof(s), buffer->cmd);

            av_log(avctx, AV_LOG_WARNING, "Unknown MMAL event %s on output port\n", s);

            goto done;

        } else if (buffer->length == 0) {

            // Unused output buffer that got drained after format change.

            mmal_buffer_header_release(buffer);

            continue;

        }



        ctx->frames_output++;



        if ((ret = ffmal_copy_frame(avctx, frame, buffer)) < 0)

            goto done;



        *got_frame = 1;

        break;

    }



done:

    if (buffer)

        mmal_buffer_header_release(buffer);

    if (status && ret >= 0)

        ret = AVERROR_UNKNOWN;

    return ret;

}
 and probability:0.2289156626506024
code:static int send_dma_request(int cmd, uint64_t sector, int nb_sectors,

                            PrdtEntry *prdt, int prdt_entries,

                            void(*post_exec)(QPCIDevice *dev, void *ide_base,

                                             uint64_t sector, int nb_sectors))

{

    QPCIDevice *dev;

    void *bmdma_base;

    void *ide_base;

    uintptr_t guest_prdt;

    size_t len;

    bool from_dev;

    uint8_t status;

    int flags;



    dev = get_pci_device(&bmdma_base, &ide_base);



    flags = cmd & ~0xff;

    cmd &= 0xff;



    switch (cmd) {

    case CMD_READ_DMA:

    case CMD_PACKET:

        /* Assuming we only test data reads w/ ATAPI, otherwise we need to know

         * the SCSI command being sent in the packet, too. */

        from_dev = true;

        break;

    case CMD_WRITE_DMA:

        from_dev = false;

        break;

    default:

        g_assert_not_reached();

    }



    if (flags & CMDF_NO_BM) {

        qpci_config_writew(dev, PCI_COMMAND,

                           PCI_COMMAND_IO | PCI_COMMAND_MEMORY);

    }



    /* Select device 0 */

    qpci_io_writeb(dev, ide_base + reg_device, 0 | LBA);



    /* Stop any running transfer, clear any pending interrupt */

    qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);

    qpci_io_writeb(dev, bmdma_base + bmreg_status, BM_STS_INTR);



    /* Setup PRDT */

    len = sizeof(*prdt) * prdt_entries;

    guest_prdt = guest_alloc(guest_malloc, len);

    memwrite(guest_prdt, prdt, len);

    qpci_io_writel(dev, bmdma_base + bmreg_prdt, guest_prdt);



    /* ATA DMA command */

    if (cmd == CMD_PACKET) {

        /* Enables ATAPI DMA; otherwise PIO is attempted */

        qpci_io_writeb(dev, ide_base + reg_feature, 0x01);

    } else {

        qpci_io_writeb(dev, ide_base + reg_nsectors, nb_sectors);

        qpci_io_writeb(dev, ide_base + reg_lba_low,    sector & 0xff);

        qpci_io_writeb(dev, ide_base + reg_lba_middle, (sector >> 8) & 0xff);

        qpci_io_writeb(dev, ide_base + reg_lba_high,   (sector >> 16) & 0xff);

    }



    qpci_io_writeb(dev, ide_base + reg_command, cmd);



    if (post_exec) {

        post_exec(dev, ide_base, sector, nb_sectors);

    }



    /* Start DMA transfer */

    qpci_io_writeb(dev, bmdma_base + bmreg_cmd,

                   BM_CMD_START | (from_dev ? BM_CMD_WRITE : 0));



    if (flags & CMDF_ABORT) {

        qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);

    }



    /* Wait for the DMA transfer to complete */

    do {

        status = qpci_io_readb(dev, bmdma_base + bmreg_status);

    } while ((status & (BM_STS_ACTIVE | BM_STS_INTR)) == BM_STS_ACTIVE);



    g_assert_cmpint(get_irq(IDE_PRIMARY_IRQ), ==, !!(status & BM_STS_INTR));



    /* Check IDE status code */

    assert_bit_set(qpci_io_readb(dev, ide_base + reg_status), DRDY);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), BSY | DRQ);



    /* Reading the status register clears the IRQ */

    g_assert(!get_irq(IDE_PRIMARY_IRQ));



    /* Stop DMA transfer if still active */

    if (status & BM_STS_ACTIVE) {

        qpci_io_writeb(dev, bmdma_base + bmreg_cmd, 0);

    }



    free_pci_device(dev);



    return status;

}
 and probability:0.2125
code:static int mxf_read_close(AVFormatContext *s)

{

    MXFContext *mxf = s->priv_data;

    MXFIndexTableSegment *seg;

    int i;



    av_freep(&mxf->packages_refs);



    for (i = 0; i < s->nb_streams; i++)

        s->streams[i]->priv_data = NULL;



    for (i = 0; i < mxf->metadata_sets_count; i++) {

        switch (mxf->metadata_sets[i]->type) {

        case MultipleDescriptor:

            av_freep(&((MXFDescriptor *)mxf->metadata_sets[i])->sub_descriptors_refs);

            break;

        case Sequence:

            av_freep(&((MXFSequence *)mxf->metadata_sets[i])->structural_components_refs);

            break;

        case SourcePackage:

        case MaterialPackage:

            av_freep(&((MXFPackage *)mxf->metadata_sets[i])->tracks_refs);

            break;

        case IndexTableSegment:

            seg = (MXFIndexTableSegment *)mxf->metadata_sets[i];

            av_freep(&seg->temporal_offset_entries);

            av_freep(&seg->flag_entries);

            av_freep(&seg->stream_offset_entries);

            break;

        default:

            break;

        }

        av_freep(&mxf->metadata_sets[i]);

    }

    av_freep(&mxf->partitions);

    av_freep(&mxf->metadata_sets);

    av_freep(&mxf->aesc);

    av_freep(&mxf->local_tags);



    for (i = 0; i < mxf->nb_index_tables; i++) {

        av_freep(&mxf->index_tables[i].segments);

        av_freep(&mxf->index_tables[i].ptses);

        av_freep(&mxf->index_tables[i].fake_index);

    }

    av_freep(&mxf->index_tables);



    return 0;

}
 and probability:0.5348837209302325
code:static int adts_aac_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    int ret, fsize;



    ret = av_get_packet(s->pb, pkt, ADTS_HEADER_SIZE);

    if (ret < 0)

        return ret;

    if (ret < ADTS_HEADER_SIZE) {

        av_packet_unref(pkt);

        return AVERROR(EIO);

    }



    if ((AV_RB16(pkt->data) >> 4) != 0xfff) {

        av_packet_unref(pkt);

        return AVERROR_INVALIDDATA;

    }



    fsize = (AV_RB32(pkt->data + 3) >> 13) & 0x1FFF;

    if (fsize < ADTS_HEADER_SIZE) {

        av_packet_unref(pkt);

        return AVERROR_INVALIDDATA;

    }



    return av_append_packet(s->pb, pkt, fsize - ADTS_HEADER_SIZE);

}
 and probability:0.19047619047619047
code:static int bgr24ToYv12Wrapper(SwsContext *c, const uint8_t *src[],

                              int srcStride[], int srcSliceY, int srcSliceH,

                              uint8_t *dst[], int dstStride[])

{

    rgb24toyv12(

        src[0],

        dst[0] +  srcSliceY       * dstStride[0],

        dst[1] + (srcSliceY >> 1) * dstStride[1],

        dst[2] + (srcSliceY >> 1) * dstStride[2],

        c->srcW, srcSliceH,

        dstStride[0], dstStride[1], srcStride[0]);

    if (dst[3])

        fillPlane(dst[3], dstStride[3], c->srcW, srcSliceH, srcSliceY, 255);

    return srcSliceH;

}
 and probability:0.5333333333333333
code:void rgb15tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	const uint16_t *end;

	uint8_t *d = (uint8_t *)dst;

	const uint16_t *s = (const uint16_t *)src;

	end = s + src_size/2;

	while(s < end)

	{

		register uint16_t bgr;

		bgr = *s++;

		*d++ = (bgr&0x7C00)>>7;

		*d++ = (bgr&0x3E0)>>2;

		*d++ = (bgr&0x1F)<<3;

		*d++ = 0;

	}

}
 and probability:0.375
code:static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)

{

    VP56RangeCoder *c = &s->c;

    int rows, cols;



    ff_vp56_init_range_decoder(&s->c, buf, buf_size);

    s->frames[VP56_FRAME_CURRENT]->key_frame = !vp56_rac_get(c);

    vp56_rac_get(c);

    ff_vp56_init_dequant(s, vp56_rac_gets(c, 6));

    if (s->frames[VP56_FRAME_CURRENT]->key_frame)

    {

        vp56_rac_gets(c, 8);

        if(vp56_rac_gets(c, 5) > 5)

            return AVERROR_INVALIDDATA;

        vp56_rac_gets(c, 2);

        if (vp56_rac_get(c)) {

            av_log(s->avctx, AV_LOG_ERROR, "interlacing not supported\n");

            return AVERROR_PATCHWELCOME;

        }

        rows = vp56_rac_gets(c, 8);  /* number of stored macroblock rows */

        cols = vp56_rac_gets(c, 8);  /* number of stored macroblock cols */

        if (!rows || !cols) {

            av_log(s->avctx, AV_LOG_ERROR, "Invalid size %dx%d\n",

                   cols << 4, rows << 4);

            return AVERROR_INVALIDDATA;

        }

        vp56_rac_gets(c, 8);  /* number of displayed macroblock rows */

        vp56_rac_gets(c, 8);  /* number of displayed macroblock cols */

        vp56_rac_gets(c, 2);

        if (!s->macroblocks || /* first frame */

            16*cols != s->avctx->coded_width ||

            16*rows != s->avctx->coded_height) {

            int ret = ff_set_dimensions(s->avctx, 16 * cols, 16 * rows);

            if (ret < 0)

                return ret;

            return VP56_SIZE_CHANGE;

        }

    } else if (!s->macroblocks)

        return AVERROR_INVALIDDATA;

    return 0;

}
 and probability:0.275
code:static inline int coeff_unpack_golomb(GetBitContext *gb, int qfactor, int qoffset)

{

    int coeff = dirac_get_se_golomb(gb);

    const int sign = FFSIGN(coeff);

    if (coeff)

        coeff = sign*((sign * coeff * qfactor + qoffset) >> 2);

    return coeff;

}
 and probability:0.125
code:int ff_h264_frame_start(H264Context *h)

{

    Picture *pic;

    int i, ret;

    const int pixel_shift = h->pixel_shift;

    int c[4] = {

        1<<(h->sps.bit_depth_luma-1),

        1<<(h->sps.bit_depth_chroma-1),

        1<<(h->sps.bit_depth_chroma-1),

        -1

    };



    if (!ff_thread_can_start_frame(h->avctx)) {

        av_log(h->avctx, AV_LOG_ERROR, "Attempt to start a frame outside SETUP state\n");

        return -1;

    }



    release_unused_pictures(h, 1);

    h->cur_pic_ptr = NULL;



    i = find_unused_picture(h);

    if (i < 0) {

        av_log(h->avctx, AV_LOG_ERROR, "no frame buffer available\n");

        return i;

    }

    pic = &h->DPB[i];



    pic->f.reference            = h->droppable ? 0 : h->picture_structure;

    pic->f.coded_picture_number = h->coded_picture_number++;

    pic->field_picture          = h->picture_structure != PICT_FRAME;



    /*

     * Zero key_frame here; IDR markings per slice in frame or fields are ORed

     * in later.

     * See decode_nal_units().

     */

    pic->f.key_frame = 0;

    pic->sync        = 0;

    pic->mmco_reset  = 0;



    if ((ret = alloc_picture(h, pic)) < 0)

        return ret;

    if(!h->sync && !h->avctx->hwaccel)

        avpriv_color_frame(&pic->f, c);



    h->cur_pic_ptr = pic;

    h->cur_pic     = *h->cur_pic_ptr;

    h->cur_pic.f.extended_data = h->cur_pic.f.data;



    ff_er_frame_start(&h->er);



    assert(h->linesize && h->uvlinesize);



    for (i = 0; i < 16; i++) {

        h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->linesize * ((scan8[i] - scan8[0]) >> 3);

        h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->linesize * ((scan8[i] - scan8[0]) >> 3);

    }

    for (i = 0; i < 16; i++) {

        h->block_offset[16 + i]      =

        h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);

        h->block_offset[48 + 16 + i] =

        h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * h->uvlinesize * ((scan8[i] - scan8[0]) >> 3);

    }



    /* can't be in alloc_tables because linesize isn't known there.

     * FIXME: redo bipred weight to not require extra buffer? */

    for (i = 0; i < h->slice_context_count; i++)

        if (h->thread_context[i]) {

            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);

            if (ret < 0)

                return ret;

        }



    /* Some macroblocks can be accessed before they're available in case

     * of lost slices, MBAFF or threading. */

    memset(h->slice_table, -1,

           (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));



    // s->decode = (h->flags & CODEC_FLAG_PSNR) || !s->encoding ||

    //             h->cur_pic.f.reference /* || h->contains_intra */ || 1;



    /* We mark the current picture as non-reference after allocating it, so

     * that if we break out due to an error it can be released automatically

     * in the next ff_MPV_frame_start().

     * SVQ3 as well as most other codecs have only last/next/current and thus

     * get released even with set reference, besides SVQ3 and others do not

     * mark frames as reference later "naturally". */

    if (h->avctx->codec_id != AV_CODEC_ID_SVQ3)

        h->cur_pic_ptr->f.reference = 0;



    h->cur_pic_ptr->field_poc[0] = h->cur_pic_ptr->field_poc[1] = INT_MAX;



    h->next_output_pic = NULL;



    assert(h->cur_pic_ptr->long_ref == 0);



    return 0;

}
 and probability:0.5
code:static void gen_rfe(DisasContext *s, TCGv_i32 pc, TCGv_i32 cpsr)

{

    gen_set_cpsr(cpsr, CPSR_ERET_MASK);

    tcg_temp_free_i32(cpsr);

    store_reg(s, 15, pc);

    s->is_jmp = DISAS_UPDATE;

}
 and probability:0.14285714285714285
code:static void gen_mfc0(DisasContext *ctx, TCGv arg, int reg, int sel)

{

    const char *rn = "invalid";



    if (sel != 0)

        check_insn(ctx, ISA_MIPS32);



    switch (reg) {

    case 0:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Index));

            rn = "Index";

            break;

        case 1:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_mvpcontrol(arg, cpu_env);

            rn = "MVPControl";

            break;

        case 2:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_mvpconf0(arg, cpu_env);

            rn = "MVPConf0";

            break;

        case 3:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_mvpconf1(arg, cpu_env);

            rn = "MVPConf1";

            break;

        case 4:

            CP0_CHECK(ctx->vp);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPControl));

            rn = "VPControl";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 1:

        switch (sel) {

        case 0:

            CP0_CHECK(!(ctx->insn_flags & ISA_MIPS32R6));

            gen_helper_mfc0_random(arg, cpu_env);

            rn = "Random";

            break;

        case 1:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEControl));

            rn = "VPEControl";

            break;

        case 2:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEConf0));

            rn = "VPEConf0";

            break;

        case 3:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEConf1));

            rn = "VPEConf1";

            break;

        case 4:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_YQMask));

            rn = "YQMask";

            break;

        case 5:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_VPESchedule));

            rn = "VPESchedule";

            break;

        case 6:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load64(arg, offsetof(CPUMIPSState, CP0_VPEScheFBack));

            rn = "VPEScheFBack";

            break;

        case 7:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_VPEOpt));

            rn = "VPEOpt";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 2:

        switch (sel) {

        case 0:

            {

                TCGv_i64 tmp = tcg_temp_new_i64();

                tcg_gen_ld_i64(tmp, cpu_env,

                               offsetof(CPUMIPSState, CP0_EntryLo0));

#if defined(TARGET_MIPS64)

                if (ctx->rxi) {

                    /* Move RI/XI fields to bits 31:30 */

                    tcg_gen_shri_tl(arg, tmp, CP0EnLo_XI);

                    tcg_gen_deposit_tl(tmp, tmp, arg, 30, 2);

                }

#endif

                gen_move_low32(arg, tmp);

                tcg_temp_free_i64(tmp);

            }

            rn = "EntryLo0";

            break;

        case 1:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tcstatus(arg, cpu_env);

            rn = "TCStatus";

            break;

        case 2:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tcbind(arg, cpu_env);

            rn = "TCBind";

            break;

        case 3:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tcrestart(arg, cpu_env);

            rn = "TCRestart";

            break;

        case 4:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tchalt(arg, cpu_env);

            rn = "TCHalt";

            break;

        case 5:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tccontext(arg, cpu_env);

            rn = "TCContext";

            break;

        case 6:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tcschedule(arg, cpu_env);

            rn = "TCSchedule";

            break;

        case 7:

            CP0_CHECK(ctx->insn_flags & ASE_MT);

            gen_helper_mfc0_tcschefback(arg, cpu_env);

            rn = "TCScheFBack";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 3:

        switch (sel) {

        case 0:

            {

                TCGv_i64 tmp = tcg_temp_new_i64();

                tcg_gen_ld_i64(tmp, cpu_env,

                               offsetof(CPUMIPSState, CP0_EntryLo1));

#if defined(TARGET_MIPS64)

                if (ctx->rxi) {

                    /* Move RI/XI fields to bits 31:30 */

                    tcg_gen_shri_tl(arg, tmp, CP0EnLo_XI);

                    tcg_gen_deposit_tl(tmp, tmp, arg, 30, 2);

                }

#endif

                gen_move_low32(arg, tmp);

                tcg_temp_free_i64(tmp);

            }

            rn = "EntryLo1";

            break;

        case 1:

            CP0_CHECK(ctx->vp);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_GlobalNumber));

            rn = "GlobalNumber";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 4:

        switch (sel) {

        case 0:

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_Context));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "Context";

            break;

        case 1:

//            gen_helper_mfc0_contextconfig(arg); /* SmartMIPS ASE */

            rn = "ContextConfig";

            goto cp0_unimplemented;

        case 2:

            CP0_CHECK(ctx->ulri);

            tcg_gen_ld_tl(arg, cpu_env,

                          offsetof(CPUMIPSState, active_tc.CP0_UserLocal));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "UserLocal";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 5:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PageMask));

            rn = "PageMask";

            break;

        case 1:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PageGrain));

            rn = "PageGrain";

            break;

        case 2:

            CP0_CHECK(ctx->sc);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl0));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "SegCtl0";

            break;

        case 3:

            CP0_CHECK(ctx->sc);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl1));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "SegCtl1";

            break;

        case 4:

            CP0_CHECK(ctx->sc);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_SegCtl2));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "SegCtl2";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 6:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Wired));

            rn = "Wired";

            break;

        case 1:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf0));

            rn = "SRSConf0";

            break;

        case 2:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf1));

            rn = "SRSConf1";

            break;

        case 3:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf2));

            rn = "SRSConf2";

            break;

        case 4:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf3));

            rn = "SRSConf3";

            break;

        case 5:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSConf4));

            rn = "SRSConf4";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 7:

        switch (sel) {

        case 0:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_HWREna));

            rn = "HWREna";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 8:

        switch (sel) {

        case 0:

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_BadVAddr));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "BadVAddr";

            break;

        case 1:

            CP0_CHECK(ctx->bi);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_BadInstr));

            rn = "BadInstr";

            break;

        case 2:

            CP0_CHECK(ctx->bp);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_BadInstrP));

            rn = "BadInstrP";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 9:

        switch (sel) {

        case 0:

            /* Mark as an IO operation because we read the time.  */

            if (ctx->tb->cflags & CF_USE_ICOUNT) {

                gen_io_start();

	    }

            gen_helper_mfc0_count(arg, cpu_env);

            if (ctx->tb->cflags & CF_USE_ICOUNT) {

                gen_io_end();

            }

            /* Break the TB to be able to take timer interrupts immediately

               after reading count. BS_STOP isn't sufficient, we need to ensure

               we break completely out of translated code.  */

            gen_save_pc(ctx->pc + 4);

            ctx->bstate = BS_EXCP;

            rn = "Count";

            break;

        /* 6,7 are implementation dependent */

        default:

            goto cp0_unimplemented;

        }

        break;

    case 10:

        switch (sel) {

        case 0:

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EntryHi));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "EntryHi";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 11:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Compare));

            rn = "Compare";

            break;

        /* 6,7 are implementation dependent */

        default:

            goto cp0_unimplemented;

        }

        break;

    case 12:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Status));

            rn = "Status";

            break;

        case 1:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_IntCtl));

            rn = "IntCtl";

            break;

        case 2:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSCtl));

            rn = "SRSCtl";

            break;

        case 3:

            check_insn(ctx, ISA_MIPS32R2);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_SRSMap));

            rn = "SRSMap";

            break;

        default:

            goto cp0_unimplemented;

       }

        break;

    case 13:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Cause));

            rn = "Cause";

            break;

        default:

            goto cp0_unimplemented;

       }

        break;

    case 14:

        switch (sel) {

        case 0:

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EPC));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "EPC";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 15:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_PRid));

            rn = "PRid";

            break;

        case 1:

            check_insn(ctx, ISA_MIPS32R2);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_EBase));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "EBase";

            break;

        case 3:

            check_insn(ctx, ISA_MIPS32R2);

            CP0_CHECK(ctx->cmgcr);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_CMGCRBase));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "CMGCRBase";

            break;

        default:

            goto cp0_unimplemented;

       }

        break;

    case 16:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config0));

            rn = "Config";

            break;

        case 1:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config1));

            rn = "Config1";

            break;

        case 2:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config2));

            rn = "Config2";

            break;

        case 3:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config3));

            rn = "Config3";

            break;

        case 4:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config4));

            rn = "Config4";

            break;

        case 5:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config5));

            rn = "Config5";

            break;

        /* 6,7 are implementation dependent */

        case 6:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config6));

            rn = "Config6";

            break;

        case 7:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Config7));

            rn = "Config7";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 17:

        switch (sel) {

        case 0:

            gen_helper_mfc0_lladdr(arg, cpu_env);

            rn = "LLAddr";

            break;

        case 1:

            CP0_CHECK(ctx->mrp);

            gen_helper_mfc0_maar(arg, cpu_env);

            rn = "MAAR";

            break;

        case 2:

            CP0_CHECK(ctx->mrp);

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_MAARI));

            rn = "MAARI";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 18:

        switch (sel) {

        case 0 ... 7:

            gen_helper_1e0i(mfc0_watchlo, arg, sel);

            rn = "WatchLo";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 19:

        switch (sel) {

        case 0 ...7:

            gen_helper_1e0i(mfc0_watchhi, arg, sel);

            rn = "WatchHi";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 20:

        switch (sel) {

        case 0:

#if defined(TARGET_MIPS64)

            check_insn(ctx, ISA_MIPS3);

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_XContext));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "XContext";

            break;

#endif

        default:

            goto cp0_unimplemented;

        }

        break;

    case 21:

       /* Officially reserved, but sel 0 is used for R1x000 framemask */

        CP0_CHECK(!(ctx->insn_flags & ISA_MIPS32R6));

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Framemask));

            rn = "Framemask";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 22:

        tcg_gen_movi_tl(arg, 0); /* unimplemented */

        rn = "'Diagnostic"; /* implementation dependent */

        break;

    case 23:

        switch (sel) {

        case 0:

            gen_helper_mfc0_debug(arg, cpu_env); /* EJTAG support */

            rn = "Debug";

            break;

        case 1:

//            gen_helper_mfc0_tracecontrol(arg); /* PDtrace support */

            rn = "TraceControl";

            goto cp0_unimplemented;

        case 2:

//            gen_helper_mfc0_tracecontrol2(arg); /* PDtrace support */

            rn = "TraceControl2";

            goto cp0_unimplemented;

        case 3:

//            gen_helper_mfc0_usertracedata(arg); /* PDtrace support */

            rn = "UserTraceData";

            goto cp0_unimplemented;

        case 4:

//            gen_helper_mfc0_tracebpc(arg); /* PDtrace support */

            rn = "TraceBPC";

            goto cp0_unimplemented;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 24:

        switch (sel) {

        case 0:

            /* EJTAG support */

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_DEPC));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "DEPC";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 25:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_Performance0));

            rn = "Performance0";

            break;

        case 1:

//            gen_helper_mfc0_performance1(arg);

            rn = "Performance1";

            goto cp0_unimplemented;

        case 2:

//            gen_helper_mfc0_performance2(arg);

            rn = "Performance2";

            goto cp0_unimplemented;

        case 3:

//            gen_helper_mfc0_performance3(arg);

            rn = "Performance3";

            goto cp0_unimplemented;

        case 4:

//            gen_helper_mfc0_performance4(arg);

            rn = "Performance4";

            goto cp0_unimplemented;

        case 5:

//            gen_helper_mfc0_performance5(arg);

            rn = "Performance5";

            goto cp0_unimplemented;

        case 6:

//            gen_helper_mfc0_performance6(arg);

            rn = "Performance6";

            goto cp0_unimplemented;

        case 7:

//            gen_helper_mfc0_performance7(arg);

            rn = "Performance7";

            goto cp0_unimplemented;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 26:

        switch (sel) {

        case 0:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_ErrCtl));

            rn = "ErrCtl";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 27:

        switch (sel) {

        case 0 ... 3:

            tcg_gen_movi_tl(arg, 0); /* unimplemented */

            rn = "CacheErr";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 28:

        switch (sel) {

        case 0:

        case 2:

        case 4:

        case 6:

            {

                TCGv_i64 tmp = tcg_temp_new_i64();

                tcg_gen_ld_i64(tmp, cpu_env, offsetof(CPUMIPSState, CP0_TagLo));

                gen_move_low32(arg, tmp);

                tcg_temp_free_i64(tmp);

            }

            rn = "TagLo";

            break;

        case 1:

        case 3:

        case 5:

        case 7:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DataLo));

            rn = "DataLo";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 29:

        switch (sel) {

        case 0:

        case 2:

        case 4:

        case 6:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_TagHi));

            rn = "TagHi";

            break;

        case 1:

        case 3:

        case 5:

        case 7:

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DataHi));

            rn = "DataHi";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 30:

        switch (sel) {

        case 0:

            tcg_gen_ld_tl(arg, cpu_env, offsetof(CPUMIPSState, CP0_ErrorEPC));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "ErrorEPC";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    case 31:

        switch (sel) {

        case 0:

            /* EJTAG support */

            gen_mfc0_load32(arg, offsetof(CPUMIPSState, CP0_DESAVE));

            rn = "DESAVE";

            break;

        case 2 ... 7:

            CP0_CHECK(ctx->kscrexist & (1 << sel));

            tcg_gen_ld_tl(arg, cpu_env,

                          offsetof(CPUMIPSState, CP0_KScratch[sel-2]));

            tcg_gen_ext32s_tl(arg, arg);

            rn = "KScratch";

            break;

        default:

            goto cp0_unimplemented;

        }

        break;

    default:

       goto cp0_unimplemented;

    }

    trace_mips_translate_c0("mfc0", rn, reg, sel);

    return;



cp0_unimplemented:

    qemu_log_mask(LOG_UNIMP, "mfc0 %s (reg %d sel %d)\n", rn, reg, sel);

    gen_mfc0_unimplemented(ctx, arg);

}
 and probability:0.05491329479768786
code:static int gdb_handle_packet(GDBState *s, CPUState *env, const char *line_buf)

{

    const char *p;

    int ch, reg_size, type;

    char buf[4096];

    uint8_t mem_buf[4096];

    uint32_t *registers;

    target_ulong addr, len;



#ifdef DEBUG_GDB

    printf("command='%s'\n", line_buf);

#endif

    p = line_buf;

    ch = *p++;

    switch(ch) {

    case '?':

        /* TODO: Make this return the correct value for user-mode.  */

        snprintf(buf, sizeof(buf), "S%02x", SIGTRAP);

        put_packet(s, buf);

        /* Remove all the breakpoints when this query is issued,

         * because gdb is doing and initial connect and the state

         * should be cleaned up.

         */




    case 'c':

        if (*p != '\0') {

            addr = strtoull(p, (char **)&p, 16);

#if defined(TARGET_I386)

            env->eip = addr;

#elif defined (TARGET_PPC)

            env->nip = addr;

#elif defined (TARGET_SPARC)

            env->pc = addr;

            env->npc = addr + 4;

#elif defined (TARGET_ARM)

            env->regs[15] = addr;

#elif defined (TARGET_SH4)

            env->pc = addr;

#elif defined (TARGET_MIPS)

            env->PC[env->current_tc] = addr;

#elif defined (TARGET_CRIS)

            env->pc = addr;

#endif

        }


	return RS_IDLE;












    case 's':

        if (*p != '\0') {

            addr = strtoull(p, (char **)&p, 16);

#if defined(TARGET_I386)

            env->eip = addr;

#elif defined (TARGET_PPC)

            env->nip = addr;

#elif defined (TARGET_SPARC)

            env->pc = addr;

            env->npc = addr + 4;

#elif defined (TARGET_ARM)

            env->regs[15] = addr;

#elif defined (TARGET_SH4)

            env->pc = addr;

#elif defined (TARGET_MIPS)

            env->PC[env->current_tc] = addr;

#elif defined (TARGET_CRIS)

            env->pc = addr;

#endif

        }

        cpu_single_step(env, sstep_flags);


	return RS_IDLE;

    case 'F':

        {

            target_ulong ret;

            target_ulong err;



            ret = strtoull(p, (char **)&p, 16);

            if (*p == ',') {

                p++;

                err = strtoull(p, (char **)&p, 16);

            } else {

                err = 0;

            }

            if (*p == ',')

                p++;

            type = *p;

            if (gdb_current_syscall_cb)

                gdb_current_syscall_cb(s->env, ret, err);

            if (type == 'C') {

                put_packet(s, "T02");

            } else {


            }

        }


    case 'g':

        reg_size = cpu_gdb_read_registers(env, mem_buf);

        memtohex(buf, mem_buf, reg_size);

        put_packet(s, buf);


    case 'G':

        registers = (void *)mem_buf;

        len = strlen(p) / 2;

        hextomem((uint8_t *)registers, p, len);

        cpu_gdb_write_registers(env, mem_buf, len);



    case 'm':

        addr = strtoull(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        len = strtoull(p, NULL, 16);

        if (cpu_memory_rw_debug(env, addr, mem_buf, len, 0) != 0) {

            put_packet (s, "E14");

        } else {

            memtohex(buf, mem_buf, len);

            put_packet(s, buf);

        }


    case 'M':

        addr = strtoull(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        len = strtoull(p, (char **)&p, 16);

        if (*p == ':')

            p++;

        hextomem(mem_buf, p, len);

        if (cpu_memory_rw_debug(env, addr, mem_buf, len, 1) != 0)

            put_packet(s, "E14");

        else



    case 'Z':

        type = strtoul(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        addr = strtoull(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        len = strtoull(p, (char **)&p, 16);

        if (type == 0 || type == 1) {

            if (cpu_breakpoint_insert(env, addr) < 0)

                goto breakpoint_error;


#ifndef CONFIG_USER_ONLY

        } else if (type == 2) {

            if (cpu_watchpoint_insert(env, addr) < 0)

                goto breakpoint_error;


#endif

        } else {

        breakpoint_error:

            put_packet(s, "E22");

        }


    case 'z':

        type = strtoul(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        addr = strtoull(p, (char **)&p, 16);

        if (*p == ',')

            p++;

        len = strtoull(p, (char **)&p, 16);

        if (type == 0 || type == 1) {

            cpu_breakpoint_remove(env, addr);


#ifndef CONFIG_USER_ONLY

        } else if (type == 2) {

            cpu_watchpoint_remove(env, addr);


#endif

        } else {

            goto breakpoint_error;

        }


    case 'q':

    case 'Q':

        /* parse any 'q' packets here */

        if (!strcmp(p,"qemu.sstepbits")) {

            /* Query Breakpoint bit definitions */

            sprintf(buf,"ENABLE=%x,NOIRQ=%x,NOTIMER=%x",

                    SSTEP_ENABLE,

                    SSTEP_NOIRQ,

                    SSTEP_NOTIMER);

            put_packet(s, buf);


        } else if (strncmp(p,"qemu.sstep",10) == 0) {

            /* Display or change the sstep_flags */

            p += 10;

            if (*p != '=') {

                /* Display current setting */

                sprintf(buf,"0x%x", sstep_flags);

                put_packet(s, buf);


            }

            p++;

            type = strtoul(p, (char **)&p, 16);

            sstep_flags = type;



        }

#ifdef CONFIG_LINUX_USER

        else if (strncmp(p, "Offsets", 7) == 0) {

            TaskState *ts = env->opaque;



            sprintf(buf,

                    "Text=" TARGET_ABI_FMT_lx ";Data=" TARGET_ABI_FMT_lx

                    ";Bss=" TARGET_ABI_FMT_lx,

                    ts->info->code_offset,

                    ts->info->data_offset,

                    ts->info->data_offset);

            put_packet(s, buf);


        }

#endif

        /* Fall through.  */

    default:

        /* put empty packet */

        buf[0] = '\0';

        put_packet(s, buf);


    }

    return RS_IDLE;

} and probability:0.2602040816326531
code:static void decode_ac_filter(WmallDecodeCtx *s)

{

    int i;

    s->acfilter_order = get_bits(&s->gb, 4) + 1;

    s->acfilter_scaling = get_bits(&s->gb, 4);



    for(i = 0; i < s->acfilter_order; i++) {

	s->acfilter_coeffs[i] = get_bits(&s->gb, s->acfilter_scaling) + 1;

    }

}
 and probability:0.4444444444444444
code:static void check_loopfilter(void)

{

    LOCAL_ALIGNED_32(uint8_t, base0, [32 + 16 * 16 * 2]);

    LOCAL_ALIGNED_32(uint8_t, base1, [32 + 16 * 16 * 2]);

    VP9DSPContext dsp;

    int dir, wd, wd2, bit_depth;

    static const char *const dir_name[2] = { "h", "v" };

    static const int E[2] = { 20, 28 }, I[2] = { 10, 16 };

    static const int H[2] = { 7, 11 }, F[2] = { 1, 1 };

    declare_func(void, uint8_t *dst, ptrdiff_t stride, int E, int I, int H);



    for (bit_depth = 8; bit_depth <= 12; bit_depth += 2) {

        ff_vp9dsp_init(&dsp, bit_depth, 0);



        for (dir = 0; dir < 2; dir++) {

            int midoff = (dir ? 8 * 8 : 8) * SIZEOF_PIXEL;

            int midoff_aligned = (dir ? 8 * 8 : 16) * SIZEOF_PIXEL;

            uint8_t *buf0 = base0 + midoff_aligned;

            uint8_t *buf1 = base1 + midoff_aligned;



            for (wd = 0; wd < 3; wd++) {

                // 4/8/16wd_8px

                if (check_func(dsp.loop_filter_8[wd][dir],

                               "vp9_loop_filter_%s_%d_8_%dbpp",

                               dir_name[dir], 4 << wd, bit_depth)) {

                    randomize_buffers(0, 0, 8);

                    memcpy(buf1 - midoff, buf0 - midoff,

                           16 * 8 * SIZEOF_PIXEL);

                    call_ref(buf0, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);

                    call_new(buf1, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);

                    if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 8 * SIZEOF_PIXEL))

                        fail();

                    bench_new(buf1, 16 * SIZEOF_PIXEL >> dir, E[0], I[0], H[0]);

                }

            }



            midoff = (dir ? 16 * 8 : 8) * SIZEOF_PIXEL;

            midoff_aligned = (dir ? 16 * 8 : 16) * SIZEOF_PIXEL;



            buf0 = base0 + midoff_aligned;

            buf1 = base1 + midoff_aligned;



            // 16wd_16px loopfilter

            if (check_func(dsp.loop_filter_16[dir],

                           "vp9_loop_filter_%s_16_16_%dbpp",

                           dir_name[dir], bit_depth)) {

                randomize_buffers(0, 0, 16);

                randomize_buffers(0, 8, 16);

                memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);

                call_ref(buf0, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);

                call_new(buf1, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);

                if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))

                    fail();

                bench_new(buf1, 16 * SIZEOF_PIXEL, E[0], I[0], H[0]);

            }



            for (wd = 0; wd < 2; wd++) {

                for (wd2 = 0; wd2 < 2; wd2++) {

                    // mix2 loopfilter

                    if (check_func(dsp.loop_filter_mix2[wd][wd2][dir],

                                   "vp9_loop_filter_mix2_%s_%d%d_16_%dbpp",

                                   dir_name[dir], 4 << wd, 4 << wd2, bit_depth)) {

                        randomize_buffers(0, 0, 16);

                        randomize_buffers(1, 8, 16);

                        memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);

#define M(a) (((a)[1] << 8) | (a)[0])

                        call_ref(buf0, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));

                        call_new(buf1, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));

                        if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))

                            fail();

                        bench_new(buf1, 16 * SIZEOF_PIXEL, M(E), M(I), M(H));

#undef M

                    }

                }

            }

        }

    }

    report("loopfilter");

}
 and probability:0.5277777777777778
code:av_cold void ff_dsputil_init_x86(DSPContext *c, AVCodecContext *avctx)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_7REGS && HAVE_INLINE_ASM

    if (HAVE_MMX && cpu_flags & AV_CPU_FLAG_CMOV)

        c->add_hfyu_median_prediction = ff_add_hfyu_median_prediction_cmov;

#endif



    if (X86_MMX(cpu_flags)) {

#if HAVE_INLINE_ASM

        const int idct_algo = avctx->idct_algo;



        if (avctx->lowres == 0 && avctx->bits_per_raw_sample <= 8) {

            if (idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_SIMPLEMMX) {

                c->idct_put              = ff_simple_idct_put_mmx;

                c->idct_add              = ff_simple_idct_add_mmx;

                c->idct                  = ff_simple_idct_mmx;

                c->idct_permutation_type = FF_SIMPLE_IDCT_PERM;

            } else if (idct_algo == FF_IDCT_XVIDMMX) {

                if (cpu_flags & AV_CPU_FLAG_SSE2) {

                    c->idct_put              = ff_idct_xvid_sse2_put;

                    c->idct_add              = ff_idct_xvid_sse2_add;

                    c->idct                  = ff_idct_xvid_sse2;

                    c->idct_permutation_type = FF_SSE2_IDCT_PERM;

                } else if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

                    c->idct_put              = ff_idct_xvid_mmxext_put;

                    c->idct_add              = ff_idct_xvid_mmxext_add;

                    c->idct                  = ff_idct_xvid_mmxext;

                } else {

                    c->idct_put              = ff_idct_xvid_mmx_put;

                    c->idct_add              = ff_idct_xvid_mmx_add;

                    c->idct                  = ff_idct_xvid_mmx;

                }

            }

        }

#endif /* HAVE_INLINE_ASM */



        dsputil_init_mmx(c, avctx, cpu_flags);

    }



    if (X86_MMXEXT(cpu_flags))

        dsputil_init_mmxext(c, avctx, cpu_flags);



    if (X86_SSE(cpu_flags))

        dsputil_init_sse(c, avctx, cpu_flags);



    if (X86_SSE2(cpu_flags))

        dsputil_init_sse2(c, avctx, cpu_flags);



    if (EXTERNAL_SSSE3(cpu_flags))

        dsputil_init_ssse3(c, avctx, cpu_flags);



    if (EXTERNAL_SSE4(cpu_flags))

        dsputil_init_sse4(c, avctx, cpu_flags);



    if (CONFIG_ENCODERS)

        ff_dsputilenc_init_mmx(c, avctx);

}
 and probability:0.3469387755102041
code:static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,

                                       SingleChannelElement *sce,

                                       const float lambda)

{

    int q, w, w2, g, start = 0;

    int i, j;

    int idx;

    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];

    int bandaddr[TRELLIS_STAGES];

    int minq;

    float mincost;

    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;

    int q0, q1, qcnt = 0;



    for (i = 0; i < 1024; i++) {

        float t = fabsf(sce->coeffs[i]);

        if (t > 0.0f) {

            q0f = FFMIN(q0f, t);

            q1f = FFMAX(q1f, t);

            qnrgf += t*t;

            qcnt++;

        }

    }



    if (!qcnt) {

        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));

        memset(sce->zeroes, 1, sizeof(sce->zeroes));

        return;

    }



    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped

    q0 = coef2minsf(q0f);

    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero

    q1 = coef2maxsf(q1f);

    if (q1 - q0 > 60) {

        int q0low  = q0;

        int q1high = q1;

        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped

        int qnrg = av_clip_uint8(log2f(sqrtf(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);

        q1 = qnrg + 30;

        q0 = qnrg - 30;

        if (q0 < q0low) {

            q1 += q0low - q0;

            q0  = q0low;

        } else if (q1 > q1high) {

            q0 -= q1 - q1high;

            q1  = q1high;

        }

    }



    for (i = 0; i < TRELLIS_STATES; i++) {

        paths[0][i].cost    = 0.0f;

        paths[0][i].prev    = -1;

    }

    for (j = 1; j < TRELLIS_STAGES; j++) {

        for (i = 0; i < TRELLIS_STATES; i++) {

            paths[j][i].cost    = INFINITY;

            paths[j][i].prev    = -2;

        }

    }

    idx = 1;

    abs_pow34_v(s->scoefs, sce->coeffs, 1024);

    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {

        start = w*128;

        for (g = 0; g < sce->ics.num_swb; g++) {

            const float *coefs = &sce->coeffs[start];

            float qmin, qmax;

            int nz = 0;



            bandaddr[idx] = w * 16 + g;

            qmin = INT_MAX;

            qmax = 0.0f;

            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {

                FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];

                if (band->energy <= band->threshold || band->threshold == 0.0f) {

                    sce->zeroes[(w+w2)*16+g] = 1;

                    continue;

                }

                sce->zeroes[(w+w2)*16+g] = 0;

                nz = 1;

                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {

                    float t = fabsf(coefs[w2*128+i]);

                    if (t > 0.0f)

                        qmin = FFMIN(qmin, t);

                    qmax = FFMAX(qmax, t);

                }

            }

            if (nz) {

                int minscale, maxscale;

                float minrd = INFINITY;

                float maxval;

                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped

                minscale = coef2minsf(qmin);

                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero

                maxscale = coef2maxsf(qmax);

                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);

                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);

                maxval = find_max_val(sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);

                for (q = minscale; q < maxscale; q++) {

                    float dist = 0;

                    int cb = find_min_book(maxval, sce->sf_idx[w*16+g]);

                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {

                        FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];

                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],

                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, NULL, 0);

                    }

                    minrd = FFMIN(minrd, dist);



                    for (i = 0; i < q1 - q0; i++) {

                        float cost;

                        cost = paths[idx - 1][i].cost + dist

                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];

                        if (cost < paths[idx][q].cost) {

                            paths[idx][q].cost    = cost;

                            paths[idx][q].prev    = i;

                        }

                    }

                }

            } else {

                for (q = 0; q < q1 - q0; q++) {

                    paths[idx][q].cost = paths[idx - 1][q].cost + 1;

                    paths[idx][q].prev = q;

                }

            }

            sce->zeroes[w*16+g] = !nz;

            start += sce->ics.swb_sizes[g];

            idx++;

        }

    }

    idx--;

    mincost = paths[idx][0].cost;

    minq    = 0;

    for (i = 1; i < TRELLIS_STATES; i++) {

        if (paths[idx][i].cost < mincost) {

            mincost = paths[idx][i].cost;

            minq = i;

        }

    }

    while (idx) {

        sce->sf_idx[bandaddr[idx]] = minq + q0;

        minq = paths[idx][minq].prev;

        idx--;

    }

    //set the same quantizers inside window groups

    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])

        for (g = 0;  g < sce->ics.num_swb; g++)

            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)

                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];

}
 and probability:0.45454545454545453
code:QDict *qdict_get_qdict(const QDict *qdict, const char *key)

{

    return qobject_to_qdict(qdict_get_obj(qdict, key, QTYPE_QDICT));

}
 and probability:0.0
code:static int guess_ni_flag(AVFormatContext *s){

    int i;

    int64_t last_start=0;

    int64_t first_end= INT64_MAX;

    int64_t oldpos= avio_tell(s->pb);

    int *idx;

    int64_t min_pos, pos;



    for(i=0; i<s->nb_streams; i++){

        AVStream *st = s->streams[i];

        int n= st->nb_index_entries;

        unsigned int size;



        if(n <= 0)

            continue;



        if(n >= 2){

            int64_t pos= st->index_entries[0].pos;

            avio_seek(s->pb, pos + 4, SEEK_SET);

            size= avio_rl32(s->pb);

            if(pos + size > st->index_entries[1].pos)

                last_start= INT64_MAX;

        }



        if(st->index_entries[0].pos > last_start)

            last_start= st->index_entries[0].pos;

        if(st->index_entries[n-1].pos < first_end)

            first_end= st->index_entries[n-1].pos;

    }

    avio_seek(s->pb, oldpos, SEEK_SET);

    if (last_start > first_end)

        return 1;

    idx= av_mallocz(sizeof(*idx) * s->nb_streams);

    for (min_pos=pos=0; min_pos!=INT64_MAX; pos= min_pos+1) {

        int64_t max_dts = INT64_MIN/2, min_dts= INT64_MAX/2;

        min_pos = INT64_MAX;



        for (i=0; i<s->nb_streams; i++) {

            AVStream *st = s->streams[i];

            int n= st->nb_index_entries;

            while (idx[i]<n && st->index_entries[idx[i]].pos < pos)

                idx[i]++;

            if (idx[i] < n) {

                min_dts = FFMIN(min_dts, av_rescale_q(st->index_entries[idx[i]].timestamp, st->time_base, AV_TIME_BASE_Q));

                min_pos = FFMIN(min_pos, st->index_entries[idx[i]].pos);

            }

            if (idx[i])

                max_dts = FFMAX(max_dts, av_rescale_q(st->index_entries[idx[i]-1].timestamp, st->time_base, AV_TIME_BASE_Q));

        }

        if(max_dts - min_dts > 2*AV_TIME_BASE) {

            av_free(idx);

            return 1;

        }

    }

    av_free(idx);

    return 0;

}
 and probability:0.5192307692307693
code:static int nut_write_trailer(AVFormatContext *s)

{

    NUTContext *nut = s->priv_data;

    AVIOContext *bc = s->pb, *dyn_bc;

    int i, ret;



    while (nut->header_count < 3)

        write_headers(s, bc);



    ret = avio_open_dyn_buf(&dyn_bc);

    if (ret >= 0 && nut->sp_count) {

        av_assert1(nut->write_index);

        write_index(nut, dyn_bc);

        put_packet(nut, bc, dyn_bc, 1, INDEX_STARTCODE);

    }



    ff_nut_free_sp(nut);

    for (i=0; i<s->nb_streams; i++)

        av_freep(&nut->stream[i].keyframe_pts);



    av_freep(&nut->stream);

    av_freep(&nut->chapter);

    av_freep(&nut->time_base);



    return 0;

}
 and probability:0.47619047619047616
code:static uint32_t arm_ldl_ptw(CPUState *cs, hwaddr addr, bool is_secure,

                            ARMMMUIdx mmu_idx, ARMMMUFaultInfo *fi)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    MemTxAttrs attrs = {};

    AddressSpace *as;



    attrs.secure = is_secure;

    as = arm_addressspace(cs, attrs);

    addr = S1_ptw_translate(env, mmu_idx, addr, attrs, fi);

    if (fi->s1ptw) {

        return 0;

    }

    if (regime_translation_big_endian(env, mmu_idx)) {

        return address_space_ldl_be(as, addr, attrs, NULL);

    } else {

        return address_space_ldl_le(as, addr, attrs, NULL);

    }

}
 and probability:0.10526315789473684
code:void aio_context_acquire(AioContext *ctx)

{

    qemu_rec_mutex_lock(&ctx->lock);

}
 and probability:0.25
code:static void qjson_finalizefn(Object *obj)

{

    QJSON *json = QJSON(obj);



    qobject_decref(QOBJECT(json->str));

}
 and probability:0.2
code:static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t v32, unsigned size)

{

    TyphoonState *s = opaque;

    uint64_t val, oldval, newval;



    if (addr & 4) {

        val = v32 << 32 | s->latch_tmp;

        addr ^= 4;

    } else {

        s->latch_tmp = v32;

        return;

    }



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

        newval = oldval = s->cchip.misc;

        newval &= ~(val & 0x10000ff0);     /* W1C fields */

        if (val & 0x100000) {

            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

            newval |= val & 0x00f00000;    /* ABT field is W1S */

            if ((newval & 0xf0000) == 0) {

                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */



        newval &= ~0xf0000000000ull;       /* WO and RW fields */

        newval |= val & 0xf0000000000ull;

        s->cchip.misc = newval;



        /* Pass on changes to IPI and ITI state.  */

        if ((newval ^ oldval) & 0xff0) {

            int i;

            for (i = 0; i < 4; ++i) {

                AlphaCPU *cpu = s->cchip.cpu[i];

                if (cpu != NULL) {

                    CPUState *cs = CPU(cpu);

                    /* IPI can be either cleared or set by the write.  */

                    if (newval & (1 << (i + 8))) {

                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);

                    } else {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);

                    }



                    /* ITI can only be cleared by the write.  */

                    if ((newval & (1 << (i + 4))) == 0) {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);

                    }

                }

            }

        }

        break;



    case 0x00c0:

        /* MPD: Memory Presence Detect Register.  */

        break;



    case 0x0100: /* AAR0 */

    case 0x0140: /* AAR1 */

    case 0x0180: /* AAR2 */

    case 0x01c0: /* AAR3 */

        /* AAR: Array Address Register.  */

        /* All sorts of information about DRAM.  */

        break;



    case 0x0200: /* DIM0 */

        /* DIM: Device Interrupt Mask Register, CPU0.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);

        break;

    case 0x0240: /* DIM1 */

        /* DIM: Device Interrupt Mask Register, CPU1.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);

        break;



    case 0x0280: /* DIR0 (RO) */

    case 0x02c0: /* DIR1 (RO) */

    case 0x0300: /* DRIR (RO) */

        break;



    case 0x0340:

        /* PRBEN: Probe Enable Register.  */

        break;



    case 0x0380: /* IIC0 */

        s->cchip.iic[0] = val & 0xffffff;

        break;

    case 0x03c0: /* IIC1 */

        s->cchip.iic[1] = val & 0xffffff;

        break;



    case 0x0400: /* MPR0 */

    case 0x0440: /* MPR1 */

    case 0x0480: /* MPR2 */

    case 0x04c0: /* MPR3 */

        /* MPR: Memory Programming Register.  */

        break;



    case 0x0580:

        /* TTR: TIGbus Timing Register.  */

        /* All sorts of stuff related to interrupt delivery timings.  */

        break;

    case 0x05c0:

        /* TDR: TIGbug Device Timing Register.  */

        break;



    case 0x0600:

        /* DIM2: Device Interrupt Mask Register, CPU2.  */

        s->cchip.dim[2] = val;

        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);

        break;

    case 0x0640:

        /* DIM3: Device Interrupt Mask Register, CPU3.  */

        s->cchip.dim[3] = val;

        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);

        break;



    case 0x0680: /* DIR2 (RO) */

    case 0x06c0: /* DIR3 (RO) */

        break;



    case 0x0700: /* IIC2 */

        s->cchip.iic[2] = val & 0xffffff;

        break;

    case 0x0740: /* IIC3 */

        s->cchip.iic[3] = val & 0xffffff;

        break;



    case 0x0780:

        /* PWR: Power Management Control.   */

        break;

    

    case 0x0c00: /* CMONCTLA */

    case 0x0c40: /* CMONCTLB */

    case 0x0c80: /* CMONCNT01 */

    case 0x0cc0: /* CMONCNT23 */

        break;



    default:

        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);

        return;

    }

}
 and probability:0.14705882352941177
code:static void visitor_output_setup(TestOutputVisitorData *data,

                                 const void *unused)

{

    data->qov = qmp_output_visitor_new();

    g_assert(data->qov != NULL);



    data->ov = qmp_output_get_visitor(data->qov);

    g_assert(data->ov != NULL);

}
 and probability:0.5
code:static void group_exponents(AC3EncodeContext *s)

{

    int blk, ch, i;

    int group_size, nb_groups, bit_count;

    uint8_t *p;

    int delta0, delta1, delta2;

    int exp0, exp1;



    bit_count = 0;

    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {

        AC3Block *block = &s->blocks[blk];

        for (ch = 0; ch < s->channels; ch++) {

            if (s->exp_strategy[ch][blk] == EXP_REUSE)

                continue;

            group_size = s->exp_strategy[ch][blk] + (s->exp_strategy[ch][blk] == EXP_D45);

            nb_groups = exponent_group_tab[s->exp_strategy[ch][blk]-1][s->nb_coefs[ch]];

            bit_count += 4 + (nb_groups * 7);

            p = block->exp[ch];



            /* DC exponent */

            exp1 = *p++;

            block->grouped_exp[ch][0] = exp1;



            /* remaining exponents are delta encoded */

            for (i = 1; i <= nb_groups; i++) {

                /* merge three delta in one code */

                exp0   = exp1;

                exp1   = p[0];

                p     += group_size;

                delta0 = exp1 - exp0 + 2;



                exp0   = exp1;

                exp1   = p[0];

                p     += group_size;

                delta1 = exp1 - exp0 + 2;



                exp0   = exp1;

                exp1   = p[0];

                p     += group_size;

                delta2 = exp1 - exp0 + 2;



                block->grouped_exp[ch][i] = ((delta0 * 5 + delta1) * 5) + delta2;

            }

        }

    }



    s->exponent_bits = bit_count;

}
 and probability:0.5365853658536586
code:void sd_write_data(SDState *sd, uint8_t value)

{

    int i;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)

        return;



    if (sd->state != sd_receivingdata_state) {

        fprintf(stderr, "sd_write_data: not in Receiving-Data state\n");

        return;

    }



    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))

        return;



    switch (sd->current_cmd) {

    case 24:	/* CMD24:  WRITE_SINGLE_BLOCK */

        sd->data[sd->data_offset ++] = value;

        if (sd->data_offset >= sd->blk_len) {

            /* TODO: Check CRC before committing */

            sd->state = sd_programming_state;

            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);

            sd->blk_written ++;

            sd->csd[14] |= 0x40;

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

        }

        break;



    case 25:	/* CMD25:  WRITE_MULTIPLE_BLOCK */

        if (sd->data_offset == 0) {

            /* Start of the block - let's check the address is valid */

            if (sd->data_start + sd->blk_len > sd->size) {

                sd->card_status |= ADDRESS_ERROR;

                break;

            }

            if (sd_wp_addr(sd, sd->data_start)) {

                sd->card_status |= WP_VIOLATION;

                break;

            }

        }

        sd->data[sd->data_offset++] = value;

        if (sd->data_offset >= sd->blk_len) {

            /* TODO: Check CRC before committing */

            sd->state = sd_programming_state;

            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);

            sd->blk_written++;

            sd->data_start += sd->blk_len;

            sd->data_offset = 0;

            sd->csd[14] |= 0x40;



            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_receivingdata_state;

        }

        break;



    case 26:	/* CMD26:  PROGRAM_CID */

        sd->data[sd->data_offset ++] = value;

        if (sd->data_offset >= sizeof(sd->cid)) {

            /* TODO: Check CRC before committing */

            sd->state = sd_programming_state;

            for (i = 0; i < sizeof(sd->cid); i ++)

                if ((sd->cid[i] | 0x00) != sd->data[i])

                    sd->card_status |= CID_CSD_OVERWRITE;



            if (!(sd->card_status & CID_CSD_OVERWRITE))

                for (i = 0; i < sizeof(sd->cid); i ++) {

                    sd->cid[i] |= 0x00;

                    sd->cid[i] &= sd->data[i];

                }

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

        }

        break;



    case 27:	/* CMD27:  PROGRAM_CSD */

        sd->data[sd->data_offset ++] = value;

        if (sd->data_offset >= sizeof(sd->csd)) {

            /* TODO: Check CRC before committing */

            sd->state = sd_programming_state;

            for (i = 0; i < sizeof(sd->csd); i ++)

                if ((sd->csd[i] | sd_csd_rw_mask[i]) !=

                    (sd->data[i] | sd_csd_rw_mask[i]))

                    sd->card_status |= CID_CSD_OVERWRITE;



            /* Copy flag (OTP) & Permanent write protect */

            if (sd->csd[14] & ~sd->data[14] & 0x60)

                sd->card_status |= CID_CSD_OVERWRITE;



            if (!(sd->card_status & CID_CSD_OVERWRITE))

                for (i = 0; i < sizeof(sd->csd); i ++) {

                    sd->csd[i] |= sd_csd_rw_mask[i];

                    sd->csd[i] &= sd->data[i];

                }

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

        }

        break;



    case 42:	/* CMD42:  LOCK_UNLOCK */

        sd->data[sd->data_offset ++] = value;

        if (sd->data_offset >= sd->blk_len) {

            /* TODO: Check CRC before committing */

            sd->state = sd_programming_state;

            sd_lock_command(sd);

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

        }

        break;



    case 56:	/* CMD56:  GEN_CMD */

        sd->data[sd->data_offset ++] = value;

        if (sd->data_offset >= sd->blk_len) {

            APP_WRITE_BLOCK(sd->data_start, sd->data_offset);

            sd->state = sd_transfer_state;

        }

        break;



    default:

        fprintf(stderr, "sd_write_data: unknown command\n");

        break;

    }

}
 and probability:0.5321100917431193
code:int event_notifier_get_fd(EventNotifier *e)

{

    return e->fd;

}
 and probability:0.25
code:opts_type_size(Visitor *v, const char *name, uint64_t *obj, Error **errp)

{

    OptsVisitor *ov = to_ov(v);

    const QemuOpt *opt;

    int64_t val;



    opt = lookup_scalar(ov, name, errp);

    if (!opt) {

        return;

    }



    val = qemu_strtosz(opt->str ? opt->str : "", NULL);

    if (val < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, opt->name,

                   "a size value representible as a non-negative int64");

        return;

    }



    *obj = val;

    processed(ov, name);

}
 and probability:0.2222222222222222
code:static void handle_mousemotion(SDL_Event *ev)

{

    int max_x, max_y;

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);



    if (qemu_input_is_absolute() || absolute_enabled) {

        int scr_w, scr_h;

        SDL_GetWindowSize(scon->real_window, &scr_w, &scr_h);

        max_x = scr_w - 1;

        max_y = scr_h - 1;

        if (gui_grab && (ev->motion.x == 0 || ev->motion.y == 0 ||

                         ev->motion.x == max_x || ev->motion.y == max_y)) {

            sdl_grab_end(scon);

        }

        if (!gui_grab &&

            (ev->motion.x > 0 && ev->motion.x < max_x &&

             ev->motion.y > 0 && ev->motion.y < max_y)) {

            sdl_grab_start(scon);

        }

    }

    if (gui_grab || qemu_input_is_absolute() || absolute_enabled) {

        sdl_send_mouse_event(scon, ev->motion.xrel, ev->motion.yrel,

                             ev->motion.x, ev->motion.y, ev->motion.state);

    }

}
 and probability:0.4166666666666667
code:static int qemu_rdma_registration_stop(QEMUFile *f, void *opaque,

                                       uint64_t flags)

{

    Error *local_err = NULL, **errp = &local_err;

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;

    RDMAControlHeader head = { .len = 0, .repeat = 1 };

    int ret = 0;



    CHECK_ERROR_STATE();



    qemu_fflush(f);

    ret = qemu_rdma_drain_cq(f, rdma);



    if (ret < 0) {

        goto err;

    }



    if (flags == RAM_CONTROL_SETUP) {

        RDMAControlHeader resp = {.type = RDMA_CONTROL_RAM_BLOCKS_RESULT };

        RDMALocalBlocks *local = &rdma->local_ram_blocks;

        int reg_result_idx, i, j, nb_remote_blocks;



        head.type = RDMA_CONTROL_RAM_BLOCKS_REQUEST;

        DPRINTF("Sending registration setup for ram blocks...\n");



        /*

         * Make sure that we parallelize the pinning on both sides.

         * For very large guests, doing this serially takes a really

         * long time, so we have to 'interleave' the pinning locally

         * with the control messages by performing the pinning on this

         * side before we receive the control response from the other

         * side that the pinning has completed.

         */

        ret = qemu_rdma_exchange_send(rdma, &head, NULL, &resp,

                    &reg_result_idx, rdma->pin_all ?

                    qemu_rdma_reg_whole_ram_blocks : NULL);

        if (ret < 0) {

            ERROR(errp, "receiving remote info!");

            return ret;

        }



        qemu_rdma_move_header(rdma, reg_result_idx, &resp);

        memcpy(rdma->block,

            rdma->wr_data[reg_result_idx].control_curr, resp.len);



        nb_remote_blocks = resp.len / sizeof(RDMARemoteBlock);



        /*

         * The protocol uses two different sets of rkeys (mutually exclusive):

         * 1. One key to represent the virtual address of the entire ram block.

         *    (dynamic chunk registration disabled - pin everything with one rkey.)

         * 2. One to represent individual chunks within a ram block.

         *    (dynamic chunk registration enabled - pin individual chunks.)

         *

         * Once the capability is successfully negotiated, the destination transmits

         * the keys to use (or sends them later) including the virtual addresses

         * and then propagates the remote ram block descriptions to his local copy.

         */



        if (local->nb_blocks != nb_remote_blocks) {

            ERROR(errp, "ram blocks mismatch #1! "

                        "Your QEMU command line parameters are probably "

                        "not identical on both the source and destination.");

            return -EINVAL;

        }



        for (i = 0; i < nb_remote_blocks; i++) {

            network_to_remote_block(&rdma->block[i]);



            /* search local ram blocks */

            for (j = 0; j < local->nb_blocks; j++) {

                if (rdma->block[i].offset != local->block[j].offset) {

                    continue;

                }



                if (rdma->block[i].length != local->block[j].length) {

                    ERROR(errp, "ram blocks mismatch #2! "

                        "Your QEMU command line parameters are probably "

                        "not identical on both the source and destination.");

                    return -EINVAL;

                }

                local->block[j].remote_host_addr =

                        rdma->block[i].remote_host_addr;

                local->block[j].remote_rkey = rdma->block[i].remote_rkey;

                break;

            }



            if (j >= local->nb_blocks) {

                ERROR(errp, "ram blocks mismatch #3! "

                        "Your QEMU command line parameters are probably "

                        "not identical on both the source and destination.");

                return -EINVAL;

            }

        }

    }



    DDDPRINTF("Sending registration finish %" PRIu64 "...\n", flags);



    head.type = RDMA_CONTROL_REGISTER_FINISHED;

    ret = qemu_rdma_exchange_send(rdma, &head, NULL, NULL, NULL, NULL);



    if (ret < 0) {

        goto err;

    }



    return 0;

err:

    rdma->error_state = ret;

    return ret;

}
 and probability:0.1827956989247312
code:static void xen_platform_ioport_writeb(void *opaque, uint32_t addr, uint32_t val)

{

    PCIXenPlatformState *s = opaque;



    addr &= 0xff;

    val  &= 0xff;



    switch (addr) {

    case 0: /* Platform flags */

        platform_fixed_ioport_writeb(opaque, XEN_PLATFORM_IOPORT, val);

        break;

    case 8:

        log_writeb(s, val);

        break;

    default:

        break;

    }

}
 and probability:0.0
code:static uint32_t nabm_readb (void *opaque, uint32_t addr)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    AC97BusMasterRegs *r = NULL;

    uint32_t index = addr - s->base[1];

    uint32_t val = ~0U;



    switch (index) {

    case CAS:

        dolog ("CAS %d\n", s->cas);

        val = s->cas;

        s->cas = 1;

        break;

    case PI_CIV:

    case PO_CIV:

    case MC_CIV:

        r = &s->bm_regs[GET_BM (index)];

        val = r->civ;

        dolog ("CIV[%d] -> %#x\n", GET_BM (index), val);

        break;

    case PI_LVI:

    case PO_LVI:

    case MC_LVI:

        r = &s->bm_regs[GET_BM (index)];

        val = r->lvi;

        dolog ("LVI[%d] -> %#x\n", GET_BM (index), val);

        break;

    case PI_PIV:

    case PO_PIV:

    case MC_PIV:

        r = &s->bm_regs[GET_BM (index)];

        val = r->piv;

        dolog ("PIV[%d] -> %#x\n", GET_BM (index), val);

        break;

    case PI_CR:

    case PO_CR:

    case MC_CR:

        r = &s->bm_regs[GET_BM (index)];

        val = r->cr;

        dolog ("CR[%d] -> %#x\n", GET_BM (index), val);

        break;

    case PI_SR:

    case PO_SR:

    case MC_SR:

        r = &s->bm_regs[GET_BM (index)];

        val = r->sr & 0xff;

        dolog ("SRb[%d] -> %#x\n", GET_BM (index), val);

        break;

    default:

        dolog ("U nabm readb %#x -> %#x\n", addr, val);

        break;

    }

    return val;

}
 and probability:0.2777777777777778
code:static int ac3_encode_frame(AVCodecContext *avctx,

                            unsigned char *frame, int buf_size, void *data)

{

    AC3EncodeContext *s = avctx->priv_data;

    const int16_t *samples = data;

    int16_t planar_samples[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE+AC3_FRAME_SIZE];

    int32_t mdct_coef[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];

    uint8_t exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];

    uint8_t exp_strategy[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];

    uint8_t encoded_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];

    uint8_t num_exp_groups[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];

    uint8_t grouped_exp[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_EXP_GROUPS];

    uint8_t bap[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];

    int8_t exp_shift[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS];

    uint16_t qmant[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS];

    int frame_bits;



    if (s->bit_alloc.sr_code == 1)

        adjust_frame_size(s);



    deinterleave_input_samples(s, samples, planar_samples);



    apply_mdct(s, planar_samples, exp_shift, mdct_coef);



    frame_bits = process_exponents(s, mdct_coef, exp_shift, exp, exp_strategy,

                                   encoded_exp, num_exp_groups, grouped_exp);



    compute_bit_allocation(s, bap, encoded_exp, exp_strategy, frame_bits);



    quantize_mantissas(s, mdct_coef, exp_shift, encoded_exp, bap, qmant);



    output_frame(s, frame, exp_strategy, num_exp_groups, grouped_exp, bap, qmant);



    return s->frame_size;

}
 and probability:0.14814814814814814
code:void cpu_physical_memory_write_rom(target_phys_addr_t addr,

                                   const uint8_t *buf, int len)

{

    AddressSpaceDispatch *d = address_space_memory.dispatch;

    int l;

    uint8_t *ptr;

    target_phys_addr_t page;

    MemoryRegionSection *section;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        section = phys_page_find(d, page >> TARGET_PAGE_BITS);



        if (!(memory_region_is_ram(section->mr) ||

              memory_region_is_romd(section->mr))) {

            /* do nothing */

        } else {

            unsigned long addr1;

            addr1 = memory_region_get_ram_addr(section->mr)

                + memory_region_section_addr(section, addr);

            /* ROM/RAM case */

            ptr = qemu_get_ram_ptr(addr1);

            memcpy(ptr, buf, l);

            invalidate_and_set_dirty(addr1, l);

            qemu_put_ram_ptr(ptr);

        }

        len -= l;

        buf += l;

        addr += l;

    }

}
 and probability:0.21875
code:av_cold int ff_lpc_init(LPCContext *s, int blocksize, int max_order,

                        enum FFLPCType lpc_type)

{

    s->blocksize = blocksize;

    s->max_order = max_order;

    s->lpc_type  = lpc_type;



    if (lpc_type == FF_LPC_TYPE_LEVINSON) {

        s->windowed_samples = av_mallocz((blocksize + max_order + 2) *

                                         sizeof(*s->windowed_samples));

        if (!s->windowed_samples)

            return AVERROR(ENOMEM);

    } else {

        s->windowed_samples = NULL;

    }



    s->lpc_apply_welch_window = lpc_apply_welch_window_c;

    s->lpc_compute_autocorr   = lpc_compute_autocorr_c;



    if (HAVE_MMX)

        ff_lpc_init_x86(s);



    return 0;

}
 and probability:0.45
code:static int audio_decode_frame(VideoState *is, double *pts_ptr)

{

    AVPacket *pkt_temp = &is->audio_pkt_temp;

    AVPacket *pkt = &is->audio_pkt;

    AVCodecContext *dec = is->audio_st->codec;

    int len1, len2, data_size, resampled_data_size;

    int64_t dec_channel_layout;

    int got_frame;

    double pts;

    int new_packet = 0;

    int flush_complete = 0;

    int wanted_nb_samples;



    for (;;) {

        /* NOTE: the audio packet can contain several frames */

        while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet)) {

            if (!is->frame) {

                if (!(is->frame = avcodec_alloc_frame()))

                    return AVERROR(ENOMEM);

            } else

                avcodec_get_frame_defaults(is->frame);



            if (is->paused)

                return -1;



            if (flush_complete)

                break;

            new_packet = 0;

            len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);

            if (len1 < 0) {

                /* if error, we skip the frame */

                pkt_temp->size = 0;

                break;

            }



            pkt_temp->data += len1;

            pkt_temp->size -= len1;



            if (!got_frame) {

                /* stop sending empty packets if the decoder is finished */

                if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)

                    flush_complete = 1;

                continue;

            }

            data_size = av_samples_get_buffer_size(NULL, dec->channels,

                                                   is->frame->nb_samples,

                                                   dec->sample_fmt, 1);



            dec_channel_layout = (dec->channel_layout && dec->channels == av_get_channel_layout_nb_channels(dec->channel_layout)) ? dec->channel_layout : av_get_default_channel_layout(dec->channels);

            wanted_nb_samples = synchronize_audio(is, is->frame->nb_samples);



            if (dec->sample_fmt != is->audio_src.fmt ||

                dec_channel_layout != is->audio_src.channel_layout ||

                dec->sample_rate != is->audio_src.freq ||

                (wanted_nb_samples != is->frame->nb_samples && !is->swr_ctx)) {

                if (is->swr_ctx)

                    swr_free(&is->swr_ctx);

                is->swr_ctx = swr_alloc_set_opts(NULL,

                                                 is->audio_tgt.channel_layout, is->audio_tgt.fmt, is->audio_tgt.freq,

                                                 dec_channel_layout,           dec->sample_fmt,   dec->sample_rate,

                                                 0, NULL);

                if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {

                    fprintf(stderr, "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n",

                        dec->sample_rate,

                        av_get_sample_fmt_name(dec->sample_fmt),

                        dec->channels,

                        is->audio_tgt.freq,

                        av_get_sample_fmt_name(is->audio_tgt.fmt),

                        is->audio_tgt.channels);

                    break;

                }

                is->audio_src.channel_layout = dec_channel_layout;

                is->audio_src.channels = dec->channels;

                is->audio_src.freq = dec->sample_rate;

                is->audio_src.fmt = dec->sample_fmt;

            }



            resampled_data_size = data_size;

            if (is->swr_ctx) {

                const uint8_t *in[] = { is->frame->data[0] };

                uint8_t *out[] = {is->audio_buf2};

                if (wanted_nb_samples != is->frame->nb_samples) {

                    if (swr_set_compensation(is->swr_ctx, (wanted_nb_samples - is->frame->nb_samples) * is->audio_tgt.freq / dec->sample_rate,

                                                wanted_nb_samples * is->audio_tgt.freq / dec->sample_rate) < 0) {

                        fprintf(stderr, "swr_set_compensation() failed\n");

                        break;

                    }

                }

                len2 = swr_convert(is->swr_ctx, out, sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt),

                                                in, is->frame->nb_samples);

                if (len2 < 0) {

                    fprintf(stderr, "swr_convert() failed\n");

                    break;

                }

                if (len2 == sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt)) {

                    fprintf(stderr, "warning: audio buffer is probably too small\n");

                    swr_init(is->swr_ctx);

                }

                is->audio_buf = is->audio_buf2;

                resampled_data_size = len2 * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);

            } else {

                is->audio_buf = is->frame->data[0];

            }



            /* if no pts, then compute it */

            pts = is->audio_clock;

            *pts_ptr = pts;

            is->audio_clock += (double)data_size /

                (dec->channels * dec->sample_rate * av_get_bytes_per_sample(dec->sample_fmt));

#ifdef DEBUG

            {

                static double last_clock;

                printf("audio: delay=%0.3f clock=%0.3f pts=%0.3f\n",

                       is->audio_clock - last_clock,

                       is->audio_clock, pts);

                last_clock = is->audio_clock;

            }

#endif

            return resampled_data_size;

        }



        /* free the current packet */

        if (pkt->data)

            av_free_packet(pkt);

        memset(pkt_temp, 0, sizeof(*pkt_temp));



        if (is->paused || is->audioq.abort_request) {

            return -1;

        }



        /* read next packet */

        if ((new_packet = packet_queue_get(&is->audioq, pkt, 1)) < 0)

            return -1;



        if (pkt->data == flush_pkt.data) {

            avcodec_flush_buffers(dec);

            flush_complete = 0;

        }



        *pkt_temp = *pkt;



        /* if update the audio clock with the pts */

        if (pkt->pts != AV_NOPTS_VALUE) {

            is->audio_clock = av_q2d(is->audio_st->time_base)*pkt->pts;

        }

    }

}
 and probability:0.5
code:void YM3812UpdateOne(FM_OPL *OPL, INT16 *buffer, int length)

{

    int i;

	int data;

	OPLSAMPLE *buf = buffer;

	UINT32 amsCnt  = OPL->amsCnt;

	UINT32 vibCnt  = OPL->vibCnt;

	UINT8 rythm = OPL->rythm&0x20;

	OPL_CH *CH,*R_CH;



	if( (void *)OPL != cur_chip ){

		cur_chip = (void *)OPL;

		/* channel pointers */

		S_CH = OPL->P_CH;

		E_CH = &S_CH[9];

		/* rythm slot */

		SLOT7_1 = &S_CH[7].SLOT[SLOT1];

		SLOT7_2 = &S_CH[7].SLOT[SLOT2];

		SLOT8_1 = &S_CH[8].SLOT[SLOT1];

		SLOT8_2 = &S_CH[8].SLOT[SLOT2];

		/* LFO state */

		amsIncr = OPL->amsIncr;

		vibIncr = OPL->vibIncr;

		ams_table = OPL->ams_table;

		vib_table = OPL->vib_table;

	}

	R_CH = rythm ? &S_CH[6] : E_CH;

    for( i=0; i < length ; i++ )

	{

		/*            channel A         channel B         channel C      */

		/* LFO */

		ams = ams_table[(amsCnt+=amsIncr)>>AMS_SHIFT];

		vib = vib_table[(vibCnt+=vibIncr)>>VIB_SHIFT];

		outd[0] = 0;

		/* FM part */

		for(CH=S_CH ; CH < R_CH ; CH++)

			OPL_CALC_CH(CH);

		/* Rythn part */

		if(rythm)

			OPL_CALC_RH(S_CH);

		/* limit check */

		data = Limit( outd[0] , OPL_MAXOUT, OPL_MINOUT );

		/* store to sound buffer */

		buf[i] = data >> OPL_OUTSB;

	}



	OPL->amsCnt = amsCnt;

	OPL->vibCnt = vibCnt;

#ifdef OPL_OUTPUT_LOG

	if(opl_dbg_fp)

	{

		for(opl_dbg_chip=0;opl_dbg_chip<opl_dbg_maxchip;opl_dbg_chip++)

			if( opl_dbg_opl[opl_dbg_chip] == OPL) break;

		fprintf(opl_dbg_fp,"%c%c%c",0x20+opl_dbg_chip,length&0xff,length/256);

	}

#endif

}
 and probability:0.4727272727272727
code:static void omap_tipb_bridge_write(void *opaque, target_phys_addr_t addr,

                                   uint64_t value, unsigned size)

{

    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *) opaque;



    if (size < 2) {

        return omap_badwidth_write16(opaque, addr, value);

    }



    switch (addr) {

    case 0x00:	/* TIPB_CNTL */

        s->control = value & 0xffff;

        break;



    case 0x04:	/* TIPB_BUS_ALLOC */

        s->alloc = value & 0x003f;

        break;



    case 0x08:	/* MPU_TIPB_CNTL */

        s->buffer = value & 0x0003;

        break;



    case 0x0c:	/* ENHANCED_TIPB_CNTL */

        s->width_intr = !(value & 2);

        s->enh_control = value & 0x000f;

        break;



    case 0x10:	/* ADDRESS_DBG */

    case 0x14:	/* DATA_DEBUG_LOW */

    case 0x18:	/* DATA_DEBUG_HIGH */

    case 0x1c:	/* DEBUG_CNTR_SIG */

        OMAP_RO_REG(addr);

        break;



    default:

        OMAP_BAD_REG(addr);

    }

}
 and probability:0.16129032258064516
code:PCIDevice *pci_register_device(PCIBus *bus, const char *name,

                               int instance_size, int devfn,

                               PCIConfigReadFunc *config_read,

                               PCIConfigWriteFunc *config_write)

{

    PCIDevice *pci_dev;



    pci_dev = qemu_mallocz(instance_size);

    pci_dev = do_pci_register_device(pci_dev, bus, name, devfn,

                                     config_read, config_write);

    return pci_dev;

}
 and probability:0.0
code:int64 float64_to_int64_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    bits64 aSig;

    int64 z;



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( aExp ) aSig |= LIT64( 0x0010000000000000 );

    shiftCount = aExp - 0x433;

    if ( 0 <= shiftCount ) {

        if ( 0x43E <= aExp ) {

            if ( a != LIT64( 0xC3E0000000000000 ) ) {

                float_raise( float_flag_invalid STATUS_VAR);

                if (    ! aSign

                     || (    ( aExp == 0x7FF )

                          && ( aSig != LIT64( 0x0010000000000000 ) ) )

                   ) {

                    return LIT64( 0x7FFFFFFFFFFFFFFF );

                }

            }

            return (sbits64) LIT64( 0x8000000000000000 );

        }

        z = aSig<<shiftCount;

    }

    else {

        if ( aExp < 0x3FE ) {

            if ( aExp | aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

            return 0;

        }

        z = aSig>>( - shiftCount );

        if ( (bits64) ( aSig<<( shiftCount & 63 ) ) ) {

            STATUS(float_exception_flags) |= float_flag_inexact;

        }

    }

    if ( aSign ) z = - z;

    return z;



}
 and probability:0.02564102564102564
code:static void icount_warp_rt(void)

{

    unsigned seq;

    int64_t warp_start;



    /* The icount_warp_timer is rescheduled soon after vm_clock_warp_start

     * changes from -1 to another value, so the race here is okay.

     */

    do {

        seq = seqlock_read_begin(&timers_state.vm_clock_seqlock);

        warp_start = vm_clock_warp_start;

    } while (seqlock_read_retry(&timers_state.vm_clock_seqlock, seq));



    if (warp_start == -1) {

        return;

    }



    seqlock_write_begin(&timers_state.vm_clock_seqlock);

    if (runstate_is_running()) {

        int64_t clock = REPLAY_CLOCK(REPLAY_CLOCK_VIRTUAL_RT,

                                     cpu_get_clock_locked());

        int64_t warp_delta;



        warp_delta = clock - vm_clock_warp_start;

        if (use_icount == 2) {

            /*

             * In adaptive mode, do not let QEMU_CLOCK_VIRTUAL run too

             * far ahead of real time.

             */

            int64_t cur_icount = cpu_get_icount_locked();

            int64_t delta = clock - cur_icount;

            warp_delta = MIN(warp_delta, delta);

        }

        timers_state.qemu_icount_bias += warp_delta;

    }

    vm_clock_warp_start = -1;

    seqlock_write_end(&timers_state.vm_clock_seqlock);



    if (qemu_clock_expired(QEMU_CLOCK_VIRTUAL)) {

        qemu_clock_notify(QEMU_CLOCK_VIRTUAL);

    }

}
 and probability:0.08108108108108109
code:void bdrv_aio_cancel(BlockAIOCB *acb)

{

    qemu_aio_ref(acb);

    bdrv_aio_cancel_async(acb);

    while (acb->refcnt > 1) {

        if (acb->aiocb_info->get_aio_context) {

            aio_poll(acb->aiocb_info->get_aio_context(acb), true);

        } else if (acb->bs) {

            aio_poll(bdrv_get_aio_context(acb->bs), true);

        } else {

            abort();

        }

    }

    qemu_aio_unref(acb);

}
 and probability:0.3333333333333333
code:static void vnc_listen_read(void *opaque, bool websocket)

{

    VncDisplay *vs = opaque;

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int csock;



    /* Catch-up */

    graphic_hw_update(vs->dcl.con);

#ifdef CONFIG_VNC_WS

    if (websocket) {

        csock = qemu_accept(vs->lwebsock, (struct sockaddr *)&addr, &addrlen);

    } else

#endif /* CONFIG_VNC_WS */

    {

        csock = qemu_accept(vs->lsock, (struct sockaddr *)&addr, &addrlen);

    }



    if (csock != -1) {

        socket_set_nodelay(csock);

        vnc_connect(vs, csock, false, websocket);

    }

}
 and probability:0.14285714285714285
code:static void gen_sraq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_sar_tl(t1, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_subfi_tl(t2, 32, t2);

    tcg_gen_shl_tl(t2, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_or_tl(t0, t0, t2);

    gen_store_spr(SPR_MQ, t0);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l1);

    tcg_gen_mov_tl(t2, cpu_gpr[rS(ctx->opcode)]);

    tcg_gen_sari_tl(t1, cpu_gpr[rS(ctx->opcode)], 31);

    gen_set_label(l1);

    tcg_temp_free(t0);

    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t1);

    tcg_gen_movi_tl(cpu_ca, 0);

    tcg_gen_brcondi_tl(TCG_COND_GE, t1, 0, l2);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t2, 0, l2);

    tcg_gen_movi_tl(cpu_ca, 1);

    gen_set_label(l2);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
 and probability:0.3225806451612903
code:static void reverse_dc_prediction(Vp3DecodeContext *s,

                                  int first_fragment,

                                  int fragment_width,

                                  int fragment_height)

{



#define PUL 8

#define PU 4

#define PUR 2

#define PL 1



    int x, y;

    int i = first_fragment;



    int predicted_dc;



    /* DC values for the left, up-left, up, and up-right fragments */

    int vl, vul, vu, vur;



    /* indexes for the left, up-left, up, and up-right fragments */

    int l, ul, u, ur;



    /*

     * The 6 fields mean:

     *   0: up-left multiplier

     *   1: up multiplier

     *   2: up-right multiplier

     *   3: left multiplier

     */

    static const int predictor_transform[16][4] = {

        {  0,  0,  0,  0},

        {  0,  0,  0,128},        // PL

        {  0,  0,128,  0},        // PUR

        {  0,  0, 53, 75},        // PUR|PL

        {  0,128,  0,  0},        // PU

        {  0, 64,  0, 64},        // PU|PL

        {  0,128,  0,  0},        // PU|PUR

        {  0,  0, 53, 75},        // PU|PUR|PL

        {128,  0,  0,  0},        // PUL

        {  0,  0,  0,128},        // PUL|PL

        { 64,  0, 64,  0},        // PUL|PUR

        {  0,  0, 53, 75},        // PUL|PUR|PL

        {  0,128,  0,  0},        // PUL|PU

       {-104,116,  0,116},        // PUL|PU|PL

        { 24, 80, 24,  0},        // PUL|PU|PUR

       {-104,116,  0,116}         // PUL|PU|PUR|PL

    };



    /* This table shows which types of blocks can use other blocks for

     * prediction. For example, INTRA is the only mode in this table to

     * have a frame number of 0. That means INTRA blocks can only predict

     * from other INTRA blocks. There are 2 golden frame coding types;

     * blocks encoding in these modes can only predict from other blocks

     * that were encoded with these 1 of these 2 modes. */

    static const unsigned char compatible_frame[8] = {

        1,    /* MODE_INTER_NO_MV */

        0,    /* MODE_INTRA */

        1,    /* MODE_INTER_PLUS_MV */

        1,    /* MODE_INTER_LAST_MV */

        1,    /* MODE_INTER_PRIOR_MV */

        2,    /* MODE_USING_GOLDEN */

        2,    /* MODE_GOLDEN_MV */

        1     /* MODE_INTER_FOUR_MV */

    };

    int current_frame_type;



    /* there is a last DC predictor for each of the 3 frame types */

    short last_dc[3];



    int transform = 0;



    vul = vu = vur = vl = 0;

    last_dc[0] = last_dc[1] = last_dc[2] = 0;



    /* for each fragment row... */

    for (y = 0; y < fragment_height; y++) {



        /* for each fragment in a row... */

        for (x = 0; x < fragment_width; x++, i++) {



            /* reverse prediction if this block was coded */

            if (s->all_fragments[i].coding_method != MODE_COPY) {



                current_frame_type =

                    compatible_frame[s->all_fragments[i].coding_method];



                transform= 0;

                if(x){

                    l= i-1;

                    vl = DC_COEFF(l);

                    if(FRAME_CODED(l) && COMPATIBLE_FRAME(l))

                        transform |= PL;

                }

                if(y){

                    u= i-fragment_width;

                    vu = DC_COEFF(u);

                    if(FRAME_CODED(u) && COMPATIBLE_FRAME(u))

                        transform |= PU;

                    if(x){

                        ul= i-fragment_width-1;

                        vul = DC_COEFF(ul);

                        if(FRAME_CODED(ul) && COMPATIBLE_FRAME(ul))

                            transform |= PUL;

                    }

                    if(x + 1 < fragment_width){

                        ur= i-fragment_width+1;

                        vur = DC_COEFF(ur);

                        if(FRAME_CODED(ur) && COMPATIBLE_FRAME(ur))

                            transform |= PUR;

                    }

                }



                if (transform == 0) {



                    /* if there were no fragments to predict from, use last

                     * DC saved */

                    predicted_dc = last_dc[current_frame_type];

                } else {



                    /* apply the appropriate predictor transform */

                    predicted_dc =

                        (predictor_transform[transform][0] * vul) +

                        (predictor_transform[transform][1] * vu) +

                        (predictor_transform[transform][2] * vur) +

                        (predictor_transform[transform][3] * vl);



                    predicted_dc /= 128;



                    /* check for outranging on the [ul u l] and

                     * [ul u ur l] predictors */

                    if ((transform == 13) || (transform == 15)) {

                        if (FFABS(predicted_dc - vu) > 128)

                            predicted_dc = vu;

                        else if (FFABS(predicted_dc - vl) > 128)

                            predicted_dc = vl;

                        else if (FFABS(predicted_dc - vul) > 128)

                            predicted_dc = vul;

                    }

                }



                /* at long last, apply the predictor */

                if(s->coeffs[i].index){

                    *s->next_coeff= s->coeffs[i];

                    s->coeffs[i].index=0;

                    s->coeffs[i].coeff=0;

                    s->coeffs[i].next= s->next_coeff++;

                }

                s->coeffs[i].coeff += predicted_dc;

                /* save the DC */

                last_dc[current_frame_type] = DC_COEFF(i);

                if(DC_COEFF(i) && !(s->coeff_counts[i]&127)){

                    s->coeff_counts[i]= 129;

//                    s->all_fragments[i].next_coeff= s->next_coeff;

                    s->coeffs[i].next= s->next_coeff;

                    (s->next_coeff++)->next=NULL;

                }

            }

        }

    }

}
 and probability:0.2158273381294964
code:static PhysPageDesc *phys_page_find_alloc(target_phys_addr_t index, int alloc)

{

    void **lp, **p;



    p = (void **)l1_phys_map;

#if TARGET_PHYS_ADDR_SPACE_BITS > 32



#if TARGET_PHYS_ADDR_SPACE_BITS > (32 + L1_BITS)

#error unsupported TARGET_PHYS_ADDR_SPACE_BITS

#endif

    lp = p + ((index >> (L1_BITS + L2_BITS)) & (L1_SIZE - 1));

    p = *lp;

    if (!p) {

        /* allocate if not found */

        if (!alloc)

            return NULL;

        p = qemu_vmalloc(sizeof(void *) * L1_SIZE);

        memset(p, 0, sizeof(void *) * L1_SIZE);

        *lp = p;

    }

#endif

    lp = p + ((index >> L2_BITS) & (L1_SIZE - 1));

    p = *lp;

    if (!p) {

        /* allocate if not found */

        if (!alloc)

            return NULL;

        p = qemu_vmalloc(sizeof(PhysPageDesc) * L2_SIZE);

        memset(p, 0, sizeof(PhysPageDesc) * L2_SIZE);

        *lp = p;

    }

    return ((PhysPageDesc *)p) + (index & (L2_SIZE - 1));

}
 and probability:0.3870967741935484
code:CPUState *cpu_mb_init (const char *cpu_model)

{

    CPUState *env;

    static int tcg_initialized = 0;

    int i;



    env = qemu_mallocz(sizeof(CPUState));



    cpu_exec_init(env);

    cpu_reset(env);



    env->pvr.regs[0] = PVR0_PVR_FULL_MASK \

                       | PVR0_USE_BARREL_MASK \

                       | PVR0_USE_DIV_MASK \

                       | PVR0_USE_HW_MUL_MASK \

                       | PVR0_USE_EXC_MASK \

                       | PVR0_USE_ICACHE_MASK \

                       | PVR0_USE_DCACHE_MASK \

                       | PVR0_USE_MMU \

                       | (0xb << 8);

    env->pvr.regs[2] = PVR2_D_OPB_MASK \

                        | PVR2_D_LMB_MASK \

                        | PVR2_I_OPB_MASK \

                        | PVR2_I_LMB_MASK \

                        | PVR2_USE_MSR_INSTR \

                        | PVR2_USE_PCMP_INSTR \

                        | PVR2_USE_BARREL_MASK \

                        | PVR2_USE_DIV_MASK \

                        | PVR2_USE_HW_MUL_MASK \

                        | PVR2_USE_MUL64_MASK \

                        | 0;

    env->pvr.regs[10] = 0x0c000000; /* Default to spartan 3a dsp family.  */

    env->pvr.regs[11] = PVR11_USE_MMU | (16 << 17);

#if !defined(CONFIG_USER_ONLY)

    env->mmu.c_mmu = 3;

    env->mmu.c_mmu_tlb_access = 3;

    env->mmu.c_mmu_zones = 16;

#endif



    if (tcg_initialized)

        return env;



    tcg_initialized = 1;



    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env");



    env_debug = tcg_global_mem_new(TCG_AREG0, 

                    offsetof(CPUState, debug),

                    "debug0");

    env_iflags = tcg_global_mem_new(TCG_AREG0, 

                    offsetof(CPUState, iflags),

                    "iflags");

    env_imm = tcg_global_mem_new(TCG_AREG0, 

                    offsetof(CPUState, imm),

                    "imm");

    env_btarget = tcg_global_mem_new(TCG_AREG0,

                     offsetof(CPUState, btarget),

                     "btarget");

    env_btaken = tcg_global_mem_new(TCG_AREG0,

                     offsetof(CPUState, btaken),

                     "btaken");

    for (i = 0; i < ARRAY_SIZE(cpu_R); i++) {

        cpu_R[i] = tcg_global_mem_new(TCG_AREG0,

                          offsetof(CPUState, regs[i]),

                          regnames[i]);

    }

    for (i = 0; i < ARRAY_SIZE(cpu_SR); i++) {

        cpu_SR[i] = tcg_global_mem_new(TCG_AREG0,

                          offsetof(CPUState, sregs[i]),

                          special_regnames[i]);

    }

#define GEN_HELPER 2

#include "helper.h"



    return env;

}
 and probability:0.22058823529411764
code:int cpu_x86_exec(CPUX86State *env1)

{

    int saved_T0, saved_T1, saved_A0;

    CPUX86State *saved_env;

#ifdef reg_EAX

    int saved_EAX;

#endif

#ifdef reg_ECX

    int saved_ECX;

#endif

#ifdef reg_EDX

    int saved_EDX;

#endif

#ifdef reg_EBX

    int saved_EBX;

#endif

#ifdef reg_ESP

    int saved_ESP;

#endif

#ifdef reg_EBP

    int saved_EBP;

#endif

#ifdef reg_ESI

    int saved_ESI;

#endif

#ifdef reg_EDI

    int saved_EDI;

#endif

#ifdef __sparc__

    int saved_i7, tmp_T0;

#endif

    int code_gen_size, ret;

    void (*gen_func)(void);

    TranslationBlock *tb, **ptb;

    uint8_t *tc_ptr, *cs_base, *pc;

    unsigned int flags;



    /* first we save global registers */

    saved_T0 = T0;

    saved_T1 = T1;

    saved_A0 = A0;

    saved_env = env;

    env = env1;

#ifdef reg_EAX

    saved_EAX = EAX;

    EAX = env->regs[R_EAX];

#endif

#ifdef reg_ECX

    saved_ECX = ECX;

    ECX = env->regs[R_ECX];

#endif

#ifdef reg_EDX

    saved_EDX = EDX;

    EDX = env->regs[R_EDX];

#endif

#ifdef reg_EBX

    saved_EBX = EBX;

    EBX = env->regs[R_EBX];

#endif

#ifdef reg_ESP

    saved_ESP = ESP;

    ESP = env->regs[R_ESP];

#endif

#ifdef reg_EBP

    saved_EBP = EBP;

    EBP = env->regs[R_EBP];

#endif

#ifdef reg_ESI

    saved_ESI = ESI;

    ESI = env->regs[R_ESI];

#endif

#ifdef reg_EDI

    saved_EDI = EDI;

    EDI = env->regs[R_EDI];

#endif

#ifdef __sparc__

    /* we also save i7 because longjmp may not restore it */

    asm volatile ("mov %%i7, %0" : "=r" (saved_i7));

#endif

    

    /* put eflags in CPU temporary format */

    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

    DF = 1 - (2 * ((env->eflags >> 10) & 1));

    CC_OP = CC_OP_EFLAGS;

    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

    env->interrupt_request = 0;



    /* prepare setjmp context for exception handling */

    if (setjmp(env->jmp_env) == 0) {

        T0 = 0; /* force lookup of first TB */

        for(;;) {

#ifdef __sparc__

	  /* g1 can be modified by some libc? functions */ 

	    tmp_T0 = T0;

#endif	    

            if (env->interrupt_request) {

                env->exception_index = EXCP_INTERRUPT;

                cpu_loop_exit();

            }

#ifdef DEBUG_EXEC

            if (loglevel) {

                /* XXX: save all volatile state in cpu state */

                /* restore flags in standard format */

                env->regs[R_EAX] = EAX;

                env->regs[R_EBX] = EBX;

                env->regs[R_ECX] = ECX;

                env->regs[R_EDX] = EDX;

                env->regs[R_ESI] = ESI;

                env->regs[R_EDI] = EDI;

                env->regs[R_EBP] = EBP;

                env->regs[R_ESP] = ESP;

                env->eflags = env->eflags | cc_table[CC_OP].compute_all() | (DF & DF_MASK);

                cpu_x86_dump_state(env, logfile, 0);

                env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

            }

#endif

            /* we compute the CPU state. We assume it will not

               change during the whole generated block. */

            flags = env->seg_cache[R_CS].seg_32bit << GEN_FLAG_CODE32_SHIFT;

            flags |= env->seg_cache[R_SS].seg_32bit << GEN_FLAG_SS32_SHIFT;

            flags |= (((unsigned long)env->seg_cache[R_DS].base | 

                       (unsigned long)env->seg_cache[R_ES].base |

                       (unsigned long)env->seg_cache[R_SS].base) != 0) << 

                GEN_FLAG_ADDSEG_SHIFT;

            if (!(env->eflags & VM_MASK)) {

                flags |= (env->segs[R_CS] & 3) << GEN_FLAG_CPL_SHIFT;

            } else {

                /* NOTE: a dummy CPL is kept */

                flags |= (1 << GEN_FLAG_VM_SHIFT);

                flags |= (3 << GEN_FLAG_CPL_SHIFT);

            }

            flags |= (env->eflags & (IOPL_MASK | TF_MASK));

            cs_base = env->seg_cache[R_CS].base;

            pc = cs_base + env->eip;

            tb = tb_find(&ptb, (unsigned long)pc, (unsigned long)cs_base, 

                         flags);

            if (!tb) {

                spin_lock(&tb_lock);

                /* if no translated code available, then translate it now */

                tb = tb_alloc((unsigned long)pc);

                if (!tb) {

                    /* flush must be done */

                    tb_flush();

                    /* cannot fail at this point */

                    tb = tb_alloc((unsigned long)pc);

                    /* don't forget to invalidate previous TB info */

                    ptb = &tb_hash[tb_hash_func((unsigned long)pc)];

                    T0 = 0;

                }

                tc_ptr = code_gen_ptr;

                tb->tc_ptr = tc_ptr;

                tb->cs_base = (unsigned long)cs_base;

                tb->flags = flags;

                ret = cpu_x86_gen_code(tb, CODE_GEN_MAX_SIZE, &code_gen_size);

                /* if invalid instruction, signal it */

                if (ret != 0) {

                    /* NOTE: the tb is allocated but not linked, so we

                       can leave it */

                    spin_unlock(&tb_lock);

                    raise_exception(EXCP06_ILLOP);

                }

                *ptb = tb;

                tb->hash_next = NULL;

                tb_link(tb);

                code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) & ~(CODE_GEN_ALIGN - 1));

                spin_unlock(&tb_lock);

            }

#ifdef DEBUG_EXEC

	    if (loglevel) {

		fprintf(logfile, "Trace 0x%08lx [0x%08lx] %s\n",

			(long)tb->tc_ptr, (long)tb->pc,

			lookup_symbol((void *)tb->pc));

	    }

#endif

#ifdef __sparc__

	    T0 = tmp_T0;

#endif	    

            /* see if we can patch the calling TB */

            if (T0 != 0 && !(env->eflags & TF_MASK)) {

                spin_lock(&tb_lock);

                tb_add_jump((TranslationBlock *)(T0 & ~3), T0 & 3, tb);

                spin_unlock(&tb_lock);

            }

            tc_ptr = tb->tc_ptr;



            /* execute the generated code */

            gen_func = (void *)tc_ptr;

#if defined(__sparc__)

	    __asm__ __volatile__("call	%0\n\t"

				 "mov	%%o7,%%i0"

				 : /* no outputs */

				 : "r" (gen_func) 

				 : "i0", "i1", "i2", "i3", "i4", "i5");

#elif defined(__arm__)

            asm volatile ("mov pc, %0\n\t"

                          ".global exec_loop\n\t"

                          "exec_loop:\n\t"

                          : /* no outputs */

                          : "r" (gen_func)

                          : "r1", "r2", "r3", "r8", "r9", "r10", "r12", "r14");

#else

            gen_func();

#endif

        }

    }

    ret = env->exception_index;



    /* restore flags in standard format */

    env->eflags = env->eflags | cc_table[CC_OP].compute_all() | (DF & DF_MASK);



    /* restore global registers */

#ifdef reg_EAX

    EAX = saved_EAX;

#endif

#ifdef reg_ECX

    ECX = saved_ECX;

#endif

#ifdef reg_EDX

    EDX = saved_EDX;

#endif

#ifdef reg_EBX

    EBX = saved_EBX;

#endif

#ifdef reg_ESP

    ESP = saved_ESP;

#endif

#ifdef reg_EBP

    EBP = saved_EBP;

#endif

#ifdef reg_ESI

    ESI = saved_ESI;

#endif

#ifdef reg_EDI

    EDI = saved_EDI;

#endif

#ifdef __sparc__

    asm volatile ("mov %0, %%i7" : : "r" (saved_i7));

#endif

    T0 = saved_T0;

    T1 = saved_T1;

    A0 = saved_A0;

    env = saved_env;

    return ret;

}
 and probability:0.20168067226890757
code:void s390_pci_sclp_configure(SCCB *sccb)

{

    PciCfgSccb *psccb = (PciCfgSccb *)sccb;

    S390PCIBusDevice *pbdev = s390_pci_find_dev_by_fid(be32_to_cpu(psccb->aid));

    uint16_t rc;



    if (be16_to_cpu(sccb->h.length) < 16) {

        rc = SCLP_RC_INSUFFICIENT_SCCB_LENGTH;

        goto out;

    }



    if (pbdev) {

        if (pbdev->configured) {

            rc = SCLP_RC_NO_ACTION_REQUIRED;

        } else {

            pbdev->configured = true;

            rc = SCLP_RC_NORMAL_COMPLETION;

        }

    } else {

        DPRINTF("sclp config no dev found\n");

        rc = SCLP_RC_ADAPTER_ID_NOT_RECOGNIZED;

    }

out:

    psccb->header.response_code = cpu_to_be16(rc);

}
 and probability:0.21739130434782608
code:static BlockJob *find_block_job(const char *device)

{

    BlockDriverState *bs;



    bs = bdrv_find(device);

    if (!bs || !bs->job) {

        return NULL;

    }

    return bs->job;

}
 and probability:0.2222222222222222
code:static void usb_host_realize(USBDevice *udev, Error **errp)

{

    USBHostDevice *s = USB_HOST_DEVICE(udev);



    if (s->match.vendor_id > 0xffff) {

        error_setg(errp, "vendorid out of range");

        return;

    }

    if (s->match.product_id > 0xffff) {

        error_setg(errp, "productid out of range");

        return;

    }

    if (s->match.addr > 127) {

        error_setg(errp, "hostaddr out of range");

        return;

    }



    loglevel = s->loglevel;

    udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);

    udev->auto_attach = 0;

    QTAILQ_INIT(&s->requests);

    QTAILQ_INIT(&s->isorings);



    s->exit.notify = usb_host_exit_notifier;

    qemu_add_exit_notifier(&s->exit);



    QTAILQ_INSERT_TAIL(&hostdevs, s, next);

    usb_host_auto_check(NULL);

}
 and probability:0.4
code:static void rtas_int_off(sPAPREnvironment *spapr, uint32_t token,

                         uint32_t nargs, target_ulong args,

                         uint32_t nret, target_ulong rets)

{

    struct ics_state *ics = spapr->icp->ics;

    uint32_t nr;



    if ((nargs != 1) || (nret != 1)) {

        rtas_st(rets, 0, -3);

        return;

    }



    nr = rtas_ld(args, 0);



    if (!ics_valid_irq(ics, nr)) {

        rtas_st(rets, 0, -3);

        return;

    }



    ics_write_xive(ics, nr, ics->irqs[nr - ics->offset].server, 0xff,

                   ics->irqs[nr - ics->offset].priority);



    rtas_st(rets, 0, 0); /* Success */

}
 and probability:0.15789473684210525
code:static void filter_mb_mbaff_edgecv( H264Context *h, uint8_t *pix, int stride, int16_t bS[7], int bsi, int qp ) {

    int index_a = qp + h->slice_alpha_c0_offset;

    int alpha = alpha_table[index_a];

    int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0*bsi]] + 1;

        tc[1] = tc0_table[index_a][bS[1*bsi]] + 1;

        tc[2] = tc0_table[index_a][bS[2*bsi]] + 1;

        tc[3] = tc0_table[index_a][bS[3*bsi]] + 1;

        h->h264dsp.h264_h_loop_filter_chroma_mbaff(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_mbaff_intra(pix, stride, alpha, beta);

    }

}
 and probability:0.625
code:static uint32_t gic_dist_readb(void *opaque, target_phys_addr_t offset)

{

    GICState *s = (GICState *)opaque;

    uint32_t res;

    int irq;

    int i;

    int cpu;

    int cm;

    int mask;



    cpu = gic_get_current_cpu(s);

    cm = 1 << cpu;

    if (offset < 0x100) {

        if (offset == 0)

            return s->enabled;

        if (offset == 4)

            return ((s->num_irq / 32) - 1) | ((NUM_CPU(s) - 1) << 5);

        if (offset < 0x08)

            return 0;

        if (offset >= 0x80) {

            /* Interrupt Security , RAZ/WI */

            return 0;

        }

        goto bad_reg;

    } else if (offset < 0x200) {

        /* Interrupt Set/Clear Enable.  */

        if (offset < 0x180)

            irq = (offset - 0x100) * 8;

        else

            irq = (offset - 0x180) * 8;

        irq += GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        res = 0;

        for (i = 0; i < 8; i++) {

            if (GIC_TEST_ENABLED(irq + i, cm)) {

                res |= (1 << i);

            }

        }

    } else if (offset < 0x300) {

        /* Interrupt Set/Clear Pending.  */

        if (offset < 0x280)

            irq = (offset - 0x200) * 8;

        else

            irq = (offset - 0x280) * 8;

        irq += GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        res = 0;

        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;

        for (i = 0; i < 8; i++) {

            if (GIC_TEST_PENDING(irq + i, mask)) {

                res |= (1 << i);

            }

        }

    } else if (offset < 0x400) {

        /* Interrupt Active.  */

        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        res = 0;

        mask = (irq < GIC_INTERNAL) ?  cm : ALL_CPU_MASK;

        for (i = 0; i < 8; i++) {

            if (GIC_TEST_ACTIVE(irq + i, mask)) {

                res |= (1 << i);

            }

        }

    } else if (offset < 0x800) {

        /* Interrupt Priority.  */

        irq = (offset - 0x400) + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        res = GIC_GET_PRIORITY(irq, cpu);

    } else if (offset < 0xc00) {

        /* Interrupt CPU Target.  */

        if (s->num_cpu == 1 && s->revision != REV_11MPCORE) {

            /* For uniprocessor GICs these RAZ/WI */

            res = 0;

        } else {

            irq = (offset - 0x800) + GIC_BASE_IRQ;

            if (irq >= s->num_irq) {

                goto bad_reg;

            }

            if (irq >= 29 && irq <= 31) {

                res = cm;

            } else {

                res = GIC_TARGET(irq);

            }

        }

    } else if (offset < 0xf00) {

        /* Interrupt Configuration.  */

        irq = (offset - 0xc00) * 2 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        res = 0;

        for (i = 0; i < 4; i++) {

            if (GIC_TEST_MODEL(irq + i))

                res |= (1 << (i * 2));

            if (GIC_TEST_TRIGGER(irq + i))

                res |= (2 << (i * 2));

        }

    } else if (offset < 0xfe0) {

        goto bad_reg;

    } else /* offset >= 0xfe0 */ {

        if (offset & 3) {

            res = 0;

        } else {

            res = gic_id[(offset - 0xfe0) >> 2];

        }

    }

    return res;

bad_reg:

    hw_error("gic_dist_readb: Bad offset %x\n", (int)offset);

    return 0;

}
 and probability:0.2719298245614035
code:static void qmp_serialize(void *native_in, void **datap,

                          VisitorFunc visit, Error **errp)

{

    QmpSerializeData *d = g_malloc0(sizeof(*d));



    d->qov = qmp_output_visitor_new(&d->obj);

    visit(d->qov, &native_in, errp);

    *datap = d;

}
 and probability:0.5
code:static void tcg_target_init(TCGContext *s)

{

    tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xffffffff);

    tcg_regset_set32(tcg_target_call_clobber_regs, 0,

                     (1 << TCG_REG_R0) |

#ifdef _CALL_DARWIN

                     (1 << TCG_REG_R2) |

#endif

                     (1 << TCG_REG_R3) |

                     (1 << TCG_REG_R4) |

                     (1 << TCG_REG_R5) |

                     (1 << TCG_REG_R6) |

                     (1 << TCG_REG_R7) |

                     (1 << TCG_REG_R8) |

                     (1 << TCG_REG_R9) |

                     (1 << TCG_REG_R10) |

                     (1 << TCG_REG_R11) |

                     (1 << TCG_REG_R12)

        );



    tcg_regset_clear(s->reserved_regs);

    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R0);

    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R1);

#ifndef _CALL_DARWIN

    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R2);

#endif

#ifdef _CALL_SYSV

    tcg_regset_set_reg(s->reserved_regs, TCG_REG_R13);

#endif



    tcg_add_target_add_op_defs(ppc_op_defs);

}
 and probability:0.2
code:static void emulate_spapr_hypercall(PPCVirtualHypervisor *vhyp,
                                    PowerPCCPU *cpu)
{
    CPUPPCState *env = &cpu->env;
    if (msr_pr) {
        hcall_dprintf("Hypercall made with MSR[PR]=1\n");
        env->gpr[3] = H_PRIVILEGE;
    } else {
        env->gpr[3] = spapr_hypercall(cpu, env->gpr[3], &env->gpr[4]);
    }
} and probability:0.2727272727272727
code:test_opts_range_unvisited(void)

{

    intList *list = NULL;

    intList *tail;

    QemuOpts *opts;

    Visitor *v;



    opts = qemu_opts_parse(qemu_find_opts("userdef"), "ilist=0-2", false,

                           &error_abort);



    v = opts_visitor_new(opts);



    visit_start_struct(v, NULL, NULL, 0, &error_abort);



    /* Would be simpler if the visitor genuinely supported virtual walks */

    visit_start_list(v, "ilist", (GenericList **)&list, sizeof(*list),

                     &error_abort);

    tail = list;

    visit_type_int(v, NULL, &tail->value, &error_abort);

    g_assert_cmpint(tail->value, ==, 0);

    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));

    g_assert(tail);

    visit_type_int(v, NULL, &tail->value, &error_abort);

    g_assert_cmpint(tail->value, ==, 1);

    tail = (intList *)visit_next_list(v, (GenericList *)tail, sizeof(*list));

    g_assert(tail);

    visit_check_list(v, &error_abort); /* BUG: unvisited tail not reported */

    visit_end_list(v, (void **)&list);



    visit_check_struct(v, &error_abort);

    visit_end_struct(v, NULL);



    qapi_free_intList(list);

    visit_free(v);

    qemu_opts_del(opts);

}
 and probability:0.23333333333333334
code:static int decode_subframe(WMAProDecodeCtx *s)

{

    int offset = s->samples_per_frame;

    int subframe_len = s->samples_per_frame;

    int i;

    int total_samples   = s->samples_per_frame * s->avctx->channels;

    int transmit_coeffs = 0;

    int cur_subwoofer_cutoff;



    s->subframe_offset = get_bits_count(&s->gb);



    /** reset channel context and find the next block offset and size

        == the next block of the channel with the smallest number of

        decoded samples

    */

    for (i = 0; i < s->avctx->channels; i++) {

        s->channel[i].grouped = 0;

        if (offset > s->channel[i].decoded_samples) {

            offset = s->channel[i].decoded_samples;

            subframe_len =

                s->channel[i].subframe_len[s->channel[i].cur_subframe];

        }

    }



    av_dlog(s->avctx,

            "processing subframe with offset %i len %i\n", offset, subframe_len);



    /** get a list of all channels that contain the estimated block */

    s->channels_for_cur_subframe = 0;

    for (i = 0; i < s->avctx->channels; i++) {

        const int cur_subframe = s->channel[i].cur_subframe;

        /** subtract already processed samples */

        total_samples -= s->channel[i].decoded_samples;



        /** and count if there are multiple subframes that match our profile */

        if (offset == s->channel[i].decoded_samples &&

            subframe_len == s->channel[i].subframe_len[cur_subframe]) {

            total_samples -= s->channel[i].subframe_len[cur_subframe];

            s->channel[i].decoded_samples +=

                s->channel[i].subframe_len[cur_subframe];

            s->channel_indexes_for_cur_subframe[s->channels_for_cur_subframe] = i;

            ++s->channels_for_cur_subframe;

        }

    }



    /** check if the frame will be complete after processing the

        estimated block */

    if (!total_samples)

        s->parsed_all_subframes = 1;





    av_dlog(s->avctx, "subframe is part of %i channels\n",

            s->channels_for_cur_subframe);



    /** calculate number of scale factor bands and their offsets */

    s->table_idx         = av_log2(s->samples_per_frame/subframe_len);

    s->num_bands         = s->num_sfb[s->table_idx];

    s->cur_sfb_offsets   = s->sfb_offsets[s->table_idx];

    cur_subwoofer_cutoff = s->subwoofer_cutoffs[s->table_idx];



    /** configure the decoder for the current subframe */

    for (i = 0; i < s->channels_for_cur_subframe; i++) {

        int c = s->channel_indexes_for_cur_subframe[i];



        s->channel[c].coeffs = &s->channel[c].out[(s->samples_per_frame >> 1)

                                                  + offset];

    }



    s->subframe_len = subframe_len;

    s->esc_len = av_log2(s->subframe_len - 1) + 1;



    /** skip extended header if any */

    if (get_bits1(&s->gb)) {

        int num_fill_bits;

        if (!(num_fill_bits = get_bits(&s->gb, 2))) {

            int len = get_bits(&s->gb, 4);

            num_fill_bits = get_bits(&s->gb, len) + 1;

        }



        if (num_fill_bits >= 0) {

            if (get_bits_count(&s->gb) + num_fill_bits > s->num_saved_bits) {

                av_log(s->avctx, AV_LOG_ERROR, "invalid number of fill bits\n");

                return AVERROR_INVALIDDATA;

            }



            skip_bits_long(&s->gb, num_fill_bits);

        }

    }



    /** no idea for what the following bit is used */

    if (get_bits1(&s->gb)) {

        avpriv_request_sample(s->avctx, "Reserved bit");

        return AVERROR_PATCHWELCOME;

    }





    if (decode_channel_transform(s) < 0)

        return AVERROR_INVALIDDATA;





    for (i = 0; i < s->channels_for_cur_subframe; i++) {

        int c = s->channel_indexes_for_cur_subframe[i];

        if ((s->channel[c].transmit_coefs = get_bits1(&s->gb)))

            transmit_coeffs = 1;

    }



    if (transmit_coeffs) {

        int step;

        int quant_step = 90 * s->bits_per_sample >> 4;



        /** decode number of vector coded coefficients */

        if ((s->transmit_num_vec_coeffs = get_bits1(&s->gb))) {

            int num_bits = av_log2((s->subframe_len + 3)/4) + 1;

            for (i = 0; i < s->channels_for_cur_subframe; i++) {

                int c = s->channel_indexes_for_cur_subframe[i];

                int num_vec_coeffs = get_bits(&s->gb, num_bits) << 2;

                if (num_vec_coeffs > WMAPRO_BLOCK_MAX_SIZE) {

                    av_log(s->avctx, AV_LOG_ERROR, "num_vec_coeffs %d is too large\n", num_vec_coeffs);

                    return AVERROR_INVALIDDATA;

                }

                s->channel[c].num_vec_coeffs = num_vec_coeffs;

            }

        } else {

            for (i = 0; i < s->channels_for_cur_subframe; i++) {

                int c = s->channel_indexes_for_cur_subframe[i];

                s->channel[c].num_vec_coeffs = s->subframe_len;

            }

        }

        /** decode quantization step */

        step = get_sbits(&s->gb, 6);

        quant_step += step;

        if (step == -32 || step == 31) {

            const int sign = (step == 31) - 1;

            int quant = 0;

            while (get_bits_count(&s->gb) + 5 < s->num_saved_bits &&

                   (step = get_bits(&s->gb, 5)) == 31) {

                quant += 31;

            }

            quant_step += ((quant + step) ^ sign) - sign;

        }

        if (quant_step < 0) {

            av_log(s->avctx, AV_LOG_DEBUG, "negative quant step\n");

        }



        /** decode quantization step modifiers for every channel */



        if (s->channels_for_cur_subframe == 1) {

            s->channel[s->channel_indexes_for_cur_subframe[0]].quant_step = quant_step;

        } else {

            int modifier_len = get_bits(&s->gb, 3);

            for (i = 0; i < s->channels_for_cur_subframe; i++) {

                int c = s->channel_indexes_for_cur_subframe[i];

                s->channel[c].quant_step = quant_step;

                if (get_bits1(&s->gb)) {

                    if (modifier_len) {

                        s->channel[c].quant_step += get_bits(&s->gb, modifier_len) + 1;

                    } else

                        ++s->channel[c].quant_step;

                }

            }

        }



        /** decode scale factors */

        if (decode_scale_factors(s) < 0)

            return AVERROR_INVALIDDATA;

    }



    av_dlog(s->avctx, "BITSTREAM: subframe header length was %i\n",

            get_bits_count(&s->gb) - s->subframe_offset);



    /** parse coefficients */

    for (i = 0; i < s->channels_for_cur_subframe; i++) {

        int c = s->channel_indexes_for_cur_subframe[i];

        if (s->channel[c].transmit_coefs &&

            get_bits_count(&s->gb) < s->num_saved_bits) {

            decode_coeffs(s, c);

        } else

            memset(s->channel[c].coeffs, 0,

                   sizeof(*s->channel[c].coeffs) * subframe_len);

    }



    av_dlog(s->avctx, "BITSTREAM: subframe length was %i\n",

            get_bits_count(&s->gb) - s->subframe_offset);



    if (transmit_coeffs) {

        FFTContext *mdct = &s->mdct_ctx[av_log2(subframe_len) - WMAPRO_BLOCK_MIN_BITS];

        /** reconstruct the per channel data */

        inverse_channel_transform(s);

        for (i = 0; i < s->channels_for_cur_subframe; i++) {

            int c = s->channel_indexes_for_cur_subframe[i];

            const int* sf = s->channel[c].scale_factors;

            int b;



            if (c == s->lfe_channel)

                memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *

                       (subframe_len - cur_subwoofer_cutoff));



            /** inverse quantization and rescaling */

            for (b = 0; b < s->num_bands; b++) {

                const int end = FFMIN(s->cur_sfb_offsets[b+1], s->subframe_len);

                const int exp = s->channel[c].quant_step -

                            (s->channel[c].max_scale_factor - *sf++) *

                            s->channel[c].scale_factor_step;

                const float quant = pow(10.0, exp / 20.0);

                int start = s->cur_sfb_offsets[b];

                s->fdsp.vector_fmul_scalar(s->tmp + start,

                                           s->channel[c].coeffs + start,

                                           quant, end - start);

            }



            /** apply imdct (imdct_half == DCTIV with reverse) */

            mdct->imdct_half(mdct, s->channel[c].coeffs, s->tmp);

        }

    }



    /** window and overlapp-add */

    wmapro_window(s);



    /** handled one subframe */

    for (i = 0; i < s->channels_for_cur_subframe; i++) {

        int c = s->channel_indexes_for_cur_subframe[i];

        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {

            av_log(s->avctx, AV_LOG_ERROR, "broken subframe\n");

            return AVERROR_INVALIDDATA;

        }

        ++s->channel[c].cur_subframe;

    }



    return 0;

}
 and probability:0.5435897435897435
code:static int find_vdi_name(BDRVSheepdogState *s, char *filename, uint32_t snapid,

                         char *tag, uint32_t *vid, int for_snapshot)

{

    int ret, fd;

    SheepdogVdiReq hdr;

    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;

    unsigned int wlen, rlen = 0;

    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    memset(buf, 0, sizeof(buf));

    strncpy(buf, filename, SD_MAX_VDI_LEN);

    strncpy(buf + SD_MAX_VDI_LEN, tag, SD_MAX_VDI_TAG_LEN);



    memset(&hdr, 0, sizeof(hdr));

    if (for_snapshot) {

        hdr.opcode = SD_OP_GET_VDI_INFO;

    } else {

        hdr.opcode = SD_OP_LOCK_VDI;

    }

    wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN;

    hdr.proto_ver = SD_PROTO_VER;

    hdr.data_length = wlen;

    hdr.snapid = snapid;

    hdr.flags = SD_FLAG_CMD_WRITE;



    ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);

    if (ret) {

        goto out;

    }



    if (rsp->result != SD_RES_SUCCESS) {

        error_report("cannot get vdi info, %s, %s %d %s",

                     sd_strerror(rsp->result), filename, snapid, tag);

        if (rsp->result == SD_RES_NO_VDI) {

            ret = -ENOENT;

        } else {

            ret = -EIO;

        }

        goto out;

    }

    *vid = rsp->vdi_id;



    ret = 0;

out:

    closesocket(fd);

    return ret;

}
 and probability:0.1956521739130435
code:static void setup_frame(int sig, struct target_sigaction *ka,

			target_sigset_t *set, CPUX86State *env)

{

	abi_ulong frame_addr;

	struct sigframe *frame;

	int i, err = 0;



	frame_addr = get_sigframe(ka, env, sizeof(*frame));



	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))

		goto give_sigsegv;



    __put_user(current_exec_domain_sig(sig),

               &frame->sig);

	if (err)

		goto give_sigsegv;



	setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0],

                         frame_addr + offsetof(struct sigframe, fpstate));

	if (err)

		goto give_sigsegv;



        for(i = 1; i < TARGET_NSIG_WORDS; i++) {

            if (__put_user(set->sig[i], &frame->extramask[i - 1]))

                goto give_sigsegv;

        }



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa_flags & TARGET_SA_RESTORER) {

        __put_user(ka->sa_restorer, &frame->pretcode);

	} else {

                uint16_t val16;

                abi_ulong retcode_addr;

                retcode_addr = frame_addr + offsetof(struct sigframe, retcode);

        __put_user(retcode_addr, &frame->pretcode);

		/* This is popl %eax ; movl $,%eax ; int $0x80 */

                val16 = 0xb858;

        __put_user(val16, (uint16_t *)(frame->retcode+0));

        __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));

                val16 = 0x80cd;

        __put_user(val16, (uint16_t *)(frame->retcode+6));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	env->regs[R_ESP] = frame_addr;

	env->eip = ka->_sa_handler;



        cpu_x86_load_seg(env, R_DS, __USER_DS);

        cpu_x86_load_seg(env, R_ES, __USER_DS);

        cpu_x86_load_seg(env, R_SS, __USER_DS);

        cpu_x86_load_seg(env, R_CS, __USER_CS);

	env->eflags &= ~TF_MASK;



	unlock_user_struct(frame, frame_addr, 1);



	return;



give_sigsegv:

	unlock_user_struct(frame, frame_addr, 1);

	if (sig == TARGET_SIGSEGV)

		ka->_sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
 and probability:0.3090909090909091
code:static void ahci_pci_enable(AHCIQState *ahci)

{

    uint8_t reg;



    start_ahci_device(ahci);



    switch (ahci->fingerprint) {

    case AHCI_INTEL_ICH9:

        /* ICH9 has a register at PCI 0x92 that

         * acts as a master port enabler mask. */

        reg = qpci_config_readb(ahci->dev, 0x92);

        reg |= 0x3F;

        qpci_config_writeb(ahci->dev, 0x92, reg);

        /* 0...0111111b -- bit significant, ports 0-5 enabled. */

        ASSERT_BIT_SET(qpci_config_readb(ahci->dev, 0x92), 0x3F);

        break;

    }



}
 and probability:0.25
code:main(

    int argc,

    char *argv[]

) {

    GMainLoop *loop;

    GIOChannel *channel_stdin;

    char *qemu_host;

    char *qemu_port;

    VSCMsgHeader mhHeader;



    VCardEmulOptions *command_line_options = NULL;



    char *cert_names[MAX_CERTS];

    char *emul_args = NULL;

    int cert_count = 0;

    int c, sock;



    if (socket_init() != 0)

        return 1;



    while ((c = getopt(argc, argv, "c:e:pd:")) != -1) {

        switch (c) {

        case 'c':

            if (cert_count >= MAX_CERTS) {

                printf("too many certificates (max = %d)\n", MAX_CERTS);

                exit(5);

            }

            cert_names[cert_count++] = optarg;

            break;

        case 'e':

            emul_args = optarg;

            break;

        case 'p':

            print_usage();

            exit(4);

            break;

        case 'd':

            verbose = get_id_from_string(optarg, 1);

            break;

        }

    }



    if (argc - optind != 2) {

        print_usage();

        exit(4);

    }



    if (cert_count > 0) {

        char *new_args;

        int len, i;

        /* if we've given some -c options, we clearly we want do so some

         * software emulation.  add that emulation now. this is NSS Emulator

         * specific */

        if (emul_args == NULL) {

            emul_args = (char *)"db=\"/etc/pki/nssdb\"";

        }

#define SOFT_STRING ",soft=(,Virtual Reader,CAC,,"

             /* 2 == close paren & null */

        len = strlen(emul_args) + strlen(SOFT_STRING) + 2;

        for (i = 0; i < cert_count; i++) {

            len += strlen(cert_names[i])+1; /* 1 == comma */

        }

        new_args = g_malloc(len);

        strcpy(new_args, emul_args);

        strcat(new_args, SOFT_STRING);

        for (i = 0; i < cert_count; i++) {

            strcat(new_args, cert_names[i]);

            strcat(new_args, ",");

        }

        strcat(new_args, ")");

        emul_args = new_args;

    }

    if (emul_args) {

        command_line_options = vcard_emul_options(emul_args);

    }



    qemu_host = g_strdup(argv[argc - 2]);

    qemu_port = g_strdup(argv[argc - 1]);

    sock = connect_to_qemu(qemu_host, qemu_port);

    if (sock == -1) {

        fprintf(stderr, "error opening socket, exiting.\n");

        exit(5);

    }



    socket_to_send = g_byte_array_new();

    qemu_mutex_init(&socket_to_send_lock);

    qemu_mutex_init(&pending_reader_lock);

    qemu_cond_init(&pending_reader_condition);



    vcard_emul_init(command_line_options);



    loop = g_main_loop_new(NULL, true);



    printf("> ");

    fflush(stdout);



#ifdef _WIN32

    channel_stdin = g_io_channel_win32_new_fd(STDIN_FILENO);

#else

    channel_stdin = g_io_channel_unix_new(STDIN_FILENO);

#endif

    g_io_add_watch(channel_stdin, G_IO_IN, do_command, NULL);

#ifdef _WIN32

    channel_socket = g_io_channel_win32_new_socket(sock);

#else

    channel_socket = g_io_channel_unix_new(sock);

#endif

    g_io_channel_set_encoding(channel_socket, NULL, NULL);

    /* we buffer ourself for thread safety reasons */

    g_io_channel_set_buffered(channel_socket, FALSE);



    /* Send init message, Host responds (and then we send reader attachments) */

    VSCMsgInit init = {

        .version = htonl(VSCARD_VERSION),

        .magic = VSCARD_MAGIC,

        .capabilities = {0}

    };

    send_msg(VSC_Init, mhHeader.reader_id, &init, sizeof(init));



    g_main_loop_run(loop);

    g_main_loop_unref(loop);



    g_io_channel_unref(channel_stdin);

    g_io_channel_unref(channel_socket);

    g_byte_array_unref(socket_to_send);



    closesocket(sock);

    return 0;

}
 and probability:0.11504424778761062
code:static VFIOINTp *vfio_init_intp(VFIODevice *vbasedev,

                                struct vfio_irq_info info)

{

    int ret;

    VFIOPlatformDevice *vdev =

        container_of(vbasedev, VFIOPlatformDevice, vbasedev);

    SysBusDevice *sbdev = SYS_BUS_DEVICE(vdev);

    VFIOINTp *intp;



    intp = g_malloc0(sizeof(*intp));

    intp->vdev = vdev;

    intp->pin = info.index;

    intp->flags = info.flags;

    intp->state = VFIO_IRQ_INACTIVE;

    intp->kvm_accel = false;



    sysbus_init_irq(sbdev, &intp->qemuirq);



    /* Get an eventfd for trigger */

    intp->interrupt = g_malloc0(sizeof(EventNotifier));

    ret = event_notifier_init(intp->interrupt, 0);

    if (ret) {

        g_free(intp->interrupt);

        g_free(intp);

        error_report("vfio: Error: trigger event_notifier_init failed ");

        return NULL;

    }

    /* Get an eventfd for resample/unmask */

    intp->unmask = g_malloc0(sizeof(EventNotifier));

    ret = event_notifier_init(intp->unmask, 0);

    if (ret) {

        g_free(intp->interrupt);

        g_free(intp->unmask);

        g_free(intp);

        error_report("vfio: Error: resamplefd event_notifier_init failed");

        return NULL;

    }



    QLIST_INSERT_HEAD(&vdev->intp_list, intp, next);

    return intp;

}
 and probability:0.40540540540540543
code:void OPPROTO op_udivx_T1_T0(void)

{




    T0 /= T1;

    FORCE_RET();
 and probability:0.25
code:void address_space_init(AddressSpace *as, MemoryRegion *root)

{

    memory_region_transaction_begin();

    as->root = root;

    as->current_map = g_new(FlatView, 1);

    flatview_init(as->current_map);



    QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);

    as->name = NULL;

    memory_region_transaction_commit();

    address_space_init_dispatch(as);

} and probability:0.36363636363636365
code:ebml_read_ascii (MatroskaDemuxContext *matroska,

                 uint32_t             *id,

                 char                **str)

{

    ByteIOContext *pb = matroska->ctx->pb;

    int size, res;

    uint64_t rlength;



    if ((res = ebml_read_element_id(matroska, id, NULL)) < 0 ||

        (res = ebml_read_element_length(matroska, &rlength)) < 0)

        return res;

    size = rlength;



    /* ebml strings are usually not 0-terminated, so we allocate one

     * byte more, read the string and NULL-terminate it ourselves. */

    if (size < 0 || !(*str = av_malloc(size + 1))) {

        av_log(matroska->ctx, AV_LOG_ERROR, "Memory allocation failed\n");

        return AVERROR(ENOMEM);

    }

    if (get_buffer(pb, (uint8_t *) *str, size) != size) {

        offset_t pos = url_ftell(pb);

        av_log(matroska->ctx, AV_LOG_ERROR,

               "Read error at pos. %"PRIu64" (0x%"PRIx64")\n", pos, pos);


        return AVERROR(EIO);

    }

    (*str)[size] = '\0';



    return 0;

} and probability:0.34615384615384615
code:static void memory_dump(Monitor *mon, int count, int format, int wsize,

                        target_phys_addr_t addr, int is_physical)

{

    CPUState *env;

    int l, line_size, i, max_digits, len;

    uint8_t buf[16];

    uint64_t v;



    if (format == 'i') {

        int flags;

        flags = 0;

        env = mon_get_cpu();

        if (!env && !is_physical)

            return;

#ifdef TARGET_I386

        if (wsize == 2) {

            flags = 1;

        } else if (wsize == 4) {

            flags = 0;

        } else {

            /* as default we use the current CS size */

            flags = 0;

            if (env) {

#ifdef TARGET_X86_64

                if ((env->efer & MSR_EFER_LMA) &&

                    (env->segs[R_CS].flags & DESC_L_MASK))

                    flags = 2;

                else

#endif

                if (!(env->segs[R_CS].flags & DESC_B_MASK))

                    flags = 1;

            }

        }

#endif

        monitor_disas(mon, env, addr, count, is_physical, flags);

        return;

    }



    len = wsize * count;

    if (wsize == 1)

        line_size = 8;

    else

        line_size = 16;

    max_digits = 0;



    switch(format) {

    case 'o':

        max_digits = (wsize * 8 + 2) / 3;

        break;

    default:

    case 'x':

        max_digits = (wsize * 8) / 4;

        break;

    case 'u':

    case 'd':

        max_digits = (wsize * 8 * 10 + 32) / 33;

        break;

    case 'c':

        wsize = 1;

        break;

    }



    while (len > 0) {

        if (is_physical)

            monitor_printf(mon, TARGET_FMT_plx ":", addr);

        else

            monitor_printf(mon, TARGET_FMT_lx ":", (target_ulong)addr);

        l = len;

        if (l > line_size)

            l = line_size;

        if (is_physical) {

            cpu_physical_memory_rw(addr, buf, l, 0);

        } else {

            env = mon_get_cpu();

            if (!env)

                break;

            if (cpu_memory_rw_debug(env, addr, buf, l, 0) < 0) {

                monitor_printf(mon, " Cannot access memory\n");

                break;

            }

        }

        i = 0;

        while (i < l) {

            switch(wsize) {

            default:

            case 1:

                v = ldub_raw(buf + i);

                break;

            case 2:

                v = lduw_raw(buf + i);

                break;

            case 4:

                v = (uint32_t)ldl_raw(buf + i);

                break;

            case 8:

                v = ldq_raw(buf + i);

                break;

            }

            monitor_printf(mon, " ");

            switch(format) {

            case 'o':

                monitor_printf(mon, "%#*" PRIo64, max_digits, v);

                break;

            case 'x':

                monitor_printf(mon, "0x%0*" PRIx64, max_digits, v);

                break;

            case 'u':

                monitor_printf(mon, "%*" PRIu64, max_digits, v);

                break;

            case 'd':

                monitor_printf(mon, "%*" PRId64, max_digits, v);

                break;

            case 'c':

                monitor_printc(mon, v);

                break;

            }

            i += wsize;

        }

        monitor_printf(mon, "\n");

        addr += l;

        len -= l;

    }

}
 and probability:0.11764705882352941
code:RGB_FUNCTIONS(rgba32)



#undef RGB_IN

#undef RGB_OUT

#undef BPP





static void rgb24_to_rgb565(AVPicture *dst, AVPicture *src,

                            int width, int height)

{

    const unsigned char *p;

    unsigned char *q;

    int r, g, b, dst_wrap, src_wrap;

    int x, y;



    p = src->data[0];

    src_wrap = src->linesize[0] - 3 * width;



    q = dst->data[0];

    dst_wrap = dst->linesize[0] - 2 * width;



    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            r = p[0];

            g = p[1];

            b = p[2];



            ((unsigned short *)q)[0] = 

                ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);

            q += 2;

            p += 3;

        }

        p += src_wrap;

        q += dst_wrap;

    }

}
 and probability:0.4827586206896552
code:static void avc_luma_mid_and_aver_dst_16x16_msa(const uint8_t *src,

                                                int32_t src_stride,

                                                uint8_t *dst,

                                                int32_t dst_stride)

{

    avc_luma_mid_and_aver_dst_8w_msa(src, src_stride, dst, dst_stride, 16);

    avc_luma_mid_and_aver_dst_8w_msa(src + 8, src_stride, dst + 8, dst_stride,

                                     16);

}
 and probability:0.1111111111111111
code:void MPV_common_init_armv4l(MpegEncContext *s)

{

    int i;

    const int idct_algo= s->avctx->idct_algo;



    ff_put_pixels_clamped = s->avctx->dsp.put_pixels_clamped;

    ff_add_pixels_clamped = s->avctx->dsp.put_pixels_clamped;



    if(idct_algo==FF_IDCT_AUTO || idct_algo==FF_IDCT_ARM){

        s->idct_put= arm_idct_put;

        s->idct_add= arm_idct_add;

        s->idct_permutation_type= FF_NO_IDCT_PERM;

    }

}
 and probability:0.5
code:static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)

{

    int i, k, sb = 0;

    int msb = sbr->k[0];

    int usb = sbr->kx[1];

    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;



    sbr->num_patches = 0;



    if (goal_sb < sbr->kx[1] + sbr->m[1]) {

        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;

    } else

        k = sbr->n_master;



    do {

        int odd = 0;

        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {

            sb = sbr->f_master[i];

            odd = (sb + sbr->k[0]) & 1;

        }



        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.

        // After this check the final number of patches can still be six which is

        // illegal however the Coding Technologies decoder check stream has a final

        // count of 6 patches

        if (sbr->num_patches > 5) {

            av_log(ac->avctx, AV_LOG_ERROR, "Too many patches: %d\n", sbr->num_patches);

            return -1;

        }



        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);

        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];



        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {

            usb = sb;

            msb = sb;

            sbr->num_patches++;

        } else

            msb = sbr->kx[1];



        if (sbr->f_master[k] - sb < 3)

            k = sbr->n_master;

    } while (sb != sbr->kx[1] + sbr->m[1]);



    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)

        sbr->num_patches--;



    return 0;

}
 and probability:0.55
code:static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)

{

    int channel, stereo, phase, exp;

    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;

    int local_int_14, stereo_exp, local_int_20, local_int_28;

    int n, offset;



    local_int_4 = 0;

    local_int_28 = 0;

    local_int_20 = 2;

    local_int_8 = (4 - duration);

    local_int_10 = 1 << (q->group_order - duration - 1);

    offset = 1;



    while (1) {

        if (q->superblocktype_2_3) {

            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {

                offset = 1;

                if (n == 0) {

                    local_int_4 += local_int_10;

                    local_int_28 += (1 << local_int_8);

                } else {

                    local_int_4 += 8*local_int_10;

                    local_int_28 += (8 << local_int_8);

                }

            }

            offset += (n - 2);

        } else {

            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);

            while (offset >= (local_int_10 - 1)) {

                offset += (1 - (local_int_10 - 1));

                local_int_4  += local_int_10;

                local_int_28 += (1 << local_int_8);

            }

        }



        if (local_int_4 >= q->group_size)

            return;



        local_int_14 = (offset >> local_int_8);

        if (local_int_14 >= FF_ARRAY_ELEMS(fft_level_index_table))

            return;



        if (q->nb_channels > 1) {

            channel = get_bits1(gb);

            stereo = get_bits1(gb);

        } else {

            channel = 0;

            stereo = 0;

        }



        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);

        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];

        exp = (exp < 0) ? 0 : exp;



        phase = get_bits(gb, 3);

        stereo_exp = 0;

        stereo_phase = 0;



        if (stereo) {

            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));

            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));

            if (stereo_phase < 0)

                stereo_phase += 8;

        }



        if (q->frequency_range > (local_int_14 + 1)) {

            int sub_packet = (local_int_20 + local_int_28);



            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);

            if (stereo)

                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);

        }



        offset++;

    }

}
 and probability:0.36363636363636365
code:void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size)

{

    RTPMuxContext *s = s1->priv_data;

    int len, max_packet_size;

    uint8_t *q;



    max_packet_size = s->max_payload_size;



    while (size > 0) {

        q = s->buf;

        if ((buf1[0] == 0) && (buf1[1] == 0)) {

            *q++ = 0x04;

            buf1 += 2;

            size -= 2;

        } else {

            *q++ = 0;

        }

        *q++ = 0;



        len = FFMIN(max_packet_size - 2, size);



        /* Look for a better place to split the frame into packets. */

        if (len < size) {

            const uint8_t *end = find_resync_marker_reverse(buf1, buf1 + len);

            len = end - buf1;

        }



        memcpy(q, buf1, len);

        q += len;



        /* 90 KHz time stamp */

        s->timestamp = s->cur_timestamp;

        ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));



        buf1 += len;

        size -= len;

    }

}
 and probability:0.5483870967741935
code:void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)

{

    TCGContext *s = tcg_ctx;

    int i, real_args, nb_rets, pi;

    unsigned sizemask, flags;

    TCGHelperInfo *info;

    TCGOp *op;



    info = g_hash_table_lookup(helper_table, (gpointer)func);

    flags = info->flags;

    sizemask = info->sizemask;



#if defined(__sparc__) && !defined(__arch64__) \

    && !defined(CONFIG_TCG_INTERPRETER)

    /* We have 64-bit values in one register, but need to pass as two

       separate parameters.  Split them.  */

    int orig_sizemask = sizemask;

    int orig_nargs = nargs;

    TCGv_i64 retl, reth;

    TCGTemp *split_args[MAX_OPC_PARAM];



    retl = NULL;

    reth = NULL;

    if (sizemask != 0) {

        for (i = real_args = 0; i < nargs; ++i) {

            int is_64bit = sizemask & (1 << (i+1)*2);

            if (is_64bit) {

                TCGv_i64 orig = temp_tcgv_i64(args[i]);

                TCGv_i32 h = tcg_temp_new_i32();

                TCGv_i32 l = tcg_temp_new_i32();

                tcg_gen_extr_i64_i32(l, h, orig);

                split_args[real_args++] = tcgv_i32_temp(h);

                split_args[real_args++] = tcgv_i32_temp(l);

            } else {

                split_args[real_args++] = args[i];

            }

        }

        nargs = real_args;

        args = split_args;

        sizemask = 0;

    }

#elif defined(TCG_TARGET_EXTEND_ARGS) && TCG_TARGET_REG_BITS == 64

    for (i = 0; i < nargs; ++i) {

        int is_64bit = sizemask & (1 << (i+1)*2);

        int is_signed = sizemask & (2 << (i+1)*2);

        if (!is_64bit) {

            TCGv_i64 temp = tcg_temp_new_i64();

            TCGv_i64 orig = temp_tcgv_i64(args[i]);

            if (is_signed) {

                tcg_gen_ext32s_i64(temp, orig);

            } else {

                tcg_gen_ext32u_i64(temp, orig);

            }

            args[i] = tcgv_i64_temp(temp);

        }

    }

#endif /* TCG_TARGET_EXTEND_ARGS */



    i = s->gen_next_op_idx;

    tcg_debug_assert(i < OPC_BUF_SIZE);

    s->gen_op_buf[0].prev = i;

    s->gen_next_op_idx = i + 1;

    op = &s->gen_op_buf[i];



    /* Set links for sequential allocation during translation.  */

    memset(op, 0, offsetof(TCGOp, args));

    op->opc = INDEX_op_call;

    op->prev = i - 1;

    op->next = i + 1;



    pi = 0;

    if (ret != NULL) {

#if defined(__sparc__) && !defined(__arch64__) \

    && !defined(CONFIG_TCG_INTERPRETER)

        if (orig_sizemask & 1) {

            /* The 32-bit ABI is going to return the 64-bit value in

               the %o0/%o1 register pair.  Prepare for this by using

               two return temporaries, and reassemble below.  */

            retl = tcg_temp_new_i64();

            reth = tcg_temp_new_i64();

            op->args[pi++] = tcgv_i64_arg(reth);

            op->args[pi++] = tcgv_i64_arg(retl);

            nb_rets = 2;

        } else {

            op->args[pi++] = temp_arg(ret);

            nb_rets = 1;

        }

#else

        if (TCG_TARGET_REG_BITS < 64 && (sizemask & 1)) {

#ifdef HOST_WORDS_BIGENDIAN

            op->args[pi++] = temp_arg(ret + 1);

            op->args[pi++] = temp_arg(ret);

#else

            op->args[pi++] = temp_arg(ret);

            op->args[pi++] = temp_arg(ret + 1);

#endif

            nb_rets = 2;

        } else {

            op->args[pi++] = temp_arg(ret);

            nb_rets = 1;

        }

#endif

    } else {

        nb_rets = 0;

    }

    op->callo = nb_rets;



    real_args = 0;

    for (i = 0; i < nargs; i++) {

        int is_64bit = sizemask & (1 << (i+1)*2);

        if (TCG_TARGET_REG_BITS < 64 && is_64bit) {

#ifdef TCG_TARGET_CALL_ALIGN_ARGS

            /* some targets want aligned 64 bit args */

            if (real_args & 1) {

                op->args[pi++] = TCG_CALL_DUMMY_ARG;

                real_args++;

            }

#endif

           /* If stack grows up, then we will be placing successive

              arguments at lower addresses, which means we need to

              reverse the order compared to how we would normally

              treat either big or little-endian.  For those arguments

              that will wind up in registers, this still works for

              HPPA (the only current STACK_GROWSUP target) since the

              argument registers are *also* allocated in decreasing

              order.  If another such target is added, this logic may

              have to get more complicated to differentiate between

              stack arguments and register arguments.  */

#if defined(HOST_WORDS_BIGENDIAN) != defined(TCG_TARGET_STACK_GROWSUP)

            op->args[pi++] = temp_arg(args[i] + 1);

            op->args[pi++] = temp_arg(args[i]);

#else

            op->args[pi++] = temp_arg(args[i]);

            op->args[pi++] = temp_arg(args[i] + 1);

#endif

            real_args += 2;

            continue;

        }



        op->args[pi++] = temp_arg(args[i]);

        real_args++;

    }

    op->args[pi++] = (uintptr_t)func;

    op->args[pi++] = flags;

    op->calli = real_args;



    /* Make sure the fields didn't overflow.  */

    tcg_debug_assert(op->calli == real_args);

    tcg_debug_assert(pi <= ARRAY_SIZE(op->args));



#if defined(__sparc__) && !defined(__arch64__) \

    && !defined(CONFIG_TCG_INTERPRETER)

    /* Free all of the parts we allocated above.  */

    for (i = real_args = 0; i < orig_nargs; ++i) {

        int is_64bit = orig_sizemask & (1 << (i+1)*2);

        if (is_64bit) {

            tcg_temp_free_internal(args[real_args++]);

            tcg_temp_free_internal(args[real_args++]);

        } else {

            real_args++;

        }

    }

    if (orig_sizemask & 1) {

        /* The 32-bit ABI returned two 32-bit pieces.  Re-assemble them.

           Note that describing these as TCGv_i64 eliminates an unnecessary

           zero-extension that tcg_gen_concat_i32_i64 would create.  */

        tcg_gen_concat32_i64(temp_tcgv_i64(ret), retl, reth);

        tcg_temp_free_i64(retl);

        tcg_temp_free_i64(reth);

    }

#elif defined(TCG_TARGET_EXTEND_ARGS) && TCG_TARGET_REG_BITS == 64

    for (i = 0; i < nargs; ++i) {

        int is_64bit = sizemask & (1 << (i+1)*2);

        if (!is_64bit) {

            tcg_temp_free_internal(args[i]);

        }

    }

#endif /* TCG_TARGET_EXTEND_ARGS */

}
 and probability:0.3136094674556213
code:void block_job_enter(BlockJob *job)

{

    if (!block_job_started(job)) {

        return;

    }

    if (job->deferred_to_main_loop) {

        return;

    }



    if (!job->busy) {

        bdrv_coroutine_enter(blk_bs(job->blk), job->co);

    }

}
 and probability:0.25
code:static int vorbis_decode_frame(AVCodecContext *avccontext,

                               void *data, int *data_size,

                               AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    vorbis_context *vc = avccontext->priv_data ;

    GetBitContext *gb = &(vc->gb);

    const float *channel_ptrs[255];

    int i, len;



    if (!buf_size)

        return 0;



    av_dlog(NULL, "packet length %d \n", buf_size);



    init_get_bits(gb, buf, buf_size*8);



    len = vorbis_parse_audio_packet(vc);



    if (len <= 0) {

        *data_size = 0;

        return buf_size;

    }



    if (!vc->first_frame) {

        vc->first_frame = 1;

        *data_size = 0;

        return buf_size ;

    }



    av_dlog(NULL, "parsed %d bytes %d bits, returned %d samples (*ch*bits) \n",

            get_bits_count(gb) / 8, get_bits_count(gb) % 8, len);



    if (vc->audio_channels > 8) {

        for (i = 0; i < vc->audio_channels; i++)

            channel_ptrs[i] = vc->channel_floors + i * len;

    } else {

        for (i = 0; i < vc->audio_channels; i++)

            channel_ptrs[i] = vc->channel_floors +

                              len * ff_vorbis_channel_layout_offsets[vc->audio_channels - 1][i];

    }



    if (avccontext->sample_fmt == AV_SAMPLE_FMT_FLT)

        vc->fmt_conv.float_interleave(data, channel_ptrs, len, vc->audio_channels);

    else

        vc->fmt_conv.float_to_int16_interleave(data, channel_ptrs, len,

                                               vc->audio_channels);



    *data_size = len * vc->audio_channels *

                 av_get_bytes_per_sample(avccontext->sample_fmt);



    return buf_size ;

}
 and probability:0.5116279069767442
code:void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)

{

    UINT shutdown_flag = EWX_FORCE;



    slog("guest-shutdown called, mode: %s", mode);



    if (!has_mode || strcmp(mode, "powerdown") == 0) {

        shutdown_flag |= EWX_POWEROFF;

    } else if (strcmp(mode, "halt") == 0) {

        shutdown_flag |= EWX_SHUTDOWN;

    } else if (strcmp(mode, "reboot") == 0) {

        shutdown_flag |= EWX_REBOOT;

    } else {

        error_set(err, QERR_INVALID_PARAMETER_VALUE, "mode",

                  "halt|powerdown|reboot");

        return;

    }



    /* Request a shutdown privilege, but try to shut down the system

       anyway. */

    acquire_privilege(SE_SHUTDOWN_NAME, err);

    if (error_is_set(err)) {

        return;

    }



    if (!ExitWindowsEx(shutdown_flag, SHTDN_REASON_FLAG_PLANNED)) {

        slog("guest-shutdown failed: %d", GetLastError());

        error_set(err, QERR_UNDEFINED_ERROR);

    }

}
 and probability:0.0
code:void helper_rdmsr(void)

{

    uint64_t val;



    helper_svm_check_intercept_param(SVM_EXIT_MSR, 0);



    switch((uint32_t)ECX) {

    case MSR_IA32_SYSENTER_CS:

        val = env->sysenter_cs;


    case MSR_IA32_SYSENTER_ESP:

        val = env->sysenter_esp;


    case MSR_IA32_SYSENTER_EIP:

        val = env->sysenter_eip;


    case MSR_IA32_APICBASE:

        val = cpu_get_apic_base(env);


    case MSR_EFER:

        val = env->efer;


    case MSR_STAR:

        val = env->star;


    case MSR_PAT:

        val = env->pat;


    case MSR_VM_HSAVE_PA:

        val = env->vm_hsave;


    case MSR_IA32_PERF_STATUS:

        /* tsc_increment_by_tick */

        val = 1000ULL;

        /* CPU multiplier */

        val |= (((uint64_t)4ULL) << 40);


#ifdef TARGET_X86_64

    case MSR_LSTAR:

        val = env->lstar;


    case MSR_CSTAR:

        val = env->cstar;


    case MSR_FMASK:

        val = env->fmask;


    case MSR_FSBASE:

        val = env->segs[R_FS].base;


    case MSR_GSBASE:

        val = env->segs[R_GS].base;


    case MSR_KERNELGSBASE:

        val = env->kernelgsbase;


#endif

#ifdef USE_KQEMU

    case MSR_QPI_COMMBASE:

        if (env->kqemu_enabled) {

            val = kqemu_comm_base;

        } else {

            val = 0;

        }


#endif









































    default:

        /* XXX: exception ? */

        val = 0;


    }

    EAX = (uint32_t)(val);

    EDX = (uint32_t)(val >> 32);

} and probability:0.2545454545454545
code:BlockJobInfoList *qmp_query_block_jobs(Error **errp)

{

    BlockJobInfoList *head = NULL, **p_next = &head;

    BlockDriverState *bs;

    BdrvNextIterator *it = NULL;



    while ((it = bdrv_next(it, &bs))) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);



        if (bs->job) {

            BlockJobInfoList *elem = g_new0(BlockJobInfoList, 1);

            elem->value = block_job_query(bs->job);

            *p_next = elem;

            p_next = &elem->next;

        }



        aio_context_release(aio_context);

    }



    return head;

}
 and probability:0.2222222222222222
code:DeviceState *ssi_create_slave(SSIBus *bus, const char *name)

{

    DeviceState *dev;

    dev = qdev_create(&bus->qbus, name);

    qdev_init(dev);

    return dev;

}
 and probability:0.14285714285714285
code:int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask,

                        const AVFrame *reference)

{

    int len, nb_components, i, h, v, predictor, point_transform;

    int index, id, ret;

    const int block_size = s->lossless ? 1 : 8;

    int ilv, prev_shift;



    if (!s->got_picture) {

        av_log(s->avctx, AV_LOG_WARNING,

                "Can not process SOS before SOF, skipping\n");

        return -1;

    }



    av_assert0(s->picture_ptr->data[0]);

    /* XXX: verify len field validity */

    len = get_bits(&s->gb, 16);

    nb_components = get_bits(&s->gb, 8);

    if (nb_components == 0 || nb_components > MAX_COMPONENTS) {

        av_log(s->avctx, AV_LOG_ERROR,

               "decode_sos: nb_components (%d) unsupported\n", nb_components);

        return AVERROR_PATCHWELCOME;

    }

    if (len != 6 + 2 * nb_components) {

        av_log(s->avctx, AV_LOG_ERROR, "decode_sos: invalid len (%d)\n", len);

        return AVERROR_INVALIDDATA;

    }

    for (i = 0; i < nb_components; i++) {

        id = get_bits(&s->gb, 8) - 1;

        av_log(s->avctx, AV_LOG_DEBUG, "component: %d\n", id);

        /* find component index */

        for (index = 0; index < s->nb_components; index++)

            if (id == s->component_id[index])

                break;

        if (index == s->nb_components) {

            av_log(s->avctx, AV_LOG_ERROR,

                   "decode_sos: index(%d) out of components\n", index);

            return AVERROR_INVALIDDATA;

        }

        /* Metasoft MJPEG codec has Cb and Cr swapped */

        if (s->avctx->codec_tag == MKTAG('M', 'T', 'S', 'J')

            && nb_components == 3 && s->nb_components == 3 && i)

            index = 3 - i;



        s->quant_sindex[i] = s->quant_index[index];

        s->nb_blocks[i] = s->h_count[index] * s->v_count[index];

        s->h_scount[i]  = s->h_count[index];

        s->v_scount[i]  = s->v_count[index];



        if(nb_components == 3 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)

            index = (i+2)%3;

        if(nb_components == 1 && s->nb_components == 3 && s->avctx->pix_fmt == AV_PIX_FMT_GBR24P)

            index = (index+2)%3;



        s->comp_index[i] = index;



        s->dc_index[i] = get_bits(&s->gb, 4);

        s->ac_index[i] = get_bits(&s->gb, 4);



        if (s->dc_index[i] <  0 || s->ac_index[i] < 0 ||

            s->dc_index[i] >= 4 || s->ac_index[i] >= 4)

            goto out_of_range;

        if (!s->vlcs[0][s->dc_index[i]].table || !(s->progressive ? s->vlcs[2][s->ac_index[0]].table : s->vlcs[1][s->ac_index[i]].table))

            goto out_of_range;

    }



    predictor = get_bits(&s->gb, 8);       /* JPEG Ss / lossless JPEG predictor /JPEG-LS NEAR */

    ilv = get_bits(&s->gb, 8);             /* JPEG Se / JPEG-LS ILV */

    if(s->avctx->codec_tag != AV_RL32("CJPG")){

        prev_shift      = get_bits(&s->gb, 4); /* Ah */

        point_transform = get_bits(&s->gb, 4); /* Al */

    }else

        prev_shift = point_transform = 0;



    if (nb_components > 1) {

        /* interleaved stream */

        s->mb_width  = (s->width  + s->h_max * block_size - 1) / (s->h_max * block_size);

        s->mb_height = (s->height + s->v_max * block_size - 1) / (s->v_max * block_size);

    } else if (!s->ls) { /* skip this for JPEG-LS */

        h = s->h_max / s->h_scount[0];

        v = s->v_max / s->v_scount[0];

        s->mb_width     = (s->width  + h * block_size - 1) / (h * block_size);

        s->mb_height    = (s->height + v * block_size - 1) / (v * block_size);

        s->nb_blocks[0] = 1;

        s->h_scount[0]  = 1;

        s->v_scount[0]  = 1;

    }



    if (s->avctx->debug & FF_DEBUG_PICT_INFO)

        av_log(s->avctx, AV_LOG_DEBUG, "%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\n",

               s->lossless ? "lossless" : "sequential DCT", s->rgb ? "RGB" : "",

               predictor, point_transform, ilv, s->bits, s->mjpb_skiptosod,

               s->pegasus_rct ? "PRCT" : (s->rct ? "RCT" : ""), nb_components);





    /* mjpeg-b can have padding bytes between sos and image data, skip them */

    for (i = s->mjpb_skiptosod; i > 0; i--)

        skip_bits(&s->gb, 8);



next_field:

    for (i = 0; i < nb_components; i++)

        s->last_dc[i] = (4 << s->bits);



    if (s->lossless) {

        av_assert0(s->picture_ptr == s->picture);

        if (CONFIG_JPEGLS_DECODER && s->ls) {

//            for () {

//            reset_ls_coding_parameters(s, 0);



            if ((ret = ff_jpegls_decode_picture(s, predictor,

                                                point_transform, ilv)) < 0)

                return ret;

        } else {

            if (s->rgb) {

                if ((ret = ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform)) < 0)

                    return ret;

            } else {

                if ((ret = ljpeg_decode_yuv_scan(s, predictor,

                                                 point_transform,

                                                 nb_components)) < 0)

                    return ret;

            }

        }

    } else {

        if (s->progressive && predictor) {

            av_assert0(s->picture_ptr == s->picture);

            if ((ret = mjpeg_decode_scan_progressive_ac(s, predictor,

                                                        ilv, prev_shift,

                                                        point_transform)) < 0)

                return ret;

        } else {

            if ((ret = mjpeg_decode_scan(s, nb_components,

                                         prev_shift, point_transform,

                                         mb_bitmask, reference)) < 0)

                return ret;

        }

    }



    if (s->interlaced &&

        get_bits_left(&s->gb) > 32 &&

        show_bits(&s->gb, 8) == 0xFF) {

        GetBitContext bak = s->gb;

        align_get_bits(&bak);

        if (show_bits(&bak, 16) == 0xFFD1) {

            av_log(s->avctx, AV_LOG_DEBUG, "AVRn interlaced picture marker found\n");

            s->gb = bak;

            skip_bits(&s->gb, 16);

            s->bottom_field ^= 1;



            goto next_field;

        }

    }



    emms_c();

    return 0;

 out_of_range:

    av_log(s->avctx, AV_LOG_ERROR, "decode_sos: ac/dc index out of range\n");

    return AVERROR_INVALIDDATA;

}
 and probability:0.5106382978723404
code:static void v9fs_renameat(void *opaque)
{
    ssize_t err = 0;
    size_t offset = 7;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t olddirfid, newdirfid;
    V9fsString old_name, new_name;
    v9fs_string_init(&old_name);
    v9fs_string_init(&new_name);
    err = pdu_unmarshal(pdu, offset, "dsds", &olddirfid,
                        &old_name, &newdirfid, &new_name);
    if (err < 0) {
    if (name_is_illegal(old_name.data) || name_is_illegal(new_name.data)) {
        err = -ENOENT;
    v9fs_path_write_lock(s);
    err = v9fs_complete_renameat(pdu, olddirfid,
                                 &old_name, newdirfid, &new_name);
    v9fs_path_unlock(s);
    if (!err) {
        err = offset;
out_err:
    pdu_complete(pdu, err);
    v9fs_string_free(&old_name);
    v9fs_string_free(&new_name); and probability:0.04
code:if_start(void)
{
	struct mbuf *ifm, *ifqt;
	DEBUG_CALL("if_start");
	if (if_queued == 0)
	   return; /* Nothing to do */
 again:
        /* check if we can really output */
        if (!slirp_can_output())
            return;
	/*
	 * See which queue to get next packet from
	 * If there's something in the fastq, select it immediately
	 */
	if (if_fastq.ifq_next != &if_fastq) {
		ifm = if_fastq.ifq_next;
	} else {
		/* Nothing on fastq, see if next_m is valid */
		if (next_m != &if_batchq)
		   ifm = next_m;
		else
		   ifm = if_batchq.ifq_next;
		/* Set which packet to send on next iteration */
		next_m = ifm->ifq_next;
	}
	/* Remove it from the queue */
	ifqt = ifm->ifq_prev;
	remque(ifm);
	--if_queued;
	/* If there are more packets for this session, re-queue them */
	if (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {
		insque(ifm->ifs_next, ifqt);
		ifs_remque(ifm);
	}
	/* Update so_queued */
	if (ifm->ifq_so) {
		if (--ifm->ifq_so->so_queued == 0)
		   /* If there's no more queued, reset nqueued */
		   ifm->ifq_so->so_nqueued = 0;
	}
	/* Encapsulate the packet for sending */
        if_encap(ifm->m_data, ifm->m_len);
	if (if_queued)
	   goto again;
} and probability:0.2
code:static void mips_cpu_realizefn(DeviceState *dev, Error **errp)

{

    MIPSCPU *cpu = MIPS_CPU(dev);

    MIPSCPUClass *mcc = MIPS_CPU_GET_CLASS(dev);



    cpu_reset(CPU(cpu));



    mcc->parent_realize(dev, errp);

}
 and probability:0.14285714285714285
code:int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)

{

    int ret = 0;

    if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(p) * 6 / 8;

        char *buf = av_mallocz(len);

        av_base64_decode(buf, p, len);



        if (rtp_asf_fix_header(buf, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   "Failed to fix invalid RTSP-MS/ASF min_pktsize\n");

        init_packetizer(&pb, buf, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }

        if (!(rt->asf_ctx = avformat_alloc_context()))

            return AVERROR(ENOMEM);

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, "no_resync_search", "1", 0);

        ret = avformat_open_input(&rt->asf_ctx, "", &ff_asf_demuxer, &opts);

        av_dict_free(&opts);

        if (ret < 0)

            return ret;

        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(buf);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
 and probability:0.3125
code:static void alloc_picture(VideoState *is)

{

    VideoPicture *vp;

    int64_t bufferdiff;



    vp = &is->pictq[is->pictq_windex];



    if (vp->bmp)

        SDL_FreeYUVOverlay(vp->bmp);



    video_open(is, 0, vp);



    vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height,

                                   SDL_YV12_OVERLAY,

                                   screen);

    bufferdiff = vp->bmp ? FFMAX(vp->bmp->pixels[0], vp->bmp->pixels[1]) - FFMIN(vp->bmp->pixels[0], vp->bmp->pixels[1]) : 0;

    if (!vp->bmp || vp->bmp->pitches[0] < vp->width || bufferdiff < vp->height * vp->bmp->pitches[0]) {

        /* SDL allocates a buffer smaller than requested if the video

         * overlay hardware is unable to support the requested size. */

        av_log(NULL, AV_LOG_FATAL,

               "Error: the video system does not support an image\n"

                        "size of %dx%d pixels. Try using -lowres or -vf \"scale=w:h\"\n"

                        "to reduce the image size.\n", vp->width, vp->height );

        do_exit(is);

    }



    SDL_LockMutex(is->pictq_mutex);

    vp->allocated = 1;

    SDL_CondSignal(is->pictq_cond);

    SDL_UnlockMutex(is->pictq_mutex);

}
 and probability:0.4230769230769231
code:void virtqueue_discard(VirtQueue *vq, const VirtQueueElement *elem,

                       unsigned int len)

{

    vq->last_avail_idx--;


    virtqueue_unmap_sg(vq, elem, len);

} and probability:0.16666666666666666
code:static void arm_gic_common_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->reset = arm_gic_common_reset;

    dc->realize = arm_gic_common_realize;

    dc->props = arm_gic_common_properties;

    dc->vmsd = &vmstate_gic;

    dc->no_user = 1;

}
 and probability:0.5555555555555556
code:static CharDriverState *qemu_chr_open_tty(QemuOpts *opts)

{

    const char *filename = qemu_opt_get(opts, "path");

    CharDriverState *chr;

    int fd;



    TFR(fd = open(filename, O_RDWR | O_NONBLOCK));

    if (fd < 0) {

        return NULL;

    }

    tty_serial_init(fd, 115200, 'N', 8, 1);

    chr = qemu_chr_open_fd(fd, fd);

    if (!chr) {

        close(fd);

        return NULL;

    }

    chr->chr_ioctl = tty_serial_ioctl;

    chr->chr_close = qemu_chr_close_tty;

    return chr;

}
 and probability:0.10526315789473684
code:void object_property_set_qobject(Object *obj, QObject *value,

                                 const char *name, Error **errp)

{

    Visitor *v;

    /* TODO: Should we reject, rather than ignore, excess input? */

    v = qobject_input_visitor_new(value, false);

    object_property_set(obj, v, name, errp);

    visit_free(v);

}
 and probability:0.0
code:static int http_receive_data(HTTPContext *c)

{

    int len;

    HTTPContext *c1;



    if (c->buffer_ptr >= c->buffer_end) {

        FFStream *feed = c->stream;

        /* a packet has been received : write it in the store, except

           if header */

        if (c->data_count > FFM_PACKET_SIZE) {

            

            //            printf("writing pos=0x%Lx size=0x%Lx\n", feed->feed_write_index, feed->feed_size);

            /* XXX: use llseek or url_seek */

            lseek(c->feed_fd, feed->feed_write_index, SEEK_SET);

            write(c->feed_fd, c->buffer, FFM_PACKET_SIZE);

            

            feed->feed_write_index += FFM_PACKET_SIZE;

            /* update file size */

            if (feed->feed_write_index > c->stream->feed_size)

                feed->feed_size = feed->feed_write_index;



            /* handle wrap around if max file size reached */

            if (feed->feed_write_index >= c->stream->feed_max_size)

                feed->feed_write_index = FFM_PACKET_SIZE;



            /* write index */

            ffm_write_write_index(c->feed_fd, feed->feed_write_index);



            /* wake up any waiting connections */

            for(c1 = first_http_ctx; c1 != NULL; c1 = c1->next) {

                if (c1->state == HTTPSTATE_WAIT_FEED && 

                    c1->stream->feed == c->stream->feed) {

                    c1->state = HTTPSTATE_SEND_DATA;

                }

            }

        } else {

            /* We have a header in our hands that contains useful data */

            AVFormatContext s;

            ByteIOContext *pb = &s.pb;

            int i;



            memset(&s, 0, sizeof(s));



            url_open_buf(pb, c->buffer, c->buffer_end - c->buffer, URL_RDONLY);

            pb->buf_end = c->buffer_end;        /* ?? */

            pb->is_streamed = 1;



            if (feed->fmt->read_header(&s, 0) < 0) {

                goto fail;

            }



            /* Now we have the actual streams */

            if (s.nb_streams != feed->nb_streams) {

                goto fail;

            }

            for (i = 0; i < s.nb_streams; i++) {

                memcpy(&feed->streams[i]->codec, &s.streams[i]->codec, sizeof(AVCodecContext));

            } 

        }

        c->buffer_ptr = c->buffer;

    }



    len = read(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr);

    if (len < 0) {

        if (errno != EAGAIN && errno != EINTR) {

            /* error : close connection */

            goto fail;

        }

    } else if (len == 0) {

        /* end of connection : close it */

        goto fail;

    } else {

        c->buffer_ptr += len;

        c->data_count += len;

    }

    return 0;

 fail:

    c->stream->feed_opened = 0;

    close(c->feed_fd);

    return -1;

}
 and probability:0.4
code:static int stellaris_sys_init(uint32_t base, qemu_irq irq,

                              stellaris_board_info * board,

                              uint8_t *macaddr)

{

    ssys_state *s;



    s = (ssys_state *)g_malloc0(sizeof(ssys_state));

    s->irq = irq;

    s->board = board;

    /* Most devices come preprogrammed with a MAC address in the user data. */

    s->user0 = macaddr[0] | (macaddr[1] << 8) | (macaddr[2] << 16);

    s->user1 = macaddr[3] | (macaddr[4] << 8) | (macaddr[5] << 16);



    memory_region_init_io(&s->iomem, NULL, &ssys_ops, s, "ssys", 0x00001000);

    memory_region_add_subregion(get_system_memory(), base, &s->iomem);

    ssys_reset(s);

    vmstate_register(NULL, -1, &vmstate_stellaris_sys, s);

    return 0;

}
 and probability:0.35294117647058826
code:static int kvm_recommended_vcpus(KVMState *s)

{

    int ret = kvm_check_extension(s, KVM_CAP_NR_VCPUS);

    return (ret) ? ret : 4;

}
 and probability:0.0
code:static void reschedule_dma(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    qemu_bh_delete(dbs->bh);

    dbs->bh = NULL;

    dma_bdrv_cb(opaque, 0);

}
 and probability:0.2857142857142857
code:static int adpcm_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            uint8_t *buf, int buf_size)

{

    ADPCMContext *c = avctx->priv_data;

    ADPCMChannelStatus *cs;

    int n, m, channel, i;

    int block_predictor[2];

    short *samples;

    short *samples_end;

    uint8_t *src;

    int st; /* stereo */



    /* DK3 ADPCM accounting variables */

    unsigned char last_byte = 0;

    unsigned char nibble;

    int decode_top_nibble_next = 0;

    int diff_channel;



    /* EA ADPCM state variables */

    uint32_t samples_in_chunk;

    int32_t previous_left_sample, previous_right_sample;

    int32_t current_left_sample, current_right_sample;

    int32_t next_left_sample, next_right_sample;

    int32_t coeff1l, coeff2l, coeff1r, coeff2r;

    uint8_t shift_left, shift_right;

    int count1, count2;



    if (!buf_size)

        return 0;



    //should protect all 4bit ADPCM variants

    //8 is needed for CODEC_ID_ADPCM_IMA_WAV with 2 channels

    //

    if(*data_size/4 < buf_size + 8)

        return -1;



    samples = data;

    samples_end= samples + *data_size/2;

    *data_size= 0;

    src = buf;



    st = avctx->channels == 2 ? 1 : 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_IMA_QT:

        n = (buf_size - 2);/* >> 2*avctx->channels;*/

        channel = c->channel;

        cs = &(c->status[channel]);

        /* (pppppp) (piiiiiii) */



        /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */

        cs->predictor = (*src++) << 8;

        cs->predictor |= (*src & 0x80);

        cs->predictor &= 0xFF80;



        /* sign extension */

        if(cs->predictor & 0x8000)

            cs->predictor -= 0x10000;



        CLAMP_TO_SHORT(cs->predictor);



        cs->step_index = (*src++) & 0x7F;



        if (cs->step_index > 88){

            av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i\n", cs->step_index);

            cs->step_index = 88;

        }



        cs->step = step_table[cs->step_index];



        if (st && channel)

            samples++;



        for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */

            *samples = adpcm_ima_expand_nibble(cs, src[0] & 0x0F, 3);

            samples += avctx->channels;

            *samples = adpcm_ima_expand_nibble(cs, (src[0] >> 4) & 0x0F, 3);

            samples += avctx->channels;

            src ++;

        }



        if(st) { /* handle stereo interlacing */

            c->channel = (channel + 1) % 2; /* we get one packet for left, then one for right data */

            if(channel == 1) { /* wait for the other packet before outputing anything */

                return src - buf;

            }

        }

        break;

    case CODEC_ID_ADPCM_IMA_WAV:

        if (avctx->block_align != 0 && buf_size > avctx->block_align)

            buf_size = avctx->block_align;



//        samples_per_block= (block_align-4*chanels)*8 / (bits_per_sample * chanels) + 1;



        for(i=0; i<avctx->channels; i++){

            cs = &(c->status[i]);

            cs->predictor = (int16_t)(src[0] + (src[1]<<8));

            src+=2;



        // XXX: is this correct ??: *samples++ = cs->predictor;



            cs->step_index = *src++;

            if (cs->step_index > 88){

                av_log(avctx, AV_LOG_ERROR, "ERROR: step_index = %i\n", cs->step_index);

                cs->step_index = 88;

            }

            if (*src++) av_log(avctx, AV_LOG_ERROR, "unused byte should be null but is %d!!\n", src[-1]); /* unused */

        }



        while(src < buf + buf_size){

            for(m=0; m<4; m++){

                for(i=0; i<=st; i++)

                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] & 0x0F, 3);

                for(i=0; i<=st; i++)

                    *samples++ = adpcm_ima_expand_nibble(&c->status[i], src[4*i] >> 4  , 3);

                src++;

            }

            src += 4*st;

        }

        break;

    case CODEC_ID_ADPCM_4XM:

        cs = &(c->status[0]);

        c->status[0].predictor= (int16_t)(src[0] + (src[1]<<8)); src+=2;

        if(st){

            c->status[1].predictor= (int16_t)(src[0] + (src[1]<<8)); src+=2;

        }

        c->status[0].step_index= (int16_t)(src[0] + (src[1]<<8)); src+=2;

        if(st){

            c->status[1].step_index= (int16_t)(src[0] + (src[1]<<8)); src+=2;

        }

        if (cs->step_index < 0) cs->step_index = 0;

        if (cs->step_index > 88) cs->step_index = 88;



        m= (buf_size - (src - buf))>>st;

        for(i=0; i<m; i++) {

            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] & 0x0F, 4);

            if (st)

                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] & 0x0F, 4);

            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[i] >> 4, 4);

            if (st)

                *samples++ = adpcm_ima_expand_nibble(&c->status[1], src[i+m] >> 4, 4);

        }



        src += m<<st;



        break;

    case CODEC_ID_ADPCM_MS:

        if (avctx->block_align != 0 && buf_size > avctx->block_align)

            buf_size = avctx->block_align;

        n = buf_size - 7 * avctx->channels;

        if (n < 0)

            return -1;

        block_predictor[0] = av_clip(*src++, 0, 7);

        block_predictor[1] = 0;

        if (st)

            block_predictor[1] = av_clip(*src++, 0, 7);

        c->status[0].idelta = (int16_t)((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

        src+=2;

        if (st){

            c->status[1].idelta = (int16_t)((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

            src+=2;

        }

        c->status[0].coeff1 = AdaptCoeff1[block_predictor[0]];

        c->status[0].coeff2 = AdaptCoeff2[block_predictor[0]];

        c->status[1].coeff1 = AdaptCoeff1[block_predictor[1]];

        c->status[1].coeff2 = AdaptCoeff2[block_predictor[1]];



        c->status[0].sample1 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

        src+=2;

        if (st) c->status[1].sample1 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

        if (st) src+=2;

        c->status[0].sample2 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

        src+=2;

        if (st) c->status[1].sample2 = ((*src & 0xFF) | ((src[1] << 8) & 0xFF00));

        if (st) src+=2;



        *samples++ = c->status[0].sample1;

        if (st) *samples++ = c->status[1].sample1;

        *samples++ = c->status[0].sample2;

        if (st) *samples++ = c->status[1].sample2;

        for(;n>0;n--) {

            *samples++ = adpcm_ms_expand_nibble(&c->status[0], (src[0] >> 4) & 0x0F);

            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);

            src ++;

        }

        break;

    case CODEC_ID_ADPCM_IMA_DK4:

        if (avctx->block_align != 0 && buf_size > avctx->block_align)

            buf_size = avctx->block_align;



        c->status[0].predictor = (int16_t)(src[0] | (src[1] << 8));

        c->status[0].step_index = src[2];

        src += 4;

        *samples++ = c->status[0].predictor;

        if (st) {

            c->status[1].predictor = (int16_t)(src[0] | (src[1] << 8));

            c->status[1].step_index = src[2];

            src += 4;

            *samples++ = c->status[1].predictor;

        }

        while (src < buf + buf_size) {



            /* take care of the top nibble (always left or mono channel) */

            *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                (src[0] >> 4) & 0x0F, 3);



            /* take care of the bottom nibble, which is right sample for

             * stereo, or another mono sample */

            if (st)

                *samples++ = adpcm_ima_expand_nibble(&c->status[1],

                    src[0] & 0x0F, 3);

            else

                *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                    src[0] & 0x0F, 3);



            src++;

        }

        break;

    case CODEC_ID_ADPCM_IMA_DK3:

        if (avctx->block_align != 0 && buf_size > avctx->block_align)

            buf_size = avctx->block_align;



        if(buf_size + 16 > (samples_end - samples)*3/8)

            return -1;



        c->status[0].predictor = (int16_t)(src[10] | (src[11] << 8));

        c->status[1].predictor = (int16_t)(src[12] | (src[13] << 8));

        c->status[0].step_index = src[14];

        c->status[1].step_index = src[15];

        /* sign extend the predictors */

        src += 16;

        diff_channel = c->status[1].predictor;



        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when

         * the buffer is consumed */

        while (1) {



            /* for this algorithm, c->status[0] is the sum channel and

             * c->status[1] is the diff channel */



            /* process the first predictor of the sum channel */

            DK3_GET_NEXT_NIBBLE();

            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);



            /* process the diff channel predictor */

            DK3_GET_NEXT_NIBBLE();

            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);



            /* process the first pair of stereo PCM samples */

            diff_channel = (diff_channel + c->status[1].predictor) / 2;

            *samples++ = c->status[0].predictor + c->status[1].predictor;

            *samples++ = c->status[0].predictor - c->status[1].predictor;



            /* process the second predictor of the sum channel */

            DK3_GET_NEXT_NIBBLE();

            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);



            /* process the second pair of stereo PCM samples */

            diff_channel = (diff_channel + c->status[1].predictor) / 2;

            *samples++ = c->status[0].predictor + c->status[1].predictor;

            *samples++ = c->status[0].predictor - c->status[1].predictor;

        }

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        /* no per-block initialization; just start decoding the data */

        while (src < buf + buf_size) {



            if (st) {

                *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                    (src[0] >> 4) & 0x0F, 3);

                *samples++ = adpcm_ima_expand_nibble(&c->status[1],

                    src[0] & 0x0F, 3);

            } else {

                *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                    (src[0] >> 4) & 0x0F, 3);

                *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                    src[0] & 0x0F, 3);

            }



            src++;

        }

        break;

    case CODEC_ID_ADPCM_XA:

        c->status[0].sample1 = c->status[0].sample2 =

        c->status[1].sample1 = c->status[1].sample2 = 0;

        while (buf_size >= 128) {

            xa_decode(samples, src, &c->status[0], &c->status[1],

                avctx->channels);

            src += 128;

            samples += 28 * 8;

            buf_size -= 128;

        }

        break;

    case CODEC_ID_ADPCM_EA:

        samples_in_chunk = AV_RL32(src);

        if (samples_in_chunk >= ((buf_size - 12) * 2)) {

            src += buf_size;

            break;

        }

        src += 4;

        current_left_sample = (int16_t)AV_RL16(src);

        src += 2;

        previous_left_sample = (int16_t)AV_RL16(src);

        src += 2;

        current_right_sample = (int16_t)AV_RL16(src);

        src += 2;

        previous_right_sample = (int16_t)AV_RL16(src);

        src += 2;



        for (count1 = 0; count1 < samples_in_chunk/28;count1++) {

            coeff1l = ea_adpcm_table[(*src >> 4) & 0x0F];

            coeff2l = ea_adpcm_table[((*src >> 4) & 0x0F) + 4];

            coeff1r = ea_adpcm_table[*src & 0x0F];

            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];

            src++;



            shift_left = ((*src >> 4) & 0x0F) + 8;

            shift_right = (*src & 0x0F) + 8;

            src++;



            for (count2 = 0; count2 < 28; count2++) {

                next_left_sample = (((*src & 0xF0) << 24) >> shift_left);

                next_right_sample = (((*src & 0x0F) << 28) >> shift_right);

                src++;



                next_left_sample = (next_left_sample +

                    (current_left_sample * coeff1l) +

                    (previous_left_sample * coeff2l) + 0x80) >> 8;

                next_right_sample = (next_right_sample +

                    (current_right_sample * coeff1r) +

                    (previous_right_sample * coeff2r) + 0x80) >> 8;

                CLAMP_TO_SHORT(next_left_sample);

                CLAMP_TO_SHORT(next_right_sample);



                previous_left_sample = current_left_sample;

                current_left_sample = next_left_sample;

                previous_right_sample = current_right_sample;

                current_right_sample = next_right_sample;

                *samples++ = (unsigned short)current_left_sample;

                *samples++ = (unsigned short)current_right_sample;

            }

        }

        break;

    case CODEC_ID_ADPCM_IMA_SMJPEG:

        c->status[0].predictor = *src;

        src += 2;

        c->status[0].step_index = *src++;

        src++;  /* skip another byte before getting to the meat */

        while (src < buf + buf_size) {

            *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                *src & 0x0F, 3);

            *samples++ = adpcm_ima_expand_nibble(&c->status[0],

                (*src >> 4) & 0x0F, 3);

            src++;

        }

        break;

    case CODEC_ID_ADPCM_CT:

        while (src < buf + buf_size) {

            if (st) {

                *samples++ = adpcm_ct_expand_nibble(&c->status[0],

                    (src[0] >> 4) & 0x0F);

                *samples++ = adpcm_ct_expand_nibble(&c->status[1],

                    src[0] & 0x0F);

            } else {

                *samples++ = adpcm_ct_expand_nibble(&c->status[0],

                    (src[0] >> 4) & 0x0F);

                *samples++ = adpcm_ct_expand_nibble(&c->status[0],

                    src[0] & 0x0F);

            }

            src++;

        }

        break;

    case CODEC_ID_ADPCM_SBPRO_4:

    case CODEC_ID_ADPCM_SBPRO_3:

    case CODEC_ID_ADPCM_SBPRO_2:

        if (!c->status[0].step_index) {

            /* the first byte is a raw sample */

            *samples++ = 128 * (*src++ - 0x80);

            if (st)

              *samples++ = 128 * (*src++ - 0x80);

            c->status[0].step_index = 1;

        }

        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {

            while (src < buf + buf_size) {

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    (src[0] >> 4) & 0x0F, 4, 0);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],

                    src[0] & 0x0F, 4, 0);

                src++;

            }

        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {

            while (src < buf + buf_size && samples + 2 < samples_end) {

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    (src[0] >> 5) & 0x07, 3, 0);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    (src[0] >> 2) & 0x07, 3, 0);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    src[0] & 0x03, 2, 0);

                src++;

            }

        } else {

            while (src < buf + buf_size && samples + 3 < samples_end) {

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    (src[0] >> 6) & 0x03, 2, 2);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],

                    (src[0] >> 4) & 0x03, 2, 2);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],

                    (src[0] >> 2) & 0x03, 2, 2);

                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],

                    src[0] & 0x03, 2, 2);

                src++;

            }

        }

        break;

    case CODEC_ID_ADPCM_SWF:

    {

        GetBitContext gb;

        const int *table;

        int k0, signmask, nb_bits;

        int size = buf_size*8;



        init_get_bits(&gb, buf, size);



        //read bits & inital values

        nb_bits = get_bits(&gb, 2)+2;

        //av_log(NULL,AV_LOG_INFO,"nb_bits: %d\n", nb_bits);

        table = swf_index_tables[nb_bits-2];

        k0 = 1 << (nb_bits-2);

        signmask = 1 << (nb_bits-1);



        for (i = 0; i < avctx->channels; i++) {

            *samples++ = c->status[i].predictor = get_sbits(&gb, 16);

            c->status[i].step_index = get_bits(&gb, 6);

        }



        while (get_bits_count(&gb) < size)

        {

            int i;



            for (i = 0; i < avctx->channels; i++) {

                // similar to IMA adpcm

                int delta = get_bits(&gb, nb_bits);

                int step = step_table[c->status[i].step_index];

                long vpdiff = 0; // vpdiff = (delta+0.5)*step/4

                int k = k0;



                do {

                    if (delta & k)

                        vpdiff += step;

                    step >>= 1;

                    k >>= 1;

                } while(k);

                vpdiff += step;



                if (delta & signmask)

                    c->status[i].predictor -= vpdiff;

                else

                    c->status[i].predictor += vpdiff;



                c->status[i].step_index += table[delta & (~signmask)];



                c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);

                c->status[i].predictor = av_clip(c->status[i].predictor, -32768, 32767);



                *samples++ = c->status[i].predictor;

                if (samples >= samples_end) {

                    av_log(avctx, AV_LOG_ERROR, "allocated output buffer is too small\n");

                    return -1;

                }

            }

        }

        src += buf_size;

        break;

    }

    case CODEC_ID_ADPCM_YAMAHA:

        while (src < buf + buf_size) {

            if (st) {

                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],

                        src[0] & 0x0F);

                *samples++ = adpcm_yamaha_expand_nibble(&c->status[1],

                        (src[0] >> 4) & 0x0F);

            } else {

                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],

                        src[0] & 0x0F);

                *samples++ = adpcm_yamaha_expand_nibble(&c->status[0],

                        (src[0] >> 4) & 0x0F);

            }

            src++;

        }

        break;

    case CODEC_ID_ADPCM_THP:

    {

        int table[2][16];

        unsigned int samplecnt;

        int prev[2][2];

        int ch;



        if (buf_size < 80) {

            av_log(avctx, AV_LOG_ERROR, "frame too small\n");

            return -1;

        }



        src+=4;

        samplecnt = bytestream_get_be32(&src);



        for (i = 0; i < 32; i++)

            table[0][i] = (int16_t)bytestream_get_be16(&src);



        /* Initialize the previous sample.  */

        for (i = 0; i < 4; i++)

            prev[0][i] = (int16_t)bytestream_get_be16(&src);



        if (samplecnt >= (samples_end - samples) /  (st + 1)) {

            av_log(avctx, AV_LOG_ERROR, "allocated output buffer is too small\n");

            return -1;

        }



        for (ch = 0; ch <= st; ch++) {

            samples = (unsigned short *) data + ch;



            /* Read in every sample for this channel.  */

            for (i = 0; i < samplecnt / 14; i++) {

                int index = (*src >> 4) & 7;

                unsigned int exp = 28 - (*src++ & 15);

                int factor1 = table[ch][index * 2];

                int factor2 = table[ch][index * 2 + 1];



                /* Decode 14 samples.  */

                for (n = 0; n < 14; n++) {

                    int32_t sampledat;

                    if(n&1) sampledat=  *src++    <<28;

                    else    sampledat= (*src&0xF0)<<24;



                    *samples = ((prev[ch][0]*factor1

                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);

                    prev[ch][1] = prev[ch][0];

                    prev[ch][0] = *samples++;



                    /* In case of stereo, skip one sample, this sample

                       is for the other channel.  */

                    samples += st;

                }

            }

        }



        /* In the previous loop, in case stereo is used, samples is

           increased exactly one time too often.  */

        samples -= st;

        break;

    }



    default:

        return -1;

    }

    *data_size = (uint8_t *)samples - (uint8_t *)data;

    return src - buf;

}
 and probability:0.563265306122449
code:static coroutine_fn void test_multi_co_schedule_entry(void *opaque)

{

    g_assert(to_schedule[id] == NULL);

    atomic_mb_set(&to_schedule[id], qemu_coroutine_self());



    while (!atomic_mb_read(&now_stopping)) {

        int n;



        n = g_test_rand_int_range(0, NUM_CONTEXTS);

        schedule_next(n);

        qemu_coroutine_yield();



        g_assert(to_schedule[id] == NULL);

        atomic_mb_set(&to_schedule[id], qemu_coroutine_self());

    }

}
 and probability:0.3076923076923077
code:static int qcow_open(BlockDriverState *bs, QDict *options, int flags,

                     Error **errp)

{

    BDRVQcowState *s = bs->opaque;

    int len, i, shift, ret;

    QCowHeader header;



    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));

    if (ret < 0) {

        goto fail;

    }

    be32_to_cpus(&header.magic);

    be32_to_cpus(&header.version);

    be64_to_cpus(&header.backing_file_offset);

    be32_to_cpus(&header.backing_file_size);

    be32_to_cpus(&header.mtime);

    be64_to_cpus(&header.size);

    be32_to_cpus(&header.crypt_method);

    be64_to_cpus(&header.l1_table_offset);



    if (header.magic != QCOW_MAGIC) {

        error_setg(errp, "Image not in qcow format");

        ret = -EINVAL;

        goto fail;

    }

    if (header.version != QCOW_VERSION) {

        char version[64];

        snprintf(version, sizeof(version), "QCOW version %" PRIu32,

                 header.version);

        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,

                  bs->device_name, "qcow", version);

        ret = -ENOTSUP;

        goto fail;

    }



    if (header.size <= 1) {

        error_setg(errp, "Image size is too small (must be at least 2 bytes)");

        ret = -EINVAL;

        goto fail;

    }

    if (header.cluster_bits < 9 || header.cluster_bits > 16) {

        error_setg(errp, "Cluster size must be between 512 and 64k");

        ret = -EINVAL;

        goto fail;

    }



    /* l2_bits specifies number of entries; storing a uint64_t in each entry,

     * so bytes = num_entries << 3. */

    if (header.l2_bits < 9 - 3 || header.l2_bits > 16 - 3) {

        error_setg(errp, "L2 table size must be between 512 and 64k");

        ret = -EINVAL;

        goto fail;

    }



    if (header.crypt_method > QCOW_CRYPT_AES) {

        error_setg(errp, "invalid encryption method in qcow header");

        ret = -EINVAL;

        goto fail;

    }

    s->crypt_method_header = header.crypt_method;

    if (s->crypt_method_header) {

        bs->encrypted = 1;

    }

    s->cluster_bits = header.cluster_bits;

    s->cluster_size = 1 << s->cluster_bits;

    s->cluster_sectors = 1 << (s->cluster_bits - 9);

    s->l2_bits = header.l2_bits;

    s->l2_size = 1 << s->l2_bits;

    bs->total_sectors = header.size / 512;

    s->cluster_offset_mask = (1LL << (63 - s->cluster_bits)) - 1;



    /* read the level 1 table */

    shift = s->cluster_bits + s->l2_bits;

    if (header.size > UINT64_MAX - (1LL << shift)) {

        error_setg(errp, "Image too large");

        ret = -EINVAL;

        goto fail;

    } else {

        uint64_t l1_size = (header.size + (1LL << shift) - 1) >> shift;

        if (l1_size > INT_MAX / sizeof(uint64_t)) {

            error_setg(errp, "Image too large");

            ret = -EINVAL;

            goto fail;

        }

        s->l1_size = l1_size;

    }



    s->l1_table_offset = header.l1_table_offset;

    s->l1_table = g_malloc(s->l1_size * sizeof(uint64_t));



    ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,

               s->l1_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail;

    }



    for(i = 0;i < s->l1_size; i++) {

        be64_to_cpus(&s->l1_table[i]);

    }

    /* alloc L2 cache */

    s->l2_cache = g_malloc(s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));

    s->cluster_cache = g_malloc(s->cluster_size);

    s->cluster_data = g_malloc(s->cluster_size);

    s->cluster_cache_offset = -1;



    /* read the backing file name */

    if (header.backing_file_offset != 0) {

        len = header.backing_file_size;

        if (len > 1023) {

            len = 1023;

        }

        ret = bdrv_pread(bs->file, header.backing_file_offset,

                   bs->backing_file, len);

        if (ret < 0) {

            goto fail;

        }

        bs->backing_file[len] = '\0';

    }



    /* Disable migration when qcow images are used */

    error_set(&s->migration_blocker,

              QERR_BLOCK_FORMAT_FEATURE_NOT_SUPPORTED,

              "qcow", bs->device_name, "live migration");

    migrate_add_blocker(s->migration_blocker);



    qemu_co_mutex_init(&s->lock);

    return 0;



 fail:

    g_free(s->l1_table);

    g_free(s->l2_cache);

    g_free(s->cluster_cache);

    g_free(s->cluster_data);

    return ret;

}
 and probability:0.32786885245901637
code:static AVFilterBufferRef *copy_buffer_ref(AVFilterContext *ctx,

                                          AVFilterBufferRef *ref)

{

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *buf;

    int channels, data_size, i;



    switch (outlink->type) {



    case AVMEDIA_TYPE_VIDEO:

        buf = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,

                                        ref->video->w, ref->video->h);



        av_image_copy(buf->data, buf->linesize,

                      (void*)ref->data, ref->linesize,

                      ref->format, ref->video->w, ref->video->h);

        break;



    case AVMEDIA_TYPE_AUDIO:

        buf = ff_get_audio_buffer(outlink, AV_PERM_WRITE,

                                        ref->audio->nb_samples);



        channels = av_get_channel_layout_nb_channels(ref->audio->channel_layout);

        av_samples_copy(buf->extended_data, ref->buf->extended_data,

                        0, 0, ref->audio->nb_samples,

                        channels,

                        ref->format);

        break;



    default:


    }

    avfilter_copy_buffer_ref_props(buf, ref);

    return buf;

} and probability:0.39285714285714285
code:void qmp_block_commit(const char *device,

                      bool has_base, const char *base, const char *top,

                      bool has_speed, int64_t speed,

                      Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs, *top_bs;

    Error *local_err = NULL;

    /* This will be part of the QMP command, if/when the

     * BlockdevOnError change for blkmirror makes it in

     */

    BlockdevOnError on_error = BLOCKDEV_ON_ERROR_REPORT;



    /* drain all i/o before commits */

    bdrv_drain_all();



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }

    if (base && has_base) {

        base_bs = bdrv_find_backing_image(bs, base);

    } else {

        base_bs = bdrv_find_base(bs);

    }



    if (base_bs == NULL) {

        error_set(errp, QERR_BASE_NOT_FOUND, base ? base : "NULL");

        return;

    }



    /* default top_bs is the active layer */

    top_bs = bs;



    if (top) {

        if (strcmp(bs->filename, top) != 0) {

            top_bs = bdrv_find_backing_image(bs, top);

        }

    }



    if (top_bs == NULL) {

        error_setg(errp, "Top image file %s not found", top ? top : "NULL");

        return;

    }



    commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,

                &local_err);

    if (local_err != NULL) {

        error_propagate(errp, local_err);

        return;

    }

    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));

}
 and probability:0.02
code:static int mkv_check_tag(AVDictionary *m)

{

    AVDictionaryEntry *t = NULL;



    while ((t = av_dict_get(m, "", t, AV_DICT_IGNORE_SUFFIX)))

        if (av_strcasecmp(t->key, "title") && av_strcasecmp(t->key, "stereo_mode"))

            return 1;



    return 0;

}
 and probability:0.125
code:int ff_h2645_extract_rbsp(const uint8_t *src, int length,

                          H2645NAL *nal)

{

    int i, si, di;

    uint8_t *dst;



    nal->skipped_bytes = 0;

#define STARTCODE_TEST                                                  \

        if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \

            if (src[i + 2] != 3 && src[i + 2] != 0) {                   \

                /* startcode, so we must be past the end */             \

                length = i;                                             \

            }                                                           \

            break;                                                      \

        }

#if HAVE_FAST_UNALIGNED

#define FIND_FIRST_ZERO                                                 \

        if (i > 0 && !src[i])                                           \

            i--;                                                        \

        while (src[i])                                                  \

            i++

#if HAVE_FAST_64BIT

    for (i = 0; i + 1 < length; i += 9) {

        if (!((~AV_RN64A(src + i) &

               (AV_RN64A(src + i) - 0x0100010001000101ULL)) &

              0x8000800080008080ULL))

            continue;

        FIND_FIRST_ZERO;

        STARTCODE_TEST;

        i -= 7;

    }

#else

    for (i = 0; i + 1 < length; i += 5) {

        if (!((~AV_RN32A(src + i) &

               (AV_RN32A(src + i) - 0x01000101U)) &

              0x80008080U))

            continue;

        FIND_FIRST_ZERO;

        STARTCODE_TEST;

        i -= 3;

    }

#endif /* HAVE_FAST_64BIT */

#else

    for (i = 0; i + 1 < length; i += 2) {

        if (src[i])

            continue;

        if (i > 0 && src[i - 1] == 0)

            i--;

        STARTCODE_TEST;

    }

#endif /* HAVE_FAST_UNALIGNED */



    if (i >= length - 1) { // no escaped 0

        nal->data     =

        nal->raw_data = src;

        nal->size     =

        nal->raw_size = length;

        return length;

    }



    av_fast_malloc(&nal->rbsp_buffer, &nal->rbsp_buffer_size,

                   length + AV_INPUT_BUFFER_PADDING_SIZE);

    if (!nal->rbsp_buffer)

        return AVERROR(ENOMEM);



    dst = nal->rbsp_buffer;



    memcpy(dst, src, i);

    si = di = i;

    while (si + 2 < length) {

        // remove escapes (very rare 1:2^22)

        if (src[si + 2] > 3) {

            dst[di++] = src[si++];

            dst[di++] = src[si++];

        } else if (src[si] == 0 && src[si + 1] == 0 && src[si + 2] != 0) {

            if (src[si + 2] == 3) { // escape

                dst[di++] = 0;

                dst[di++] = 0;

                si       += 3;



                if (nal->skipped_bytes_pos) {

                    nal->skipped_bytes++;

                    if (nal->skipped_bytes_pos_size < nal->skipped_bytes) {

                        nal->skipped_bytes_pos_size *= 2;

                        av_assert0(nal->skipped_bytes_pos_size >= nal->skipped_bytes);

                        av_reallocp_array(&nal->skipped_bytes_pos,

                                nal->skipped_bytes_pos_size,

                                sizeof(*nal->skipped_bytes_pos));

                        if (!nal->skipped_bytes_pos) {

                            nal->skipped_bytes_pos_size = 0;

                            return AVERROR(ENOMEM);

                        }

                    }

                    if (nal->skipped_bytes_pos)

                        nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;

                }

                continue;

            } else // next start code

                goto nsc;

        }



        dst[di++] = src[si++];

    }

    while (si < length)

        dst[di++] = src[si++];



nsc:

    memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);



    nal->data = dst;

    nal->size = di;

    nal->raw_data = src;

    nal->raw_size = si;

    return si;

}
 and probability:0.5094339622641509
code:static int encode_mode(CinepakEncContext *s, CinepakMode mode, int h, int v1_size, int v4_size, int v4, AVPicture *scratch_pict, strip_info *info, unsigned char *buf)

{

    int x, y, z, flags, bits, temp_size, header_ofs, ret = 0, mb_count = s->w * h / MB_AREA;

    int needs_extra_bit, should_write_temp;

    unsigned char temp[64]; //32/2 = 16 V4 blocks at 4 B each -> 64 B

    mb_info *mb;

    AVPicture sub_scratch;



    //encode codebooks

    if(v1_size)

        ret += encode_codebook(s, info->v1_codebook, v1_size, 0x22, 0x26, buf + ret);



    if(v4_size)

        ret += encode_codebook(s, info->v4_codebook, v4_size, 0x20, 0x24, buf + ret);



    //update scratch picture

    for(z = y = 0; y < h; y += MB_SIZE) {

        for(x = 0; x < s->w; x += MB_SIZE, z++) {

            mb = &s->mb[z];



            if(mode == MODE_MC && mb->best_encoding == ENC_SKIP)

                continue;



            get_sub_picture(s, x, y, scratch_pict, &sub_scratch);



            if(mode == MODE_V1_ONLY || mb->best_encoding == ENC_V1)

                decode_v1_vector(s, &sub_scratch, mb, info);

            else if(mode != MODE_V1_ONLY && mb->best_encoding == ENC_V4)

                decode_v4_vector(s, &sub_scratch, mb->v4_vector[v4], info);

        }

    }



    switch(mode) {

    case MODE_V1_ONLY:

        //av_log(s->avctx, AV_LOG_INFO, "mb_count = %i\n", mb_count);

        ret += write_chunk_header(buf + ret, 0x32, mb_count);



        for(x = 0; x < mb_count; x++)

            buf[ret++] = s->mb[x].v1_vector;



        break;

    case MODE_V1_V4:

        //remember header position

        header_ofs = ret;

        ret += CHUNK_HEADER_SIZE;



        for(x = 0; x < mb_count; x += 32) {

            flags = 0;

            for(y = x; y < FFMIN(x+32, mb_count); y++)

                if(s->mb[y].best_encoding == ENC_V4)

                    flags |= 1 << (31 - y + x);



            AV_WB32(&buf[ret], flags);

            ret += 4;



            for(y = x; y < FFMIN(x+32, mb_count); y++) {

                mb = &s->mb[y];



                if(mb->best_encoding == ENC_V1)

                    buf[ret++] = mb->v1_vector;

                else

                    for(z = 0; z < 4; z++)

                        buf[ret++] = mb->v4_vector[v4][z];

            }

        }



        write_chunk_header(buf + header_ofs, 0x30, ret - header_ofs - CHUNK_HEADER_SIZE);



        break;

    case MODE_MC:

        //remember header position

        header_ofs = ret;

        ret += CHUNK_HEADER_SIZE;

        flags = bits = temp_size = 0;



        for(x = 0; x < mb_count; x++) {

            mb = &s->mb[x];

            flags |= (mb->best_encoding != ENC_SKIP) << (31 - bits++);

            needs_extra_bit = 0;

            should_write_temp = 0;



            if(mb->best_encoding != ENC_SKIP) {

                if(bits < 32)

                    flags |= (mb->best_encoding == ENC_V4) << (31 - bits++);

                else

                    needs_extra_bit = 1;

            }



            if(bits == 32) {

                AV_WB32(&buf[ret], flags);

                ret += 4;

                flags = bits = 0;



                if(mb->best_encoding == ENC_SKIP || needs_extra_bit) {

                    memcpy(&buf[ret], temp, temp_size);

                    ret += temp_size;

                    temp_size = 0;

                } else

                    should_write_temp = 1;

            }



            if(needs_extra_bit) {

                flags = (mb->best_encoding == ENC_V4) << 31;

                bits = 1;

            }



            if(mb->best_encoding == ENC_V1)

                temp[temp_size++] = mb->v1_vector;

            else if(mb->best_encoding == ENC_V4)

                for(z = 0; z < 4; z++)

                    temp[temp_size++] = mb->v4_vector[v4][z];



            if(should_write_temp) {

                memcpy(&buf[ret], temp, temp_size);

                ret += temp_size;

                temp_size = 0;

            }

        }



        if(bits > 0) {

            AV_WB32(&buf[ret], flags);

            ret += 4;

            memcpy(&buf[ret], temp, temp_size);

            ret += temp_size;

        }



        write_chunk_header(buf + header_ofs, 0x31, ret - header_ofs - CHUNK_HEADER_SIZE);



        break;

    }



    return ret;

}
 and probability:0.4766355140186916
code:static int smacker_read_header(AVFormatContext *s, AVFormatParameters *ap)
{
    ByteIOContext *pb = &s->pb;
    SmackerContext *smk = (SmackerContext *)s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = get_le32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = get_le32(pb);
    smk->height = get_le32(pb);
    smk->frames = get_le32(pb);
    smk->pts_inc = (int32_t)get_le32(pb);
    smk->flags = get_le32(pb);
    for(i = 0; i < 7; i++)
        smk->audio[i] = get_le32(pb);
    smk->treesize = get_le32(pb);
    smk->mmap_size = get_le32(pb);
    smk->mclr_size = get_le32(pb);
    smk->full_size = get_le32(pb);
    smk->type_size = get_le32(pb);
    for(i = 0; i < 7; i++)
        smk->rates[i] = get_le32(pb);
    smk->pad = get_le32(pb);
    /* setup data */
    if(smk->frames > 0xFFFFFF) {
        av_log(s, AV_LOG_ERROR, "Too many frames: %i\n", smk->frames);
    smk->frm_size = av_malloc(smk->frames * 4);
    smk->frm_flags = av_malloc(smk->frames);
    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < smk->frames; i++) {
        smk->frm_size[i] = get_le32(pb);
    for(i = 0; i < smk->frames; i++) {
        smk->frm_flags[i] = get_byte(pb);
    /* init video codec */
    st = av_new_stream(s, 0);
    if (!st)
    smk->videoindex = st->index;
    st->codec->width = smk->width;
    st->codec->height = smk->height;
    st->codec->pix_fmt = PIX_FMT_PAL8;
    st->codec->codec_type = CODEC_TYPE_VIDEO;
    st->codec->codec_id = CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = smk->is_ver4;
    /* Smacker uses 100000 as internal timebase */
    if(smk->pts_inc < 0)
        smk->pts_inc = -smk->pts_inc;
    else
        smk->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);
    av_set_pts_info(st, 33, smk->pts_inc, tbase);
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        smk->indexes[i] = -1;
        if((smk->rates[i] & 0xFFFFFF) && !(smk->rates[i] & SMK_AUD_BINKAUD)){
            ast[i] = av_new_stream(s, 0);
            smk->indexes[i] = ast[i]->index;
            av_set_pts_info(ast[i], 33, smk->pts_inc, tbase);
            ast[i]->codec->codec_type = CODEC_TYPE_AUDIO;
            ast[i]->codec->codec_id = (smk->rates[i] & SMK_AUD_PACKED) ? CODEC_ID_SMACKAUDIO : CODEC_ID_PCM_U8;
            ast[i]->codec->codec_tag = 0;
            ast[i]->codec->channels = (smk->rates[i] & SMK_AUD_STEREO) ? 2 : 1;
            ast[i]->codec->sample_rate = smk->rates[i] & 0xFFFFFF;
            ast[i]->codec->bits_per_sample = (smk->rates[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_sample == 16 && ast[i]->codec->codec_id == CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = CODEC_ID_PCM_S16LE;
    /* load trees to extradata, they will be unpacked by decoder */
    st->codec->extradata = av_malloc(smk->treesize + 16);
    st->codec->extradata_size = smk->treesize + 16;
    if(!st->codec->extradata){
        av_log(s, AV_LOG_ERROR, "Cannot allocate %i bytes of extradata\n", smk->treesize + 16);
        av_free(smk->frm_size);
        av_free(smk->frm_flags);
    ret = get_buffer(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_free(smk->frm_size);
        av_free(smk->frm_flags);
        return AVERROR_IO;
    ((int32_t*)st->codec->extradata)[0] = le2me_32(smk->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = le2me_32(smk->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = le2me_32(smk->full_size);
    ((int32_t*)st->codec->extradata)[3] = le2me_32(smk->type_size);
    smk->curstream = -1;
    smk->nextpos = url_ftell(pb);
    return 0; and probability:0.7954545454545454
code:static void pci_edu_realize(PCIDevice *pdev, Error **errp)

{

    EduState *edu = DO_UPCAST(EduState, pdev, pdev);

    uint8_t *pci_conf = pdev->config;



    timer_init_ms(&edu->dma_timer, QEMU_CLOCK_VIRTUAL, edu_dma_timer, edu);



    qemu_mutex_init(&edu->thr_mutex);

    qemu_cond_init(&edu->thr_cond);

    qemu_thread_create(&edu->thread, "edu", edu_fact_thread,

                       edu, QEMU_THREAD_JOINABLE);



    pci_config_set_interrupt_pin(pci_conf, 1);



    if (msi_init(pdev, 0, 1, true, false, errp)) {

        return;

    }



    memory_region_init_io(&edu->mmio, OBJECT(edu), &edu_mmio_ops, edu,

                    "edu-mmio", 1 << 20);

    pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &edu->mmio);

}
 and probability:0.4117647058823529
code:uint64_t pc_dimm_get_free_addr(uint64_t address_space_start,

                               uint64_t address_space_size,

                               uint64_t *hint, uint64_t size,

                               Error **errp)

{

    GSList *list = NULL, *item;

    uint64_t new_addr, ret = 0;

    uint64_t address_space_end = address_space_start + address_space_size;



    assert(address_space_end > address_space_size);

    object_child_foreach(qdev_get_machine(), pc_dimm_built_list, &list);



    if (hint) {

        new_addr = *hint;

    } else {

        new_addr = address_space_start;

    }



    /* find address range that will fit new DIMM */

    for (item = list; item; item = g_slist_next(item)) {

        PCDIMMDevice *dimm = item->data;

        uint64_t dimm_size = object_property_get_int(OBJECT(dimm),

                                                     PC_DIMM_SIZE_PROP,

                                                     errp);

        if (errp && *errp) {

            goto out;

        }



        if (ranges_overlap(dimm->addr, dimm_size, new_addr, size)) {

            if (hint) {

                DeviceState *d = DEVICE(dimm);

                error_setg(errp, "address range conflicts with '%s'", d->id);

                goto out;

            }

            new_addr = dimm->addr + dimm_size;

        }

    }

    ret = new_addr;



    if (new_addr < address_space_start) {

        error_setg(errp, "can't add memory [0x%" PRIx64 ":0x%" PRIx64

                   "] at 0x%" PRIx64, new_addr, size, address_space_start);

    } else if ((new_addr + size) > address_space_end) {

        error_setg(errp, "can't add memory [0x%" PRIx64 ":0x%" PRIx64

                   "] beyond 0x%" PRIx64, new_addr, size, address_space_end);

    }



out:

    g_slist_free(list);

    return ret;

}
 and probability:0.17777777777777778
code:static int wma_decode_block(WMACodecContext *s)

{

    int n, v, a, ch, bsize;

    int coef_nb_bits, total_gain;

    int nb_coefs[MAX_CHANNELS];

    float mdct_norm;

    FFTContext *mdct;



#ifdef TRACE

    tprintf(s->avctx, "***decode_block: %d:%d\n", s->frame_count - 1, s->block_num);

#endif



    /* compute current block length */

    if (s->use_variable_block_len) {

        n = av_log2(s->nb_block_sizes - 1) + 1;



        if (s->reset_block_lengths) {

            s->reset_block_lengths = 0;

            v = get_bits(&s->gb, n);

            if (v >= s->nb_block_sizes){

                av_log(s->avctx, AV_LOG_ERROR, "prev_block_len_bits %d out of range\n", s->frame_len_bits - v);

                return -1;


            s->prev_block_len_bits = s->frame_len_bits - v;

            v = get_bits(&s->gb, n);

            if (v >= s->nb_block_sizes){

                av_log(s->avctx, AV_LOG_ERROR, "block_len_bits %d out of range\n", s->frame_len_bits - v);

                return -1;


            s->block_len_bits = s->frame_len_bits - v;

        } else {

            /* update block lengths */

            s->prev_block_len_bits = s->block_len_bits;

            s->block_len_bits = s->next_block_len_bits;


        v = get_bits(&s->gb, n);

        if (v >= s->nb_block_sizes){

            av_log(s->avctx, AV_LOG_ERROR, "next_block_len_bits %d out of range\n", s->frame_len_bits - v);

            return -1;


        s->next_block_len_bits = s->frame_len_bits - v;

    } else {

        /* fixed block len */

        s->next_block_len_bits = s->frame_len_bits;

        s->prev_block_len_bits = s->frame_len_bits;

        s->block_len_bits = s->frame_len_bits;




    if (s->frame_len_bits - s->block_len_bits >= s->nb_block_sizes){

        av_log(s->avctx, AV_LOG_ERROR, "block_len_bits not initialized to a valid value\n");

        return -1;




    /* now check if the block length is coherent with the frame length */

    s->block_len = 1 << s->block_len_bits;

    if ((s->block_pos + s->block_len) > s->frame_len){

        av_log(s->avctx, AV_LOG_ERROR, "frame_len overflow\n");

        return -1;




    if (s->avctx->channels == 2) {

        s->ms_stereo = get_bits1(&s->gb);


    v = 0;

    for(ch = 0; ch < s->avctx->channels; ch++) {

        a = get_bits1(&s->gb);

        s->channel_coded[ch] = a;

        v |= a;




    bsize = s->frame_len_bits - s->block_len_bits;



    /* if no channel coded, no need to go further */

    /* XXX: fix potential framing problems */

    if (!v)

        goto next;



    /* read total gain and extract corresponding number of bits for

       coef escape coding */

    total_gain = 1;

    for(;;) {





        a = get_bits(&s->gb, 7);

        total_gain += a;

        if (a != 127)

            break;




    coef_nb_bits= ff_wma_total_gain_to_bits(total_gain);



    /* compute number of coefficients */

    n = s->coefs_end[bsize] - s->coefs_start;

    for(ch = 0; ch < s->avctx->channels; ch++)

        nb_coefs[ch] = n;



    /* complex coding */

    if (s->use_noise_coding) {



        for(ch = 0; ch < s->avctx->channels; ch++) {

            if (s->channel_coded[ch]) {

                int i, n, a;

                n = s->exponent_high_sizes[bsize];

                for(i=0;i<n;i++) {

                    a = get_bits1(&s->gb);

                    s->high_band_coded[ch][i] = a;

                    /* if noise coding, the coefficients are not transmitted */

                    if (a)

                        nb_coefs[ch] -= s->exponent_high_bands[bsize][i];




        for(ch = 0; ch < s->avctx->channels; ch++) {

            if (s->channel_coded[ch]) {

                int i, n, val, code;



                n = s->exponent_high_sizes[bsize];

                val = (int)0x80000000;

                for(i=0;i<n;i++) {

                    if (s->high_band_coded[ch][i]) {

                        if (val == (int)0x80000000) {

                            val = get_bits(&s->gb, 7) - 19;

                        } else {

                            code = get_vlc2(&s->gb, s->hgain_vlc.table, HGAINVLCBITS, HGAINMAX);

                            if (code < 0){

                                av_log(s->avctx, AV_LOG_ERROR, "hgain vlc invalid\n");

                                return -1;


                            val += code - 18;


                        s->high_band_values[ch][i] = val;








    /* exponents can be reused in short blocks. */

    if ((s->block_len_bits == s->frame_len_bits) ||

        get_bits1(&s->gb)) {

        for(ch = 0; ch < s->avctx->channels; ch++) {

            if (s->channel_coded[ch]) {

                if (s->use_exp_vlc) {

                    if (decode_exp_vlc(s, ch) < 0)

                        return -1;

                } else {

                    decode_exp_lsp(s, ch);


                s->exponents_bsize[ch] = bsize;






    /* parse spectral coefficients : just RLE encoding */

    for (ch = 0; ch < s->avctx->channels; ch++) {

        if (s->channel_coded[ch]) {

            int tindex;

            WMACoef* ptr = &s->coefs1[ch][0];



            /* special VLC tables are used for ms stereo because

               there is potentially less energy there */

            tindex = (ch == 1 && s->ms_stereo);

            memset(ptr, 0, s->block_len * sizeof(WMACoef));

            ff_wma_run_level_decode(s->avctx, &s->gb, &s->coef_vlc[tindex],

                  s->level_table[tindex], s->run_table[tindex],

                  0, ptr, 0, nb_coefs[ch],

                  s->block_len, s->frame_len_bits, coef_nb_bits);


        if (s->version == 1 && s->avctx->channels >= 2) {

            align_get_bits(&s->gb);





    /* normalize */

    {

        int n4 = s->block_len / 2;

        mdct_norm = 1.0 / (float)n4;

        if (s->version == 1) {

            mdct_norm *= sqrt(n4);





    /* finally compute the MDCT coefficients */

    for (ch = 0; ch < s->avctx->channels; ch++) {

        if (s->channel_coded[ch]) {

            WMACoef *coefs1;

            float *coefs, *exponents, mult, mult1, noise;

            int i, j, n, n1, last_high_band, esize;

            float exp_power[HIGH_BAND_MAX_SIZE];



            coefs1 = s->coefs1[ch];

            exponents = s->exponents[ch];

            esize = s->exponents_bsize[ch];

            mult = pow(10, total_gain * 0.05) / s->max_exponent[ch];

            mult *= mdct_norm;

            coefs = s->coefs[ch];

            if (s->use_noise_coding) {

                mult1 = mult;

                /* very low freqs : noise */

                for(i = 0;i < s->coefs_start; i++) {

                    *coefs++ = s->noise_table[s->noise_index] *

                      exponents[i<<bsize>>esize] * mult1;

                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);




                n1 = s->exponent_high_sizes[bsize];



                /* compute power of high bands */

                exponents = s->exponents[ch] +

                    (s->high_band_start[bsize]<<bsize>>esize);

                last_high_band = 0; /* avoid warning */

                for(j=0;j<n1;j++) {

                    n = s->exponent_high_bands[s->frame_len_bits -

                                              s->block_len_bits][j];

                    if (s->high_band_coded[ch][j]) {

                        float e2, v;

                        e2 = 0;

                        for(i = 0;i < n; i++) {

                            v = exponents[i<<bsize>>esize];

                            e2 += v * v;


                        exp_power[j] = e2 / n;

                        last_high_band = j;

                        tprintf(s->avctx, "%d: power=%f (%d)\n", j, exp_power[j], n);


                    exponents += n<<bsize>>esize;




                /* main freqs and high freqs */

                exponents = s->exponents[ch] + (s->coefs_start<<bsize>>esize);

                for(j=-1;j<n1;j++) {

                    if (j < 0) {

                        n = s->high_band_start[bsize] -

                            s->coefs_start;

                    } else {

                        n = s->exponent_high_bands[s->frame_len_bits -

                                                  s->block_len_bits][j];


                    if (j >= 0 && s->high_band_coded[ch][j]) {

                        /* use noise with specified power */

                        mult1 = sqrt(exp_power[j] / exp_power[last_high_band]);

                        /* XXX: use a table */

                        mult1 = mult1 * pow(10, s->high_band_values[ch][j] * 0.05);

                        mult1 = mult1 / (s->max_exponent[ch] * s->noise_mult);

                        mult1 *= mdct_norm;

                        for(i = 0;i < n; i++) {

                            noise = s->noise_table[s->noise_index];

                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);

                            *coefs++ =  noise *

                                exponents[i<<bsize>>esize] * mult1;


                        exponents += n<<bsize>>esize;

                    } else {

                        /* coded values + small noise */

                        for(i = 0;i < n; i++) {

                            noise = s->noise_table[s->noise_index];

                            s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);

                            *coefs++ = ((*coefs1++) + noise) *

                                exponents[i<<bsize>>esize] * mult;


                        exponents += n<<bsize>>esize;





                /* very high freqs : noise */

                n = s->block_len - s->coefs_end[bsize];

                mult1 = mult * exponents[((-1<<bsize))>>esize];

                for(i = 0; i < n; i++) {

                    *coefs++ = s->noise_table[s->noise_index] * mult1;

                    s->noise_index = (s->noise_index + 1) & (NOISE_TAB_SIZE - 1);


            } else {

                /* XXX: optimize more */

                for(i = 0;i < s->coefs_start; i++)

                    *coefs++ = 0.0;

                n = nb_coefs[ch];

                for(i = 0;i < n; i++) {

                    *coefs++ = coefs1[i] * exponents[i<<bsize>>esize] * mult;


                n = s->block_len - s->coefs_end[bsize];

                for(i = 0;i < n; i++)

                    *coefs++ = 0.0;






#ifdef TRACE

    for (ch = 0; ch < s->avctx->channels; ch++) {

        if (s->channel_coded[ch]) {

            dump_floats(s, "exponents", 3, s->exponents[ch], s->block_len);

            dump_floats(s, "coefs", 1, s->coefs[ch], s->block_len);



#endif



    if (s->ms_stereo && s->channel_coded[1]) {

        /* nominal case for ms stereo: we do it before mdct */

        /* no need to optimize this case because it should almost

           never happen */

        if (!s->channel_coded[0]) {

            tprintf(s->avctx, "rare ms-stereo case happened\n");

            memset(s->coefs[0], 0, sizeof(float) * s->block_len);

            s->channel_coded[0] = 1;




        s->fdsp.butterflies_float(s->coefs[0], s->coefs[1], s->block_len);




next:

    mdct = &s->mdct_ctx[bsize];



    for (ch = 0; ch < s->avctx->channels; ch++) {

        int n4, index;



        n4 = s->block_len / 2;

        if(s->channel_coded[ch]){

            mdct->imdct_calc(mdct, s->output, s->coefs[ch]);

        }else if(!(s->ms_stereo && ch==1))

            memset(s->output, 0, sizeof(s->output));



        /* multiply by the window and add in the frame */

        index = (s->frame_len / 2) + s->block_pos - n4;

        wma_window(s, &s->frame_out[ch][index]);




    /* update block number */

    s->block_num++;

    s->block_pos += s->block_len;

    if (s->block_pos >= s->frame_len)

        return 1;

    else

        return 0;
 and probability:0.628
code:static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, "/dev/fd", NULL))

        prio = 50;



    fd = open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    close(fd);

out:

    return prio;

}
 and probability:0.0
code:struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)

{

    struct XenDevice *xendev;



    TAILQ_FOREACH(xendev, &xendevs, next) {

	if (xendev->dom != dom)

	    continue;

	if (xendev->dev != dev)

	    continue;

	if (strcmp(xendev->type, type) != 0)

	    continue;

	return xendev;

    }

    return NULL;

}
 and probability:0.21428571428571427
code:static void dct_unquantize_mpeg1_mmx(MpegEncContext *s,

                                     DCTELEM *block, int n, int qscale)

{

    int i, level;

    const UINT16 *quant_matrix;

    if (s->mb_intra) {

        if (n < 4) 

            block[0] = block[0] * s->y_dc_scale;

        else

            block[0] = block[0] * s->c_dc_scale;

        if (s->out_format == FMT_H263) {

            i = 1;

            goto unquant_even;

        }

        /* XXX: only mpeg1 */

        quant_matrix = s->intra_matrix;

	i=1;

	/* Align on 4 elements boundary */

	while(i&3)

	{

            level = block[i];

            if (level) {

                if (level < 0) level = -level;

                    level = (int)(level * qscale * quant_matrix[i]) >> 3;

                    level = (level - 1) | 1;

                if (block[i] < 0) level = -level;

                block[i] = level;

            }

	    i++;

	}

	__asm __volatile(

	"movd	%0, %%mm6\n\t"       /* mm6 = qscale | 0  */

	"punpckldq %%mm6, %%mm6\n\t" /* mm6 = qscale | qscale */

	"movq	%2, %%mm4\n\t"

	"movq	%%mm6, %%mm7\n\t"

	"movq	%1, %%mm5\n\t"

	"packssdw %%mm6, %%mm7\n\t" /* mm7 = qscale | qscale | qscale | qscale */

	"pxor	%%mm6, %%mm6\n\t"

	::"g"(qscale),"m"(mm_wone),"m"(mm_wabs):"memory");

        for(;i<64;i+=4) {

		__asm __volatile(

			"movq	%1, %%mm0\n\t"

			"movq	%%mm7, %%mm1\n\t"

			"movq	%%mm0, %%mm2\n\t"

			"movq	%%mm0, %%mm3\n\t"

			"pcmpgtw %%mm6, %%mm2\n\t"

			"pmullw	%2, %%mm1\n\t"

			"pandn	%%mm4, %%mm2\n\t"

			"por	%%mm5, %%mm2\n\t"

			"pmullw	%%mm2, %%mm0\n\t" /* mm0 = abs(block[i]). */



			"pcmpeqw %%mm6, %%mm3\n\t"

			"pmullw	%%mm0, %%mm1\n\t"

			"psraw	$3, %%mm1\n\t"

			"psubw	%%mm5, %%mm1\n\t"   /* block[i] --; */

			"pandn	%%mm4, %%mm3\n\t"  /* fake of pcmpneqw : mm0 != 0 then mm1 = -1 */

			"por	%%mm5, %%mm1\n\t"   /* block[i] |= 1 */

			"pmullw %%mm2, %%mm1\n\t"   /* change signs again */



			"pand	%%mm3, %%mm1\n\t" /* nullify if was zero */

			"movq	%%mm1, %0"

			:"=m"(block[i])

			:"m"(block[i]), "m"(quant_matrix[i])

			:"memory");

        }

    } else {

        i = 0;

    unquant_even:

        quant_matrix = s->non_intra_matrix;

	/* Align on 4 elements boundary */

	while(i&7)

	{

	    level = block[i];

            if (level) {

                if (level < 0) level = -level;

                    level = (((level << 1) + 1) * qscale *

                             ((int) quant_matrix[i])) >> 4;

                    level = (level - 1) | 1;

                if(block[i] < 0) level = -level;

                block[i] = level;

	    }

	    i++;

	}



asm volatile(

		"pcmpeqw %%mm7, %%mm7		\n\t"

		"psrlw $15, %%mm7		\n\t"

		"movd %2, %%mm6			\n\t"

		"packssdw %%mm6, %%mm6		\n\t"

		"packssdw %%mm6, %%mm6		\n\t"

		"1:				\n\t"

		"movq (%0, %3), %%mm0		\n\t"

		"movq 8(%0, %3), %%mm1		\n\t"

		"movq (%1, %3), %%mm4		\n\t"

		"movq 8(%1, %3), %%mm5		\n\t"

		"pmullw %%mm6, %%mm4		\n\t" // q=qscale*quant_matrix[i]

		"pmullw %%mm6, %%mm5		\n\t" // q=qscale*quant_matrix[i]

		"pxor %%mm2, %%mm2		\n\t"

		"pxor %%mm3, %%mm3		\n\t"

		"pcmpgtw %%mm0, %%mm2		\n\t" // block[i] < 0 ? -1 : 0

		"pcmpgtw %%mm1, %%mm3		\n\t" // block[i] < 0 ? -1 : 0

		"pxor %%mm2, %%mm0		\n\t"

		"pxor %%mm3, %%mm1		\n\t"

		"psubw %%mm2, %%mm0		\n\t" // abs(block[i])

		"psubw %%mm3, %%mm1		\n\t" // abs(block[i])

		"paddw %%mm0, %%mm0		\n\t" // abs(block[i])*2

		"paddw %%mm1, %%mm1		\n\t" // abs(block[i])*2

		"paddw %%mm7, %%mm0		\n\t" // abs(block[i])*2 + 1

		"paddw %%mm7, %%mm1		\n\t" // abs(block[i])*2 + 1

		"pmullw %%mm4, %%mm0		\n\t" // (abs(block[i])*2 + 1)*q

		"pmullw %%mm5, %%mm1		\n\t" // (abs(block[i])*2 + 1)*q

		"pxor %%mm4, %%mm4		\n\t"

		"pxor %%mm5, %%mm5		\n\t" // FIXME slow

		"pcmpeqw (%0, %3), %%mm4	\n\t" // block[i] == 0 ? -1 : 0

		"pcmpeqw 8(%0, %3), %%mm5	\n\t" // block[i] == 0 ? -1 : 0

		"psraw $4, %%mm0		\n\t"

		"psraw $4, %%mm1		\n\t"

		"psubw %%mm7, %%mm0		\n\t"

		"psubw %%mm7, %%mm1		\n\t"

		"por %%mm7, %%mm0		\n\t"

		"por %%mm7, %%mm1		\n\t"

		"pxor %%mm2, %%mm0		\n\t"

		"pxor %%mm3, %%mm1		\n\t"

		"psubw %%mm2, %%mm0		\n\t"

		"psubw %%mm3, %%mm1		\n\t"

		"pandn %%mm0, %%mm4		\n\t"

		"pandn %%mm1, %%mm5		\n\t"

		"movq %%mm4, (%0, %3)		\n\t"

		"movq %%mm5, 8(%0, %3)		\n\t"



		"addl $16, %3			\n\t"

		"cmpl $128, %3			\n\t"

		"jb 1b				\n\t"

		::"r" (block), "r"(quant_matrix), "g" (qscale), "r" (2*i)

		: "memory"

	);



#if 0

	__asm __volatile(

	"movd	%0, %%mm6\n\t"       /* mm6 = qscale | 0  */

	"punpckldq %%mm6, %%mm6\n\t" /* mm6 = qscale | qscale */

	"movq	%2, %%mm4\n\t"

	"movq	%%mm6, %%mm7\n\t"

	"movq	%1, %%mm5\n\t"

	"packssdw %%mm6, %%mm7\n\t" /* mm7 = qscale | qscale | qscale | qscale */

	"pxor	%%mm6, %%mm6\n\t"

	::"g"(qscale),"m"(mm_wone),"m"(mm_wabs));

        for(;i<64;i+=4) {

		__asm __volatile(

			"movq	%1, %%mm0\n\t"

			"movq	%%mm7, %%mm1\n\t"

			"movq	%%mm0, %%mm2\n\t"

			"movq	%%mm0, %%mm3\n\t"

			"pcmpgtw %%mm6, %%mm2\n\t"

			"pmullw	%2, %%mm1\n\t"

			"pandn	%%mm4, %%mm2\n\t"

			"por	%%mm5, %%mm2\n\t"

			"pmullw	%%mm2, %%mm0\n\t" /* mm0 = abs(block[i]). */

			"psllw	$1, %%mm0\n\t" /* block[i] <<= 1 */

			"paddw	%%mm5, %%mm0\n\t" /* block[i] ++ */



			"pmullw	%%mm0, %%mm1\n\t"

			"psraw	$4, %%mm1\n\t"

			"pcmpeqw %%mm6, %%mm3\n\t"

			"psubw	%%mm5, %%mm1\n\t"   /* block[i] --; */

			"pandn	%%mm4, %%mm3\n\t"  /* fake of pcmpneqw : mm0 != 0 then mm1 = -1 */

			"por	%%mm5, %%mm1\n\t"   /* block[i] |= 1 */

			"pmullw %%mm2, %%mm1\n\t"   /* change signs again */



			"pand	%%mm3, %%mm1\n\t" /* nullify if was zero */

			"movq	%%mm1, %0"

			:"=m"(block[i])

			:"m"(block[i]), "m"(quant_matrix[i]));

        }

#endif

    }

}
 and probability:0.1411764705882353
code:static int virtio_ccw_set_vqs(SubchDev *sch, VqInfoBlock *info,

                              VqInfoBlockLegacy *linfo)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);

    uint16_t index = info ? info->index : linfo->index;

    uint16_t num = info ? info->num : linfo->num;

    uint64_t desc = info ? info->desc : linfo->queue;



    if (index >= VIRTIO_CCW_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (linfo && desc && (linfo->align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    if (info) {

        virtio_queue_set_rings(vdev, index, desc, info->avail, info->used);

    } else {

        virtio_queue_set_addr(vdev, index, desc);

    }

    if (!desc) {

        virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);

    } else {

        if (info) {

            /* virtio-1 allows changing the ring size. */

            if (virtio_queue_get_max_num(vdev, index) < num) {

                /* Fail if we exceed the maximum number. */

                return -EINVAL;

            }

            virtio_queue_set_num(vdev, index, num);

        } else if (virtio_queue_get_num(vdev, index) > num) {

            /* Fail if we don't have a big enough queue. */

            return -EINVAL;

        }

        /* We ignore possible increased num for legacy for compatibility. */

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    vdev->config_vector = VIRTIO_CCW_QUEUE_MAX;

    return 0;

}
 and probability:0.13953488372093023
code:void qemu_system_debug_request(void)

{

    debug_requested = 1;

    vm_stop(VMSTOP_DEBUG);

}
 and probability:0.0
code:static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,

                                             int64_t offset, int count,

                                             BdrvRequestFlags flags)

{

    return bdrv_co_pwrite_zeroes(bs->file->bs, offset, count, flags);

}
 and probability:0.16666666666666666
code:void monitor_flush(Monitor *mon)

{

    int i;

    if (term_outbuf_index > 0) {

        for (i = 0; i < MAX_MON; i++)

            if (monitor_hd[i] && monitor_hd[i]->focus == 0)

                qemu_chr_write(monitor_hd[i], term_outbuf, term_outbuf_index);

        term_outbuf_index = 0;

    }

}
 and probability:0.3
code:void qemu_co_queue_restart_all(CoQueue *queue)

{

    while (qemu_co_queue_next(queue)) {

        /* Do nothing */

    }

}
 and probability:0.0
code:static void nvdimm_dsm_func_read_fit(AcpiNVDIMMState *state, NvdimmDsmIn *in,

                                     hwaddr dsm_mem_addr)

{

    NvdimmFitBuffer *fit_buf = &state->fit_buf;

    NvdimmFuncReadFITIn *read_fit;

    NvdimmFuncReadFITOut *read_fit_out;

    GArray *fit;

    uint32_t read_len = 0, func_ret_status;

    int size;



    read_fit = (NvdimmFuncReadFITIn *)in->arg3;

    le32_to_cpus(&read_fit->offset);



    qemu_mutex_lock(&fit_buf->lock);

    fit = fit_buf->fit;



    nvdimm_debug("Read FIT: offset %#x FIT size %#x Dirty %s.\n",

                 read_fit->offset, fit->len, fit_buf->dirty ? "Yes" : "No");



    if (read_fit->offset > fit->len) {

        func_ret_status = 3 /* Invalid Input Parameters */;

        goto exit;

    }



    /* It is the first time to read FIT. */

    if (!read_fit->offset) {

        fit_buf->dirty = false;

    } else if (fit_buf->dirty) { /* FIT has been changed during RFIT. */

        func_ret_status = 0x100 /* fit changed */;

        goto exit;

    }



    func_ret_status = 0 /* Success */;

    read_len = MIN(fit->len - read_fit->offset,

                   4096 - sizeof(NvdimmFuncReadFITOut));



exit:

    size = sizeof(NvdimmFuncReadFITOut) + read_len;

    read_fit_out = g_malloc(size);



    read_fit_out->len = cpu_to_le32(size);

    read_fit_out->func_ret_status = cpu_to_le32(func_ret_status);

    memcpy(read_fit_out->fit, fit->data + read_fit->offset, read_len);



    cpu_physical_memory_write(dsm_mem_addr, read_fit_out, size);



    g_free(read_fit_out);

    qemu_mutex_unlock(&fit_buf->lock);

}
 and probability:0.4358974358974359
code:static void tftp_send_error(struct tftp_session *spt,

                            uint16_t errorcode, const char *msg,

                            struct tftp_t *recv_tp)

{

  struct sockaddr_in saddr, daddr;

  struct mbuf *m;

  struct tftp_t *tp;



  m = m_get(spt->slirp);



  if (!m) {

    goto out;

  }



  memset(m->m_data, 0, m->m_size);



  m->m_data += IF_MAXLINKHDR;

  tp = (void *)m->m_data;

  m->m_data += sizeof(struct udpiphdr);



  tp->tp_op = htons(TFTP_ERROR);

  tp->x.tp_error.tp_error_code = htons(errorcode);

  pstrcpy((char *)tp->x.tp_error.tp_msg, sizeof(tp->x.tp_error.tp_msg), msg);



  saddr.sin_addr = recv_tp->ip.ip_dst;

  saddr.sin_port = recv_tp->udp.uh_dport;



  daddr.sin_addr = spt->client_ip;

  daddr.sin_port = spt->client_port;



  m->m_len = sizeof(struct tftp_t) - 514 + 3 + strlen(msg) -

        sizeof(struct ip) - sizeof(struct udphdr);



  udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);



out:

  tftp_session_terminate(spt);

}
 and probability:0.4642857142857143
code:static void omap_rtc_alarm_update(struct omap_rtc_s *s)

{

    s->alarm_ti = mktimegm(&s->alarm_tm);

    if (s->alarm_ti == -1)

        printf("%s: conversion failed\n", __FUNCTION__);

}
 and probability:0.3333333333333333
code:static int http_send_data(HTTPContext *c)

{

    int len, ret;



    for(;;) {

        if (c->buffer_ptr >= c->buffer_end) {

            ret = http_prepare_data(c);

            if (ret < 0)

                return -1;

            else if (ret != 0)

                /* state change requested */

                break;

        } else {

            if (c->is_packetized) {

                /* RTP data output */

                len = c->buffer_end - c->buffer_ptr;

                if (len < 4) {

                    /* fail safe - should never happen */

                fail1:

                    c->buffer_ptr = c->buffer_end;

                    return 0;

                }

                len = (c->buffer_ptr[0] << 24) |

                    (c->buffer_ptr[1] << 16) |

                    (c->buffer_ptr[2] << 8) |

                    (c->buffer_ptr[3]);

                if (len > (c->buffer_end - c->buffer_ptr))

                    goto fail1;

                if ((get_packet_send_clock(c) - get_server_clock(c)) > 0) {

                    /* nothing to send yet: we can wait */

                    return 0;

                }



                c->data_count += len;

                update_datarate(&c->datarate, c->data_count);

                if (c->stream)

                    c->stream->bytes_served += len;



                if (c->rtp_protocol == RTSP_LOWER_TRANSPORT_TCP) {

                    /* RTP packets are sent inside the RTSP TCP connection */

                    AVIOContext *pb;

                    int interleaved_index, size;

                    uint8_t header[4];

                    HTTPContext *rtsp_c;



                    rtsp_c = c->rtsp_c;

                    /* if no RTSP connection left, error */

                    if (!rtsp_c)

                        return -1;

                    /* if already sending something, then wait. */

                    if (rtsp_c->state != RTSPSTATE_WAIT_REQUEST)

                        break;

                    if (avio_open_dyn_buf(&pb) < 0)

                        goto fail1;

                    interleaved_index = c->packet_stream_index * 2;

                    /* RTCP packets are sent at odd indexes */

                    if (c->buffer_ptr[1] == 200)

                        interleaved_index++;

                    /* write RTSP TCP header */

                    header[0] = '$';

                    header[1] = interleaved_index;

                    header[2] = len >> 8;

                    header[3] = len;

                    avio_write(pb, header, 4);

                    /* write RTP packet data */

                    c->buffer_ptr += 4;

                    avio_write(pb, c->buffer_ptr, len);

                    size = avio_close_dyn_buf(pb, &c->packet_buffer);

                    /* prepare asynchronous TCP sending */

                    rtsp_c->packet_buffer_ptr = c->packet_buffer;

                    rtsp_c->packet_buffer_end = c->packet_buffer + size;

                    c->buffer_ptr += len;



                    /* send everything we can NOW */

                    len = send(rtsp_c->fd, rtsp_c->packet_buffer_ptr,

                                rtsp_c->packet_buffer_end - rtsp_c->packet_buffer_ptr, 0);

                    if (len > 0)

                        rtsp_c->packet_buffer_ptr += len;

                    if (rtsp_c->packet_buffer_ptr < rtsp_c->packet_buffer_end) {

                        /* if we could not send all the data, we will

                           send it later, so a new state is needed to

                           "lock" the RTSP TCP connection */

                        rtsp_c->state = RTSPSTATE_SEND_PACKET;

                        break;

                    } else

                        /* all data has been sent */

                        av_freep(&c->packet_buffer);

                } else {

                    /* send RTP packet directly in UDP */

                    c->buffer_ptr += 4;

                    ffurl_write(c->rtp_handles[c->packet_stream_index],

                                c->buffer_ptr, len);

                    c->buffer_ptr += len;

                    /* here we continue as we can send several packets per 10 ms slot */

                }

            } else {

                /* TCP data output */

                len = send(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);

                if (len < 0) {

                    if (ff_neterrno() != AVERROR(EAGAIN) &&

                        ff_neterrno() != AVERROR(EINTR))

                        /* error : close connection */

                        return -1;

                    else

                        return 0;

                } else

                    c->buffer_ptr += len;



                c->data_count += len;

                update_datarate(&c->datarate, c->data_count);

                if (c->stream)

                    c->stream->bytes_served += len;

                break;

            }

        }

    } /* for(;;) */

    return 0;

}
 and probability:0.4107142857142857
code:static inline bool vtd_iova_range_check(uint64_t iova, VTDContextEntry *ce)

{

    /*

     * Check if @iova is above 2^X-1, where X is the minimum of MGAW

     * in CAP_REG and AW in context-entry.

     */

    return !(iova & ~(vtd_iova_limit(ce) - 1));

}
 and probability:0.125
code:DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)

{

    const char *value;

    BlockBackend *blk;

    DriveInfo *dinfo = NULL;

    QDict *bs_opts;

    QemuOpts *legacy_opts;

    DriveMediaType media = MEDIA_DISK;

    BlockInterfaceType type;

    int cyls, heads, secs, translation;

    int max_devs, bus_id, unit_id, index;

    const char *devaddr;

    const char *werror, *rerror;

    bool read_only = false;

    bool copy_on_read;

    const char *serial;

    const char *filename;

    Error *local_err = NULL;

    int i;

    const char *deprecated[] = {

        "serial", "trans", "secs", "heads", "cyls", "addr"

    };



    /* Change legacy command line options into QMP ones */

    static const struct {

        const char *from;

        const char *to;

    } opt_renames[] = {

        { "iops",           "throttling.iops-total" },

        { "iops_rd",        "throttling.iops-read" },

        { "iops_wr",        "throttling.iops-write" },



        { "bps",            "throttling.bps-total" },

        { "bps_rd",         "throttling.bps-read" },

        { "bps_wr",         "throttling.bps-write" },



        { "iops_max",       "throttling.iops-total-max" },

        { "iops_rd_max",    "throttling.iops-read-max" },

        { "iops_wr_max",    "throttling.iops-write-max" },



        { "bps_max",        "throttling.bps-total-max" },

        { "bps_rd_max",     "throttling.bps-read-max" },

        { "bps_wr_max",     "throttling.bps-write-max" },



        { "iops_size",      "throttling.iops-size" },



        { "group",          "throttling.group" },



        { "readonly",       BDRV_OPT_READ_ONLY },

    };



    for (i = 0; i < ARRAY_SIZE(opt_renames); i++) {

        qemu_opt_rename(all_opts, opt_renames[i].from, opt_renames[i].to,

                        &local_err);

        if (local_err) {

            error_report_err(local_err);

            return NULL;

        }

    }



    value = qemu_opt_get(all_opts, "cache");

    if (value) {

        int flags = 0;

        bool writethrough;



        if (bdrv_parse_cache_mode(value, &flags, &writethrough) != 0) {

            error_report("invalid cache option");

            return NULL;

        }



        /* Specific options take precedence */

        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_WB)) {

            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_WB,

                              !writethrough, &error_abort);

        }

        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_DIRECT)) {

            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_DIRECT,

                              !!(flags & BDRV_O_NOCACHE), &error_abort);

        }

        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_NO_FLUSH)) {

            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_NO_FLUSH,

                              !!(flags & BDRV_O_NO_FLUSH), &error_abort);

        }

        qemu_opt_unset(all_opts, "cache");

    }



    /* Get a QDict for processing the options */

    bs_opts = qdict_new();

    qemu_opts_to_qdict(all_opts, bs_opts);



    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,

                                   &error_abort);

    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);

    if (local_err) {

        error_report_err(local_err);

        goto fail;

    }



    /* Deprecated option boot=[on|off] */

    if (qemu_opt_get(legacy_opts, "boot") != NULL) {

        fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "

                "ignored. Future versions will reject this parameter. Please "

                "update your scripts.\n");

    }



    /* Other deprecated options */

    if (!qtest_enabled()) {

        for (i = 0; i < ARRAY_SIZE(deprecated); i++) {

            if (qemu_opt_get(legacy_opts, deprecated[i]) != NULL) {

                error_report("'%s' is deprecated, please use the corresponding "

                             "option of '-device' instead", deprecated[i]);

            }

        }

    }



    /* Media type */

    value = qemu_opt_get(legacy_opts, "media");

    if (value) {

        if (!strcmp(value, "disk")) {

            media = MEDIA_DISK;

        } else if (!strcmp(value, "cdrom")) {

            media = MEDIA_CDROM;

            read_only = true;

        } else {

            error_report("'%s' invalid media", value);

            goto fail;

        }

    }



    /* copy-on-read is disabled with a warning for read-only devices */

    read_only |= qemu_opt_get_bool(legacy_opts, BDRV_OPT_READ_ONLY, false);

    copy_on_read = qemu_opt_get_bool(legacy_opts, "copy-on-read", false);



    if (read_only && copy_on_read) {

        error_report("warning: disabling copy-on-read on read-only drive");

        copy_on_read = false;

    }



    qdict_put_str(bs_opts, BDRV_OPT_READ_ONLY, read_only ? "on" : "off");

    qdict_put_str(bs_opts, "copy-on-read", copy_on_read ? "on" : "off");



    /* Controller type */

    value = qemu_opt_get(legacy_opts, "if");

    if (value) {

        for (type = 0;

             type < IF_COUNT && strcmp(value, if_name[type]);

             type++) {

        }

        if (type == IF_COUNT) {

            error_report("unsupported bus type '%s'", value);

            goto fail;

        }

    } else {

        type = block_default_type;

    }



    /* Geometry */

    cyls  = qemu_opt_get_number(legacy_opts, "cyls", 0);

    heads = qemu_opt_get_number(legacy_opts, "heads", 0);

    secs  = qemu_opt_get_number(legacy_opts, "secs", 0);



    if (cyls || heads || secs) {

        if (cyls < 1) {

            error_report("invalid physical cyls number");

            goto fail;

        }

        if (heads < 1) {

            error_report("invalid physical heads number");

            goto fail;

        }

        if (secs < 1) {

            error_report("invalid physical secs number");

            goto fail;

        }

    }



    translation = BIOS_ATA_TRANSLATION_AUTO;

    value = qemu_opt_get(legacy_opts, "trans");

    if (value != NULL) {

        if (!cyls) {

            error_report("'%s' trans must be used with cyls, heads and secs",

                         value);

            goto fail;

        }

        if (!strcmp(value, "none")) {

            translation = BIOS_ATA_TRANSLATION_NONE;

        } else if (!strcmp(value, "lba")) {

            translation = BIOS_ATA_TRANSLATION_LBA;

        } else if (!strcmp(value, "large")) {

            translation = BIOS_ATA_TRANSLATION_LARGE;

        } else if (!strcmp(value, "rechs")) {

            translation = BIOS_ATA_TRANSLATION_RECHS;

        } else if (!strcmp(value, "auto")) {

            translation = BIOS_ATA_TRANSLATION_AUTO;

        } else {

            error_report("'%s' invalid translation type", value);

            goto fail;

        }

    }



    if (media == MEDIA_CDROM) {

        if (cyls || secs || heads) {

            error_report("CHS can't be set with media=cdrom");

            goto fail;

        }

    }



    /* Device address specified by bus/unit or index.

     * If none was specified, try to find the first free one. */

    bus_id  = qemu_opt_get_number(legacy_opts, "bus", 0);

    unit_id = qemu_opt_get_number(legacy_opts, "unit", -1);

    index   = qemu_opt_get_number(legacy_opts, "index", -1);



    max_devs = if_max_devs[type];



    if (index != -1) {

        if (bus_id != 0 || unit_id != -1) {

            error_report("index cannot be used with bus and unit");

            goto fail;

        }

        bus_id = drive_index_to_bus_id(type, index);

        unit_id = drive_index_to_unit_id(type, index);

    }



    if (unit_id == -1) {

       unit_id = 0;

       while (drive_get(type, bus_id, unit_id) != NULL) {

           unit_id++;

           if (max_devs && unit_id >= max_devs) {

               unit_id -= max_devs;

               bus_id++;

           }

       }

    }



    if (max_devs && unit_id >= max_devs) {

        error_report("unit %d too big (max is %d)", unit_id, max_devs - 1);

        goto fail;

    }



    if (drive_get(type, bus_id, unit_id) != NULL) {

        error_report("drive with bus=%d, unit=%d (index=%d) exists",

                     bus_id, unit_id, index);

        goto fail;

    }



    /* Serial number */

    serial = qemu_opt_get(legacy_opts, "serial");



    /* no id supplied -> create one */

    if (qemu_opts_id(all_opts) == NULL) {

        char *new_id;

        const char *mediastr = "";

        if (type == IF_IDE || type == IF_SCSI) {

            mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd";

        }

        if (max_devs) {

            new_id = g_strdup_printf("%s%i%s%i", if_name[type], bus_id,

                                     mediastr, unit_id);

        } else {

            new_id = g_strdup_printf("%s%s%i", if_name[type],

                                     mediastr, unit_id);

        }

        qdict_put_str(bs_opts, "id", new_id);

        g_free(new_id);

    }



    /* Add virtio block device */

    devaddr = qemu_opt_get(legacy_opts, "addr");

    if (devaddr && type != IF_VIRTIO) {

        error_report("addr is not supported by this bus type");

        goto fail;

    }



    if (type == IF_VIRTIO) {

        QemuOpts *devopts;

        devopts = qemu_opts_create(qemu_find_opts("device"), NULL, 0,

                                   &error_abort);

        if (arch_type == QEMU_ARCH_S390X) {

            qemu_opt_set(devopts, "driver", "virtio-blk-ccw", &error_abort);

        } else {

            qemu_opt_set(devopts, "driver", "virtio-blk-pci", &error_abort);

        }

        qemu_opt_set(devopts, "drive", qdict_get_str(bs_opts, "id"),

                     &error_abort);

        if (devaddr) {

            qemu_opt_set(devopts, "addr", devaddr, &error_abort);

        }

    }



    filename = qemu_opt_get(legacy_opts, "file");



    /* Check werror/rerror compatibility with if=... */

    werror = qemu_opt_get(legacy_opts, "werror");

    if (werror != NULL) {

        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&

            type != IF_NONE) {

            error_report("werror is not supported by this bus type");

            goto fail;

        }

        qdict_put_str(bs_opts, "werror", werror);

    }



    rerror = qemu_opt_get(legacy_opts, "rerror");

    if (rerror != NULL) {

        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&

            type != IF_NONE) {

            error_report("rerror is not supported by this bus type");

            goto fail;

        }

        qdict_put_str(bs_opts, "rerror", rerror);

    }



    /* Actual block device init: Functionality shared with blockdev-add */

    blk = blockdev_init(filename, bs_opts, &local_err);

    bs_opts = NULL;

    if (!blk) {

        if (local_err) {

            error_report_err(local_err);

        }

        goto fail;

    } else {

        assert(!local_err);

    }



    /* Create legacy DriveInfo */

    dinfo = g_malloc0(sizeof(*dinfo));

    dinfo->opts = all_opts;



    dinfo->cyls = cyls;

    dinfo->heads = heads;

    dinfo->secs = secs;

    dinfo->trans = translation;



    dinfo->type = type;

    dinfo->bus = bus_id;

    dinfo->unit = unit_id;

    dinfo->devaddr = devaddr;

    dinfo->serial = g_strdup(serial);



    blk_set_legacy_dinfo(blk, dinfo);



    switch(type) {

    case IF_IDE:

    case IF_SCSI:

    case IF_XEN:

    case IF_NONE:

        dinfo->media_cd = media == MEDIA_CDROM;

        break;

    default:

        break;

    }



fail:

    qemu_opts_del(legacy_opts);

    QDECREF(bs_opts);

    return dinfo;

}
 and probability:0.08280254777070063
code:void qerror_report_internal(const char *file, int linenr, const char *func,

                            const char *fmt, ...)

{

    va_list va;

    QError *qerror;



    va_start(va, fmt);

    qerror = qerror_from_info(file, linenr, func, fmt, &va);

    va_end(va);



    if (cur_mon) {

        monitor_set_error(cur_mon, qerror);

    } else {

        qerror_print(qerror);

        QDECREF(qerror);

    }

}
 and probability:0.0
code:static void qdev_prop_set(DeviceState *dev, const char *name, void *src, enum PropertyType type)

{

    Property *prop;



    prop = qdev_prop_find(dev, name);

    if (!prop) {

        fprintf(stderr, "%s: property \"%s.%s\" not found\n",

                __FUNCTION__, object_get_typename(OBJECT(dev)), name);

        abort();

    }

    if (prop->info->type != type) {

        fprintf(stderr, "%s: property \"%s.%s\" type mismatch\n",

                __FUNCTION__, object_get_typename(OBJECT(dev)), name);

        abort();

    }

    qdev_prop_cpy(dev, prop, src);

}
 and probability:0.0625
code:void qdev_prop_set_drive_nofail(DeviceState *dev, const char *name,

                                BlockDriverState *value)

{

    if (qdev_prop_set_drive(dev, name, value) < 0) {

        exit(1);

    }

}
 and probability:0.0
code:static int piix3_post_load(void *opaque, int version_id)

{

    PIIX3State *piix3 = opaque;

    int pirq;



    /* Because the i8259 has not been deserialized yet, qemu_irq_raise

     * might bring the system to a different state than the saved one;

     * for example, the interrupt could be masked but the i8259 would

     * not know that yet and would trigger an interrupt in the CPU.

     *

     * Here, we update irq levels without raising the interrupt.

     * Interrupt state will be deserialized separately through the i8259.

     */

    piix3->pic_levels = 0;

    for (pirq = 0; pirq < PIIX_NUM_PIRQS; pirq++) {

        piix3_set_irq_level_internal(piix3, pirq,

                            pci_bus_get_irq_level(piix3->dev.bus, pirq));

    }

    return 0;

}
 and probability:0.15789473684210525
code:static void unset_dirty_tracking(void)

{

    BlkMigDevState *bmds;



    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {

        aio_context_acquire(blk_get_aio_context(bmds->blk));

        bdrv_release_dirty_bitmap(blk_bs(bmds->blk), bmds->dirty_bitmap);

        aio_context_release(blk_get_aio_context(bmds->blk));

    }

}
 and probability:0.3333333333333333
code:static void cb_hmp_change_bdrv_pwd(Monitor *mon, const char *password,

                                   void *opaque)

{

    Error *encryption_err = opaque;

    Error *err = NULL;

    const char *device;



    device = error_get_field(encryption_err, "device");



    qmp_block_passwd(device, password, &err);

    hmp_handle_error(mon, &err);

    error_free(encryption_err);



    monitor_read_command(mon, 1);

}
 and probability:0.0
code:av_cold int ff_ivi_decode_close(AVCodecContext *avctx)

{

    IVI45DecContext *ctx = avctx->priv_data;



    ivi_free_buffers(&ctx->planes[0]);



    if (ctx->mb_vlc.cust_tab.table)

        ff_free_vlc(&ctx->mb_vlc.cust_tab);



#if IVI4_STREAM_ANALYSER

    if (ctx->is_indeo4) {

    if (ctx->is_scalable)

        av_log(avctx, AV_LOG_ERROR, "This video uses scalability mode!\n");

    if (ctx->uses_tiling)

        av_log(avctx, AV_LOG_ERROR, "This video uses local decoding!\n");

    if (ctx->has_b_frames)

        av_log(avctx, AV_LOG_ERROR, "This video contains B-frames!\n");

    if (ctx->has_transp)

        av_log(avctx, AV_LOG_ERROR, "Transparency mode is enabled!\n");

    if (ctx->uses_haar)

        av_log(avctx, AV_LOG_ERROR, "This video uses Haar transform!\n");

    if (ctx->uses_fullpel)

        av_log(avctx, AV_LOG_ERROR, "This video uses fullpel motion vectors!\n");

    }

#endif



    av_frame_free(&ctx->p_frame);



    return 0;

}
 and probability:0.48
code:static av_cold int cinepak_decode_init(AVCodecContext *avctx)

{

    CinepakContext *s = avctx->priv_data;



    s->avctx = avctx;

    s->width = (avctx->width + 3) & ~3;

    s->height = (avctx->height + 3) & ~3;

    s->sega_film_skip_bytes = -1;  /* uninitialized state */



    // check for paletted data

    if (avctx->bits_per_coded_sample != 8) {

        s->palette_video = 0;

        avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    } else {

        s->palette_video = 1;

        avctx->pix_fmt = AV_PIX_FMT_PAL8;

    }



    s->frame.data[0] = NULL;



    return 0;

}
 and probability:0.6111111111111112
code:static int xen_host_pci_config_open(XenHostPCIDevice *d)

{

    char path[PATH_MAX];

    int rc;



    rc = xen_host_pci_sysfs_path(d, "config", path, sizeof (path));

    if (rc) {

        return rc;

    }

    d->config_fd = open(path, O_RDWR);

    if (d->config_fd < 0) {

        return -errno;

    }

    return 0;

}
 and probability:0.14285714285714285
code:void cpu_exec_init(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUClass *cc = CPU_GET_CLASS(cpu);

    CPUState *some_cpu;

    int cpu_index;



#if defined(CONFIG_USER_ONLY)

    cpu_list_lock();

#endif

    cpu_index = 0;

    CPU_FOREACH(some_cpu) {

        cpu_index++;

    }

    cpu->cpu_index = cpu_index;

    cpu->numa_node = 0;

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

#ifndef CONFIG_USER_ONLY

    cpu->as = &address_space_memory;

    cpu->thread_id = qemu_get_thread_id();


#endif

    QTAILQ_INSERT_TAIL(&cpus, cpu, node);

#if defined(CONFIG_USER_ONLY)

    cpu_list_unlock();

#endif

    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {

        vmstate_register(NULL, cpu_index, &vmstate_cpu_common, cpu);

    }

#if defined(CPU_SAVE_VERSION) && !defined(CONFIG_USER_ONLY)

    register_savevm(NULL, "cpu", cpu_index, CPU_SAVE_VERSION,

                    cpu_save, cpu_load, env);

    assert(cc->vmsd == NULL);

    assert(qdev_get_vmsd(DEVICE(cpu)) == NULL);

#endif

    if (cc->vmsd != NULL) {

        vmstate_register(NULL, cpu_index, cc->vmsd, cpu);

    }

} and probability:0.2631578947368421
code:static int vhost_set_vring_file(struct vhost_dev *dev,

                                VhostUserRequest request,

                                struct vhost_vring_file *file)

{

    int fds[VHOST_MEMORY_MAX_NREGIONS];

    size_t fd_num = 0;

    VhostUserMsg msg = {

        .request = request,

        .flags = VHOST_USER_VERSION,

        .payload.u64 = file->index & VHOST_USER_VRING_IDX_MASK,

        .size = sizeof(msg.payload.u64),

    };



    if (ioeventfd_enabled() && file->fd > 0) {

        fds[fd_num++] = file->fd;

    } else {

        msg.payload.u64 |= VHOST_USER_VRING_NOFD_MASK;

    }



    vhost_user_write(dev, &msg, fds, fd_num);



    return 0;

}
 and probability:0.15
code:char *qdist_pr(const struct qdist *dist, size_t n_bins, uint32_t opt)

{

    const char *border = opt & QDIST_PR_BORDER ? "|" : "";

    char *llabel, *rlabel;

    char *hgram;

    GString *s;



    if (dist->n == 0) {

        return NULL;

    }



    s = g_string_new("");



    llabel = qdist_pr_label(dist, n_bins, opt, true);

    rlabel = qdist_pr_label(dist, n_bins, opt, false);

    hgram = qdist_pr_plain(dist, n_bins);

    g_string_append_printf(s, "%s%s%s%s%s",

                           llabel, border, hgram, border, rlabel);

    g_free(llabel);

    g_free(rlabel);

    g_free(hgram);



    return g_string_free(s, FALSE);

}
 and probability:0.05
code:static int qemu_rdma_write_one(QEMUFile *f, RDMAContext *rdma,

                               int current_index, uint64_t current_addr,

                               uint64_t length)

{

    struct ibv_sge sge;

    struct ibv_send_wr send_wr = { 0 };

    struct ibv_send_wr *bad_wr;

    int reg_result_idx, ret, count = 0;

    uint64_t chunk, chunks;

    uint8_t *chunk_start, *chunk_end;

    RDMALocalBlock *block = &(rdma->local_ram_blocks.block[current_index]);

    RDMARegister reg;

    RDMARegisterResult *reg_result;

    RDMAControlHeader resp = { .type = RDMA_CONTROL_REGISTER_RESULT };

    RDMAControlHeader head = { .len = sizeof(RDMARegister),

                               .type = RDMA_CONTROL_REGISTER_REQUEST,

                               .repeat = 1,

                             };



retry:

    sge.addr = (uint64_t)(block->local_host_addr +

                            (current_addr - block->offset));

    sge.length = length;



    chunk = ram_chunk_index(block->local_host_addr, (uint8_t *) sge.addr);

    chunk_start = ram_chunk_start(block, chunk);



    if (block->is_ram_block) {

        chunks = length / (1UL << RDMA_REG_CHUNK_SHIFT);



        if (chunks && ((length % (1UL << RDMA_REG_CHUNK_SHIFT)) == 0)) {

            chunks--;

        }

    } else {

        chunks = block->length / (1UL << RDMA_REG_CHUNK_SHIFT);



        if (chunks && ((block->length % (1UL << RDMA_REG_CHUNK_SHIFT)) == 0)) {

            chunks--;

        }

    }



    DDPRINTF("Writing %" PRIu64 " chunks, (%" PRIu64 " MB)\n",

        chunks + 1, (chunks + 1) * (1UL << RDMA_REG_CHUNK_SHIFT) / 1024 / 1024);



    chunk_end = ram_chunk_end(block, chunk + chunks);



    if (!rdma->pin_all) {

#ifdef RDMA_UNREGISTRATION_EXAMPLE

        qemu_rdma_unregister_waiting(rdma);

#endif

    }



    while (test_bit(chunk, block->transit_bitmap)) {

        (void)count;

        DDPRINTF("(%d) Not clobbering: block: %d chunk %" PRIu64

                " current %" PRIu64 " len %" PRIu64 " %d %d\n",

                count++, current_index, chunk,

                sge.addr, length, rdma->nb_sent, block->nb_chunks);



        ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RDMA_WRITE, NULL);



        if (ret < 0) {

            fprintf(stderr, "Failed to Wait for previous write to complete "

                    "block %d chunk %" PRIu64

                    " current %" PRIu64 " len %" PRIu64 " %d\n",

                    current_index, chunk, sge.addr, length, rdma->nb_sent);

            return ret;

        }

    }



    if (!rdma->pin_all || !block->is_ram_block) {

        if (!block->remote_keys[chunk]) {

            /*

             * This chunk has not yet been registered, so first check to see

             * if the entire chunk is zero. If so, tell the other size to

             * memset() + madvise() the entire chunk without RDMA.

             */



            if (can_use_buffer_find_nonzero_offset((void *)sge.addr, length)

                   && buffer_find_nonzero_offset((void *)sge.addr,

                                                    length) == length) {

                RDMACompress comp = {

                                        .offset = current_addr,

                                        .value = 0,

                                        .block_idx = current_index,

                                        .length = length,

                                    };



                head.len = sizeof(comp);

                head.type = RDMA_CONTROL_COMPRESS;



                DDPRINTF("Entire chunk is zero, sending compress: %"

                    PRIu64 " for %d "

                    "bytes, index: %d, offset: %" PRId64 "...\n",

                    chunk, sge.length, current_index, current_addr);



                compress_to_network(&comp);

                ret = qemu_rdma_exchange_send(rdma, &head,

                                (uint8_t *) &comp, NULL, NULL, NULL);



                if (ret < 0) {

                    return -EIO;

                }



                acct_update_position(f, sge.length, true);



                return 1;

            }



            /*

             * Otherwise, tell other side to register.

             */

            reg.current_index = current_index;

            if (block->is_ram_block) {

                reg.key.current_addr = current_addr;

            } else {

                reg.key.chunk = chunk;

            }

            reg.chunks = chunks;



            DDPRINTF("Sending registration request chunk %" PRIu64 " for %d "

                    "bytes, index: %d, offset: %" PRId64 "...\n",

                    chunk, sge.length, current_index, current_addr);



            register_to_network(&reg);

            ret = qemu_rdma_exchange_send(rdma, &head, (uint8_t *) &reg,

                                    &resp, &reg_result_idx, NULL);

            if (ret < 0) {

                return ret;

            }



            /* try to overlap this single registration with the one we sent. */

            if (qemu_rdma_register_and_get_keys(rdma, block,

                                                (uint8_t *) sge.addr,

                                                &sge.lkey, NULL, chunk,

                                                chunk_start, chunk_end)) {

                fprintf(stderr, "cannot get lkey!\n");

                return -EINVAL;

            }



            reg_result = (RDMARegisterResult *)

                    rdma->wr_data[reg_result_idx].control_curr;



            network_to_result(reg_result);



            DDPRINTF("Received registration result:"

                    " my key: %x their key %x, chunk %" PRIu64 "\n",

                    block->remote_keys[chunk], reg_result->rkey, chunk);



            block->remote_keys[chunk] = reg_result->rkey;

            block->remote_host_addr = reg_result->host_addr;

        } else {

            /* already registered before */

            if (qemu_rdma_register_and_get_keys(rdma, block,

                                                (uint8_t *)sge.addr,

                                                &sge.lkey, NULL, chunk,

                                                chunk_start, chunk_end)) {

                fprintf(stderr, "cannot get lkey!\n");

                return -EINVAL;

            }

        }



        send_wr.wr.rdma.rkey = block->remote_keys[chunk];

    } else {

        send_wr.wr.rdma.rkey = block->remote_rkey;



        if (qemu_rdma_register_and_get_keys(rdma, block, (uint8_t *)sge.addr,

                                                     &sge.lkey, NULL, chunk,

                                                     chunk_start, chunk_end)) {

            fprintf(stderr, "cannot get lkey!\n");

            return -EINVAL;

        }

    }



    /*

     * Encode the ram block index and chunk within this wrid.

     * We will use this information at the time of completion

     * to figure out which bitmap to check against and then which

     * chunk in the bitmap to look for.

     */

    send_wr.wr_id = qemu_rdma_make_wrid(RDMA_WRID_RDMA_WRITE,

                                        current_index, chunk);



    send_wr.opcode = IBV_WR_RDMA_WRITE;

    send_wr.send_flags = IBV_SEND_SIGNALED;

    send_wr.sg_list = &sge;

    send_wr.num_sge = 1;

    send_wr.wr.rdma.remote_addr = block->remote_host_addr +

                                (current_addr - block->offset);



    DDDPRINTF("Posting chunk: %" PRIu64 ", addr: %lx"

              " remote: %lx, bytes %" PRIu32 "\n",

              chunk, sge.addr, send_wr.wr.rdma.remote_addr,

              sge.length);



    /*

     * ibv_post_send() does not return negative error numbers,

     * per the specification they are positive - no idea why.

     */

    ret = ibv_post_send(rdma->qp, &send_wr, &bad_wr);



    if (ret == ENOMEM) {

        DDPRINTF("send queue is full. wait a little....\n");

        ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RDMA_WRITE, NULL);

        if (ret < 0) {

            fprintf(stderr, "rdma migration: failed to make "

                            "room in full send queue! %d\n", ret);

            return ret;

        }



        goto retry;



    } else if (ret > 0) {

        perror("rdma migration: post rdma write failed");

        return -ret;

    }



    set_bit(chunk, block->transit_bitmap);

    acct_update_position(f, sge.length, false);

    rdma->total_writes++;



    return 0;

}
 and probability:0.17297297297297298
code:static int init_directories(BDRVVVFATState* s,

	const char* dirname)

{

    bootsector_t* bootsector;

    mapping_t* mapping;

    unsigned int i;

    unsigned int cluster;



    memset(&(s->first_sectors[0]),0,0x40*0x200);



    s->cluster_size=s->sectors_per_cluster*0x200;

    s->cluster_buffer=qemu_malloc(s->cluster_size);



    /*

     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),

     * where sc is sector_count,

     * spf is sectors_per_fat,

     * spc is sectors_per_clusters, and

     * fat_type = 12, 16 or 32.

     */

    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;

    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */



    array_init(&(s->mapping),sizeof(mapping_t));

    array_init(&(s->directory),sizeof(direntry_t));



    /* add volume label */

    {

	direntry_t* entry=array_get_next(&(s->directory));

	entry->attributes=0x28; /* archive | volume label */

	snprintf((char*)entry->name,11,"QEMU VVFAT");

    }



    /* Now build FAT, and write back information into directory */

    init_fat(s);



    s->faked_sectors=s->first_sectors_number+s->sectors_per_fat*2;

    s->cluster_count=sector2cluster(s, s->sector_count);



    mapping = array_get_next(&(s->mapping));

    mapping->begin = 0;

    mapping->dir_index = 0;

    mapping->info.dir.parent_mapping_index = -1;

    mapping->first_mapping_index = -1;

    mapping->path = strdup(dirname);

    i = strlen(mapping->path);

    if (i > 0 && mapping->path[i - 1] == '/')

	mapping->path[i - 1] = '\0';

    mapping->mode = MODE_DIRECTORY;

    mapping->read_only = 0;

    s->path = mapping->path;



    for (i = 0, cluster = 0; i < s->mapping.next; i++) {

	/* MS-DOS expects the FAT to be 0 for the root directory

	 * (except for the media byte). */

	/* LATER TODO: still true for FAT32? */

	int fix_fat = (i != 0);

	mapping = array_get(&(s->mapping), i);



        if (mapping->mode & MODE_DIRECTORY) {

	    mapping->begin = cluster;

	    if(read_directory(s, i)) {

		fprintf(stderr, "Could not read directory %s\n",

			mapping->path);

		return -1;

	    }

	    mapping = array_get(&(s->mapping), i);

	} else {

	    assert(mapping->mode == MODE_UNDEFINED);

	    mapping->mode=MODE_NORMAL;

	    mapping->begin = cluster;

	    if (mapping->end > 0) {

		direntry_t* direntry = array_get(&(s->directory),

			mapping->dir_index);



		mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;

		set_begin_of_direntry(direntry, mapping->begin);

	    } else {

		mapping->end = cluster + 1;

		fix_fat = 0;

	    }

	}



	assert(mapping->begin < mapping->end);



	/* next free cluster */

	cluster = mapping->end;



	if(cluster > s->cluster_count) {

	    fprintf(stderr,"Directory does not fit in FAT%d (capacity %s)\n",

		    s->fat_type,

		    s->fat_type == 12 ? s->sector_count == 2880 ? "1.44 MB"

								: "2.88 MB"

				      : "504MB");

	    return -EINVAL;

	}



	/* fix fat for entry */

	if (fix_fat) {

	    int j;

	    for(j = mapping->begin; j < mapping->end - 1; j++)

		fat_set(s, j, j+1);

	    fat_set(s, mapping->end - 1, s->max_fat_value);

	}

    }



    mapping = array_get(&(s->mapping), 0);

    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;

    s->last_cluster_of_root_directory = mapping->end;



    /* the FAT signature */

    fat_set(s,0,s->max_fat_value);

    fat_set(s,1,s->max_fat_value);



    s->current_mapping = NULL;



    bootsector=(bootsector_t*)(s->first_sectors+(s->first_sectors_number-1)*0x200);

    bootsector->jump[0]=0xeb;

    bootsector->jump[1]=0x3e;

    bootsector->jump[2]=0x90;

    memcpy(bootsector->name,"QEMU    ",8);

    bootsector->sector_size=cpu_to_le16(0x200);

    bootsector->sectors_per_cluster=s->sectors_per_cluster;

    bootsector->reserved_sectors=cpu_to_le16(1);

    bootsector->number_of_fats=0x2; /* number of FATs */

    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);

    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);

    bootsector->media_type=(s->fat_type!=12?0xf8:s->sector_count==5760?0xf9:0xf8); /* media descriptor */

    s->fat.pointer[0] = bootsector->media_type;

    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);

    bootsector->sectors_per_track=cpu_to_le16(s->bs->secs);

    bootsector->number_of_heads=cpu_to_le16(s->bs->heads);

    bootsector->hidden_sectors=cpu_to_le32(s->first_sectors_number==1?0:0x3f);

    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);



    /* LATER TODO: if FAT32, this is wrong */

    bootsector->u.fat16.drive_number=s->fat_type==12?0:0x80; /* assume this is hda (TODO) */

    bootsector->u.fat16.current_head=0;

    bootsector->u.fat16.signature=0x29;

    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);



    memcpy(bootsector->u.fat16.volume_label,"QEMU VVFAT ",11);

    memcpy(bootsector->fat_type,(s->fat_type==12?"FAT12   ":s->fat_type==16?"FAT16   ":"FAT32   "),8);

    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;



    return 0;

}
 and probability:0.624
code:static int mpegts_read_header(AVFormatContext *s)

{

    MpegTSContext *ts = s->priv_data;

    AVIOContext *pb   = s->pb;

    uint8_t buf[8 * 1024] = {0};

    int len;

    int64_t pos, probesize = s->probesize;



    if (ffio_ensure_seekback(pb, probesize) < 0)

        av_log(s, AV_LOG_WARNING, "Failed to allocate buffers for seekback\n");



    /* read the first 8192 bytes to get packet size */

    pos = avio_tell(pb);

    len = avio_read(pb, buf, sizeof(buf));

    ts->raw_packet_size = get_packet_size(buf, len);

    if (ts->raw_packet_size <= 0) {

        av_log(s, AV_LOG_WARNING, "Could not detect TS packet size, defaulting to non-FEC/DVHS\n");

        ts->raw_packet_size = TS_PACKET_SIZE;

    }

    ts->stream     = s;

    ts->auto_guess = 0;



    if (s->iformat == &ff_mpegts_demuxer) {

        /* normal demux */



        /* first do a scan to get all the services */

        seek_back(s, pb, pos);



        mpegts_open_section_filter(ts, SDT_PID, sdt_cb, ts, 1);



        mpegts_open_section_filter(ts, PAT_PID, pat_cb, ts, 1);



        handle_packets(ts, probesize / ts->raw_packet_size);

        /* if could not find service, enable auto_guess */



        ts->auto_guess = 1;



        av_log(ts->stream, AV_LOG_TRACE, "tuning done\n");



        s->ctx_flags |= AVFMTCTX_NOHEADER;

    } else {

        AVStream *st;

        int pcr_pid, pid, nb_packets, nb_pcrs, ret, pcr_l;

        int64_t pcrs[2], pcr_h;

        int packet_count[2];

        uint8_t packet[TS_PACKET_SIZE];

        const uint8_t *data;



        /* only read packets */



        st = avformat_new_stream(s, NULL);

        if (!st)

            return AVERROR(ENOMEM);

        avpriv_set_pts_info(st, 60, 1, 27000000);

        st->codecpar->codec_type = AVMEDIA_TYPE_DATA;

        st->codecpar->codec_id   = AV_CODEC_ID_MPEG2TS;



        /* we iterate until we find two PCRs to estimate the bitrate */

        pcr_pid    = -1;

        nb_pcrs    = 0;

        nb_packets = 0;

        for (;;) {

            ret = read_packet(s, packet, ts->raw_packet_size, &data);

            if (ret < 0)

                return ret;

            pid = AV_RB16(data + 1) & 0x1fff;

            if ((pcr_pid == -1 || pcr_pid == pid) &&

                parse_pcr(&pcr_h, &pcr_l, data) == 0) {

                finished_reading_packet(s, ts->raw_packet_size);

                pcr_pid = pid;

                packet_count[nb_pcrs] = nb_packets;

                pcrs[nb_pcrs] = pcr_h * 300 + pcr_l;

                nb_pcrs++;

                if (nb_pcrs >= 2)

                    break;

            } else {

                finished_reading_packet(s, ts->raw_packet_size);

            }

            nb_packets++;

        }



        /* NOTE1: the bitrate is computed without the FEC */

        /* NOTE2: it is only the bitrate of the start of the stream */

        ts->pcr_incr = (pcrs[1] - pcrs[0]) / (packet_count[1] - packet_count[0]);

        ts->cur_pcr  = pcrs[0] - ts->pcr_incr * packet_count[0];

        s->bit_rate  = TS_PACKET_SIZE * 8 * 27000000LL / ts->pcr_incr;

        st->codecpar->bit_rate = s->bit_rate;

        st->start_time      = ts->cur_pcr;

        av_log(ts->stream, AV_LOG_TRACE, "start=%0.3f pcr=%0.3f incr=%d\n",

                st->start_time / 1000000.0, pcrs[0] / 27e6, ts->pcr_incr);

    }



    seek_back(s, pb, pos);

    return 0;

}
 and probability:0.3875
code:static QPCIDevice *get_ahci_device(uint32_t *fingerprint)

{

    QPCIDevice *ahci;

    uint32_t ahci_fingerprint;

    QPCIBus *pcibus;



    pcibus = qpci_init_pc();



    /* Find the AHCI PCI device and verify it's the right one. */

    ahci = qpci_device_find(pcibus, QPCI_DEVFN(0x1F, 0x02));

    g_assert(ahci != NULL);



    ahci_fingerprint = qpci_config_readl(ahci, PCI_VENDOR_ID);



    switch (ahci_fingerprint) {

    case AHCI_INTEL_ICH9:

        break;

    default:

        /* Unknown device. */

        g_assert_not_reached();

    }



    if (fingerprint) {

        *fingerprint = ahci_fingerprint;

    }

    return ahci;

}
 and probability:0.045454545454545456
code:static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)

{

    int i;

    uint16_t limit;



    switch (data[0]) {

    case 0:

	if (len == 1)

	    return 20;



	set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),

			 read_u8(data, 6), read_u8(data, 7),

			 read_u16(data, 8), read_u16(data, 10),

			 read_u16(data, 12), read_u8(data, 14),

			 read_u8(data, 15), read_u8(data, 16));

	break;

    case 2:

	if (len == 1)

	    return 4;



	if (len == 4)

	    return 4 + (read_u16(data, 2) * 4);



	limit = read_u16(data, 2);

	for (i = 0; i < limit; i++) {

	    int32_t val = read_s32(data, 4 + (i * 4));

	    memcpy(data + 4 + (i * 4), &val, sizeof(val));

	}



	set_encodings(vs, (int32_t *)(data + 4), limit);

	break;

    case 3:

	if (len == 1)

	    return 10;



	framebuffer_update_request(vs,

				   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),

				   read_u16(data, 6), read_u16(data, 8));

	break;

    case 4:

	if (len == 1)

	    return 8;



	key_event(vs, read_u8(data, 1), read_u32(data, 4));

	break;

    case 5:

	if (len == 1)

	    return 6;



	pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));

	break;

    case 6:

	if (len == 1)

	    return 8;



	if (len == 8) {

            uint32_t dlen = read_u32(data, 4);

            if (dlen > 0)

                return 8 + dlen;

        }



	client_cut_text(vs, read_u32(data, 4), data + 8);

	break;

    case 255:

        if (len == 1)

            return 2;



        switch (read_u8(data, 1)) {

        case 0:

            if (len == 2)

                return 12;



            ext_key_event(vs, read_u16(data, 2),

                          read_u32(data, 4), read_u32(data, 8));

            break;

        case 1:

            if (len == 2)

                return 4;



            switch (read_u16 (data, 2)) {

            case 0:

                audio_add(vs);

                break;

            case 1:

                audio_del(vs);

                break;

            case 2:

                if (len == 4)

                    return 10;

                switch (read_u8(data, 4)) {

                case 0: vs->as.fmt = AUD_FMT_U8; break;

                case 1: vs->as.fmt = AUD_FMT_S8; break;

                case 2: vs->as.fmt = AUD_FMT_U16; break;

                case 3: vs->as.fmt = AUD_FMT_S16; break;

                case 4: vs->as.fmt = AUD_FMT_U32; break;

                case 5: vs->as.fmt = AUD_FMT_S32; break;

                default:

                    printf("Invalid audio format %d\n", read_u8(data, 4));

                    vnc_client_error(vs);

                    break;

                }

                vs->as.nchannels = read_u8(data, 5);

                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {

                    printf("Invalid audio channel coount %d\n",

                           read_u8(data, 5));

                    vnc_client_error(vs);

                    break;

                }

                vs->as.freq = read_u32(data, 6);

                break;

            default:

                printf ("Invalid audio message %d\n", read_u8(data, 4));

                vnc_client_error(vs);

                break;

            }

            break;



        default:

            printf("Msg: %d\n", read_u16(data, 0));

            vnc_client_error(vs);

            break;

        }

        break;

    default:

	printf("Msg: %d\n", data[0]);

	vnc_client_error(vs);

	break;

    }



    vnc_read_when(vs, protocol_client_msg, 1);

    return 0;

}
 and probability:0.15384615384615385
code:static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,
                        AVPacket *avpkt) {
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    AVSubtitle *sub = data;
    const uint8_t *buf_end = buf + buf_size;
    uint8_t *bitmap;
    int w, h, x, y, i, ret;
    int64_t packet_time = 0;
    GetBitContext gb;
    int has_alpha = avctx->codec_tag == MKTAG('D','X','S','A');
    // check that at least header fits
    if (buf_size < 27 + 7 * 2 + 4 * (3 + has_alpha)) {
        av_log(avctx, AV_LOG_ERROR, "coded frame size %d too small\n", buf_size);
        return -1;
    }
    // read start and end time
    if (buf[0] != '[' || buf[13] != '-' || buf[26] != ']') {
        av_log(avctx, AV_LOG_ERROR, "invalid time code\n");
        return -1;
    }
    if (avpkt->pts != AV_NOPTS_VALUE)
        packet_time = av_rescale_q(avpkt->pts, AV_TIME_BASE_Q, (AVRational){1, 1000});
    sub->start_display_time = parse_timecode(buf +  1, packet_time);
    sub->end_display_time   = parse_timecode(buf + 14, packet_time);
    buf += 27;
    // read header
    w = bytestream_get_le16(&buf);
    h = bytestream_get_le16(&buf);
    if (av_image_check_size(w, h, 0, avctx) < 0)
        return -1;
    x = bytestream_get_le16(&buf);
    y = bytestream_get_le16(&buf);
    // skip bottom right position, it gives no new information
    bytestream_get_le16(&buf);
    bytestream_get_le16(&buf);
    // The following value is supposed to indicate the start offset
    // (relative to the palette) of the data for the second field,
    // however there are files in which it has a bogus value and thus
    // we just ignore it
    bytestream_get_le16(&buf);
    // allocate sub and set values
    sub->rects =  av_mallocz(sizeof(*sub->rects));
    if (!sub->rects)
        return AVERROR(ENOMEM);
    sub->rects[0] = av_mallocz(sizeof(*sub->rects[0]));
    if (!sub->rects[0]) {
        av_freep(&sub->rects);
        return AVERROR(ENOMEM);
    }
    sub->rects[0]->x = x; sub->rects[0]->y = y;
    sub->rects[0]->w = w; sub->rects[0]->h = h;
    sub->rects[0]->type = SUBTITLE_BITMAP;
    sub->rects[0]->linesize[0] = w;
    sub->rects[0]->data[0] = av_malloc(w * h);
    sub->rects[0]->nb_colors = 4;
    sub->rects[0]->data[1] = av_mallocz(AVPALETTE_SIZE);
    if (!sub->rects[0]->data[0] || !sub->rects[0]->data[1]) {
        av_freep(&sub->rects[0]->data[1]);
        av_freep(&sub->rects[0]->data[0]);
        av_freep(&sub->rects[0]);
        av_freep(&sub->rects);
        return AVERROR(ENOMEM);
    }
    sub->num_rects = 1;
    // read palette
    for (i = 0; i < sub->rects[0]->nb_colors; i++)
        ((uint32_t*)sub->rects[0]->data[1])[i] = bytestream_get_be24(&buf);
    if (!has_alpha) {
        // make all except background (first entry) non-transparent
        for (i = 1; i < sub->rects[0]->nb_colors; i++)
            ((uint32_t *)sub->rects[0]->data[1])[i] |= 0xff000000;
    } else {
        for (i = 0; i < sub->rects[0]->nb_colors; i++)
            ((uint32_t *)sub->rects[0]->data[1])[i] |= *buf++ << 24;
    }
#if FF_API_AVPICTURE
FF_DISABLE_DEPRECATION_WARNINGS
{
    AVSubtitleRect *rect;
    int j;
    rect = sub->rects[0];
    for (j = 0; j < 4; j++) {
        rect->pict.data[j] = rect->data[j];
        rect->pict.linesize[j] = rect->linesize[j];
    }
}
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    // process RLE-compressed data
    if ((ret = init_get_bits8(&gb, buf, buf_end - buf)) < 0)
        return ret;
    bitmap = sub->rects[0]->data[0];
    for (y = 0; y < h; y++) {
        // interlaced: do odd lines
        if (y == (h + 1) / 2) bitmap = sub->rects[0]->data[0] + w;
        for (x = 0; x < w; ) {
            int log2 = ff_log2_tab[show_bits(&gb, 8)];
            int run = get_bits(&gb, 14 - 4 * (log2 >> 1));
            int color = get_bits(&gb, 2);
            run = FFMIN(run, w - x);
            // run length 0 means till end of row
            if (!run) run = w - x;
            memset(bitmap, color, run);
            bitmap += run;
            x += run;
        }
        // interlaced, skip every second line
        bitmap += w;
        align_get_bits(&gb);
    }
    *data_size = 1;
    return buf_size;
} and probability:0.4473684210526316
code:static void tpm_tis_initfn(Object *obj)

{

    ISADevice *dev = ISA_DEVICE(obj);

    TPMState *s = TPM(obj);



    memory_region_init_io(&s->mmio, OBJECT(s), &tpm_tis_memory_ops,

                          s, "tpm-tis-mmio",

                          TPM_TIS_NUM_LOCALITIES << TPM_TIS_LOCALITY_SHIFT);

    memory_region_add_subregion(isa_address_space(dev), TPM_TIS_ADDR_BASE,

                                &s->mmio);

}
 and probability:0.2
code:static int process_frame(FFFrameSync *fs)

{

    AVFilterContext *ctx = fs->parent;

    LUT2Context *s = fs->opaque;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFrame *out, *srcx, *srcy;

    int ret;



    if ((ret = ff_framesync2_get_frame(&s->fs, 0, &srcx, 0)) < 0 ||

        (ret = ff_framesync2_get_frame(&s->fs, 1, &srcy, 0)) < 0)

        return ret;



    if (ctx->is_disabled) {

        out = av_frame_clone(srcx);

        if (!out)

            return AVERROR(ENOMEM);

    } else {

        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);

        if (!out)

            return AVERROR(ENOMEM);

        av_frame_copy_props(out, srcx);



        s->lut2(s, out, srcx, srcy);

    }



    out->pts = av_rescale_q(s->fs.pts, s->fs.time_base, outlink->time_base);



    return ff_filter_frame(outlink, out);

}
 and probability:0.375
code:static int handle_primary_tcp_pkt(NetFilterState *nf,

                                  Connection *conn,

                                  Packet *pkt)

{

    struct tcphdr *tcp_pkt;



    tcp_pkt = (struct tcphdr *)pkt->transport_header;

    if (trace_event_get_state_backends(TRACE_COLO_FILTER_REWRITER_DEBUG)) {

        trace_colo_filter_rewriter_pkt_info(__func__,

                    inet_ntoa(pkt->ip->ip_src), inet_ntoa(pkt->ip->ip_dst),

                    ntohl(tcp_pkt->th_seq), ntohl(tcp_pkt->th_ack),

                    tcp_pkt->th_flags);

        trace_colo_filter_rewriter_conn_offset(conn->offset);

    }



    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_SYN)) {

        /*

         * we use this flag update offset func

         * run once in independent tcp connection

         */

        conn->syn_flag = 1;

    }



    if (((tcp_pkt->th_flags & (TH_ACK | TH_SYN)) == TH_ACK)) {

        if (conn->syn_flag) {

            /*

             * offset = secondary_seq - primary seq

             * ack packet sent by guest from primary node,

             * so we use th_ack - 1 get primary_seq

             */

            conn->offset -= (ntohl(tcp_pkt->th_ack) - 1);

            conn->syn_flag = 0;

        }

        if (conn->offset) {

            /* handle packets to the secondary from the primary */

            tcp_pkt->th_ack = htonl(ntohl(tcp_pkt->th_ack) + conn->offset);



            net_checksum_calculate((uint8_t *)pkt->data, pkt->size);

        }

    }



    return 0;

}
 and probability:0.3684210526315789
code:av_cold void ff_dsputil_init_armv6(DSPContext *c, AVCodecContext *avctx)

{

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (avctx->bits_per_raw_sample <= 8 &&

        (avctx->idct_algo == FF_IDCT_AUTO ||

         avctx->idct_algo == FF_IDCT_SIMPLEARMV6)) {

        c->idct_put              = ff_simple_idct_put_armv6;

        c->idct_add              = ff_simple_idct_add_armv6;

        c->idct                  = ff_simple_idct_armv6;

        c->idct_permutation_type = FF_LIBMPEG2_IDCT_PERM;

    }



    if (!high_bit_depth) {

    c->put_pixels_tab[0][0] = ff_put_pixels16_armv6;

    c->put_pixels_tab[0][1] = ff_put_pixels16_x2_armv6;

    c->put_pixels_tab[0][2] = ff_put_pixels16_y2_armv6;

/*     c->put_pixels_tab[0][3] = ff_put_pixels16_xy2_armv6; */

    c->put_pixels_tab[1][0] = ff_put_pixels8_armv6;

    c->put_pixels_tab[1][1] = ff_put_pixels8_x2_armv6;

    c->put_pixels_tab[1][2] = ff_put_pixels8_y2_armv6;

/*     c->put_pixels_tab[1][3] = ff_put_pixels8_xy2_armv6; */



    c->put_no_rnd_pixels_tab[0][0] = ff_put_pixels16_armv6;

    c->put_no_rnd_pixels_tab[0][1] = ff_put_pixels16_x2_no_rnd_armv6;

    c->put_no_rnd_pixels_tab[0][2] = ff_put_pixels16_y2_no_rnd_armv6;

/*     c->put_no_rnd_pixels_tab[0][3] = ff_put_pixels16_xy2_no_rnd_armv6; */

    c->put_no_rnd_pixels_tab[1][0] = ff_put_pixels8_armv6;

    c->put_no_rnd_pixels_tab[1][1] = ff_put_pixels8_x2_no_rnd_armv6;

    c->put_no_rnd_pixels_tab[1][2] = ff_put_pixels8_y2_no_rnd_armv6;

/*     c->put_no_rnd_pixels_tab[1][3] = ff_put_pixels8_xy2_no_rnd_armv6; */



    c->avg_pixels_tab[0][0] = ff_avg_pixels16_armv6;

    c->avg_pixels_tab[1][0] = ff_avg_pixels8_armv6;

    }



    if (!high_bit_depth)

        c->get_pixels = ff_get_pixels_armv6;

    c->add_pixels_clamped = ff_add_pixels_clamped_armv6;

    c->diff_pixels = ff_diff_pixels_armv6;



    c->pix_abs[0][0] = ff_pix_abs16_armv6;

    c->pix_abs[0][1] = ff_pix_abs16_x2_armv6;

    c->pix_abs[0][2] = ff_pix_abs16_y2_armv6;



    c->pix_abs[1][0] = ff_pix_abs8_armv6;



    c->sad[0] = ff_pix_abs16_armv6;

    c->sad[1] = ff_pix_abs8_armv6;



    c->sse[0] = ff_sse16_armv6;



    c->pix_norm1 = ff_pix_norm1_armv6;

    c->pix_sum   = ff_pix_sum_armv6;

}
 and probability:0.7555555555555555
code:static int decode_exponents(AC3DecodeContext *ctx)

{

    ac3_audio_block *ab = &ctx->audio_block;

    int i;

    uint8_t *exps;

    uint8_t *dexps;



    if (ab->flags & AC3_AB_CPLINU && ab->cplexpstr != AC3_EXPSTR_REUSE)

        if (_decode_exponents(ab->cplexpstr, ab->ncplgrps, ab->cplabsexp,

                    ab->cplexps, ab->dcplexps + ab->cplstrtmant))

            return -1;

    for (i = 0; i < ctx->bsi.nfchans; i++)

        if (ab->chexpstr[i] != AC3_EXPSTR_REUSE) {

            exps = ab->exps[i];

            dexps = ab->dexps[i];

            if (_decode_exponents(ab->chexpstr[i], ab->nchgrps[i], exps[0], exps + 1, dexps + 1))

                return -1;

        }

    if (ctx->bsi.flags & AC3_BSI_LFEON && ab->lfeexpstr != AC3_EXPSTR_REUSE)

        if (_decode_exponents(ab->lfeexpstr, 2, ab->lfeexps[0], ab->lfeexps + 1, ab->dlfeexps))

            return -1;

    return 0;

}
 and probability:0.5
code:static void handle_pending_signal(CPUArchState *cpu_env, int sig,

                                  struct emulated_sigtable *k)

{

    CPUState *cpu = ENV_GET_CPU(cpu_env);

    abi_ulong handler;

    sigset_t set;

    target_sigset_t target_old_set;

    struct target_sigaction *sa;

    TaskState *ts = cpu->opaque;



    trace_user_handle_signal(cpu_env, sig);

    /* dequeue signal */

    k->pending = 0;



    sig = gdb_handlesig(cpu, sig);

    if (!sig) {

        sa = NULL;

        handler = TARGET_SIG_IGN;

    } else {

        sa = &sigact_table[sig - 1];

        handler = sa->_sa_handler;

    }



    if (do_strace) {

        print_taken_signal(sig, &k->info);

    }



    if (handler == TARGET_SIG_DFL) {

        /* default handler : ignore some signal. The other are job control or fatal */

        if (sig == TARGET_SIGTSTP || sig == TARGET_SIGTTIN || sig == TARGET_SIGTTOU) {

            kill(getpid(),SIGSTOP);

        } else if (sig != TARGET_SIGCHLD &&

                   sig != TARGET_SIGURG &&

                   sig != TARGET_SIGWINCH &&

                   sig != TARGET_SIGCONT) {

            force_sig(sig);

        }

    } else if (handler == TARGET_SIG_IGN) {

        /* ignore sig */

    } else if (handler == TARGET_SIG_ERR) {

        force_sig(sig);

    } else {

        /* compute the blocked signals during the handler execution */

        sigset_t *blocked_set;



        target_to_host_sigset(&set, &sa->sa_mask);

        /* SA_NODEFER indicates that the current signal should not be

           blocked during the handler */

        if (!(sa->sa_flags & TARGET_SA_NODEFER))

            sigaddset(&set, target_to_host_signal(sig));



        /* save the previous blocked signal state to restore it at the

           end of the signal execution (see do_sigreturn) */

        host_to_target_sigset_internal(&target_old_set, &ts->signal_mask);



        /* block signals in the handler */

        blocked_set = ts->in_sigsuspend ?

            &ts->sigsuspend_mask : &ts->signal_mask;

        sigorset(&ts->signal_mask, blocked_set, &set);

        ts->in_sigsuspend = 0;



        /* if the CPU is in VM86 mode, we restore the 32 bit values */

#if defined(TARGET_I386) && !defined(TARGET_X86_64)

        {

            CPUX86State *env = cpu_env;

            if (env->eflags & VM_MASK)

                save_v86_state(env);

        }

#endif

        /* prepare the stack frame of the virtual CPU */

#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \

    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)

        /* These targets do not have traditional signals.  */

        setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);

#else

        if (sa->sa_flags & TARGET_SA_SIGINFO)

            setup_rt_frame(sig, sa, &k->info, &target_old_set, cpu_env);

        else

            setup_frame(sig, sa, &target_old_set, cpu_env);

#endif

        if (sa->sa_flags & TARGET_SA_RESETHAND) {

            sa->_sa_handler = TARGET_SIG_DFL;

        }

    }

}
 and probability:0.23376623376623376
code:void block_job_yield(BlockJob *job)

{

    assert(job->busy);



    /* Check cancellation *before* setting busy = false, too!  */

    if (block_job_is_cancelled(job)) {

        return;

    }



    job->busy = false;

    if (!block_job_should_pause(job)) {

        qemu_coroutine_yield();

    }

    job->busy = true;



    block_job_pause_point(job);

}
 and probability:0.21428571428571427
code:static int udp_close(URLContext *h)

{

    UDPContext *s = h->priv_data;



    if (s->is_multicast && (h->flags & AVIO_FLAG_READ))

        udp_leave_multicast_group(s->udp_fd, (struct sockaddr *)&s->dest_addr,(struct sockaddr *)&s->local_addr_storage);

    closesocket(s->udp_fd);

#if HAVE_PTHREAD_CANCEL

    if (s->thread_started) {

        int ret;

        pthread_cancel(s->circular_buffer_thread);

        ret = pthread_join(s->circular_buffer_thread, NULL);

        if (ret != 0)

            av_log(h, AV_LOG_ERROR, "pthread_join(): %s\n", strerror(ret));

        pthread_mutex_destroy(&s->mutex);

        pthread_cond_destroy(&s->cond);

    }

#endif

    av_fifo_freep(&s->fifo);

    return 0;

}
 and probability:0.5
code:static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,

                      uint8_t (*layout_map)[3],

                      GetBitContext *gb, int byte_align_ref)

{

    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc;

    int sampling_index;

    int comment_len;

    int tags;



    skip_bits(gb, 2);  // object_type



    sampling_index = get_bits(gb, 4);

    if (m4ac->sampling_index != sampling_index)

        av_log(avctx, AV_LOG_WARNING,

               "Sample rate index in program config element does not "

               "match the sample rate index configured by the container.\n");



    num_front       = get_bits(gb, 4);

    num_side        = get_bits(gb, 4);

    num_back        = get_bits(gb, 4);

    num_lfe         = get_bits(gb, 2);

    num_assoc_data  = get_bits(gb, 3);

    num_cc          = get_bits(gb, 4);



    if (get_bits1(gb))

        skip_bits(gb, 4); // mono_mixdown_tag

    if (get_bits1(gb))

        skip_bits(gb, 4); // stereo_mixdown_tag



    if (get_bits1(gb))

        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround



    if (get_bits_left(gb) < 4 * (num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc)) {

        av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err);

        return -1;

    }

    decode_channel_map(layout_map       , AAC_CHANNEL_FRONT, gb, num_front);

    tags = num_front;

    decode_channel_map(layout_map + tags, AAC_CHANNEL_SIDE,  gb, num_side);

    tags += num_side;

    decode_channel_map(layout_map + tags, AAC_CHANNEL_BACK,  gb, num_back);

    tags += num_back;

    decode_channel_map(layout_map + tags, AAC_CHANNEL_LFE,   gb, num_lfe);

    tags += num_lfe;



    skip_bits_long(gb, 4 * num_assoc_data);



    decode_channel_map(layout_map + tags, AAC_CHANNEL_CC,    gb, num_cc);

    tags += num_cc;



    relative_align_get_bits(gb, byte_align_ref);



    /* comment field, first byte is length */

    comment_len = get_bits(gb, 8) * 8;

    if (get_bits_left(gb) < comment_len) {

        av_log(avctx, AV_LOG_ERROR, "decode_pce: " overread_err);

        return AVERROR_INVALIDDATA;

    }

    skip_bits_long(gb, comment_len);

    return tags;

}
 and probability:0.23529411764705882
code:void ff_decode_dxt1(const uint8_t *s, uint8_t *dst,

                    const unsigned int w, const unsigned int h,

                    const unsigned int stride) {

    unsigned int bx, by, qstride = stride/4;

    uint32_t *d = (uint32_t *) dst;



    for (by=0; by < h/4; by++, d += stride-w)

        for (bx=0; bx < w/4; bx++, s+=8, d+=4)

            dxt1_decode_pixels(s, d, qstride, 0, 0LL);

}
 and probability:0.3333333333333333
code:static const HWAccel *get_hwaccel(enum AVPixelFormat pix_fmt)

{

    int i;

    for (i = 0; hwaccels[i].name; i++)

        if (hwaccels[i].pix_fmt == pix_fmt)

            return &hwaccels[i];

    return NULL;

}
 and probability:0.375
code:static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    VirtIOPCIProxy *proxy = opaque;

    VirtIODevice *vdev = proxy->vdev;

    target_phys_addr_t pa;



    switch (addr) {

    case VIRTIO_PCI_GUEST_FEATURES:

	/* Guest does not negotiate properly?  We have to assume nothing. */

	if (val & (1 << VIRTIO_F_BAD_FEATURE)) {

	    if (vdev->bad_features)

		val = proxy->host_features & vdev->bad_features(vdev);

	    else

		val = 0;

	}

        if (vdev->set_features)

            vdev->set_features(vdev, val);

        vdev->guest_features = val;

        break;

    case VIRTIO_PCI_QUEUE_PFN:

        pa = (target_phys_addr_t)val << VIRTIO_PCI_QUEUE_ADDR_SHIFT;

        if (pa == 0) {

            virtio_pci_stop_ioeventfd(proxy);

            virtio_reset(proxy->vdev);

            msix_unuse_all_vectors(&proxy->pci_dev);

        }

        else

            virtio_queue_set_addr(vdev, vdev->queue_sel, pa);

        break;

    case VIRTIO_PCI_QUEUE_SEL:

        if (val < VIRTIO_PCI_QUEUE_MAX)

            vdev->queue_sel = val;

        break;

    case VIRTIO_PCI_QUEUE_NOTIFY:

        virtio_queue_notify(vdev, val);

        break;

    case VIRTIO_PCI_STATUS:

        if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {

            virtio_pci_stop_ioeventfd(proxy);

        }



        virtio_set_status(vdev, val & 0xFF);



        if (val & VIRTIO_CONFIG_S_DRIVER_OK) {

            virtio_pci_start_ioeventfd(proxy);

        }



        if (vdev->status == 0) {

            virtio_reset(proxy->vdev);

            msix_unuse_all_vectors(&proxy->pci_dev);

        }



        /* Linux before 2.6.34 sets the device as OK without enabling

           the PCI device bus master bit. In this case we need to disable

           some safety checks. */

        if ((val & VIRTIO_CONFIG_S_DRIVER_OK) &&

            !(proxy->pci_dev.config[PCI_COMMAND] & PCI_COMMAND_MASTER)) {

            proxy->flags |= VIRTIO_PCI_FLAG_BUS_MASTER_BUG;

        }

        break;

    case VIRTIO_MSI_CONFIG_VECTOR:

        msix_vector_unuse(&proxy->pci_dev, vdev->config_vector);

        /* Make it possible for guest to discover an error took place. */

        if (msix_vector_use(&proxy->pci_dev, val) < 0)

            val = VIRTIO_NO_VECTOR;

        vdev->config_vector = val;

        break;

    case VIRTIO_MSI_QUEUE_VECTOR:

        msix_vector_unuse(&proxy->pci_dev,

                          virtio_queue_vector(vdev, vdev->queue_sel));

        /* Make it possible for guest to discover an error took place. */

        if (msix_vector_use(&proxy->pci_dev, val) < 0)

            val = VIRTIO_NO_VECTOR;

        virtio_queue_set_vector(vdev, vdev->queue_sel, val);

        break;

    default:

        error_report("%s: unexpected address 0x%x value 0x%x",

                     __func__, addr, val);

        break;

    }

}
 and probability:0.2894736842105263
code:int ff_get_cpu_flags_x86(void)

{

    int rval = 0;



#ifdef cpuid



    int eax, ebx, ecx, edx;

    int max_std_level, max_ext_level, std_caps = 0, ext_caps = 0;

    int family = 0, model = 0;

    union { int i[3]; char c[12]; } vendor;



    if (!cpuid_test())

        return 0; /* CPUID not supported */



    cpuid(0, max_std_level, vendor.i[0], vendor.i[2], vendor.i[1]);



    if (max_std_level >= 1) {

        cpuid(1, eax, ebx, ecx, std_caps);

        family = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);

        model  = ((eax >> 4) & 0xf) + ((eax >> 12) & 0xf0);

        if (std_caps & (1 << 15))

            rval |= AV_CPU_FLAG_CMOV;

        if (std_caps & (1 << 23))

            rval |= AV_CPU_FLAG_MMX;

        if (std_caps & (1 << 25))

            rval |= AV_CPU_FLAG_MMXEXT;

#if HAVE_SSE

        if (std_caps & (1 << 25))

            rval |= AV_CPU_FLAG_SSE;

        if (std_caps & (1 << 26))

            rval |= AV_CPU_FLAG_SSE2;

        if (ecx & 1)

            rval |= AV_CPU_FLAG_SSE3;

        if (ecx & 0x00000200 )

            rval |= AV_CPU_FLAG_SSSE3;

        if (ecx & 0x00080000 )

            rval |= AV_CPU_FLAG_SSE4;

        if (ecx & 0x00100000 )

            rval |= AV_CPU_FLAG_SSE42;

#if HAVE_AVX

        /* Check OXSAVE and AVX bits */

        if ((ecx & 0x18000000) == 0x18000000) {

            /* Check for OS support */

            xgetbv(0, eax, edx);

            if ((eax & 0x6) == 0x6) {

                rval |= AV_CPU_FLAG_AVX;

                if (ecx & 0x00001000)

                    rval |= AV_CPU_FLAG_FMA3;

            }

        }

#endif /* HAVE_AVX */

#endif /* HAVE_SSE */

    }

    if (max_std_level >= 7) {

        cpuid(7, eax, ebx, ecx, edx);

#if HAVE_AVX2

        if (ebx & 0x00000020)

            rval |= AV_CPU_FLAG_AVX2;

#endif /* HAVE_AVX2 */

        /* BMI1/2 don't need OS support */

        if (ebx & 0x00000008) {

            rval |= AV_CPU_FLAG_BMI1;

            if (ebx & 0x00000100)

                rval |= AV_CPU_FLAG_BMI2;

        }

    }



    cpuid(0x80000000, max_ext_level, ebx, ecx, edx);



    if (max_ext_level >= 0x80000001) {

        cpuid(0x80000001, eax, ebx, ecx, ext_caps);

        if (ext_caps & (1U << 31))

            rval |= AV_CPU_FLAG_3DNOW;

        if (ext_caps & (1 << 30))

            rval |= AV_CPU_FLAG_3DNOWEXT;

        if (ext_caps & (1 << 23))

            rval |= AV_CPU_FLAG_MMX;

        if (ext_caps & (1 << 22))

            rval |= AV_CPU_FLAG_MMXEXT;



        /* Allow for selectively disabling SSE2 functions on AMD processors

           with SSE2 support but not SSE4a. This includes Athlon64, some

           Opteron, and some Sempron processors. MMX, SSE, or 3DNow! are faster

           than SSE2 often enough to utilize this special-case flag.

           AV_CPU_FLAG_SSE2 and AV_CPU_FLAG_SSE2SLOW are both set in this case

           so that SSE2 is used unless explicitly disabled by checking

           AV_CPU_FLAG_SSE2SLOW. */

        if (!strncmp(vendor.c, "AuthenticAMD", 12) &&

            rval & AV_CPU_FLAG_SSE2 && !(ecx & 0x00000040)) {

            rval |= AV_CPU_FLAG_SSE2SLOW;

        }



        /* XOP and FMA4 use the AVX instruction coding scheme, so they can't be

         * used unless the OS has AVX support. */

        if (rval & AV_CPU_FLAG_AVX) {

            if (ecx & 0x00000800)

                rval |= AV_CPU_FLAG_XOP;

            if (ecx & 0x00010000)

                rval |= AV_CPU_FLAG_FMA4;

        }

    }



    if (!strncmp(vendor.c, "GenuineIntel", 12)) {

        if (family == 6 && (model == 9 || model == 13 || model == 14)) {

            /* 6/9 (pentium-m "banias"), 6/13 (pentium-m "dothan"), and

             * 6/14 (core1 "yonah") theoretically support sse2, but it's

             * usually slower than mmx, so let's just pretend they don't.

             * AV_CPU_FLAG_SSE2 is disabled and AV_CPU_FLAG_SSE2SLOW is

             * enabled so that SSE2 is not used unless explicitly enabled

             * by checking AV_CPU_FLAG_SSE2SLOW. The same situation

             * applies for AV_CPU_FLAG_SSE3 and AV_CPU_FLAG_SSE3SLOW. */

            if (rval & AV_CPU_FLAG_SSE2)

                rval ^= AV_CPU_FLAG_SSE2SLOW | AV_CPU_FLAG_SSE2;

            if (rval & AV_CPU_FLAG_SSE3)

                rval ^= AV_CPU_FLAG_SSE3SLOW | AV_CPU_FLAG_SSE3;

        }

        /* The Atom processor has SSSE3 support, which is useful in many cases,

         * but sometimes the SSSE3 version is slower than the SSE2 equivalent

         * on the Atom, but is generally faster on other processors supporting

         * SSSE3. This flag allows for selectively disabling certain SSSE3

         * functions on the Atom. */

        if (family == 6 && model == 28)

            rval |= AV_CPU_FLAG_ATOM;

    }



#endif /* cpuid */



    return rval;

}
 and probability:0.02564102564102564
code:static int read_sl_header(PESContext *pes, SLConfigDescr *sl, const uint8_t *buf, int buf_size)

{

    GetBitContext gb;

    int au_start_flag = 0, au_end_flag = 0, ocr_flag = 0, idle_flag = 0;

    int padding_flag = 0, padding_bits = 0, inst_bitrate_flag = 0;

    int dts_flag = -1, cts_flag = -1;

    int64_t dts = AV_NOPTS_VALUE, cts = AV_NOPTS_VALUE;

    init_get_bits(&gb, buf, buf_size*8);



    if (sl->use_au_start)

        au_start_flag = get_bits1(&gb);

    if (sl->use_au_end)

        au_end_flag = get_bits1(&gb);

    if (!sl->use_au_start && !sl->use_au_end)

        au_start_flag = au_end_flag = 1;

    if (sl->ocr_len > 0)

        ocr_flag = get_bits1(&gb);

    if (sl->use_idle)

        idle_flag = get_bits1(&gb);

    if (sl->use_padding)

        padding_flag = get_bits1(&gb);

    if (padding_flag)

        padding_bits = get_bits(&gb, 3);



    if (!idle_flag && (!padding_flag || padding_bits != 0)) {

        if (sl->packet_seq_num_len)

            skip_bits_long(&gb, sl->packet_seq_num_len);

        if (sl->degr_prior_len)

            if (get_bits1(&gb))

                skip_bits(&gb, sl->degr_prior_len);

        if (ocr_flag)

            skip_bits_long(&gb, sl->ocr_len);

        if (au_start_flag) {

            if (sl->use_rand_acc_pt)

                get_bits1(&gb);

            if (sl->au_seq_num_len > 0)

                skip_bits_long(&gb, sl->au_seq_num_len);

            if (sl->use_timestamps) {

                dts_flag = get_bits1(&gb);

                cts_flag = get_bits1(&gb);

            }

        }

        if (sl->inst_bitrate_len)

            inst_bitrate_flag = get_bits1(&gb);

        if (dts_flag == 1)

            dts = get_bits64(&gb, sl->timestamp_len);

        if (cts_flag == 1)

            cts = get_bits64(&gb, sl->timestamp_len);

        if (sl->au_len > 0)

            skip_bits_long(&gb, sl->au_len);

        if (inst_bitrate_flag)

            skip_bits_long(&gb, sl->inst_bitrate_len);

    }



    if (dts != AV_NOPTS_VALUE)

        pes->dts = dts;

    if (cts != AV_NOPTS_VALUE)

        pes->pts = cts;



    avpriv_set_pts_info(pes->st, sl->timestamp_len, 1, sl->timestamp_res);



    return (get_bits_count(&gb) + 7) >> 3;

}
 and probability:0.4482758620689655
code:static enum AVHWDeviceType hw_device_match_type_in_name(const char *codec_name)

{

    const char *type_name;

    enum AVHWDeviceType type;

    for (type = av_hwdevice_iterate_types(AV_HWDEVICE_TYPE_NONE);

         type != AV_HWDEVICE_TYPE_NONE;

         type = av_hwdevice_iterate_types(type)) {

        type_name = av_hwdevice_get_type_name(type);

        if (strstr(codec_name, type_name))

            return type;

    }

    return AV_HWDEVICE_TYPE_NONE;

}
 and probability:0.0
code:static av_cold int encode_close(AVCodecContext* avc_context)

{

    TheoraContext *h = avc_context->priv_data;



    th_encode_free(h->t_state);

    av_freep(&h->stats);

    av_freep(&avc_context->coded_frame);

    av_freep(&avc_context->stats_out);

    av_freep(&avc_context->extradata);

    avc_context->extradata_size = 0;



    return 0;

}
 and probability:0.6363636363636364
code:static int vaapi_encode_h264_init_slice_params(AVCodecContext *avctx,

                                               VAAPIEncodePicture *pic,

                                               VAAPIEncodeSlice *slice)

{

    VAAPIEncodeContext                 *ctx = avctx->priv_data;

    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;

    VAEncPictureParameterBufferH264   *vpic = pic->codec_picture_params;

    VAEncSliceParameterBufferH264   *vslice = slice->codec_slice_params;

    VAAPIEncodeH264Context            *priv = ctx->priv_data;

    VAAPIEncodeH264Slice            *pslice;

    VAAPIEncodeH264MiscSliceParams  *mslice;

    int i;



    slice->priv_data = av_mallocz(sizeof(*pslice));

    if (!slice->priv_data)

        return AVERROR(ENOMEM);

    pslice = slice->priv_data;

    mslice = &pslice->misc_slice_params;



    if (pic->type == PICTURE_TYPE_IDR)

        mslice->nal_unit_type = H264_NAL_IDR_SLICE;

    else

        mslice->nal_unit_type = H264_NAL_SLICE;



    switch (pic->type) {

    case PICTURE_TYPE_IDR:

        vslice->slice_type  = SLICE_TYPE_I;

        mslice->nal_ref_idc = 3;

        break;

    case PICTURE_TYPE_I:

        vslice->slice_type  = SLICE_TYPE_I;

        mslice->nal_ref_idc = 2;

        break;

    case PICTURE_TYPE_P:

        vslice->slice_type  = SLICE_TYPE_P;

        mslice->nal_ref_idc = 1;

        break;

    case PICTURE_TYPE_B:

        vslice->slice_type  = SLICE_TYPE_B;

        mslice->nal_ref_idc = 0;

        break;

    default:

        av_assert0(0 && "invalid picture type");

    }



    // Only one slice per frame.

    vslice->macroblock_address = 0;

    vslice->num_macroblocks = priv->mb_width * priv->mb_height;



    vslice->macroblock_info = VA_INVALID_ID;



    vslice->pic_parameter_set_id = vpic->pic_parameter_set_id;

    vslice->idr_pic_id = priv->idr_pic_count++;



    vslice->pic_order_cnt_lsb = pic->display_order &

        ((1 << (4 + vseq->seq_fields.bits.log2_max_pic_order_cnt_lsb_minus4)) - 1);



    for (i = 0; i < FF_ARRAY_ELEMS(vslice->RefPicList0); i++) {

        vslice->RefPicList0[i].picture_id = VA_INVALID_ID;

        vslice->RefPicList0[i].flags      = VA_PICTURE_H264_INVALID;

        vslice->RefPicList1[i].picture_id = VA_INVALID_ID;

        vslice->RefPicList1[i].flags      = VA_PICTURE_H264_INVALID;

    }



    av_assert0(pic->nb_refs <= 2);

    if (pic->nb_refs >= 1) {

        // Backward reference for P- or B-frame.

        av_assert0(pic->type == PICTURE_TYPE_P ||

                   pic->type == PICTURE_TYPE_B);



        vslice->num_ref_idx_l0_active_minus1 = 0;

        vslice->RefPicList0[0] = vpic->ReferenceFrames[0];

    }

    if (pic->nb_refs >= 2) {

        // Forward reference for B-frame.

        av_assert0(pic->type == PICTURE_TYPE_B);



        vslice->num_ref_idx_l1_active_minus1 = 0;

        vslice->RefPicList1[0] = vpic->ReferenceFrames[1];

    }



    if (pic->type == PICTURE_TYPE_B)

        vslice->slice_qp_delta = priv->fixed_qp_b - vpic->pic_init_qp;

    else if (pic->type == PICTURE_TYPE_P)

        vslice->slice_qp_delta = priv->fixed_qp_p - vpic->pic_init_qp;

    else

        vslice->slice_qp_delta = priv->fixed_qp_idr - vpic->pic_init_qp;



    vslice->direct_spatial_mv_pred_flag = 1;



    return 0;

}
 and probability:0.6282051282051282
code:static char *assign_name(NetClientState *nc1, const char *model)

{

    NetClientState *nc;

    char buf[256];

    int id = 0;



    QTAILQ_FOREACH(nc, &net_clients, next) {

        if (nc == nc1) {

            continue;

        }

        /* For compatibility only bump id for net clients on a vlan */

        if (strcmp(nc->model, model) == 0 &&

            net_hub_id_for_client(nc, NULL) == 0) {

            id++;

        }

    }



    snprintf(buf, sizeof(buf), "%s.%d", model, id);



    return g_strdup(buf);

}
 and probability:0.1111111111111111
code:static void nbd_accept(void *opaque)

{

    int server_fd = (uintptr_t) opaque;

    struct sockaddr_in addr;

    socklen_t addr_len = sizeof(addr);



    int fd = accept(server_fd, (struct sockaddr *)&addr, &addr_len);

    nbd_started = true;

    if (fd >= 0 && nbd_client_new(exp, fd, nbd_client_closed)) {

        nb_fds++;

    }

}
 and probability:0.09090909090909091
code:static void dma_init2(struct dma_cont *d, int base, int dshift,

                      int page_base, int pageh_base,

                      qemu_irq *cpu_request_exit)

{

    int i;



    d->dshift = dshift;

    d->cpu_request_exit = cpu_request_exit;



    memory_region_init_io(&d->channel_io, NULL, &channel_io_ops, d,

                          "dma-chan", 8 << d->dshift);

    memory_region_add_subregion(isa_address_space_io(NULL),

                                base, &d->channel_io);



    isa_register_portio_list(NULL, page_base, page_portio_list, d,

                             "dma-page");

    if (pageh_base >= 0) {

        isa_register_portio_list(NULL, pageh_base, pageh_portio_list, d,

                                 "dma-pageh");

    }



    memory_region_init_io(&d->cont_io, NULL, &cont_io_ops, d, "dma-cont",

                          8 << d->dshift);

    memory_region_add_subregion(isa_address_space_io(NULL),

                                base + (8 << d->dshift), &d->cont_io);



    qemu_register_reset(dma_reset, d);

    dma_reset(d);

    for (i = 0; i < ARRAY_SIZE (d->regs); ++i) {

        d->regs[i].transfer_handler = dma_phony_handler;

    }

}
 and probability:0.37037037037037035
code:static inline bool migration_bitmap_test_and_reset_dirty(MemoryRegion *mr,

                                                         ram_addr_t offset)

{

    bool ret;

    int nr = (mr->ram_addr + offset) >> TARGET_PAGE_BITS;



    ret = test_and_clear_bit(nr, migration_bitmap);



    if (ret) {

        migration_dirty_pages--;

    }

    return ret;

}
 and probability:0.18181818181818182
code:static inline void gen_op_eval_bge(TCGv dst, TCGv_i32 src)

{

    gen_mov_reg_V(cpu_tmp0, src);

    gen_mov_reg_N(dst, src);

    tcg_gen_xor_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
 and probability:0.0
code:static int qcow_set_key(BlockDriverState *bs, const char *key)

{

    BDRVQcowState *s = bs->opaque;

    uint8_t keybuf[16];

    int len, i;

    Error *err;



    memset(keybuf, 0, 16);

    len = strlen(key);

    if (len > 16)

        len = 16;

    /* XXX: we could compress the chars to 7 bits to increase

       entropy */

    for(i = 0;i < len;i++) {

        keybuf[i] = key[i];

    }

    assert(bs->encrypted);



    qcrypto_cipher_free(s->cipher);

    s->cipher = qcrypto_cipher_new(

        QCRYPTO_CIPHER_ALG_AES_128,

        QCRYPTO_CIPHER_MODE_CBC,

        keybuf, G_N_ELEMENTS(keybuf),

        &err);



    if (!s->cipher) {

        /* XXX would be nice if errors in this method could

         * be properly propagate to the caller. Would need

         * the bdrv_set_key() API signature to be fixed. */

        error_free(err);

        return -1;

    }

    return 0;

}
 and probability:0.25806451612903225
code:int vhost_dev_init(struct vhost_dev *hdev, int devfd, const char *devpath,

                   bool force)

{

    uint64_t features;

    int r;

    if (devfd >= 0) {

        hdev->control = devfd;

    } else {

        hdev->control = open(devpath, O_RDWR);

        if (hdev->control < 0) {

            return -errno;

        }

    }

    r = ioctl(hdev->control, VHOST_SET_OWNER, NULL);

    if (r < 0) {

        goto fail;

    }



    r = ioctl(hdev->control, VHOST_GET_FEATURES, &features);

    if (r < 0) {

        goto fail;

    }

    hdev->features = features;



    hdev->memory_listener = (MemoryListener) {

        .begin = vhost_begin,

        .commit = vhost_commit,

        .region_add = vhost_region_add,

        .region_del = vhost_region_del,

        .region_nop = vhost_region_nop,

        .log_start = vhost_log_start,

        .log_stop = vhost_log_stop,

        .log_sync = vhost_log_sync,

        .log_global_start = vhost_log_global_start,

        .log_global_stop = vhost_log_global_stop,

        .eventfd_add = vhost_eventfd_add,

        .eventfd_del = vhost_eventfd_del,

        .priority = 10

    };

    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));

    hdev->n_mem_sections = 0;

    hdev->mem_sections = NULL;

    hdev->log = NULL;

    hdev->log_size = 0;

    hdev->log_enabled = false;

    hdev->started = false;

    memory_listener_register(&hdev->memory_listener, NULL);

    hdev->force = force;

    return 0;

fail:

    r = -errno;

    close(hdev->control);

    return r;

}
 and probability:0.3269230769230769
code:static void fw_cfg_mem_realize(DeviceState *dev, Error **errp)

{

    FWCfgMemState *s = FW_CFG_MEM(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);



    memory_region_init_io(&s->ctl_iomem, OBJECT(s), &fw_cfg_ctl_mem_ops,

                          FW_CFG(s), "fwcfg.ctl", FW_CFG_SIZE);

    sysbus_init_mmio(sbd, &s->ctl_iomem);



    memory_region_init_io(&s->data_iomem, OBJECT(s), &fw_cfg_data_mem_ops,

                          FW_CFG(s), "fwcfg.data",

                          fw_cfg_data_mem_ops.valid.max_access_size);

    sysbus_init_mmio(sbd, &s->data_iomem);

}
 and probability:0.3333333333333333
code:static void hls_prediction_unit(HEVCContext *s, int x0, int y0,

                                int nPbW, int nPbH,

                                int log2_cb_size, int partIdx)

{

#define POS(c_idx, x, y)                                                              \

    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \

                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]

    HEVCLocalContext *lc = &s->HEVClc;

    int merge_idx = 0;

    struct MvField current_mv = {{{ 0 }}};



    int min_pu_width = s->sps->min_pu_width;



    MvField *tab_mvf = s->ref->tab_mvf;

    RefPicList  *refPicList = s->ref->refPicList;

    HEVCFrame *ref0, *ref1;



    int tmpstride = MAX_PB_SIZE;



    uint8_t *dst0 = POS(0, x0, y0);

    uint8_t *dst1 = POS(1, x0, y0);

    uint8_t *dst2 = POS(2, x0, y0);

    int log2_min_cb_size = s->sps->log2_min_cb_size;

    int min_cb_width     = s->sps->min_cb_width;

    int x_cb             = x0 >> log2_min_cb_size;

    int y_cb             = y0 >> log2_min_cb_size;

    int x_pu, y_pu;

    int i, j;



    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);



    if (!skip_flag)

        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);



    if (skip_flag || lc->pu.merge_flag) {

        if (s->sh.max_num_merge_cand > 1)

            merge_idx = ff_hevc_merge_idx_decode(s);

        else

            merge_idx = 0;



        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,

                                   partIdx, merge_idx, &current_mv);

    } else {

        enum InterPredIdc inter_pred_idc = PRED_L0;

        int mvp_flag;



        ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);

        if (s->sh.slice_type == B_SLICE)

            inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH);



        if (inter_pred_idc != PRED_L1) {

            if (s->sh.nb_refs[L0]) {

                current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]);

            }

            current_mv.pred_flag[0] = 1;

            hls_mvd_coding(s, x0, y0, 0);

            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);

            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,

                                     partIdx, merge_idx, &current_mv,

                                     mvp_flag, 0);

            current_mv.mv[0].x += lc->pu.mvd.x;

            current_mv.mv[0].y += lc->pu.mvd.y;

        }



        if (inter_pred_idc != PRED_L0) {

            if (s->sh.nb_refs[L1]) {

                current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]);

            }



            if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) {

                AV_ZERO32(&lc->pu.mvd);

            } else {

                hls_mvd_coding(s, x0, y0, 1);

            }



            current_mv.pred_flag[1] = 1;

            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);

            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,

                                     partIdx, merge_idx, &current_mv,

                                     mvp_flag, 1);

            current_mv.mv[1].x += lc->pu.mvd.x;

            current_mv.mv[1].y += lc->pu.mvd.y;

        }

    }



    x_pu = x0 >> s->sps->log2_min_pu_size;

    y_pu = y0 >> s->sps->log2_min_pu_size;



    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)

        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)

            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;



    if (current_mv.pred_flag[0]) {

        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];

        if (!ref0)

            return;

        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);

    }

    if (current_mv.pred_flag[1]) {

        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];

        if (!ref1)

            return;

        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);

    }



    if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) {

        DECLARE_ALIGNED(16, int16_t,  tmp[MAX_PB_SIZE * MAX_PB_SIZE]);

        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);



        luma_mc(s, tmp, tmpstride, ref0->frame,

                &current_mv.mv[0], x0, y0, nPbW, nPbH);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,

                                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],

                                     s->sh.luma_offset_l0[current_mv.ref_idx[0]],

                                     dst0, s->frame->linesize[0], tmp,

                                     tmpstride, nPbW, nPbH);

        } else {

            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);

        }

        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,

                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,

                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],

                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],

                                     dst1, s->frame->linesize[1], tmp, tmpstride,

                                     nPbW / 2, nPbH / 2);

            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,

                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],

                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],

                                     dst2, s->frame->linesize[2], tmp2, tmpstride,

                                     nPbW / 2, nPbH / 2);

        } else {

            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);

            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);

        }

    } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) {

        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);

        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);



        if (!ref1)

            return;



        luma_mc(s, tmp, tmpstride, ref1->frame,

                &current_mv.mv[1], x0, y0, nPbW, nPbH);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,

                                      s->sh.luma_weight_l1[current_mv.ref_idx[1]],

                                      s->sh.luma_offset_l1[current_mv.ref_idx[1]],

                                      dst0, s->frame->linesize[0], tmp, tmpstride,

                                      nPbW, nPbH);

        } else {

            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);

        }



        chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame,

                  &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,

                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],

                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],

                                     dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);

            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,

                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],

                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],

                                     dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);

        } else {

            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);

            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);

        }

    } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) {

        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);

        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);

        DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]);

        DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]);

        HEVCFrame *ref0 = refPicList[0].ref[current_mv.ref_idx[0]];

        HEVCFrame *ref1 = refPicList[1].ref[current_mv.ref_idx[1]];



        if (!ref0 || !ref1)

            return;



        luma_mc(s, tmp, tmpstride, ref0->frame,

                &current_mv.mv[0], x0, y0, nPbW, nPbH);

        luma_mc(s, tmp2, tmpstride, ref1->frame,

                &current_mv.mv[1], x0, y0, nPbW, nPbH);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom,

                                         s->sh.luma_weight_l0[current_mv.ref_idx[0]],

                                         s->sh.luma_weight_l1[current_mv.ref_idx[1]],

                                         s->sh.luma_offset_l0[current_mv.ref_idx[0]],

                                         s->sh.luma_offset_l1[current_mv.ref_idx[1]],

                                         dst0, s->frame->linesize[0],

                                         tmp, tmp2, tmpstride, nPbW, nPbH);

        } else {

            s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0],

                                             tmp, tmp2, tmpstride, nPbW, nPbH);

        }



        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,

                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);

        chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame,

                  &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);



        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||

            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {

            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,

                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],

                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],

                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],

                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],

                                         dst1, s->frame->linesize[1], tmp, tmp3,

                                         tmpstride, nPbW / 2, nPbH / 2);

            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,

                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],

                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],

                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],

                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],

                                         dst2, s->frame->linesize[2], tmp2, tmp4,

                                         tmpstride, nPbW / 2, nPbH / 2);

        } else {

            s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2);

            s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2);

        }

    }

}
 and probability:0.6359223300970874
code:static void select_soundhw (const char *optarg)

{

    struct soundhw *c;



    if (*optarg == '?') {

    show_valid_cards:



        printf ("Valid sound card names (comma separated):\n");

        for (c = soundhw; c->name; ++c) {

            printf ("%-11s %s\n", c->name, c->descr);

        }

        printf ("\n-soundhw all will enable all of the above\n");

        exit (*optarg != '?');

    }

    else {

        size_t l;

        const char *p;

        char *e;

        int bad_card = 0;



        if (!strcmp (optarg, "all")) {

            for (c = soundhw; c->name; ++c) {

                c->enabled = 1;

            }

            return;

        }



        p = optarg;

        while (*p) {

            e = strchr (p, ',');

            l = !e ? strlen (p) : (size_t) (e - p);



            for (c = soundhw; c->name; ++c) {

                if (!strncmp (c->name, p, l) && !c->name[l]) {

                    c->enabled = 1;

                    break;

                }

            }



            if (!c->name) {

                if (l > 80) {

                    fprintf (stderr,

                             "Unknown sound card name (too big to show)\n");

                }

                else {

                    fprintf (stderr, "Unknown sound card name `%.*s'\n",

                             (int) l, p);

                }

                bad_card = 1;

            }

            p += l + (e != NULL);

        }



        if (bad_card)

            goto show_valid_cards;

    }

}
 and probability:0.26
code:void ide_bus_reset(IDEBus *bus)

{

    bus->unit = 0;

    bus->cmd = 0;

    ide_reset(&bus->ifs[0]);

    ide_reset(&bus->ifs[1]);

    ide_clear_hob(bus);



    /* pending async DMA */

    if (bus->dma->aiocb) {

#ifdef DEBUG_AIO

        printf("aio_cancel\n");

#endif

        bdrv_aio_cancel(bus->dma->aiocb);

        bus->dma->aiocb = NULL;

    }



    /* reset dma provider too */

    if (bus->dma->ops->reset) {

        bus->dma->ops->reset(bus->dma);

    }

}
 and probability:0.45
code:if_start(void)

{

	struct mbuf *ifm, *ifqt;



	DEBUG_CALL("if_start");



	if (if_queued == 0)

	   return; /* Nothing to do */



 again:

        /* check if we can really output */

        if (!slirp_can_output())

            return;



	/*

	 * See which queue to get next packet from

	 * If there's something in the fastq, select it immediately

	 */

	if (if_fastq.ifq_next != &if_fastq) {

		ifm = if_fastq.ifq_next;

	} else {

		/* Nothing on fastq, see if next_m is valid */

		if (next_m != &if_batchq)

		   ifm = next_m;

		else

		   ifm = if_batchq.ifq_next;



		/* Set which packet to send on next iteration */

		next_m = ifm->ifq_next;

	}

	/* Remove it from the queue */

	ifqt = ifm->ifq_prev;

	remque(ifm);

	--if_queued;



	/* If there are more packets for this session, re-queue them */

	if (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {

		insque(ifm->ifs_next, ifqt);

		ifs_remque(ifm);

	}



	/* Update so_queued */

	if (ifm->ifq_so) {

		if (--ifm->ifq_so->so_queued == 0)

		   /* If there's no more queued, reset nqueued */

		   ifm->ifq_so->so_nqueued = 0;

	}



	/* Encapsulate the packet for sending */

        if_encap(ifm->m_data, ifm->m_len);



        m_free(ifm);



	if (if_queued)

	   goto again;

}
 and probability:0.1956521739130435
code:MacIONVRAMState *macio_nvram_init (target_phys_addr_t size,

                                   unsigned int it_shift)

{

    MacIONVRAMState *s;



    s = g_malloc0(sizeof(MacIONVRAMState));

    s->data = g_malloc0(size);

    s->size = size;

    s->it_shift = it_shift;



    memory_region_init_io(&s->mem, &macio_nvram_ops, s, "macio-nvram",

                          size << it_shift);

    vmstate_register(NULL, -1, &vmstate_macio_nvram, s);

    qemu_register_reset(macio_nvram_reset, s);



    return s;

}
 and probability:0.2857142857142857
code:static void cmd646_data_write(void *opaque, target_phys_addr_t addr,

                             uint64_t data, unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (size == 1) {

        ide_ioport_write(cmd646bar->bus, addr, data);

    } else if (addr == 0) {

        if (size == 2) {

            ide_data_writew(cmd646bar->bus, addr, data);

        } else {

            ide_data_writel(cmd646bar->bus, addr, data);

        }

    }

}
 and probability:0.21428571428571427
code:static uint64_t kvm_apic_mem_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    return ~(uint64_t)0;

}
 and probability:0.0
code:static uint64_t bonito_cop_readl(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    uint32_t val;

    PCIBonitoState *s = opaque;



    val = ((uint32_t *)(&s->boncop))[addr/sizeof(uint32_t)];



    return val;

}
 and probability:0.125
code:size_t iov_memset(const struct iovec *iov, const unsigned int iov_cnt,

                 size_t iov_off, int fillc, size_t size)

{

    size_t iovec_off, buf_off;

    unsigned int i;



    iovec_off = 0;

    buf_off = 0;

    for (i = 0; i < iov_cnt && size; i++) {

        if (iov_off < (iovec_off + iov[i].iov_len)) {

            size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);



            memset(iov[i].iov_base + (iov_off - iovec_off), fillc, len);



            buf_off += len;

            iov_off += len;

            size -= len;

        }

        iovec_off += iov[i].iov_len;

    }

    return buf_off;

}
 and probability:0.42105263157894735
code:static int img_open_password(BlockBackend *blk, const char *filename,

                             int flags, bool quiet)

{

    BlockDriverState *bs;

    char password[256];



    bs = blk_bs(blk);

    if (bdrv_is_encrypted(bs) && !(flags & BDRV_O_NO_IO)) {

        qprintf(quiet, "Disk image '%s' is encrypted.\n", filename);

        if (qemu_read_password(password, sizeof(password)) < 0) {

            error_report("No password given");

            return -1;

        }

        if (bdrv_set_key(bs, password) < 0) {

            error_report("invalid password");

            return -1;

        }

    }

    return 0;

}
 and probability:0.0
code:void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)

{

    const char *codec_name;

    AVCodec *p;

    char buf1[32];

    int bitrate;

    AVRational display_aspect_ratio;



    if (encode)

        p = avcodec_find_encoder(enc->codec_id);

    else

        p = avcodec_find_decoder(enc->codec_id);



    if (p) {

        codec_name = p->name;

        if (!encode && enc->codec_id == CODEC_ID_MP3) {

            if (enc->sub_id == 2)

                codec_name = "mp2";

            else if (enc->sub_id == 1)

                codec_name = "mp1";

        }

    } else if (enc->codec_id == CODEC_ID_MPEG2TS) {

        /* fake mpeg2 transport stream codec (currently not

           registered) */

        codec_name = "mpeg2ts";

    } else if (enc->codec_name[0] != '\0') {

        codec_name = enc->codec_name;

    } else {

        /* output avi tags */

        if(   isprint(enc->codec_tag&0xFF) && isprint((enc->codec_tag>>8)&0xFF)

           && isprint((enc->codec_tag>>16)&0xFF) && isprint((enc->codec_tag>>24)&0xFF)){

            snprintf(buf1, sizeof(buf1), "%c%c%c%c / 0x%04X",

                     enc->codec_tag & 0xff,

                     (enc->codec_tag >> 8) & 0xff,

                     (enc->codec_tag >> 16) & 0xff,

                     (enc->codec_tag >> 24) & 0xff,

                      enc->codec_tag);

        } else {

            snprintf(buf1, sizeof(buf1), "0x%04x", enc->codec_tag);

        }

        codec_name = buf1;

    }



    switch(enc->codec_type) {

    case CODEC_TYPE_VIDEO:

        snprintf(buf, buf_size,

                 "Video: %s%s",

                 codec_name, enc->mb_decision ? " (hq)" : "");

        if (enc->pix_fmt != PIX_FMT_NONE) {

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", %s",

                     avcodec_get_pix_fmt_name(enc->pix_fmt));

        }

        if (enc->width) {

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", %dx%d",

                     enc->width, enc->height);

            if (enc->sample_aspect_ratio.num) {

                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,

                          enc->width*enc->sample_aspect_ratio.num,

                          enc->height*enc->sample_aspect_ratio.den,

                          1024*1024);

                snprintf(buf + strlen(buf), buf_size - strlen(buf),

                         " [PAR %d:%d DAR %d:%d]",

                         enc->sample_aspect_ratio.num, enc->sample_aspect_ratio.den,

                         display_aspect_ratio.num, display_aspect_ratio.den);

            }

            if(av_log_get_level() >= AV_LOG_DEBUG){

                int g= ff_gcd(enc->time_base.num, enc->time_base.den);

                snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", %d/%d",

                     enc->time_base.num/g, enc->time_base.den/g);

            }

        }

        if (encode) {

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", q=%d-%d", enc->qmin, enc->qmax);

        }

        bitrate = enc->bit_rate;

        break;

    case CODEC_TYPE_AUDIO:

        snprintf(buf, buf_size,

                 "Audio: %s",

                 codec_name);

        if (enc->sample_rate) {

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", %d Hz", enc->sample_rate);

        }

        av_strlcat(buf, ", ", buf_size);

        avcodec_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);

        if (enc->sample_fmt != SAMPLE_FMT_NONE) {

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", %s", avcodec_get_sample_fmt_name(enc->sample_fmt));

        }



        /* for PCM codecs, compute bitrate directly */

        switch(enc->codec_id) {

        case CODEC_ID_PCM_F64BE:

        case CODEC_ID_PCM_F64LE:

            bitrate = enc->sample_rate * enc->channels * 64;

            break;

        case CODEC_ID_PCM_S32LE:

        case CODEC_ID_PCM_S32BE:

        case CODEC_ID_PCM_U32LE:

        case CODEC_ID_PCM_U32BE:

        case CODEC_ID_PCM_F32BE:

        case CODEC_ID_PCM_F32LE:

            bitrate = enc->sample_rate * enc->channels * 32;

            break;

        case CODEC_ID_PCM_S24LE:

        case CODEC_ID_PCM_S24BE:

        case CODEC_ID_PCM_U24LE:

        case CODEC_ID_PCM_U24BE:

        case CODEC_ID_PCM_S24DAUD:

            bitrate = enc->sample_rate * enc->channels * 24;

            break;

        case CODEC_ID_PCM_S16LE:

        case CODEC_ID_PCM_S16BE:

        case CODEC_ID_PCM_S16LE_PLANAR:

        case CODEC_ID_PCM_U16LE:

        case CODEC_ID_PCM_U16BE:

            bitrate = enc->sample_rate * enc->channels * 16;

            break;

        case CODEC_ID_PCM_S8:

        case CODEC_ID_PCM_U8:

        case CODEC_ID_PCM_ALAW:

        case CODEC_ID_PCM_MULAW:

        case CODEC_ID_PCM_ZORK:

            bitrate = enc->sample_rate * enc->channels * 8;

            break;

        default:

            bitrate = enc->bit_rate;

            break;

        }

        break;

    case CODEC_TYPE_DATA:

        snprintf(buf, buf_size, "Data: %s", codec_name);

        bitrate = enc->bit_rate;

        break;

    case CODEC_TYPE_SUBTITLE:

        snprintf(buf, buf_size, "Subtitle: %s", codec_name);

        bitrate = enc->bit_rate;

        break;

    case CODEC_TYPE_ATTACHMENT:

        snprintf(buf, buf_size, "Attachment: %s", codec_name);

        bitrate = enc->bit_rate;

        break;

    default:

        snprintf(buf, buf_size, "Invalid Codec type %d", enc->codec_type);

        return;

    }

    if (encode) {

        if (enc->flags & CODEC_FLAG_PASS1)

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", pass 1");

        if (enc->flags & CODEC_FLAG_PASS2)

            snprintf(buf + strlen(buf), buf_size - strlen(buf),

                     ", pass 2");

    }

    if (bitrate != 0) {

        snprintf(buf + strlen(buf), buf_size - strlen(buf),

                 ", %d kb/s", bitrate / 1000);

    }

}
 and probability:0.38125
code:static int transcode_init(OutputFile *output_files,

                          int nb_output_files,

                          InputFile *input_files,

                          int nb_input_files)

{

    int ret = 0, i, j;

    AVFormatContext *os;

    AVCodecContext *codec, *icodec;

    OutputStream *ost;

    InputStream *ist;

    char error[1024];

    int want_sdp = 1;



    /* init framerate emulation */

    for (i = 0; i < nb_input_files; i++) {

        InputFile *ifile = &input_files[i];

        if (ifile->rate_emu)

            for (j = 0; j < ifile->nb_streams; j++)

                input_streams[j + ifile->ist_index].start = av_gettime();

    }



    /* output stream init */

    for(i=0;i<nb_output_files;i++) {

        os = output_files[i].ctx;

        if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {

            av_dump_format(os, i, os->filename, 1);

            fprintf(stderr, "Output file #%d does not contain any stream\n", i);

            return AVERROR(EINVAL);

        }

    }



    /* for each output stream, we compute the right encoding parameters */

    for (i = 0; i < nb_output_streams; i++) {

        ost = &output_streams[i];

        os = output_files[ost->file_index].ctx;

        ist = &input_streams[ost->source_index];



        codec = ost->st->codec;

        icodec = ist->st->codec;



        ost->st->disposition = ist->st->disposition;

        codec->bits_per_raw_sample= icodec->bits_per_raw_sample;

        codec->chroma_sample_location = icodec->chroma_sample_location;



        if (ost->st->stream_copy) {

            uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;



            if (extra_size > INT_MAX) {

                return AVERROR(EINVAL);

            }



            /* if stream_copy is selected, no need to decode or encode */

            codec->codec_id = icodec->codec_id;

            codec->codec_type = icodec->codec_type;



            if(!codec->codec_tag){

                if(   !os->oformat->codec_tag

                   || av_codec_get_id (os->oformat->codec_tag, icodec->codec_tag) == codec->codec_id

                   || av_codec_get_tag(os->oformat->codec_tag, icodec->codec_id) <= 0)

                    codec->codec_tag = icodec->codec_tag;

            }



            codec->bit_rate = icodec->bit_rate;

            codec->rc_max_rate    = icodec->rc_max_rate;

            codec->rc_buffer_size = icodec->rc_buffer_size;

            codec->extradata= av_mallocz(extra_size);

            if (!codec->extradata) {

                return AVERROR(ENOMEM);

            }

            memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);

            codec->extradata_size= icodec->extradata_size;

            if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){

                codec->time_base = icodec->time_base;

                codec->time_base.num *= icodec->ticks_per_frame;

                av_reduce(&codec->time_base.num, &codec->time_base.den,

                          codec->time_base.num, codec->time_base.den, INT_MAX);

            }else

                codec->time_base = ist->st->time_base;

            switch(codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                if(audio_volume != 256) {

                    fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");

                    exit_program(1);

                }

                codec->channel_layout = icodec->channel_layout;

                codec->sample_rate = icodec->sample_rate;

                codec->channels = icodec->channels;

                codec->frame_size = icodec->frame_size;

                codec->audio_service_type = icodec->audio_service_type;

                codec->block_align= icodec->block_align;

                if(codec->block_align == 1 && codec->codec_id == CODEC_ID_MP3)

                    codec->block_align= 0;

                if(codec->codec_id == CODEC_ID_AC3)

                    codec->block_align= 0;

                break;

            case AVMEDIA_TYPE_VIDEO:

                codec->pix_fmt = icodec->pix_fmt;

                codec->width = icodec->width;

                codec->height = icodec->height;

                codec->has_b_frames = icodec->has_b_frames;

                if (!codec->sample_aspect_ratio.num) {

                    codec->sample_aspect_ratio =

                    ost->st->sample_aspect_ratio =

                        ist->st->sample_aspect_ratio.num ? ist->st->sample_aspect_ratio :

                        ist->st->codec->sample_aspect_ratio.num ?

                        ist->st->codec->sample_aspect_ratio : (AVRational){0, 1};

                }

                break;

            case AVMEDIA_TYPE_SUBTITLE:

                codec->width = icodec->width;

                codec->height = icodec->height;

                break;

            case AVMEDIA_TYPE_DATA:

                break;

            default:

                abort();

            }

        } else {

            if (!ost->enc)

                ost->enc = avcodec_find_encoder(ost->st->codec->codec_id);

            switch(codec->codec_type) {

            case AVMEDIA_TYPE_AUDIO:

                ost->fifo= av_fifo_alloc(1024);

                if (!ost->fifo) {

                    return AVERROR(ENOMEM);

                }

                ost->reformat_pair = MAKE_SFMT_PAIR(AV_SAMPLE_FMT_NONE,AV_SAMPLE_FMT_NONE);

                if (!codec->sample_rate) {

                    codec->sample_rate = icodec->sample_rate;

                    if (icodec->lowres)

                        codec->sample_rate >>= icodec->lowres;

                }

                choose_sample_rate(ost->st, ost->enc);

                codec->time_base = (AVRational){1, codec->sample_rate};

                if (codec->sample_fmt == AV_SAMPLE_FMT_NONE)

                    codec->sample_fmt = icodec->sample_fmt;

                choose_sample_fmt(ost->st, ost->enc);

                if (!codec->channels)

                    codec->channels = icodec->channels;

                codec->channel_layout = icodec->channel_layout;

                if (av_get_channel_layout_nb_channels(codec->channel_layout) != codec->channels)

                    codec->channel_layout = 0;

                ost->audio_resample = codec->sample_rate != icodec->sample_rate || audio_sync_method > 1;

                icodec->request_channels = codec->channels;

                ist->decoding_needed = 1;

                ost->encoding_needed = 1;

                ost->resample_sample_fmt  = icodec->sample_fmt;

                ost->resample_sample_rate = icodec->sample_rate;

                ost->resample_channels    = icodec->channels;

                break;

            case AVMEDIA_TYPE_VIDEO:

                if (codec->pix_fmt == PIX_FMT_NONE)

                    codec->pix_fmt = icodec->pix_fmt;

                choose_pixel_fmt(ost->st, ost->enc);



                if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {

                    fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");

                    exit_program(1);

                }



                if (!codec->width || !codec->height) {

                    codec->width  = icodec->width;

                    codec->height = icodec->height;

                }



                ost->video_resample = codec->width   != icodec->width  ||

                                      codec->height  != icodec->height ||

                                      codec->pix_fmt != icodec->pix_fmt;

                if (ost->video_resample) {

#if !CONFIG_AVFILTER

                    avcodec_get_frame_defaults(&ost->pict_tmp);

                    if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,

                                       codec->width, codec->height)) {

                        fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");

                        exit_program(1);

                    }

                    ost->img_resample_ctx = sws_getContext(

                        icodec->width,

                        icodec->height,

                        icodec->pix_fmt,

                        codec->width,

                        codec->height,

                        codec->pix_fmt,

                        ost->sws_flags, NULL, NULL, NULL);

                    if (ost->img_resample_ctx == NULL) {

                        fprintf(stderr, "Cannot get resampling context\n");

                        exit_program(1);

                    }

#endif

                    codec->bits_per_raw_sample= 0;

                }



                ost->resample_height = icodec->height;

                ost->resample_width  = icodec->width;

                ost->resample_pix_fmt= icodec->pix_fmt;

                ost->encoding_needed = 1;

                ist->decoding_needed = 1;



                if (!ost->frame_rate.num)

                    ost->frame_rate = ist->st->r_frame_rate.num ? ist->st->r_frame_rate : (AVRational){25,1};

                if (ost->enc && ost->enc->supported_framerates && !force_fps) {

                    int idx = av_find_nearest_q_idx(ost->frame_rate, ost->enc->supported_framerates);

                    ost->frame_rate = ost->enc->supported_framerates[idx];

                }

                codec->time_base = (AVRational){ost->frame_rate.den, ost->frame_rate.num};



#if CONFIG_AVFILTER

                if (configure_video_filters(ist, ost)) {

                    fprintf(stderr, "Error opening filters!\n");

                    exit(1);

                }

#endif

                break;

            case AVMEDIA_TYPE_SUBTITLE:

                ost->encoding_needed = 1;

                ist->decoding_needed = 1;

                break;

            default:

                abort();

                break;

            }

            /* two pass mode */

            if (ost->encoding_needed &&

                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {

                char logfilename[1024];

                FILE *f;



                snprintf(logfilename, sizeof(logfilename), "%s-%d.log",

                         pass_logfilename_prefix ? pass_logfilename_prefix : DEFAULT_PASS_LOGFILENAME_PREFIX,

                         i);

                if (codec->flags & CODEC_FLAG_PASS1) {

                    f = fopen(logfilename, "wb");

                    if (!f) {

                        fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));

                        exit_program(1);

                    }

                    ost->logfile = f;

                } else {

                    char  *logbuffer;

                    size_t logbuffer_size;

                    if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {

                        fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);

                        exit_program(1);

                    }

                    codec->stats_in = logbuffer;

                }

            }

        }

        if(codec->codec_type == AVMEDIA_TYPE_VIDEO){

            int size= codec->width * codec->height;

            bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 200);

        }

    }



    if (!bit_buffer)

        bit_buffer = av_malloc(bit_buffer_size);

    if (!bit_buffer) {

        fprintf(stderr, "Cannot allocate %d bytes output buffer\n",

                bit_buffer_size);

        return AVERROR(ENOMEM);

    }



    /* open each encoder */

    for (i = 0; i < nb_output_streams; i++) {

        ost = &output_streams[i];

        if (ost->encoding_needed) {

            AVCodec *codec = ost->enc;

            AVCodecContext *dec = input_streams[ost->source_index].st->codec;

            if (!codec) {

                snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",

                         ost->st->codec->codec_id, ost->file_index, ost->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            if (dec->subtitle_header) {

                ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);

                if (!ost->st->codec->subtitle_header) {

                    ret = AVERROR(ENOMEM);

                    goto dump_format;

                }

                memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);

                ost->st->codec->subtitle_header_size = dec->subtitle_header_size;

            }

            if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {

                snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",

                        ost->file_index, ost->index);

                ret = AVERROR(EINVAL);

                goto dump_format;

            }

            assert_codec_experimental(ost->st->codec, 1);

            assert_avoptions(ost->opts);

            if (ost->st->codec->bit_rate && ost->st->codec->bit_rate < 1000)

                av_log(NULL, AV_LOG_WARNING, "The bitrate parameter is set too low."

                                             "It takes bits/s as argument, not kbits/s\n");

            extra_size += ost->st->codec->extradata_size;

        }

    }



    /* init input streams */

    for (i = 0; i < nb_input_streams; i++)

        if ((ret = init_input_stream(i, output_streams, nb_output_streams, error, sizeof(error))) < 0)

            goto dump_format;



    /* open files and write file headers */

    for (i = 0; i < nb_output_files; i++) {

        os = output_files[i].ctx;

        if (avformat_write_header(os, &output_files[i].opts) < 0) {

            snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);

            ret = AVERROR(EINVAL);

            goto dump_format;

        }

        assert_avoptions(output_files[i].opts);

        if (strcmp(os->oformat->name, "rtp")) {

            want_sdp = 0;

        }

    }



 dump_format:

    /* dump the file output parameters - cannot be done before in case

       of stream copy */

    for(i=0;i<nb_output_files;i++) {

        av_dump_format(output_files[i].ctx, i, output_files[i].ctx->filename, 1);

    }



    /* dump the stream mapping */

    if (verbose >= 0) {

        fprintf(stderr, "Stream mapping:\n");

        for (i = 0; i < nb_output_streams;i ++) {

            ost = &output_streams[i];

            fprintf(stderr, "  Stream #%d.%d -> #%d.%d",

                    input_streams[ost->source_index].file_index,

                    input_streams[ost->source_index].st->index,

                    ost->file_index,

                    ost->index);

            if (ost->sync_ist != &input_streams[ost->source_index])

                fprintf(stderr, " [sync #%d.%d]",

                        ost->sync_ist->file_index,

                        ost->sync_ist->st->index);

            if (ost->st->stream_copy)

                fprintf(stderr, " (copy)");

            else

                fprintf(stderr, " (%s -> %s)", input_streams[ost->source_index].dec ?

                        input_streams[ost->source_index].dec->name : "?",

                        ost->enc ? ost->enc->name : "?");

            fprintf(stderr, "\n");

        }

    }



    if (ret) {

        fprintf(stderr, "%s\n", error);

        return ret;

    }



    if (want_sdp) {

        print_sdp(output_files, nb_output_files);

    }



    return 0;

}
 and probability:0.5195195195195195
code:static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)

{

    LavfiContext *lavfi = avctx->priv_data;

    double min_pts = DBL_MAX;

    int stream_idx, min_pts_sink_idx = 0;

    AVFrame *frame = lavfi->decoded_frame;

    AVPicture pict;

    AVDictionary *frame_metadata;

    int ret, i;

    int size = 0;



    if (lavfi->subcc_packet.size) {

        *pkt = lavfi->subcc_packet;

        av_init_packet(&lavfi->subcc_packet);

        lavfi->subcc_packet.size = 0;

        lavfi->subcc_packet.data = NULL;

        return pkt->size;

    }



    /* iterate through all the graph sinks. Select the sink with the

     * minimum PTS */

    for (i = 0; i < lavfi->nb_sinks; i++) {

        AVRational tb = lavfi->sinks[i]->inputs[0]->time_base;

        double d;

        int ret;



        if (lavfi->sink_eof[i])

            continue;



        ret = av_buffersink_get_frame_flags(lavfi->sinks[i], frame,

                                            AV_BUFFERSINK_FLAG_PEEK);

        if (ret == AVERROR_EOF) {

            av_dlog(avctx, "EOF sink_idx:%d\n", i);

            lavfi->sink_eof[i] = 1;

            continue;

        } else if (ret < 0)

            return ret;

        d = av_rescale_q_rnd(frame->pts, tb, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);

        av_dlog(avctx, "sink_idx:%d time:%f\n", i, d);

        av_frame_unref(frame);



        if (d < min_pts) {

            min_pts = d;

            min_pts_sink_idx = i;

        }

    }

    if (min_pts == DBL_MAX)

        return AVERROR_EOF;



    av_dlog(avctx, "min_pts_sink_idx:%i\n", min_pts_sink_idx);



    av_buffersink_get_frame_flags(lavfi->sinks[min_pts_sink_idx], frame, 0);

    stream_idx = lavfi->sink_stream_map[min_pts_sink_idx];



    if (frame->width /* FIXME best way of testing a video */) {

        size = avpicture_get_size(frame->format, frame->width, frame->height);

        if ((ret = av_new_packet(pkt, size)) < 0)

            return ret;



        memcpy(pict.data,     frame->data,     4*sizeof(frame->data[0]));

        memcpy(pict.linesize, frame->linesize, 4*sizeof(frame->linesize[0]));



        avpicture_layout(&pict, frame->format, frame->width, frame->height,

                         pkt->data, size);

    } else if (av_frame_get_channels(frame) /* FIXME test audio */) {

        size = frame->nb_samples * av_get_bytes_per_sample(frame->format) *

                                   av_frame_get_channels(frame);

        if ((ret = av_new_packet(pkt, size)) < 0)

            return ret;

        memcpy(pkt->data, frame->data[0], size);

    }



    frame_metadata = av_frame_get_metadata(frame);

    if (frame_metadata) {

        uint8_t *metadata;

        AVDictionaryEntry *e = NULL;

        AVBPrint meta_buf;



        av_bprint_init(&meta_buf, 0, AV_BPRINT_SIZE_UNLIMITED);

        while ((e = av_dict_get(frame_metadata, "", e, AV_DICT_IGNORE_SUFFIX))) {

            av_bprintf(&meta_buf, "%s", e->key);

            av_bprint_chars(&meta_buf, '\0', 1);

            av_bprintf(&meta_buf, "%s", e->value);

            av_bprint_chars(&meta_buf, '\0', 1);

        }

        if (!av_bprint_is_complete(&meta_buf) ||

            !(metadata = av_packet_new_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA,

                                                 meta_buf.len))) {

            av_bprint_finalize(&meta_buf, NULL);

            return AVERROR(ENOMEM);

        }

        memcpy(metadata, meta_buf.str, meta_buf.len);

        av_bprint_finalize(&meta_buf, NULL);

    }



    if ((ret = create_subcc_packet(avctx, frame, min_pts_sink_idx)) < 0) {

        av_frame_unref(frame);

        av_packet_unref(pkt);

        return ret;

    }



    pkt->stream_index = stream_idx;

    pkt->pts = frame->pts;

    pkt->pos = av_frame_get_pkt_pos(frame);

    pkt->size = size;

    av_frame_unref(frame);

    return size;

}
 and probability:0.3191489361702128
code:static void iothread_complete(UserCreatable *obj, Error **errp)

{

    IOThread *iothread = IOTHREAD(obj);



    iothread->stopping = false;

    iothread->ctx = aio_context_new();

    iothread->thread_id = -1;



    qemu_mutex_init(&iothread->init_done_lock);

    qemu_cond_init(&iothread->init_done_cond);



    /* This assumes we are called from a thread with useful CPU affinity for us

     * to inherit.

     */

    qemu_thread_create(&iothread->thread, "iothread", iothread_run,

                       iothread, QEMU_THREAD_JOINABLE);



    /* Wait for initialization to complete */

    qemu_mutex_lock(&iothread->init_done_lock);

    while (iothread->thread_id == -1) {

        qemu_cond_wait(&iothread->init_done_cond,

                       &iothread->init_done_lock);

    }

    qemu_mutex_unlock(&iothread->init_done_lock);

}
 and probability:0.5238095238095238
code:static void gen_tlbre_440(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    switch (rB(ctx->opcode)) {

    case 0:

    case 1:

    case 2:

        {

            TCGv_i32 t0 = tcg_const_i32(rB(ctx->opcode));

            gen_helper_440_tlbre(cpu_gpr[rD(ctx->opcode)], cpu_env,

                                 t0, cpu_gpr[rA(ctx->opcode)]);

            tcg_temp_free_i32(t0);

        }

        break;

    default:

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);

        break;

    }

#endif

}
 and probability:0.19230769230769232
code:target_ulong helper_evpe(target_ulong arg1)

{

    // TODO

    arg1 = 0;

    // rt = arg1



    return arg1;

}
 and probability:0.0
code:void helper_ldmxcsr(CPUX86State *env, uint32_t val)

{

    env->mxcsr = val;

    update_sse_status(env);

}
 and probability:0.2
code:void ff_snow_horizontal_compose97i_mmx(IDWTELEM *b, int width){

    const int w2= (width+1)>>1;

    IDWTELEM temp[width >> 1];

    const int w_l= (width>>1);

    const int w_r= w2 - 1;

    int i;



    { // Lift 0

        IDWTELEM * const ref = b + w2 - 1;



        i = 1;

        b[0] = b[0] - ((W_DM * 2 * ref[1]+W_DO)>>W_DS);

        asm volatile(

            "pcmpeqw    %%mm7, %%mm7         \n\t"

            "psllw        $15, %%mm7         \n\t"

            "psrlw        $14, %%mm7         \n\t"

           ::);

        for(; i<w_l-7; i+=8){

            asm volatile(

                "movq     (%1), %%mm2        \n\t"

                "movq    8(%1), %%mm6        \n\t"

                "paddw   2(%1), %%mm2        \n\t"

                "paddw  10(%1), %%mm6        \n\t"

                "movq    %%mm2, %%mm0        \n\t"

                "movq    %%mm6, %%mm4        \n\t"

                "psraw      $1, %%mm2        \n\t"

                "psraw      $1, %%mm6        \n\t"

                "paddw   %%mm0, %%mm2        \n\t"

                "paddw   %%mm4, %%mm6        \n\t"

                "paddw   %%mm7, %%mm2        \n\t"

                "paddw   %%mm7, %%mm6        \n\t"

                "psraw      $2, %%mm2        \n\t"

                "psraw      $2, %%mm6        \n\t"

                "movq     (%0), %%mm0        \n\t"

                "movq    8(%0), %%mm4        \n\t"

                "psubw   %%mm2, %%mm0        \n\t"

                "psubw   %%mm6, %%mm4        \n\t"

                "movq    %%mm0, (%0)         \n\t"

                "movq    %%mm4, 8(%0)        \n\t"

                :: "r"(&b[i]), "r"(&ref[i])

                 : "memory"

               );

        }

        snow_horizontal_compose_lift_lead_out(i, b, b, ref, width, w_l, 0, W_DM, W_DO, W_DS);

    }



    { // Lift 1

        IDWTELEM * const dst = b+w2;



        i = 0;

        for(; i<w_r-7; i+=8){

            asm volatile(

                "movq     (%1), %%mm2        \n\t"

                "movq    8(%1), %%mm6        \n\t"

                "paddw   2(%1), %%mm2        \n\t"

                "paddw  10(%1), %%mm6        \n\t"

                "movq     (%0), %%mm0        \n\t"

                "movq    8(%0), %%mm4        \n\t"

                "psubw   %%mm2, %%mm0        \n\t"

                "psubw   %%mm6, %%mm4        \n\t"

                "movq    %%mm0, (%0)         \n\t"

                "movq    %%mm4, 8(%0)        \n\t"

                :: "r"(&dst[i]), "r"(&b[i])

                 : "memory"

               );

        }

        snow_horizontal_compose_lift_lead_out(i, dst, dst, b, width, w_r, 1, W_CM, W_CO, W_CS);

    }



    { // Lift 2

        IDWTELEM * const ref = b+w2 - 1;



        i = 1;

        b[0] = b[0] + (((2 * ref[1] + W_BO) + 4 * b[0]) >> W_BS);

        asm volatile(

            "psllw          $2, %%mm7        \n\t"

           ::);

        for(; i<w_l-7; i+=8){

            asm volatile(

                "movq     (%1), %%mm0        \n\t"

                "movq    8(%1), %%mm4        \n\t"

                "paddw   2(%1), %%mm0        \n\t"

                "paddw  10(%1), %%mm4        \n\t"

                "paddw   %%mm7, %%mm0        \n\t"

                "paddw   %%mm7, %%mm4        \n\t"

                "psraw      $2, %%mm0        \n\t"

                "psraw      $2, %%mm4        \n\t"

                "movq     (%0), %%mm1        \n\t"

                "movq    8(%0), %%mm5        \n\t"

                "paddw   %%mm1, %%mm0        \n\t"

                "paddw   %%mm5, %%mm4        \n\t"

                "psraw      $2, %%mm0        \n\t"

                "psraw      $2, %%mm4        \n\t"

                "paddw   %%mm1, %%mm0        \n\t"

                "paddw   %%mm5, %%mm4        \n\t"

                "movq    %%mm0, (%0)         \n\t"

                "movq    %%mm4, 8(%0)        \n\t"

                :: "r"(&b[i]), "r"(&ref[i])

                 : "memory"

               );

        }

        snow_horizontal_compose_liftS_lead_out(i, b, b, ref, width, w_l);

    }



    { // Lift 3

        IDWTELEM * const src = b+w2;

        i = 0;



        for(; i<w_r-7; i+=8){

            asm volatile(

                "movq    2(%1), %%mm2        \n\t"

                "movq   10(%1), %%mm6        \n\t"

                "paddw    (%1), %%mm2        \n\t"

                "paddw   8(%1), %%mm6        \n\t"

                "movq     (%0), %%mm0        \n\t"

                "movq    8(%0), %%mm4        \n\t"

                "paddw   %%mm2, %%mm0        \n\t"

                "paddw   %%mm6, %%mm4        \n\t"

                "psraw      $1, %%mm2        \n\t"

                "psraw      $1, %%mm6        \n\t"

                "paddw   %%mm0, %%mm2        \n\t"

                "paddw   %%mm4, %%mm6        \n\t"

                "movq    %%mm2, (%2)         \n\t"

                "movq    %%mm6, 8(%2)        \n\t"

                :: "r"(&src[i]), "r"(&b[i]), "r"(&temp[i])

                 : "memory"

               );

        }

        snow_horizontal_compose_lift_lead_out(i, temp, src, b, width, w_r, 1, -W_AM, W_AO+1, W_AS);

    }



    {

        snow_interleave_line_header(&i, width, b, temp);



        for (; (i & 0x1E) != 0x1E; i-=2){

            b[i+1] = temp[i>>1];

            b[i] = b[i>>1];

        }

        for (i-=30; i>=0; i-=32){

            asm volatile(

                "movq        (%1), %%mm0       \n\t"

                "movq       8(%1), %%mm2       \n\t"

                "movq      16(%1), %%mm4       \n\t"

                "movq      24(%1), %%mm6       \n\t"

                "movq        (%1), %%mm1       \n\t"

                "movq       8(%1), %%mm3       \n\t"

                "movq      16(%1), %%mm5       \n\t"

                "movq      24(%1), %%mm7       \n\t"

                "punpcklwd   (%2), %%mm0       \n\t"

                "punpcklwd  8(%2), %%mm2       \n\t"

                "punpcklwd 16(%2), %%mm4       \n\t"

                "punpcklwd 24(%2), %%mm6       \n\t"

                "movq       %%mm0, (%0)        \n\t"

                "movq       %%mm2, 16(%0)      \n\t"

                "movq       %%mm4, 32(%0)      \n\t"

                "movq       %%mm6, 48(%0)      \n\t"

                "punpckhwd   (%2), %%mm1       \n\t"

                "punpckhwd  8(%2), %%mm3       \n\t"

                "punpckhwd 16(%2), %%mm5       \n\t"

                "punpckhwd 24(%2), %%mm7       \n\t"

                "movq       %%mm1, 8(%0)       \n\t"

                "movq       %%mm3, 24(%0)      \n\t"

                "movq       %%mm5, 40(%0)      \n\t"

                "movq       %%mm7, 56(%0)      \n\t"

                :: "r"(&b[i]), "r"(&b[i>>1]), "r"(&temp[i>>1])

                 : "memory"

               );

        }

    }

}
 and probability:0.1375
code:static int net_dump_init(VLANState *vlan, const char *device,

                         const char *name, const char *filename, int len)

{

    struct pcap_file_hdr hdr;

    DumpState *s;



    s = qemu_malloc(sizeof(DumpState));



    s->fd = open(filename, O_CREAT | O_WRONLY | O_BINARY, 0644);

    if (s->fd < 0) {

        qemu_error("-net dump: can't open %s\n", filename);

        return -1;

    }



    s->pcap_caplen = len;



    hdr.magic = PCAP_MAGIC;

    hdr.version_major = 2;

    hdr.version_minor = 4;

    hdr.thiszone = 0;

    hdr.sigfigs = 0;

    hdr.snaplen = s->pcap_caplen;

    hdr.linktype = 1;



    if (write(s->fd, &hdr, sizeof(hdr)) < sizeof(hdr)) {

        qemu_error("-net dump write error: %s\n", strerror(errno));

        close(s->fd);

        qemu_free(s);

        return -1;

    }



    s->pcap_vc = qemu_new_vlan_client(NET_CLIENT_TYPE_DUMP,

                                      vlan, NULL, device, name, NULL,

                                      dump_receive, NULL, NULL,

                                      net_dump_cleanup, s);

    snprintf(s->pcap_vc->info_str, sizeof(s->pcap_vc->info_str),

             "dump to %s (len=%d)", filename, len);

    return 0;

}
 and probability:0.24242424242424243
code:void check_values (eq2_param_t *par)

{

  /* yuck! floating point comparisons... */



  if ((par->c == 1.0) && (par->b == 0.0) && (par->g == 1.0)) {

    par->adjust = NULL;

  }

#if HAVE_MMX && HAVE_6REGS

  else if (par->g == 1.0 && ff_gCpuCaps.hasMMX) {

    par->adjust = &affine_1d_MMX;

  }

#endif

  else {

    par->adjust = &apply_lut;

  }

}
 and probability:0.26666666666666666
code:static int ipvideo_decode_block_opcode_0x2(IpvideoContext *s)

{

    unsigned char B;

    int x, y;



    /* copy block from 2 frames ago using a motion vector; need 1 more byte */

    CHECK_STREAM_PTR(s->stream_ptr, s->stream_end, 1);

    B = *s->stream_ptr++;



    if (B < 56) {

        x = 8 + (B % 7);

        y = B / 7;

    } else {

        x = -14 + ((B - 56) % 29);

        y =   8 + ((B - 56) / 29);

    }



    debug_interplay ("    motion byte = %d, (x, y) = (%d, %d)\n", B, x, y);

    return copy_from(s, &s->second_last_frame, x, y);

}
 and probability:0.4117647058823529
code:static int input_get_buffer(AVCodecContext *codec, AVFrame *pic)

{

    AVFilterContext *ctx = codec->opaque;

    AVFilterBufferRef  *ref;

    int perms = AV_PERM_WRITE;

    int i, w, h, stride[4];

    unsigned edge;



    if(av_image_check_size(w, h, 0, codec))

        return -1;



    if (codec->codec->capabilities & CODEC_CAP_NEG_LINESIZES)

        perms |= AV_PERM_NEG_LINESIZES;



    if(pic->buffer_hints & FF_BUFFER_HINTS_VALID) {

        if(pic->buffer_hints & FF_BUFFER_HINTS_READABLE) perms |= AV_PERM_READ;

        if(pic->buffer_hints & FF_BUFFER_HINTS_PRESERVE) perms |= AV_PERM_PRESERVE;

        if(pic->buffer_hints & FF_BUFFER_HINTS_REUSABLE) perms |= AV_PERM_REUSE2;

    }

    if(pic->reference) perms |= AV_PERM_READ | AV_PERM_PRESERVE;



    w = codec->width;

    h = codec->height;

    avcodec_align_dimensions2(codec, &w, &h, stride);

    edge = codec->flags & CODEC_FLAG_EMU_EDGE ? 0 : avcodec_get_edge_width();

    w += edge << 1;

    h += edge << 1;



    if(!(ref = avfilter_get_video_buffer(ctx->outputs[0], perms, w, h)))

        return -1;



    ref->video->w = codec->width;

    ref->video->h = codec->height;

    for(i = 0; i < 4; i ++) {

        unsigned hshift = (i == 1 || i == 2) ? av_pix_fmt_descriptors[ref->format].log2_chroma_w : 0;

        unsigned vshift = (i == 1 || i == 2) ? av_pix_fmt_descriptors[ref->format].log2_chroma_h : 0;



        if (ref->data[i]) {

            ref->data[i]    += (edge >> hshift) + ((edge * ref->linesize[i]) >> vshift);

        }

        pic->data[i]     = ref->data[i];

        pic->linesize[i] = ref->linesize[i];

    }

    pic->opaque = ref;

    pic->age    = INT_MAX;

    pic->type   = FF_BUFFER_TYPE_USER;

    pic->reordered_opaque = codec->reordered_opaque;

    if(codec->pkt) pic->pkt_pts = codec->pkt->pts;

    else           pic->pkt_pts = AV_NOPTS_VALUE;

    return 0;

}
 and probability:0.6363636363636364
code:static void coroutine_fn wait_for_overlapping_requests(BlockDriverState *bs,
        int64_t sector_num, int nb_sectors)
{
    BdrvTrackedRequest *req;
    int64_t cluster_sector_num;
    int cluster_nb_sectors;
    bool retry;
    /* If we touch the same cluster it counts as an overlap.  This guarantees
     * that allocating writes will be serialized and not race with each other
     * for the same cluster.  For example, in copy-on-read it ensures that the
     * CoR read and write operations are atomic and guest writes cannot
     * interleave between them.
    round_to_clusters(bs, sector_num, nb_sectors,
                      &cluster_sector_num, &cluster_nb_sectors);
    do {
        retry = false;
        QLIST_FOREACH(req, &bs->tracked_requests, list) {
            if (tracked_request_overlaps(req, cluster_sector_num,
                                         cluster_nb_sectors)) {
                qemu_co_queue_wait(&req->wait_queue);
                retry = true;
                break;
            }
        }
    } while (retry);
} and probability:0.19230769230769232
code:static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan,

                                                const char *model,

                                                const char *name,

                                                int fd, int is_connected)

{

    struct sockaddr_in saddr;

    int newfd;

    socklen_t saddr_len;

    VLANClientState *nc;

    NetSocketState *s;



    /* fd passed: multicast: "learn" dgram_dst address from bound address and save it

     * Because this may be "shared" socket from a "master" process, datagrams would be recv()

     * by ONLY ONE process: we must "clone" this dgram socket --jjo

     */



    if (is_connected) {

        if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {

            /* must be bound */

            if (saddr.sin_addr.s_addr == 0) {

                fprintf(stderr, "qemu: error: init_dgram: fd=%d unbound, "

                        "cannot setup multicast dst addr\n", fd);

                return NULL;

            }

            /* clone dgram socket */

            newfd = net_socket_mcast_create(&saddr, NULL);

            if (newfd < 0) {

                /* error already reported by net_socket_mcast_create() */

                close(fd);

                return NULL;

            }

            /* clone newfd to fd, close newfd */

            dup2(newfd, fd);

            close(newfd);



        } else {

            fprintf(stderr,

                    "qemu: error: init_dgram: fd=%d failed getsockname(): %s\n",

                    fd, strerror(errno));

            return NULL;

        }

    }



    nc = qemu_new_net_client(&net_dgram_socket_info, vlan, NULL, model, name);



    snprintf(nc->info_str, sizeof(nc->info_str),

            "socket: fd=%d (%s mcast=%s:%d)",

            fd, is_connected ? "cloned" : "",

            inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));



    s = DO_UPCAST(NetSocketState, nc, nc);



    s->fd = fd;



    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);



    /* mcast: save bound address as dst */

    if (is_connected) s->dgram_dst=saddr;



    return s;

}
 and probability:0.0784313725490196
code:int64_t bdrv_dirty_iter_next(BdrvDirtyBitmapIter *iter)

{

    return hbitmap_iter_next(&iter->hbi);

}
 and probability:0.25
code:static void rtl8139_write_buffer(RTL8139State *s, const void *buf, int size)

{

    if (s->RxBufAddr + size > s->RxBufferSize)

    {

        int wrapped = MOD2(s->RxBufAddr + size, s->RxBufferSize);



        /* write packet data */

        if (wrapped && s->RxBufferSize < 65536 && !rtl8139_RxWrap(s))

        {

            DEBUG_PRINT((">>> RTL8139: rx packet wrapped in buffer at %d\n", size-wrapped));



            if (size > wrapped)

            {

                cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,

                                           buf, size-wrapped );

            }



            /* reset buffer pointer */

            s->RxBufAddr = 0;



            cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,

                                       buf + (size-wrapped), wrapped );



            s->RxBufAddr = wrapped;



            return;

        }

    }



    /* non-wrapping path or overwrapping enabled */

    cpu_physical_memory_write( s->RxBuf + s->RxBufAddr, buf, size );



    s->RxBufAddr += size;

}
 and probability:0.46153846153846156
code:int ppc_hash32_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,

                                int mmu_idx)

{

    struct mmu_ctx_hash32 ctx;

    int access_type;

    int ret = 0;



    if (rw == 2) {

        /* code access */

        rw = 0;

        access_type = ACCESS_CODE;

    } else {

        /* data access */

        access_type = env->access_type;

    }

    ret = ppc_hash32_get_physical_address(env, &ctx, address, rw, access_type);

    if (ret == 0) {

        tlb_set_page(env, address & TARGET_PAGE_MASK,

                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,

                     mmu_idx, TARGET_PAGE_SIZE);

        ret = 0;

    } else if (ret < 0) {

        LOG_MMU_STATE(env);

        if (access_type == ACCESS_CODE) {

            switch (ret) {

            case -1:

                /* No matches in page tables or TLB */

                env->exception_index = POWERPC_EXCP_ISI;

                env->error_code = 0x40000000;

                break;

            case -2:

                /* Access rights violation */

                env->exception_index = POWERPC_EXCP_ISI;

                env->error_code = 0x08000000;

                break;

            case -3:

                /* No execute protection violation */

                env->exception_index = POWERPC_EXCP_ISI;

                env->error_code = 0x10000000;

                break;

            case -4:

                /* Direct store exception */

                /* No code fetch is allowed in direct-store areas */

                env->exception_index = POWERPC_EXCP_ISI;

                env->error_code = 0x10000000;

                break;

            }

        } else {

            switch (ret) {

            case -1:

                /* No matches in page tables or TLB */

                env->exception_index = POWERPC_EXCP_DSI;

                env->error_code = 0;

                env->spr[SPR_DAR] = address;

                if (rw == 1) {

                    env->spr[SPR_DSISR] = 0x42000000;

                } else {

                    env->spr[SPR_DSISR] = 0x40000000;

                }

                break;

            case -2:

                /* Access rights violation */

                env->exception_index = POWERPC_EXCP_DSI;

                env->error_code = 0;

                env->spr[SPR_DAR] = address;

                if (rw == 1) {

                    env->spr[SPR_DSISR] = 0x0A000000;

                } else {

                    env->spr[SPR_DSISR] = 0x08000000;

                }

                break;

            case -4:

                /* Direct store exception */

                switch (access_type) {

                case ACCESS_FLOAT:

                    /* Floating point load/store */

                    env->exception_index = POWERPC_EXCP_ALIGN;

                    env->error_code = POWERPC_EXCP_ALIGN_FP;

                    env->spr[SPR_DAR] = address;

                    break;

                case ACCESS_RES:

                    /* lwarx, ldarx or stwcx. */

                    env->exception_index = POWERPC_EXCP_DSI;

                    env->error_code = 0;

                    env->spr[SPR_DAR] = address;

                    if (rw == 1) {

                        env->spr[SPR_DSISR] = 0x06000000;

                    } else {

                        env->spr[SPR_DSISR] = 0x04000000;

                    }

                    break;

                case ACCESS_EXT:

                    /* eciwx or ecowx */

                    env->exception_index = POWERPC_EXCP_DSI;

                    env->error_code = 0;

                    env->spr[SPR_DAR] = address;

                    if (rw == 1) {

                        env->spr[SPR_DSISR] = 0x06100000;

                    } else {

                        env->spr[SPR_DSISR] = 0x04100000;

                    }

                    break;

                default:

                    printf("DSI: invalid exception (%d)\n", ret);

                    env->exception_index = POWERPC_EXCP_PROGRAM;

                    env->error_code =

                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;

                    env->spr[SPR_DAR] = address;

                    break;

                }

                break;

            }

        }

#if 0

        printf("%s: set exception to %d %02x\n", __func__,

               env->exception, env->error_code);

#endif

        ret = 1;

    }



    return ret;

}
 and probability:0.3
code:bool colo_supported(void)

{

    return true;

}
 and probability:0.0
code:static uint64_t pxa2xx_i2s_read(void *opaque, hwaddr addr,

                                unsigned size)

{

    PXA2xxI2SState *s = (PXA2xxI2SState *) opaque;



    switch (addr) {

    case SACR0:

        return s->control[0];

    case SACR1:

        return s->control[1];

    case SASR0:

        return s->status;

    case SAIMR:

        return s->mask;

    case SAICR:

        return 0;

    case SADIV:

        return s->clk;

    case SADR:

        if (s->rx_len > 0) {

            s->rx_len --;

            pxa2xx_i2s_update(s);

            return s->codec_in(s->opaque);

        }

        return 0;

    default:

        printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, addr);

        break;

    }

    return 0;

}
 and probability:0.26666666666666666
code:char *desc_get_buf(DescInfo *info, bool read_only)

{

    PCIDevice *dev = PCI_DEVICE(info->ring->r);

    size_t size = read_only ? le16_to_cpu(info->desc.tlv_size) :

                              le16_to_cpu(info->desc.buf_size);



    if (size > info->buf_size) {

        info->buf = g_realloc(info->buf, size);

        info->buf_size = size;

    }



    if (!info->buf) {

        return NULL;

    }



    if (pci_dma_read(dev, le64_to_cpu(info->desc.buf_addr), info->buf, size)) {

        return NULL;

    }



    return info->buf;

}
 and probability:0.5294117647058824
code:static void copy_context_after_encode(MpegEncContext *d, MpegEncContext *s, int type){

    int i;



    memcpy(d->mv, s->mv, 2*4*2*sizeof(int)); 

    memcpy(d->last_mv, s->last_mv, 2*2*2*sizeof(int)); //FIXME is memcpy faster then a loop?

    

    /* mpeg1 */

    d->mb_incr= s->mb_incr;

    for(i=0; i<3; i++)

        d->last_dc[i]= s->last_dc[i];

    

    /* statistics */

    d->mv_bits= s->mv_bits;

    d->i_tex_bits= s->i_tex_bits;

    d->p_tex_bits= s->p_tex_bits;

    d->i_count= s->i_count;

    d->p_count= s->p_count;

    d->skip_count= s->skip_count;

    d->misc_bits= s->misc_bits;



    d->mb_intra= s->mb_intra;

    d->mb_skiped= s->mb_skiped;

    d->mv_type= s->mv_type;

    d->mv_dir= s->mv_dir;

    d->pb= s->pb;

    d->block= s->block;

    for(i=0; i<6; i++)

        d->block_last_index[i]= s->block_last_index[i];

}
 and probability:0.8
code:static inline int gen_intermediate_code_internal (CPUState *env,

                                                  TranslationBlock *tb,

                                                  int search_pc)

{

    DisasContext ctx, *ctxp = &ctx;

    opc_handler_t **table, *handler;

    target_ulong pc_start;

    uint16_t *gen_opc_end;

    int j, lj = -1;



    pc_start = tb->pc;

    gen_opc_ptr = gen_opc_buf;

    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;

    gen_opparam_ptr = gen_opparam_buf;

    nb_gen_labels = 0;

    ctx.nip = pc_start;

    ctx.tb = tb;

    ctx.exception = EXCP_NONE;

    ctx.spr_cb = env->spr_cb;

#if defined(CONFIG_USER_ONLY)

    ctx.mem_idx = msr_le;

#if defined(TARGET_PPC64)

    ctx.mem_idx |= msr_sf << 1;

#endif

#else

    ctx.supervisor = 1 - msr_pr;

    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;

#if defined(TARGET_PPC64)

    ctx.mem_idx |= msr_sf << 2;

#endif

#endif

#if defined(TARGET_PPC64)

    ctx.sf_mode = msr_sf;

#endif

    ctx.fpu_enabled = msr_fp;

#if defined(TARGET_PPCEMB)

    ctx.spe_enabled = msr_spe;

#endif

    ctx.singlestep_enabled = env->singlestep_enabled;

#if defined (DO_SINGLE_STEP) && 0

    /* Single step trace mode */

    msr_se = 1;

#endif

    /* Set env in case of segfault during code fetch */

    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {

        if (unlikely(env->nb_breakpoints > 0)) {

            for (j = 0; j < env->nb_breakpoints; j++) {

                if (env->breakpoints[j] == ctx.nip) {

                    gen_update_nip(&ctx, ctx.nip);

                    gen_op_debug();

                    break;

                }

            }

        }

        if (unlikely(search_pc)) {

            j = gen_opc_ptr - gen_opc_buf;

            if (lj < j) {

                lj++;

                while (lj < j)

                    gen_opc_instr_start[lj++] = 0;

                gen_opc_pc[lj] = ctx.nip;

                gen_opc_instr_start[lj] = 1;

            }

        }

#if defined PPC_DEBUG_DISAS

        if (loglevel & CPU_LOG_TB_IN_ASM) {

            fprintf(logfile, "----------------\n");

            fprintf(logfile, "nip=" ADDRX " super=%d ir=%d\n",

                    ctx.nip, 1 - msr_pr, msr_ir);

        }

#endif

        ctx.opcode = ldl_code(ctx.nip);

        if (msr_le) {

            ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |

                ((ctx.opcode & 0x00FF0000) >> 8) |

                ((ctx.opcode & 0x0000FF00) << 8) |

                ((ctx.opcode & 0x000000FF) << 24);

        }

#if defined PPC_DEBUG_DISAS

        if (loglevel & CPU_LOG_TB_IN_ASM) {

            fprintf(logfile, "translate opcode %08x (%02x %02x %02x) (%s)\n",

                    ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),

                    opc3(ctx.opcode), msr_le ? "little" : "big");

        }

#endif

        ctx.nip += 4;

        table = env->opcodes;

        handler = table[opc1(ctx.opcode)];

        if (is_indirect_opcode(handler)) {

            table = ind_table(handler);

            handler = table[opc2(ctx.opcode)];

            if (is_indirect_opcode(handler)) {

                table = ind_table(handler);

                handler = table[opc3(ctx.opcode)];

            }

        }

        /* Is opcode *REALLY* valid ? */

        if (unlikely(handler->handler == &gen_invalid)) {

            if (loglevel != 0) {

                fprintf(logfile, "invalid/unsupported opcode: "

                        "%02x - %02x - %02x (%08x) 0x" ADDRX " %d\n",

                        opc1(ctx.opcode), opc2(ctx.opcode),

                        opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);

            } else {

                printf("invalid/unsupported opcode: "

                       "%02x - %02x - %02x (%08x) 0x" ADDRX " %d\n",

                       opc1(ctx.opcode), opc2(ctx.opcode),

                       opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);

            }

        } else {

            if (unlikely((ctx.opcode & handler->inval) != 0)) {

                if (loglevel != 0) {

                    fprintf(logfile, "invalid bits: %08x for opcode: "

                            "%02x -%02x - %02x (%08x) 0x" ADDRX "\n",

                            ctx.opcode & handler->inval, opc1(ctx.opcode),

                            opc2(ctx.opcode), opc3(ctx.opcode),

                            ctx.opcode, ctx.nip - 4);

                } else {

                    printf("invalid bits: %08x for opcode: "

                           "%02x -%02x - %02x (%08x) 0x" ADDRX "\n",

                           ctx.opcode & handler->inval, opc1(ctx.opcode),

                           opc2(ctx.opcode), opc3(ctx.opcode),

                           ctx.opcode, ctx.nip - 4);

                }

                RET_INVAL(ctxp);

                break;

            }

        }

        (*(handler->handler))(&ctx);

#if defined(DO_PPC_STATISTICS)

        handler->count++;

#endif

        /* Check trace mode exceptions */

#if 0 // XXX: buggy on embedded PowerPC

        if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||

                     /* Check in single step trace mode

                      * we need to stop except if:

                      * - rfi, trap or syscall

                      * - first instruction of an exception handler

                      */

                     (msr_se && (ctx.nip < 0x100 ||

                                 ctx.nip > 0xF00 ||

                                 (ctx.nip & 0xFC) != 0x04) &&

                      ctx.exception != EXCP_SYSCALL &&

                      ctx.exception != EXCP_SYSCALL_USER &&

                      ctx.exception != EXCP_TRAP))) {

            RET_EXCP(ctxp, EXCP_TRACE, 0);

        }

#endif

        /* if we reach a page boundary or are single stepping, stop

         * generation

         */

        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||

                     (env->singlestep_enabled))) {

            break;

        }

#if defined (DO_SINGLE_STEP)

        break;

#endif

    }

    if (ctx.exception == EXCP_NONE) {

        gen_goto_tb(&ctx, 0, ctx.nip);

    } else if (ctx.exception != EXCP_BRANCH) {

        gen_op_reset_T0();

        /* Generate the return instruction */

        gen_op_exit_tb();

    }

    *gen_opc_ptr = INDEX_op_end;

    if (unlikely(search_pc)) {

        j = gen_opc_ptr - gen_opc_buf;

        lj++;

        while (lj <= j)

            gen_opc_instr_start[lj++] = 0;

    } else {

        tb->size = ctx.nip - pc_start;

    }

#if defined(DEBUG_DISAS)

    if (loglevel & CPU_LOG_TB_CPU) {

        fprintf(logfile, "---------------- excp: %04x\n", ctx.exception);

        cpu_dump_state(env, logfile, fprintf, 0);

    }

    if (loglevel & CPU_LOG_TB_IN_ASM) {

        int flags;

        flags = env->bfd_mach;

        flags |= msr_le << 16;

        fprintf(logfile, "IN: %s\n", lookup_symbol(pc_start));

        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);

        fprintf(logfile, "\n");

    }

    if (loglevel & CPU_LOG_TB_OP) {

        fprintf(logfile, "OP:\n");

        dump_ops(gen_opc_buf, gen_opparam_buf);

        fprintf(logfile, "\n");

    }

#endif

    return 0;

}
 and probability:0.1989795918367347
code:void *address_space_map(AddressSpace *as,

                        target_phys_addr_t addr,

                        target_phys_addr_t *plen,

                        bool is_write)

{

    AddressSpaceDispatch *d = as->dispatch;

    target_phys_addr_t len = *plen;

    target_phys_addr_t todo = 0;

    int l;

    target_phys_addr_t page;

    MemoryRegionSection *section;

    ram_addr_t raddr = RAM_ADDR_MAX;

    ram_addr_t rlen;

    void *ret;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        section = phys_page_find(d, page >> TARGET_PAGE_BITS);



        if (!(memory_region_is_ram(section->mr) && !section->readonly)) {

            if (todo || bounce.buffer) {

                break;

            }

            bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, TARGET_PAGE_SIZE);

            bounce.addr = addr;

            bounce.len = l;

            if (!is_write) {

                address_space_read(as, addr, bounce.buffer, l);

            }



            *plen = l;

            return bounce.buffer;

        }

        if (!todo) {

            raddr = memory_region_get_ram_addr(section->mr)

                + memory_region_section_addr(section, addr);

        }



        len -= l;

        addr += l;

        todo += l;

    }

    rlen = todo;

    ret = qemu_ram_ptr_length(raddr, &rlen);

    *plen = rlen;

    return ret;

}
 and probability:0.21739130434782608
code:GenericList *visit_next_list(Visitor *v, GenericList **list, size_t size)

{

    assert(list && size >= sizeof(GenericList));

    return v->next_list(v, list, size);

}
 and probability:0.2
code:static void *vring_map(MemoryRegion **mr, hwaddr phys, hwaddr len,

                       bool is_write)

{

    MemoryRegionSection section = memory_region_find(get_system_memory(), phys, len);



    if (!section.mr || int128_get64(section.size) < len) {

        goto out;

    }

    if (is_write && section.readonly) {

        goto out;

    }

    if (!memory_region_is_ram(section.mr)) {

        goto out;

    }



    /* Ignore regions with dirty logging, we cannot mark them dirty */

    if (memory_region_is_logging(section.mr)) {

        goto out;

    }



    *mr = section.mr;

    return memory_region_get_ram_ptr(section.mr) + section.offset_within_region;



out:

    memory_region_unref(section.mr);

    *mr = NULL;

    return NULL;

}
 and probability:0.125
code:uint32_t ldl_be_phys(target_phys_addr_t addr)

{

    return ldl_phys_internal(addr, DEVICE_BIG_ENDIAN);

}
 and probability:0.0
code:stream_push(StreamSlave *sink, uint8_t *buf, size_t len, uint32_t *app)

{

    StreamSlaveClass *k =  STREAM_SLAVE_GET_CLASS(sink);



    return k->push(sink, buf, len, app);

}
 and probability:0.4
code:static int raw_write(BlockDriverState *bs, int64_t sector_num,

                     const uint8_t *buf, int nb_sectors)

{

    return bdrv_write(bs->file, sector_num, buf, nb_sectors);

}
 and probability:0.2
code:static void tftp_handle_rrq(Slirp *slirp, struct tftp_t *tp, int pktlen)

{

  struct tftp_session *spt;

  int s, k;

  size_t prefix_len;

  char *req_fname;



  /* check if a session already exists and if so terminate it */

  s = tftp_session_find(slirp, tp);

  if (s >= 0) {

    tftp_session_terminate(&slirp->tftp_sessions[s]);

  }



  s = tftp_session_allocate(slirp, tp);



  if (s < 0) {

    return;

  }



  spt = &slirp->tftp_sessions[s];



  /* unspecifed prefix means service disabled */

  if (!slirp->tftp_prefix) {

      tftp_send_error(spt, 2, "Access violation", tp);

      return;

  }



  /* skip header fields */

  k = 0;

  pktlen -= ((uint8_t *)&tp->x.tp_buf[0] - (uint8_t *)tp);



  /* prepend tftp_prefix */

  prefix_len = strlen(slirp->tftp_prefix);

  spt->filename = qemu_malloc(prefix_len + TFTP_FILENAME_MAX + 2);

  memcpy(spt->filename, slirp->tftp_prefix, prefix_len);

  spt->filename[prefix_len] = '/';



  /* get name */

  req_fname = spt->filename + prefix_len + 1;



  while (1) {

    if (k >= TFTP_FILENAME_MAX || k >= pktlen) {

      tftp_send_error(spt, 2, "Access violation", tp);

      return;

    }

    req_fname[k] = (char)tp->x.tp_buf[k];

    if (req_fname[k++] == '\0') {

      break;

    }

  }



  /* check mode */

  if ((pktlen - k) < 6) {

    tftp_send_error(spt, 2, "Access violation", tp);

    return;

  }



  if (memcmp(&tp->x.tp_buf[k], "octet\0", 6) != 0) {

      tftp_send_error(spt, 4, "Unsupported transfer mode", tp);

      return;

  }



  k += 6; /* skipping octet */



  /* do sanity checks on the filename */

  if (!strncmp(req_fname, "../", 3) ||

      req_fname[strlen(req_fname) - 1] == '/' ||

      strstr(req_fname, "/../")) {

      tftp_send_error(spt, 2, "Access violation", tp);

      return;

  }



  /* check if the file exists */

  if (tftp_read_data(spt, 0, NULL, 0) < 0) {

      tftp_send_error(spt, 1, "File not found", tp);

      return;

  }



  if (tp->x.tp_buf[pktlen - 1] != 0) {

      tftp_send_error(spt, 2, "Access violation", tp);

      return;

  }



  while (k < pktlen) {

      const char *key, *value;



      key = (const char *)&tp->x.tp_buf[k];

      k += strlen(key) + 1;



      if (k >= pktlen) {

	  tftp_send_error(spt, 2, "Access violation", tp);

	  return;

      }



      value = (const char *)&tp->x.tp_buf[k];

      k += strlen(value) + 1;



      if (strcmp(key, "tsize") == 0) {

	  int tsize = atoi(value);

	  struct stat stat_p;



	  if (tsize == 0) {

	      if (stat(spt->filename, &stat_p) == 0)

		  tsize = stat_p.st_size;

	      else {

		  tftp_send_error(spt, 1, "File not found", tp);

		  return;

	      }

	  }



	  tftp_send_oack(spt, "tsize", tsize, tp);

	  return;

      }

  }



  tftp_send_data(spt, 1, tp);

}
 and probability:0.22340425531914893
code:static MegasasCmd *megasas_next_frame(MegasasState *s,

    target_phys_addr_t frame)

{

    MegasasCmd *cmd = NULL;

    int num = 0, index;



    cmd = megasas_lookup_frame(s, frame);

    if (cmd) {

        trace_megasas_qf_found(cmd->index, cmd->pa);

        return cmd;

    }

    index = s->reply_queue_head;

    num = 0;

    while (num < s->fw_cmds) {

        if (!s->frames[index].pa) {

            cmd = &s->frames[index];

            break;

        }

        index = megasas_next_index(s, index, s->fw_cmds);

        num++;

    }

    if (!cmd) {

        trace_megasas_qf_failed(frame);

    }

    trace_megasas_qf_new(index, cmd);

    return cmd;

}
 and probability:0.2692307692307692
code:static int hnm_decode_frame(AVCodecContext *avctx, void *data,

                            int *got_frame, AVPacket *avpkt)

{

    AVFrame *frame = data;

    Hnm4VideoContext *hnm = avctx->priv_data;

    int ret;

    uint16_t chunk_id;



    if (avpkt->size < 8) {






    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)

        return ret;



    chunk_id = AV_RL16(avpkt->data + 4);



    if (chunk_id == HNM4_CHUNK_ID_PL) {

        hnm_update_palette(avctx, avpkt->data, avpkt->size);

        frame->palette_has_changed = 1;

    } else if (chunk_id == HNM4_CHUNK_ID_IZ) {





        unpack_intraframe(avctx, avpkt->data + 12, avpkt->size - 12);

        memcpy(hnm->previous, hnm->current, hnm->width * hnm->height);

        if (hnm->version == 0x4a)

            memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);

        else

            postprocess_current_frame(avctx);

        copy_processed_frame(avctx, frame);

        frame->pict_type = AV_PICTURE_TYPE_I;

        frame->key_frame = 1;

        memcpy(frame->data[1], hnm->palette, 256 * 4);

        *got_frame = 1;

    } else if (chunk_id == HNM4_CHUNK_ID_IU) {

        if (hnm->version == 0x4a) {

            decode_interframe_v4a(avctx, avpkt->data + 8, avpkt->size - 8);

            memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);

        } else {

            decode_interframe_v4(avctx, avpkt->data + 8, avpkt->size - 8);

            postprocess_current_frame(avctx);


        copy_processed_frame(avctx, frame);

        frame->pict_type = AV_PICTURE_TYPE_P;

        frame->key_frame = 0;

        memcpy(frame->data[1], hnm->palette, 256 * 4);

        *got_frame = 1;

        hnm_flip_buffers(hnm);

    } else {

        av_log(avctx, AV_LOG_ERROR, "invalid chunk id: %d\n", chunk_id);





    return avpkt->size;
 and probability:0.5238095238095238
code:static void test_nesting(void)

{

    Coroutine *root;

    NestData nd = {

        .n_enter  = 0,

        .n_return = 0,

        .max      = 128,

    };



    root = qemu_coroutine_create(nest);

    qemu_coroutine_enter(root, &nd);



    /* Must enter and return from max nesting level */

    g_assert_cmpint(nd.n_enter, ==, nd.max);

    g_assert_cmpint(nd.n_return, ==, nd.max);

}
 and probability:0.0
code:static int fdctrl_connect_drives(FDCtrl *fdctrl)

{

    unsigned int i;

    FDrive *drive;



    for (i = 0; i < MAX_FD; i++) {

        drive = &fdctrl->drives[i];

        drive->fdctrl = fdctrl;



        if (drive->bs) {

            if (bdrv_get_on_error(drive->bs, 0) != BLOCK_ERR_STOP_ENOSPC) {

                error_report("fdc doesn't support drive option werror");

                return -1;

            }

            if (bdrv_get_on_error(drive->bs, 1) != BLOCK_ERR_REPORT) {

                error_report("fdc doesn't support drive option rerror");

                return -1;

            }

        }



        fd_init(drive);

        fd_revalidate(drive);

        if (drive->bs) {

            bdrv_set_dev_ops(drive->bs, &fdctrl_block_ops, drive);

        }

    }

    return 0;

}
 and probability:0.32
code:static int ac3_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    int err;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp = { av_be2ne64(state) };

    AC3HeaderInfo hdr, *phdr = &hdr;

    GetBitContext gbc;



    init_get_bits(&gbc, tmp.u8+8-AC3_HEADER_SIZE, 54);

    err = avpriv_ac3_parse_header2(&gbc, &phdr);



    if(err < 0)

        return 0;



    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->bit_rate = hdr.bit_rate;

    hdr_info->channels = hdr.channels;

    hdr_info->channel_layout = hdr.channel_layout;

    hdr_info->samples = hdr.num_blocks * 256;

    hdr_info->service_type = hdr.bitstream_mode;

    if (hdr.bitstream_mode == 0x7 && hdr.channels > 1)

        hdr_info->service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE;

    if(hdr.bitstream_id>10)

        hdr_info->codec_id = AV_CODEC_ID_EAC3;

    else if (hdr_info->codec_id == AV_CODEC_ID_NONE)

        hdr_info->codec_id = AV_CODEC_ID_AC3;



    *need_next_header = (hdr.frame_type != EAC3_FRAME_TYPE_AC3_CONVERT);

    *new_frame_start  = (hdr.frame_type != EAC3_FRAME_TYPE_DEPENDENT);

    return hdr.frame_size;

}
 and probability:0.43333333333333335
code:static bool use_goto_tb(DisasContext *ctx, target_ulong dest)

{

    /* Suppress goto_tb in the case of single-steping and IO.  */

    if ((ctx->base.tb->cflags & CF_LAST_IO) || ctx->base.singlestep_enabled) {

        return false;

    }

    return true;

}
 and probability:0.125
code:QEMUFile *qemu_bufopen(const char *mode, QEMUSizedBuffer *input)

{

    QEMUBuffer *s;



    if (mode == NULL || (mode[0] != 'r' && mode[0] != 'w') ||

        mode[1] != '\0') {

        error_report("qemu_bufopen: Argument validity check failed");

        return NULL;

    }



    s = g_malloc0(sizeof(QEMUBuffer));

    if (mode[0] == 'r') {

        s->qsb = input;

    }



    if (s->qsb == NULL) {

        s->qsb = qsb_create(NULL, 0);

    }

    if (!s->qsb) {

        g_free(s);

        error_report("qemu_bufopen: qsb_create failed");

        return NULL;

    }





    if (mode[0] == 'r') {

        s->file = qemu_fopen_ops(s, &buf_read_ops);

    } else {

        s->file = qemu_fopen_ops(s, &buf_write_ops);

    }

    return s->file;

}
 and probability:0.4074074074074074
code:static void mips_cpu_class_init(ObjectClass *c, void *data)

{

    MIPSCPUClass *mcc = MIPS_CPU_CLASS(c);

    CPUClass *cc = CPU_CLASS(c);

    DeviceClass *dc = DEVICE_CLASS(c);



    mcc->parent_realize = dc->realize;

    dc->realize = mips_cpu_realizefn;



    mcc->parent_reset = cc->reset;

    cc->reset = mips_cpu_reset;



    cc->has_work = mips_cpu_has_work;

    cc->do_interrupt = mips_cpu_do_interrupt;

    cc->cpu_exec_interrupt = mips_cpu_exec_interrupt;

    cc->dump_state = mips_cpu_dump_state;

    cc->set_pc = mips_cpu_set_pc;

    cc->synchronize_from_tb = mips_cpu_synchronize_from_tb;

    cc->gdb_read_register = mips_cpu_gdb_read_register;

    cc->gdb_write_register = mips_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = mips_cpu_handle_mmu_fault;

#else

    cc->do_unassigned_access = mips_cpu_unassigned_access;

    cc->do_unaligned_access = mips_cpu_do_unaligned_access;

    cc->get_phys_page_debug = mips_cpu_get_phys_page_debug;

    cc->vmsd = &vmstate_mips_cpu;

#endif

    cc->disas_set_info = mips_cpu_disas_set_info;



    cc->gdb_num_core_regs = 73;

    cc->gdb_stop_before_watchpoint = true;



    /*

     * Reason: mips_cpu_initfn() calls cpu_exec_init(), which saves

     * the object in cpus -> dangling pointer after final

     * object_unref().

     */

    dc->cannot_destroy_with_object_finalize_yet = true;

}
 and probability:0.6
code:static void check_pointer_type_change(Notifier *notifier, void *data)

{

    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);

    int absolute = qemu_input_is_absolute();



    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {

        vnc_lock_output(vs);

        vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);

        vnc_write_u8(vs, 0);

        vnc_write_u16(vs, 1);

        vnc_framebuffer_update(vs, absolute, 0,

                               surface_width(vs->vd->ds),

                               surface_height(vs->vd->ds),

                               VNC_ENCODING_POINTER_TYPE_CHANGE);

        vnc_unlock_output(vs);

        vnc_flush(vs);

    }

    vs->absolute = absolute;

}
 and probability:0.2222222222222222
code:static MMSSCPacketType get_tcp_server_response(MMSContext *mms)

{

    int read_result;

    MMSSCPacketType packet_type= -1;



    for(;;) {

        if((read_result= url_read_complete(mms->mms_hd, mms->in_buffer, 8))==8) {

            // handle command packet.

            if(AV_RL32(mms->in_buffer + 4)==0xb00bface) {

                mms->incoming_flags= mms->in_buffer[3];

                read_result= url_read_complete(mms->mms_hd, mms->in_buffer+8, 4);

                if(read_result == 4) {

                    int length_remaining= AV_RL32(mms->in_buffer+8) + 4;

                    int hr;



                    dprintf(NULL, "Length remaining is %d\n", length_remaining);

                    // read the rest of the packet.

                    if (length_remaining < 0

                        || length_remaining > sizeof(mms->in_buffer) - 12) {

                        dprintf(NULL, "Incoming message len %d exceeds buffer len %d\n",

                            length_remaining, sizeof(mms->in_buffer) - 12);



                    read_result = url_read_complete(mms->mms_hd, mms->in_buffer + 12,

                                                  length_remaining) ;

                    if (read_result == length_remaining) {

                        packet_type= AV_RL16(mms->in_buffer+36);

                    } else {

                        dprintf(NULL, "read for packet type failed%d!\n", read_result);








                } else {

                    dprintf(NULL, "read for length remaining failed%d!\n", read_result);



            } else {

                int length_remaining;

                int packet_id_type;

                int tmp;



                assert(mms->remaining_in_len==0);



                // note we cache the first 8 bytes,

                // then fill up the buffer with the others

                tmp                       = AV_RL16(mms->in_buffer + 6);

                length_remaining          = (tmp - 8) & 0xffff;

                mms->incoming_packet_seq  = AV_RL32(mms->in_buffer);

                packet_id_type            = mms->in_buffer[4];

                mms->incoming_flags       = mms->in_buffer[5];



                if (length_remaining < 0

                        || length_remaining > sizeof(mms->in_buffer) - 8) {

                    dprintf(NULL, "Incoming data len %d exceeds buffer len %d\n",

                            length_remaining, sizeof(mms->in_buffer));



                mms->remaining_in_len    = length_remaining;

                mms->read_in_ptr         = mms->in_buffer;

                read_result= url_read_complete(mms->mms_hd, mms->in_buffer, length_remaining);

                if(read_result != length_remaining) {

                    dprintf(NULL, "read_bytes result: %d asking for %d\n",

                            read_result, length_remaining);


                } else {

                    // if we successfully read everything.

                    if(packet_id_type == mms->header_packet_id) {

                        packet_type = SC_PKT_ASF_HEADER;

                        // Store the asf header

                        if(!mms->header_parsed) {

                            void *p = av_realloc(mms->asf_header,

                                              mms->asf_header_size

                                              + mms->remaining_in_len);

                            if (!p) {

                                av_freep(&mms->asf_header);

                                return AVERROR(ENOMEM);


                            mms->asf_header = p;

                            memcpy(mms->asf_header + mms->asf_header_size,

                                                 mms->read_in_ptr,

                                                 mms->remaining_in_len);

                            mms->asf_header_size += mms->remaining_in_len;


                    } else if(packet_id_type == mms->packet_id) {

                        packet_type = SC_PKT_ASF_MEDIA;

                    } else {

                        dprintf(NULL, "packet id type %d is old.", packet_id_type);

                        continue;






            // preprocess some packet type

            if(packet_type == SC_PKT_KEEPALIVE) {

                send_keepalive_packet(mms);

                continue;

            } else if(packet_type == SC_PKT_STREAM_CHANGING) {

                handle_packet_stream_changing_type(mms);

            } else if(packet_type == SC_PKT_ASF_MEDIA) {

                pad_media_packet(mms);


            return packet_type;

        } else {

            if(read_result<0) {

                dprintf(NULL, "Read error (or cancelled) returned %d!\n", read_result);

                packet_type = SC_PKT_CANCEL;

            } else {

                dprintf(NULL, "Read result of zero?!\n");

                packet_type = SC_PKT_NO_DATA;


            return packet_type;


 and probability:0.36363636363636365
code:get_sigframe(struct emulated_sigaction *ka, CPUX86State *env, size_t frame_size)

{

	unsigned long esp;



	/* Default to using normal stack */

	esp = env->regs[R_ESP];

#if 0

	/* This is the X/Open sanctioned signal stack switching.  */

	if (ka->sa.sa_flags & SA_ONSTACK) {

		if (sas_ss_flags(esp) == 0)

			esp = current->sas_ss_sp + current->sas_ss_size;

	}



	/* This is the legacy signal stack switching. */

	else if ((regs->xss & 0xffff) != __USER_DS &&

		 !(ka->sa.sa_flags & SA_RESTORER) &&

		 ka->sa.sa_restorer) {

		esp = (unsigned long) ka->sa.sa_restorer;

	}

#endif

	return (void *)((esp - frame_size) & -8ul);

}
 and probability:0.45
code:static uint32_t add_weights(uint32_t w1, uint32_t w2)

{

    uint32_t max = (w1 & 0xFF) > (w2 & 0xFF) ? (w1 & 0xFF) : (w2 & 0xFF);



    return ((w1 & 0xFFFFFF00) + (w2 & 0xFFFFFF00)) | (1 + max);

}
 and probability:0.2
code:static void decode_rlc_opc(CPUTriCoreState *env, DisasContext *ctx,

                           uint32_t op1)

{

    int32_t const16;

    int r1, r2;



    const16 = MASK_OP_RLC_CONST16_SEXT(ctx->opcode);

    r1      = MASK_OP_RLC_S1(ctx->opcode);

    r2      = MASK_OP_RLC_D(ctx->opcode);



    switch (op1) {

    case OPC1_32_RLC_ADDI:

        gen_addi_d(cpu_gpr_d[r2], cpu_gpr_d[r1], const16);

        break;

    case OPC1_32_RLC_ADDIH:

        gen_addi_d(cpu_gpr_d[r2], cpu_gpr_d[r1], const16 << 16);

        break;

    case OPC1_32_RLC_ADDIH_A:

        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r1], const16 << 16);

        break;

    case OPC1_32_RLC_MFCR:

        const16 = MASK_OP_RLC_CONST16(ctx->opcode);

        gen_mfcr(env, cpu_gpr_d[r2], const16);

        break;

    case OPC1_32_RLC_MOV:

        tcg_gen_movi_tl(cpu_gpr_d[r2], const16);

        break;

    case OPC1_32_RLC_MOV_64:

        if (tricore_feature(env, TRICORE_FEATURE_16)) {

            if ((r2 & 0x1) != 0) {

                /* TODO: raise OPD trap */

            }

            tcg_gen_movi_tl(cpu_gpr_d[r2], const16);

            tcg_gen_movi_tl(cpu_gpr_d[r2+1], const16 >> 15);

        } else {

            /* TODO: raise illegal opcode trap */

        }

        break;

    case OPC1_32_RLC_MOV_U:

        const16 = MASK_OP_RLC_CONST16(ctx->opcode);

        tcg_gen_movi_tl(cpu_gpr_d[r2], const16);

        break;

    case OPC1_32_RLC_MOV_H:

        tcg_gen_movi_tl(cpu_gpr_d[r2], const16 << 16);

        break;

    case OPC1_32_RLC_MOVH_A:

        tcg_gen_movi_tl(cpu_gpr_a[r2], const16 << 16);

        break;

    case OPC1_32_RLC_MTCR:

        const16 = MASK_OP_RLC_CONST16(ctx->opcode);

        gen_mtcr(env, ctx, cpu_gpr_d[r1], const16);

        break;

    }

}
 and probability:0.3269230769230769
code:static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical("Cannot lock pid file, %s", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical("Failed to truncate pid file");

        goto fail;

    }

    snprintf(pidstr, sizeof(pidstr), "%d\n", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical("Failed to write pid file");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
 and probability:0.038461538461538464
code:static void video_image_display(VideoState *is)

{

    Frame *vp;

    Frame *sp = NULL;

    SDL_Rect rect;



    vp = frame_queue_peek_last(&is->pictq);

    if (vp->bmp) {

        if (is->subtitle_st) {

            if (frame_queue_nb_remaining(&is->subpq) > 0) {

                sp = frame_queue_peek(&is->subpq);



                if (vp->pts >= sp->pts + ((float) sp->sub.start_display_time / 1000)) {

                    if (!sp->uploaded) {

                        uint8_t *pixels;

                        int pitch;

                        int i;

                        if (!sp->width || !sp->height) {

                            sp->width = vp->width;

                            sp->height = vp->height;

                        }

                        if (realloc_texture(&is->sub_texture, SDL_PIXELFORMAT_ARGB8888, sp->width, sp->height, SDL_BLENDMODE_BLEND, 1) < 0)

                            return;



                        for (i = 0; i < sp->sub.num_rects; i++) {

                            AVSubtitleRect *sub_rect = sp->sub.rects[i];



                            sub_rect->x = av_clip(sub_rect->x, 0, sp->width );

                            sub_rect->y = av_clip(sub_rect->y, 0, sp->height);

                            sub_rect->w = av_clip(sub_rect->w, 0, sp->width  - sub_rect->x);

                            sub_rect->h = av_clip(sub_rect->h, 0, sp->height - sub_rect->y);



                            is->sub_convert_ctx = sws_getCachedContext(is->sub_convert_ctx,

                                sub_rect->w, sub_rect->h, AV_PIX_FMT_PAL8,

                                sub_rect->w, sub_rect->h, AV_PIX_FMT_BGRA,

                                0, NULL, NULL, NULL);

                            if (!is->sub_convert_ctx) {

                                av_log(NULL, AV_LOG_FATAL, "Cannot initialize the conversion context\n");

                                return;

                            }

                            if (!SDL_LockTexture(is->sub_texture, (SDL_Rect *)sub_rect, (void **)&pixels, &pitch)) {

                                sws_scale(is->sub_convert_ctx, (const uint8_t * const *)sub_rect->data, sub_rect->linesize,

                                          0, sub_rect->h, &pixels, &pitch);

                                SDL_UnlockTexture(is->sub_texture);

                            }

                        }

                        sp->uploaded = 1;

                    }

                } else

                    sp = NULL;

            }

        }



        calculate_display_rect(&rect, is->xleft, is->ytop, is->width, is->height, vp->width, vp->height, vp->sar);



        if (!vp->uploaded) {

            if (upload_texture(vp->bmp, vp->frame, &is->img_convert_ctx) < 0)

                return;

            vp->uploaded = 1;

            vp->flip_v = vp->frame->linesize[0] < 0;

        }



        SDL_RenderCopyEx(renderer, vp->bmp, NULL, &rect, 0, NULL, vp->flip_v ? SDL_FLIP_VERTICAL : 0);

        if (sp) {

#if USE_ONEPASS_SUBTITLE_RENDER

            SDL_RenderCopy(renderer, is->sub_texture, NULL, &rect);

#else

            int i;

            double xratio = (double)rect.w / (double)sp->width;

            double yratio = (double)rect.h / (double)sp->height;

            for (i = 0; i < sp->sub.num_rects; i++) {

                SDL_Rect *sub_rect = (SDL_Rect*)sp->sub.rects[i];

                SDL_Rect target = {.x = rect.x + sub_rect->x * xratio,

                                   .y = rect.y + sub_rect->y * yratio,

                                   .w = sub_rect->w * xratio,

                                   .h = sub_rect->h * yratio};

                SDL_RenderCopy(renderer, is->sub_texture, sub_rect, &target);

            }

#endif

        }

    }

}
 and probability:0.5675675675675675
code:static int rtmp_server_handshake(URLContext *s, RTMPContext *rt)

{

    uint8_t buffer[RTMP_HANDSHAKE_PACKET_SIZE];

    uint32_t hs_epoch;

    uint32_t hs_my_epoch;

    uint8_t hs_c1[RTMP_HANDSHAKE_PACKET_SIZE];

    uint8_t hs_s1[RTMP_HANDSHAKE_PACKET_SIZE];

    uint32_t zeroes;

    uint32_t temp       = 0;

    int randomidx       = 0;

    int inoutsize       = 0;

    int ret;



    inoutsize = ffurl_read_complete(rt->stream, buffer, 1);       // Receive C0

    if (inoutsize <= 0) {

        av_log(s, AV_LOG_ERROR, "Unable to read handshake\n");

        return AVERROR(EIO);

    }

    // Check Version

    if (buffer[0] != 3) {

        av_log(s, AV_LOG_ERROR, "RTMP protocol version mismatch\n");

        return AVERROR(EIO);

    }

    if (ffurl_write(rt->stream, buffer, 1) <= 0) {                 // Send S0

        av_log(s, AV_LOG_ERROR,

               "Unable to write answer - RTMP S0\n");

        return AVERROR(EIO);

    }

    /* Receive C1 */

    ret = rtmp_receive_hs_packet(rt, &hs_epoch, &zeroes, hs_c1,

                                 RTMP_HANDSHAKE_PACKET_SIZE);

    if (ret) {

        av_log(s, AV_LOG_ERROR, "RTMP Handshake C1 Error\n");

        return ret;

    }

    if (zeroes)

        av_log(s, AV_LOG_WARNING, "Erroneous C1 Message zero != 0\n");

    /* Send S1 */

    /* By now same epoch will be sent */

    hs_my_epoch = hs_epoch;

    /* Generate random */

    for (randomidx = 0; randomidx < (RTMP_HANDSHAKE_PACKET_SIZE);

         randomidx += 4)

        AV_WB32(hs_s1 + 8 + randomidx, av_get_random_seed());



    ret = rtmp_send_hs_packet(rt, hs_my_epoch, 0, hs_s1,

                              RTMP_HANDSHAKE_PACKET_SIZE);

    if (ret) {

        av_log(s, AV_LOG_ERROR, "RTMP Handshake S1 Error\n");

        return ret;

    }

    /* Send S2 */

    ret = rtmp_send_hs_packet(rt, hs_epoch, 0, hs_c1,

                              RTMP_HANDSHAKE_PACKET_SIZE);

    if (ret) {

        av_log(s, AV_LOG_ERROR, "RTMP Handshake S2 Error\n");

        return ret;

    }

    /* Receive C2 */

    ret = rtmp_receive_hs_packet(rt, &temp, &zeroes, buffer,

                                 RTMP_HANDSHAKE_PACKET_SIZE);

    if (ret) {

        av_log(s, AV_LOG_ERROR, "RTMP Handshake C2 Error\n");

        return ret;

    }

    if (temp != hs_my_epoch)

        av_log(s, AV_LOG_WARNING,

               "Erroneous C2 Message epoch does not match up with C1 epoch\n");

    if (memcmp(buffer + 8, hs_s1 + 8,

               RTMP_HANDSHAKE_PACKET_SIZE - 8))

        av_log(s, AV_LOG_WARNING,

               "Erroneous C2 Message random does not match up\n");



    return 0;

}
 and probability:0.09722222222222222
code:int hw_device_setup_for_encode(OutputStream *ost)

{

    enum AVHWDeviceType type;

    HWDevice *dev;



    type = hw_device_match_type_in_name(ost->enc->name);

    if (type != AV_HWDEVICE_TYPE_NONE) {

        dev = hw_device_get_by_type(type);

        if (!dev) {

            av_log(ost->enc_ctx, AV_LOG_WARNING, "No device available "

                   "for encoder (device type %s for codec %s).\n",

                   av_hwdevice_get_type_name(type), ost->enc->name);

            return 0;

        }

        ost->enc_ctx->hw_device_ctx = av_buffer_ref(dev->device_ref);

        if (!ost->enc_ctx->hw_device_ctx)

            return AVERROR(ENOMEM);

        return 0;

    } else {

        // No device required.

        return 0;

    }

}
 and probability:0.22727272727272727
code:e1000e_cleanup_msix(E1000EState *s)

{

    if (msix_enabled(PCI_DEVICE(s))) {

        e1000e_unuse_msix_vectors(s, E1000E_MSIX_VEC_NUM);

        msix_uninit(PCI_DEVICE(s), &s->msix, &s->msix);

    }

}
 and probability:0.2857142857142857
code:ASSStyle *ff_ass_style_get(ASSSplitContext *ctx, const char *style)

{

    ASS *ass = &ctx->ass;

    int i;



    if (!style || !*style)

        style = "Default";

    for (i=0; i<ass->styles_count; i++)

        if (!strcmp(ass->styles[i].name, style))

            return ass->styles + i;

    return NULL;

}
 and probability:0.45454545454545453
code:static void vnc_dpy_copy(DisplayChangeListener *dcl,
                         int src_x, int src_y,
                         int dst_x, int dst_y, int w, int h)
{
    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);
    VncState *vs, *vn;
    uint8_t *src_row;
    uint8_t *dst_row;
    int i, x, y, pitch, inc, w_lim, s;
    int cmp_bytes;
    vnc_refresh_server_surface(vd);
    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {
        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {
            vs->force_update = 1;
            vnc_update_client(vs, 1, true);
            /* vs might be free()ed here */
    /* do bitblit op on the local surface too */
    pitch = vnc_server_fb_stride(vd);
    src_row = vnc_server_fb_ptr(vd, src_x, src_y);
    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);
    y = dst_y;
    inc = 1;
    if (dst_y > src_y) {
        /* copy backwards */
        src_row += pitch * (h-1);
        dst_row += pitch * (h-1);
        pitch = -pitch;
        y = dst_y + h - 1;
        inc = -1;
    w_lim = w - (VNC_DIRTY_PIXELS_PER_BIT - (dst_x % VNC_DIRTY_PIXELS_PER_BIT));
    if (w_lim < 0) {
        w_lim = w;
    } else {
        w_lim = w - (w_lim % VNC_DIRTY_PIXELS_PER_BIT);
    for (i = 0; i < h; i++) {
        for (x = 0; x <= w_lim;
                x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {
            if (x == w_lim) {
                if ((s = w - w_lim) == 0)
                    break;
            } else if (!x) {
                s = (VNC_DIRTY_PIXELS_PER_BIT -
                    (dst_x % VNC_DIRTY_PIXELS_PER_BIT));
                s = MIN(s, w_lim);
            } else {
                s = VNC_DIRTY_PIXELS_PER_BIT;
            cmp_bytes = s * VNC_SERVER_FB_BYTES;
            if (memcmp(src_row, dst_row, cmp_bytes) == 0)
                continue;
            memmove(dst_row, src_row, cmp_bytes);
            QTAILQ_FOREACH(vs, &vd->clients, next) {
                if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {
                    set_bit(((x + dst_x) / VNC_DIRTY_PIXELS_PER_BIT),
                            vs->dirty[y]);
        src_row += pitch - w * VNC_SERVER_FB_BYTES;
        dst_row += pitch - w * VNC_SERVER_FB_BYTES;
        y += inc;
    QTAILQ_FOREACH(vs, &vd->clients, next) {
        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {
            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h); and probability:0.3333333333333333
code:static inline void RENAME(yuv2yuvX)(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, long dstW, long chrDstW)

{

#ifdef HAVE_MMX

        if(c->flags & SWS_ACCURATE_RND){

                if(uDest){

                        YSCALEYUV2YV12X_ACCURATE(   0, CHR_MMX_FILTER_OFFSET, uDest, chrDstW)

                        YSCALEYUV2YV12X_ACCURATE(4096, CHR_MMX_FILTER_OFFSET, vDest, chrDstW)

                }



                YSCALEYUV2YV12X_ACCURATE(0, LUM_MMX_FILTER_OFFSET, dest, dstW)

        }else{

                if(uDest){

                        YSCALEYUV2YV12X(   0, CHR_MMX_FILTER_OFFSET, uDest, chrDstW)

                        YSCALEYUV2YV12X(4096, CHR_MMX_FILTER_OFFSET, vDest, chrDstW)

                }



                YSCALEYUV2YV12X(0, LUM_MMX_FILTER_OFFSET, dest, dstW)

        }

#else

#ifdef HAVE_ALTIVEC

yuv2yuvX_altivec_real(lumFilter, lumSrc, lumFilterSize,

		      chrFilter, chrSrc, chrFilterSize,

		      dest, uDest, vDest, dstW, chrDstW);

#else //HAVE_ALTIVEC

yuv2yuvXinC(lumFilter, lumSrc, lumFilterSize,

	    chrFilter, chrSrc, chrFilterSize,

	    dest, uDest, vDest, dstW, chrDstW);

#endif //!HAVE_ALTIVEC

#endif

}
 and probability:0.03333333333333333
code:static int vorbis_residue_decode(vorbis_context *vc, vorbis_residue *vr, uint_fast8_t ch, uint_fast8_t *do_not_decode, float *vec, uint_fast16_t vlen) {

    GetBitContext *gb=&vc->gb;

    uint_fast8_t c_p_c=vc->codebooks[vr->classbook].dimensions;

    uint_fast16_t n_to_read=vr->end-vr->begin;

    uint_fast16_t ptns_to_read=n_to_read/vr->partition_size;

    uint_fast8_t classifs[ptns_to_read*vc->audio_channels];

    uint_fast8_t pass;

    uint_fast8_t ch_used;

    uint_fast8_t i,j,l;

    uint_fast16_t k;



    if (vr->type==2) {

        for(j=1;j<ch;++j) {

                do_not_decode[0]&=do_not_decode[j];  // FIXME - clobbering input

        }

        if (do_not_decode[0]) return 0;

        ch_used=1;

    } else {

        ch_used=ch;

    }



    AV_DEBUG(" residue type 0/1/2 decode begin, ch: %d  cpc %d  \n", ch, c_p_c);



    for(pass=0;pass<=vr->maxpass;++pass) { // FIXME OPTIMIZE?

        uint_fast16_t voffset;

        uint_fast16_t partition_count;

        uint_fast16_t j_times_ptns_to_read;



        voffset=vr->begin;

        for(partition_count=0;partition_count<ptns_to_read;) {  // SPEC        error

            if (!pass) {

                uint_fast32_t inverse_class = ff_inverse[vr->classifications];

                for(j_times_ptns_to_read=0, j=0;j<ch_used;++j) {

                    if (!do_not_decode[j]) {

                        uint_fast32_t temp=get_vlc2(gb, vc->codebooks[vr->classbook].vlc.table,

                        vc->codebooks[vr->classbook].nb_bits, 3);



                        AV_DEBUG("Classword: %d \n", temp);



                        assert(vr->classifications > 1 && temp<=65536); //needed for inverse[]

                        for(i=0;i<c_p_c;++i) {

                            uint_fast32_t temp2;



                            temp2=(((uint_fast64_t)temp) * inverse_class)>>32;

                            if (partition_count+c_p_c-1-i < ptns_to_read) {

                                classifs[j_times_ptns_to_read+partition_count+c_p_c-1-i]=temp-temp2*vr->classifications;

                            }

                            temp=temp2;

                        }

                    }

                    j_times_ptns_to_read+=ptns_to_read;

                }

            }

            for(i=0;(i<c_p_c) && (partition_count<ptns_to_read);++i) {

                for(j_times_ptns_to_read=0, j=0;j<ch_used;++j) {

                    uint_fast16_t voffs;



                    if (!do_not_decode[j]) {

                        uint_fast8_t vqclass=classifs[j_times_ptns_to_read+partition_count];

                        int_fast16_t vqbook=vr->books[vqclass][pass];



                        if (vqbook>=0) {

                            uint_fast16_t coffs;

                            unsigned dim= vc->codebooks[vqbook].dimensions; // not uint_fast8_t: 64bit is slower here on amd64

                            uint_fast16_t step= dim==1 ? vr->partition_size

                                              : FASTDIV(vr->partition_size, dim);

                            vorbis_codebook codebook= vc->codebooks[vqbook];



                            if (vr->type==0) {



                                voffs=voffset+j*vlen;

                                for(k=0;k<step;++k) {

                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;

                                    for(l=0;l<dim;++l) {

                                        vec[voffs+k+l*step]+=codebook.codevectors[coffs+l];  // FPMATH

                                    }

                                }

                            }

                            else if (vr->type==1) {

                                voffs=voffset+j*vlen;

                                for(k=0;k<step;++k) {

                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;

                                    for(l=0;l<dim;++l, ++voffs) {

                                        vec[voffs]+=codebook.codevectors[coffs+l];  // FPMATH



                                        AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d  \n", pass, voffs, vec[voffs], codebook.codevectors[coffs+l], coffs);

                                    }

                                }

                            }

                            else if (vr->type==2 && ch==2 && (voffset&1)==0 && (dim&1)==0) { // most frequent case optimized

                                voffs=voffset>>1;



                                if(dim==2) {

                                    for(k=0;k<step;++k) {

                                        coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * 2;

                                        vec[voffs+k     ]+=codebook.codevectors[coffs  ];  // FPMATH

                                        vec[voffs+k+vlen]+=codebook.codevectors[coffs+1];  // FPMATH

                                    }

                                } else

                                for(k=0;k<step;++k) {

                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;

                                    for(l=0;l<dim;l+=2, voffs++) {

                                        vec[voffs     ]+=codebook.codevectors[coffs+l  ];  // FPMATH

                                        vec[voffs+vlen]+=codebook.codevectors[coffs+l+1];  // FPMATH



                                        AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n", pass, voffset/ch+(voffs%ch)*vlen, vec[voffset/ch+(voffs%ch)*vlen], codebook.codevectors[coffs+l], coffs, l);

                                    }

                                }



                            }

                            else if (vr->type==2) {

                                voffs=voffset;



                                for(k=0;k<step;++k) {

                                    coffs=get_vlc2(gb, codebook.vlc.table, codebook.nb_bits, 3) * dim;

                                    for(l=0;l<dim;++l, ++voffs) {

                                        vec[voffs/ch+(voffs%ch)*vlen]+=codebook.codevectors[coffs+l];  // FPMATH FIXME use if and counter instead of / and %



                                        AV_DEBUG(" pass %d offs: %d curr: %f change: %f cv offs.: %d+%d  \n", pass, voffset/ch+(voffs%ch)*vlen, vec[voffset/ch+(voffs%ch)*vlen], codebook.codevectors[coffs+l], coffs, l);

                                    }

                                }

                            } else {

                                av_log(vc->avccontext, AV_LOG_ERROR, " Invalid residue type while residue decode?! \n");

                                return 1;

                            }

                        }

                    }

                    j_times_ptns_to_read+=ptns_to_read;

                }

                ++partition_count;

                voffset+=vr->partition_size;

            }

        }

    }

    return 0;

}
 and probability:0.5462184873949579
code:static CharDriverState *qmp_chardev_open_parallel(ChardevHostdev *parallel,

                                                  Error **errp)

{

#ifdef HAVE_CHARDEV_PARPORT

    int fd;



    fd = qmp_chardev_open_file_source(parallel->device, O_RDWR, errp);

    if (error_is_set(errp)) {

        return NULL;

    }

    return qemu_chr_open_pp_fd(fd);

#else

    error_setg(errp, "character device backend type 'parallel' not supported");

    return NULL;

#endif

}
 and probability:0.06666666666666667
code:void cpu_exit(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);



    cpu->exit_request = 1;

    cpu_unlink_tb(cpu);

}
 and probability:0.16666666666666666
code:static int hdcd_envelope(int32_t *samples, int count, int stride, int gain, int target_gain, int extend)

{

    int i;

    int32_t *samples_end = samples + stride * count;



    if (extend) {

        for (i = 0; i < count; i++) {

            int32_t sample = samples[i * stride];

            int32_t asample = abs(sample) - 0x5981;

            if (asample >= 0)

                sample = sample >= 0 ? peaktab[asample] : -peaktab[asample];

            else

                sample <<= 15;



            samples[i * stride] = sample;

        }

    } else {

        for (i = 0; i < count; i++)

            samples[i * stride] <<= 15;

    }



    if (gain <= target_gain) {

        int len = FFMIN(count, target_gain - gain);

        /* attenuate slowly */

        for (i = 0; i < len; i++) {

            ++gain;

            APPLY_GAIN(*samples, gain);

            samples += stride;

        }

        count -= len;

    } else {

        int len = FFMIN(count, (gain - target_gain) >> 3);

        /* amplify quickly */

        for (i = 0; i < len; i++) {

            gain -= 8;

            APPLY_GAIN(*samples, gain);

            samples += stride;

        }

        if (gain - 8 < target_gain)

            gain = target_gain;

        count -= len;

    }



    /* hold a steady level */

    if (gain == 0) {

        if (count > 0)

            samples += count * stride;

    } else {

        while (--count >= 0) {

            APPLY_GAIN(*samples, gain);

            samples += stride;

        }

    }



    av_assert0(samples == samples_end);



    return gain;

}
 and probability:0.4807692307692308
code:static QObject *parse_array(JSONParserContext *ctxt, va_list *ap)

{

    QList *list = NULL;

    QObject *token, *peek;



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_LSQUARE);



    list = qlist_new();



    peek = parser_context_peek_token(ctxt);

    if (peek == NULL) {

        parse_error(ctxt, NULL, "premature EOI");

        goto out;

    }



    if (token_get_type(peek) != JSON_RSQUARE) {

        QObject *obj;



        obj = parse_value(ctxt, ap);

        if (obj == NULL) {

            parse_error(ctxt, token, "expecting value");

            goto out;

        }



        qlist_append_obj(list, obj);



        token = parser_context_pop_token(ctxt);

        if (token == NULL) {

            parse_error(ctxt, NULL, "premature EOI");

            goto out;

        }



        while (token_get_type(token) != JSON_RSQUARE) {

            if (token_get_type(token) != JSON_COMMA) {

                parse_error(ctxt, token, "expected separator in list");

                goto out;

            }



            obj = parse_value(ctxt, ap);

            if (obj == NULL) {

                parse_error(ctxt, token, "expecting value");

                goto out;

            }



            qlist_append_obj(list, obj);



            token = parser_context_pop_token(ctxt);

            if (token == NULL) {

                parse_error(ctxt, NULL, "premature EOI");

                goto out;

            }

        }

    } else {

        (void)parser_context_pop_token(ctxt);

    }



    return QOBJECT(list);



out:

    QDECREF(list);

    return NULL;

}
 and probability:0.0
code:static void raw_aio_unplug(BlockDriverState *bs)

{

#ifdef CONFIG_LINUX_AIO

    BDRVRawState *s = bs->opaque;

    if (s->use_aio) {

        laio_io_unplug(bs, s->aio_ctx, true);

    }

#endif

}
 and probability:0.3333333333333333
code:void hmp_info_tpm(Monitor *mon, const QDict *qdict)

{

    TPMInfoList *info_list, *info;

    Error *err = NULL;

    unsigned int c = 0;

    TPMPassthroughOptions *tpo;



    info_list = qmp_query_tpm(&err);

    if (err) {

        monitor_printf(mon, "TPM device not supported\n");

        error_free(err);

        return;

    }



    if (info_list) {

        monitor_printf(mon, "TPM device:\n");

    }



    for (info = info_list; info; info = info->next) {

        TPMInfo *ti = info->value;

        monitor_printf(mon, " tpm%d: model=%s\n",

                       c, TpmModel_lookup[ti->model]);



        monitor_printf(mon, "  \\ %s: type=%s",

                       ti->id, TpmTypeOptionsKind_lookup[ti->options->kind]);



        switch (ti->options->kind) {

        case TPM_TYPE_OPTIONS_KIND_PASSTHROUGH:

            tpo = ti->options->passthrough;

            monitor_printf(mon, "%s%s%s%s",

                           tpo->has_path ? ",path=" : "",

                           tpo->has_path ? tpo->path : "",

                           tpo->has_cancel_path ? ",cancel-path=" : "",

                           tpo->has_cancel_path ? tpo->cancel_path : "");

            break;

        case TPM_TYPE_OPTIONS_KIND_MAX:

            break;

        }

        monitor_printf(mon, "\n");

        c++;

    }

    qapi_free_TPMInfoList(info_list);

}
 and probability:0.2894736842105263
code:static void tap_set_sndbuf(TAPState *s, int sndbuf, Monitor *mon)

{

#ifdef TUNSETSNDBUF

    if (ioctl(s->fd, TUNSETSNDBUF, &sndbuf) == -1) {

        config_error(mon, "TUNSETSNDBUF ioctl failed: %s\n",

                     strerror(errno));

    }

#else

    config_error(mon, "No '-net tap,sndbuf=<nbytes>' support available\n");

#endif

}
 and probability:0.09090909090909091
code:ssize_t pcnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size_)

{

    PCNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;

    int is_padr = 0, is_bcast = 0, is_ladr = 0;

    uint8_t buf1[60];

    int remaining;

    int crc_err = 0;

    int size = size_;



    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)

        return -1;



#ifdef PCNET_DEBUG

    printf("pcnet_receive size=%d\n", size);

#endif



    /* if too small buffer, then expand it */

    if (size < MIN_BUF_SIZE) {

        memcpy(buf1, buf, size);

        memset(buf1 + size, 0, MIN_BUF_SIZE - size);

        buf = buf1;

        size = MIN_BUF_SIZE;

    }



    if (CSR_PROM(s)

        || (is_padr=padr_match(s, buf, size))

        || (is_bcast=padr_bcast(s, buf, size))

        || (is_ladr=ladr_match(s, buf, size))) {



        pcnet_rdte_poll(s);



        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {

            struct pcnet_RMD rmd;

            int rcvrc = CSR_RCVRC(s)-1,i;

            target_phys_addr_t nrda;

            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {

                if (rcvrc <= 1)

                    rcvrc = CSR_RCVRL(s);

                nrda = s->rdra +

                    (CSR_RCVRL(s) - rcvrc) *

                    (BCR_SWSTYLE(s) ? 16 : 8 );

                RMDLOAD(&rmd, nrda);

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

#ifdef PCNET_DEBUG_RMD

                    printf("pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\n",

                                rcvrc, CSR_RCVRC(s));

#endif

                    CSR_RCVRC(s) = rcvrc;

                    pcnet_rdte_poll(s);

                    break;

                }

            }

        }



        if (!(CSR_CRST(s) & 0x8000)) {

#ifdef PCNET_DEBUG_RMD

            printf("pcnet - no buffer: RCVRC=%d\n", CSR_RCVRC(s));

#endif

            s->csr[0] |= 0x1000; /* Set MISS flag */

            CSR_MISSC(s)++;

        } else {

            uint8_t *src = s->buffer;

            target_phys_addr_t crda = CSR_CRDA(s);

            struct pcnet_RMD rmd;

            int pktcount = 0;



            if (!s->looptest) {

                memcpy(src, buf, size);

                /* no need to compute the CRC */

                src[size] = 0;

                src[size + 1] = 0;

                src[size + 2] = 0;

                src[size + 3] = 0;

                size += 4;

            } else if (s->looptest == PCNET_LOOPTEST_CRC ||

                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[size])

                    CRC(fcs, *p++);

                *(uint32_t *)p = htonl(fcs);

                size += 4;

            } else {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[size-4])

                    CRC(fcs, *p++);

                crc_err = (*(uint32_t *)p != htonl(fcs));

            }



#ifdef PCNET_DEBUG_MATCH

            PRINT_PKTHDR(buf);

#endif



            RMDLOAD(&rmd, PHYSADDR(s,crda));

            /*if (!CSR_LAPPEN(s))*/

                SET_FIELD(&rmd.status, RMDS, STP, 1);



#define PCNET_RECV_STORE() do {                                 \

    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \

    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \

    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \

    src += count; remaining -= count;                           \

    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \

    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \

    pktcount++;                                                 \

} while (0)



            remaining = size;

            PCNET_RECV_STORE();

            if ((remaining > 0) && CSR_NRDA(s)) {

                target_phys_addr_t nrda = CSR_NRDA(s);

#ifdef PCNET_DEBUG_RMD

                PRINT_RMD(&rmd);

#endif

                RMDLOAD(&rmd, PHYSADDR(s,nrda));

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

                    crda = nrda;

                    PCNET_RECV_STORE();

#ifdef PCNET_DEBUG_RMD

                    PRINT_RMD(&rmd);

#endif

                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {

                        RMDLOAD(&rmd, PHYSADDR(s,nrda));

                        if (GET_FIELD(rmd.status, RMDS, OWN)) {

                            crda = nrda;

                            PCNET_RECV_STORE();

                        }

                    }

                }

            }



#undef PCNET_RECV_STORE



            RMDLOAD(&rmd, PHYSADDR(s,crda));

            if (remaining == 0) {

                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);

                SET_FIELD(&rmd.status, RMDS, ENP, 1);

                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);

                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);

                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);

                if (crc_err) {

                    SET_FIELD(&rmd.status, RMDS, CRC, 1);

                    SET_FIELD(&rmd.status, RMDS, ERR, 1);

                }

            } else {

                SET_FIELD(&rmd.status, RMDS, OFLO, 1);

                SET_FIELD(&rmd.status, RMDS, BUFF, 1);

                SET_FIELD(&rmd.status, RMDS, ERR, 1);

            }

            RMDSTORE(&rmd, PHYSADDR(s,crda));

            s->csr[0] |= 0x0400;



#ifdef PCNET_DEBUG

            printf("RCVRC=%d CRDA=0x%08x BLKS=%d\n",

                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);

#endif

#ifdef PCNET_DEBUG_RMD

            PRINT_RMD(&rmd);

#endif



            while (pktcount--) {

                if (CSR_RCVRC(s) <= 1)

                    CSR_RCVRC(s) = CSR_RCVRL(s);

                else

                    CSR_RCVRC(s)--;

            }



            pcnet_rdte_poll(s);



        }

    }



    pcnet_poll(s);

    pcnet_update_irq(s);



    return size_;

}
 and probability:0.20253164556962025
code:static void gen_stda_asi(DisasContext *dc, TCGv hi, TCGv addr,

                         int insn, int rd)

{

    TCGv_i32 r_asi, r_size;

    TCGv lo = gen_load_gpr(dc, rd + 1);

    TCGv_i64 t64 = tcg_temp_new_i64();



    tcg_gen_concat_tl_i64(t64, lo, hi);

    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(8);

    gen_helper_st_asi(cpu_env, addr, t64, r_asi, r_size);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

    tcg_temp_free_i64(t64);

}
 and probability:0.07142857142857142
code:void s390_pci_iommu_enable(S390PCIBusDevice *pbdev)

{

    memory_region_init_iommu(&pbdev->iommu_mr, OBJECT(&pbdev->mr),

                             &s390_iommu_ops, "iommu-s390", pbdev->pal + 1);

    memory_region_add_subregion(&pbdev->mr, 0, &pbdev->iommu_mr);

    pbdev->iommu_enabled = true;

}
 and probability:0.5714285714285714
code:void vnc_disconnect_finish(VncState *vs)

{

    int i;



    vnc_jobs_join(vs); /* Wait encoding jobs */



    vnc_lock_output(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_DISCONNECTED);



    buffer_free(&vs->input);

    buffer_free(&vs->output);

#ifdef CONFIG_VNC_WS

    buffer_free(&vs->ws_input);

    buffer_free(&vs->ws_output);

#endif /* CONFIG_VNC_WS */



    qapi_free_VncClientInfo(vs->info);



    vnc_zlib_clear(vs);

    vnc_tight_clear(vs);

    vnc_zrle_clear(vs);



#ifdef CONFIG_VNC_TLS

    vnc_tls_client_cleanup(vs);

#endif /* CONFIG_VNC_TLS */

#ifdef CONFIG_VNC_SASL

    vnc_sasl_client_cleanup(vs);

#endif /* CONFIG_VNC_SASL */

    audio_del(vs);

    vnc_release_modifiers(vs);



    if (vs->initialized) {

        QTAILQ_REMOVE(&vs->vd->clients, vs, next);

        qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);

    }



    if (vs->vd->lock_key_sync)

        qemu_remove_led_event_handler(vs->led);

    vnc_unlock_output(vs);



    qemu_mutex_destroy(&vs->output_mutex);

    if (vs->bh != NULL) {

        qemu_bh_delete(vs->bh);

    }

    buffer_free(&vs->jobs_buffer);



    for (i = 0; i < VNC_STAT_ROWS; ++i) {

        g_free(vs->lossy_rect[i]);

    }

    g_free(vs->lossy_rect);

    g_free(vs);

}
 and probability:0.40476190476190477
code:void msix_write_config(PCIDevice *dev, uint32_t addr,

                       uint32_t val, int len)

{

    unsigned enable_pos = dev->msix_cap + MSIX_CONTROL_OFFSET;

    if (addr + len <= enable_pos || addr > enable_pos)

        return;



    if (msix_enabled(dev))

        qemu_set_irq(dev->irq[0], 0);

}
 and probability:0.3333333333333333
code:type_init(pflash_cfi02_register_types)



pflash_t *pflash_cfi02_register(hwaddr base,

                                DeviceState *qdev, const char *name,

                                hwaddr size,

                                BlockDriverState *bs, uint32_t sector_len,

                                int nb_blocs, int nb_mappings, int width,

                                uint16_t id0, uint16_t id1,

                                uint16_t id2, uint16_t id3,

                                uint16_t unlock_addr0, uint16_t unlock_addr1,

                                int be)

{

    DeviceState *dev = qdev_create(NULL, TYPE_CFI_PFLASH02);



    if (bs && qdev_prop_set_drive(dev, "drive", bs)) {

        abort();

    }

    qdev_prop_set_uint32(dev, "num-blocks", nb_blocs);

    qdev_prop_set_uint32(dev, "sector-length", sector_len);

    qdev_prop_set_uint8(dev, "width", width);

    qdev_prop_set_uint8(dev, "mappings", nb_mappings);

    qdev_prop_set_uint8(dev, "big-endian", !!be);

    qdev_prop_set_uint16(dev, "id0", id0);

    qdev_prop_set_uint16(dev, "id1", id1);

    qdev_prop_set_uint16(dev, "id2", id2);

    qdev_prop_set_uint16(dev, "id3", id3);

    qdev_prop_set_uint16(dev, "unlock-addr0", unlock_addr0);

    qdev_prop_set_uint16(dev, "unlock-addr1", unlock_addr1);

    qdev_prop_set_string(dev, "name", name);

    qdev_init_nofail(dev);



    sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, base);

    return CFI_PFLASH02(dev);

}
 and probability:0.0
code:static void akita_init(int ram_size, int vga_ram_size, int boot_device,

                DisplayState *ds, const char **fd_filename, int snapshot,

                const char *kernel_filename, const char *kernel_cmdline,

                const char *initrd_filename, const char *cpu_model)

{

    spitz_common_init(ram_size, vga_ram_size, ds, kernel_filename,

                kernel_cmdline, initrd_filename, akita, 0x2e8);

}
 and probability:0.0
code:static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,

                            TCGMemOpIdx oi, bool is_64)

{

    TCGMemOp memop = get_memop(oi);

#ifdef CONFIG_SOFTMMU

    unsigned memi = get_mmuidx(oi);

    TCGReg addrz, param;

    tcg_insn_unit *func;

    tcg_insn_unit *label_ptr;



    addrz = tcg_out_tlb_load(s, addr, memi, memop & MO_SIZE,

                             offsetof(CPUTLBEntry, addr_read));



    /* The fast path is exactly one insn.  Thus we can perform the

       entire TLB Hit in the (annulled) delay slot of the branch

       over the TLB Miss case.  */



    /* beq,a,pt %[xi]cc, label0 */

    label_ptr = s->code_ptr;

    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT

                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);

    /* delay slot */

    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,

                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);



    /* TLB Miss.  */



    param = TCG_REG_O1;

    if (!SPARC64 && TARGET_LONG_BITS == 64) {

        /* Skip the high-part; we'll perform the extract in the trampoline.  */

        param++;

    }

    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);



    /* We use the helpers to extend SB and SW data, leaving the case

       of SL needing explicit extending below.  */

    if ((memop & MO_SSIZE) == MO_SL) {

        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SIZE)];

    } else {

        func = qemu_ld_trampoline[memop & (MO_BSWAP | MO_SSIZE)];

    }

    assert(func != NULL);

    tcg_out_call_nodelay(s, func);

    /* delay slot */

    tcg_out_movi(s, TCG_TYPE_I32, param, oi);



    /* Recall that all of the helpers return 64-bit results.

       Which complicates things for sparcv8plus.  */

    if (SPARC64) {

        /* We let the helper sign-extend SB and SW, but leave SL for here.  */

        if (is_64 && (memop & MO_SSIZE) == MO_SL) {

            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);

        } else {

            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);

        }

    } else {

        if ((memop & MO_SIZE) == MO_64) {

            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);

            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);

            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);

        } else if (is_64) {

            /* Re-extend from 32-bit rather than reassembling when we

               know the high register must be an extension.  */

            tcg_out_arithi(s, data, TCG_REG_O1, 0,

                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);

        } else {

            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);

        }

    }



    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));

#else

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);

        addr = TCG_REG_T1;

    }

    tcg_out_ldst_rr(s, data, addr,

                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),

                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);

#endif /* CONFIG_SOFTMMU */

}
 and probability:0.1095890410958904
code:petalogix_ml605_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    MemoryRegion *address_space_mem = get_system_memory();

    DeviceState *dev, *dma, *eth0;

    Object *peer;

    MicroBlazeCPU *cpu;

    SysBusDevice *busdev;

    CPUMBState *env;

    DriveInfo *dinfo;

    int i;

    hwaddr ddr_base = MEMORY_BASEADDR;

    MemoryRegion *phys_lmb_bram = g_new(MemoryRegion, 1);

    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);

    qemu_irq irq[32], *cpu_irq;



    /* init CPUs */

    if (cpu_model == NULL) {

        cpu_model = "microblaze";

    }

    cpu = cpu_mb_init(cpu_model);

    env = &cpu->env;



    /* Attach emulated BRAM through the LMB.  */

    memory_region_init_ram(phys_lmb_bram, "petalogix_ml605.lmb_bram",

                           LMB_BRAM_SIZE);

    vmstate_register_ram_global(phys_lmb_bram);

    memory_region_add_subregion(address_space_mem, 0x00000000, phys_lmb_bram);



    memory_region_init_ram(phys_ram, "petalogix_ml605.ram", ram_size);

    vmstate_register_ram_global(phys_ram);

    memory_region_add_subregion(address_space_mem, ddr_base, phys_ram);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    /* 5th parameter 2 means bank-width

     * 10th paremeter 0 means little-endian */

    pflash_cfi01_register(FLASH_BASEADDR,

                          NULL, "petalogix_ml605.flash", FLASH_SIZE,

                          dinfo ? dinfo->bdrv : NULL, (64 * 1024),

                          FLASH_SIZE >> 16,

                          2, 0x89, 0x18, 0x0000, 0x0, 0);





    cpu_irq = microblaze_pic_init_cpu(env);

    dev = xilinx_intc_create(INTC_BASEADDR, cpu_irq[0], 4);

    for (i = 0; i < 32; i++) {

        irq[i] = qdev_get_gpio_in(dev, i);

    }



    serial_mm_init(address_space_mem, UART16550_BASEADDR + 0x1000, 2,

                   irq[5], 115200, serial_hds[0], DEVICE_LITTLE_ENDIAN);



    /* 2 timers at irq 2 @ 100 Mhz.  */

    xilinx_timer_create(TIMER_BASEADDR, irq[2], 0, 100 * 1000000);



    /* axi ethernet and dma initialization. */

    qemu_check_nic_model(&nd_table[0], "xlnx.axi-ethernet");

    eth0 = qdev_create(NULL, "xlnx.axi-ethernet");

    dma = qdev_create(NULL, "xlnx.axi-dma");



    /* FIXME: attach to the sysbus instead */

    object_property_add_child(qdev_get_machine(), "xilinx-eth", OBJECT(eth0),

                              NULL);

    object_property_add_child(qdev_get_machine(), "xilinx-dma", OBJECT(dma),

                              NULL);



    peer = object_property_get_link(OBJECT(dma),

                                    "axistream-connected-target", NULL);

    xilinx_axiethernet_init(eth0, &nd_table[0], STREAM_SLAVE(peer),

                            0x82780000, irq[3], 0x1000, 0x1000);



    peer = object_property_get_link(OBJECT(eth0),

                                    "axistream-connected-target", NULL);

    xilinx_axidma_init(dma, STREAM_SLAVE(peer), 0x84600000, irq[1], irq[0],

                       100 * 1000000);



    {

        SSIBus *spi;



        dev = qdev_create(NULL, "xlnx.xps-spi");

        qdev_prop_set_uint8(dev, "num-ss-bits", NUM_SPI_FLASHES);

        qdev_init_nofail(dev);

        busdev = SYS_BUS_DEVICE(dev);

        sysbus_mmio_map(busdev, 0, 0x40a00000);

        sysbus_connect_irq(busdev, 0, irq[4]);



        spi = (SSIBus *)qdev_get_child_bus(dev, "spi");



        for (i = 0; i < NUM_SPI_FLASHES; i++) {

            qemu_irq cs_line;



            dev = ssi_create_slave(spi, "n25q128");

            cs_line = qdev_get_gpio_in(dev, 0);

            sysbus_connect_irq(busdev, i+1, cs_line);

        }

    }



    microblaze_load_kernel(cpu, ddr_base, ram_size, BINARY_DEVICE_TREE_FILE,

                                                            machine_cpu_reset);



}
 and probability:0.2289156626506024
code:void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)

{

    if (num <= VIRTQUEUE_MAX_SIZE) {

        vdev->vq[n].vring.num = num;

        virtqueue_init(&vdev->vq[n]);

    }

}
 and probability:0.2857142857142857
code:static void arm_cpu_realizefn(DeviceState *dev, Error **errp)

{

    CPUState *cs = CPU(dev);

    ARMCPU *cpu = ARM_CPU(dev);

    ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);

    CPUARMState *env = &cpu->env;

    int pagebits;

    Error *local_err = NULL;



    cpu_exec_realizefn(cs, &local_err);

    if (local_err != NULL) {

        error_propagate(errp, local_err);

        return;

    }



    /* Some features automatically imply others: */

    if (arm_feature(env, ARM_FEATURE_V8)) {

        set_feature(env, ARM_FEATURE_V7);

        set_feature(env, ARM_FEATURE_ARM_DIV);

        set_feature(env, ARM_FEATURE_LPAE);

    }

    if (arm_feature(env, ARM_FEATURE_V7)) {

        set_feature(env, ARM_FEATURE_VAPA);

        set_feature(env, ARM_FEATURE_THUMB2);

        set_feature(env, ARM_FEATURE_MPIDR);

        if (!arm_feature(env, ARM_FEATURE_M)) {

            set_feature(env, ARM_FEATURE_V6K);

        } else {

            set_feature(env, ARM_FEATURE_V6);

        }



        /* Always define VBAR for V7 CPUs even if it doesn't exist in

         * non-EL3 configs. This is needed by some legacy boards.

         */

        set_feature(env, ARM_FEATURE_VBAR);

    }

    if (arm_feature(env, ARM_FEATURE_V6K)) {

        set_feature(env, ARM_FEATURE_V6);

        set_feature(env, ARM_FEATURE_MVFR);

    }

    if (arm_feature(env, ARM_FEATURE_V6)) {

        set_feature(env, ARM_FEATURE_V5);

        if (!arm_feature(env, ARM_FEATURE_M)) {

            set_feature(env, ARM_FEATURE_AUXCR);

        }

    }

    if (arm_feature(env, ARM_FEATURE_V5)) {

        set_feature(env, ARM_FEATURE_V4T);

    }

    if (arm_feature(env, ARM_FEATURE_M)) {

        set_feature(env, ARM_FEATURE_THUMB_DIV);

    }

    if (arm_feature(env, ARM_FEATURE_ARM_DIV)) {

        set_feature(env, ARM_FEATURE_THUMB_DIV);

    }

    if (arm_feature(env, ARM_FEATURE_VFP4)) {

        set_feature(env, ARM_FEATURE_VFP3);

        set_feature(env, ARM_FEATURE_VFP_FP16);

    }

    if (arm_feature(env, ARM_FEATURE_VFP3)) {

        set_feature(env, ARM_FEATURE_VFP);

    }

    if (arm_feature(env, ARM_FEATURE_LPAE)) {

        set_feature(env, ARM_FEATURE_V7MP);

        set_feature(env, ARM_FEATURE_PXN);

    }

    if (arm_feature(env, ARM_FEATURE_CBAR_RO)) {

        set_feature(env, ARM_FEATURE_CBAR);

    }

    if (arm_feature(env, ARM_FEATURE_THUMB2) &&

        !arm_feature(env, ARM_FEATURE_M)) {

        set_feature(env, ARM_FEATURE_THUMB_DSP);

    }



    if (arm_feature(env, ARM_FEATURE_V7) &&

        !arm_feature(env, ARM_FEATURE_M) &&

        !arm_feature(env, ARM_FEATURE_MPU)) {

        /* v7VMSA drops support for the old ARMv5 tiny pages, so we

         * can use 4K pages.

         */

        pagebits = 12;

    } else {

        /* For CPUs which might have tiny 1K pages, or which have an

         * MPU and might have small region sizes, stick with 1K pages.

         */

        pagebits = 10;

    }

    if (!set_preferred_target_page_bits(pagebits)) {

        /* This can only ever happen for hotplugging a CPU, or if

         * the board code incorrectly creates a CPU which it has

         * promised via minimum_page_size that it will not.

         */

        error_setg(errp, "This CPU requires a smaller page size than the "

                   "system is using");

        return;

    }



    /* This cpu-id-to-MPIDR affinity is used only for TCG; KVM will override it.

     * We don't support setting cluster ID ([16..23]) (known as Aff2

     * in later ARM ARM versions), or any of the higher affinity level fields,

     * so these bits always RAZ.

     */

    if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {

        uint32_t Aff1 = cs->cpu_index / ARM_DEFAULT_CPUS_PER_CLUSTER;

        uint32_t Aff0 = cs->cpu_index % ARM_DEFAULT_CPUS_PER_CLUSTER;

        cpu->mp_affinity = (Aff1 << ARM_AFF1_SHIFT) | Aff0;

    }



    if (cpu->reset_hivecs) {

            cpu->reset_sctlr |= (1 << 13);

    }



    if (cpu->cfgend) {

        if (arm_feature(&cpu->env, ARM_FEATURE_V7)) {

            cpu->reset_sctlr |= SCTLR_EE;

        } else {

            cpu->reset_sctlr |= SCTLR_B;

        }

    }



    if (!cpu->has_el3) {

        /* If the has_el3 CPU property is disabled then we need to disable the

         * feature.

         */

        unset_feature(env, ARM_FEATURE_EL3);



        /* Disable the security extension feature bits in the processor feature

         * registers as well. These are id_pfr1[7:4] and id_aa64pfr0[15:12].

         */

        cpu->id_pfr1 &= ~0xf0;

        cpu->id_aa64pfr0 &= ~0xf000;

    }



    if (!cpu->has_el2) {

        unset_feature(env, ARM_FEATURE_EL2);

    }



    if (!cpu->has_pmu || !kvm_enabled()) {

        cpu->has_pmu = false;

        unset_feature(env, ARM_FEATURE_PMU);

    }



    if (!arm_feature(env, ARM_FEATURE_EL2)) {

        /* Disable the hypervisor feature bits in the processor feature

         * registers if we don't have EL2. These are id_pfr1[15:12] and

         * id_aa64pfr0_el1[11:8].

         */

        cpu->id_aa64pfr0 &= ~0xf00;

        cpu->id_pfr1 &= ~0xf000;

    }



    if (!cpu->has_mpu) {

        unset_feature(env, ARM_FEATURE_MPU);

    }



    if (arm_feature(env, ARM_FEATURE_MPU) &&

        arm_feature(env, ARM_FEATURE_V7)) {

        uint32_t nr = cpu->pmsav7_dregion;



        if (nr > 0xff) {

            error_setg(errp, "PMSAv7 MPU #regions invalid %" PRIu32, nr);

            return;

        }



        if (nr) {

            env->pmsav7.drbar = g_new0(uint32_t, nr);

            env->pmsav7.drsr = g_new0(uint32_t, nr);

            env->pmsav7.dracr = g_new0(uint32_t, nr);

        }

    }



    if (arm_feature(env, ARM_FEATURE_EL3)) {

        set_feature(env, ARM_FEATURE_VBAR);

    }



    register_cp_regs_for_features(cpu);

    arm_cpu_register_gdb_regs_for_features(cpu);



    init_cpreg_list(cpu);



#ifndef CONFIG_USER_ONLY

    if (cpu->has_el3) {

        cs->num_ases = 2;

    } else {

        cs->num_ases = 1;

    }



    if (cpu->has_el3) {

        AddressSpace *as;



        if (!cpu->secure_memory) {

            cpu->secure_memory = cs->memory;

        }

        as = address_space_init_shareable(cpu->secure_memory,

                                          "cpu-secure-memory");

        cpu_address_space_init(cs, as, ARMASIdx_S);

    }

    cpu_address_space_init(cs,

                           address_space_init_shareable(cs->memory,

                                                        "cpu-memory"),

                           ARMASIdx_NS);

#endif



    qemu_init_vcpu(cs);

    cpu_reset(cs);



    acc->parent_realize(dev, errp);

}
 and probability:0.1793478260869565
code:static bool nbd_process_legacy_socket_options(QDict *output_options,

                                              QemuOpts *legacy_opts,

                                              Error **errp)

{

    const char *path = qemu_opt_get(legacy_opts, "path");

    const char *host = qemu_opt_get(legacy_opts, "host");

    const char *port = qemu_opt_get(legacy_opts, "port");

    const QDictEntry *e;



    if (!path && !host && !port) {

        return true;

    }



    for (e = qdict_first(output_options); e; e = qdict_next(output_options, e))

    {

        if (strstart(e->key, "server.", NULL)) {

            error_setg(errp, "Cannot use 'server' and path/host/port at the "

                       "same time");

            return false;

        }

    }



    if (path && host) {

        error_setg(errp, "path and host may not be used at the same time");

        return false;

    } else if (path) {

        if (port) {

            error_setg(errp, "port may not be used without host");

            return false;

        }



        qdict_put(output_options, "server.type", qstring_from_str("unix"));

        qdict_put(output_options, "server.data.path", qstring_from_str(path));

    } else if (host) {

        qdict_put(output_options, "server.type", qstring_from_str("inet"));

        qdict_put(output_options, "server.data.host", qstring_from_str(host));

        qdict_put(output_options, "server.data.port",

                  qstring_from_str(port ?: stringify(NBD_DEFAULT_PORT)));

    }



    return true;

}
 and probability:0.02702702702702703
code:static void cirrus_linear_bitblt_write(void *opaque,

                                       target_phys_addr_t addr,

                                       uint64_t val,

                                       unsigned size)

{

    CirrusVGAState *s = opaque;



    if (s->cirrus_srcptr != s->cirrus_srcptr_end) {

	/* bitblt */

	*s->cirrus_srcptr++ = (uint8_t) val;

	if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {

	    cirrus_bitblt_cputovideo_next(s);

	}

    }

}
 and probability:0.21428571428571427
code:static int default_monitor_get_fd(Monitor *mon, const char *name, Error **errp)

{

    error_setg(errp, "only QEMU supports file descriptor passing");

    return -1;

}
 and probability:0.0
code:uint64_t helper_st_virt_to_phys (uint64_t virtaddr)

{

    uint64_t tlb_addr, physaddr;

    int index, mmu_idx;

    void *retaddr;



    mmu_idx = cpu_mmu_index(env);

    index = (virtaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

 redo:

    tlb_addr = env->tlb_table[mmu_idx][index].addr_write;

    if ((virtaddr & TARGET_PAGE_MASK) ==

        (tlb_addr & (TARGET_PAGE_MASK | TLB_INVALID_MASK))) {

        physaddr = virtaddr + env->tlb_table[mmu_idx][index].addend;

    } else {

        /* the page is not in the TLB : fill it */

        retaddr = GETPC();

        tlb_fill(virtaddr, 1, mmu_idx, retaddr);

        goto redo;

    }

    return physaddr;

}
 and probability:0.15
code:static int decode_recovery_point(H264Context *h)

{

    h->sei_recovery_frame_cnt = get_ue_golomb(&h->gb);



    /* 1b exact_match_flag,

     * 1b broken_link_flag,

     * 2b changing_slice_group_idc */

    skip_bits(&h->gb, 4);



    if (h->avctx->debug & FF_DEBUG_PICT_INFO)

        av_log(h->avctx, AV_LOG_DEBUG, "sei_recovery_frame_cnt: %d\n", h->sei_recovery_frame_cnt);



    h->has_recovery_point = 1;



    return 0;

}
 and probability:0.4166666666666667
code:static int mkv_write_header(AVFormatContext *s)

{

    MatroskaMuxContext *mkv = s->priv_data;

    AVIOContext *pb = s->pb;

    ebml_master ebml_header;

    AVDictionaryEntry *tag;

    int ret, i, version = 2;

    int64_t creation_time;



    if (!strcmp(s->oformat->name, "webm"))

        mkv->mode = MODE_WEBM;

    else

        mkv->mode = MODE_MATROSKAv2;



    if (mkv->mode != MODE_WEBM ||

        av_dict_get(s->metadata, "stereo_mode", NULL, 0) ||

        av_dict_get(s->metadata, "alpha_mode", NULL, 0))

        version = 4;



    for (i = 0; i < s->nb_streams; i++) {

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {

            av_log(s, AV_LOG_ERROR,

                   "The Matroska muxer does not yet support muxing %s\n",

                   avcodec_get_name(s->streams[i]->codecpar->codec_id));

            return AVERROR_PATCHWELCOME;

        }

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||

            av_dict_get(s->streams[i]->metadata, "stereo_mode", NULL, 0) ||

            av_dict_get(s->streams[i]->metadata, "alpha_mode", NULL, 0))

            version = 4;

    }



    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));

    if (!mkv->tracks) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);

    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);

    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);

    end_ebml_master(pb, ebml_header);



    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);

    mkv->segment_offset = avio_tell(pb);



    // we write 2 seek heads - one at the end of the file to point to each

    // cluster, and one at the beginning to point to all other level one

    // elements (including the seek head at the end of the file), which

    // isn't more than 10 elements if we only write one of each other

    // currently defined level 1 element

    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);

    if (!mkv->main_seekhead) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));

    if (ret < 0) goto fail;



    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);

    if (ret < 0)

        return ret;

    pb = mkv->info_bc;



    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);

    if ((tag = av_dict_get(s->metadata, "title", NULL, 0)))

        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);

    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);

        if ((tag = av_dict_get(s->metadata, "encoding_tool", NULL, 0)))

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);

        else

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);



        if (mkv->mode != MODE_WEBM) {

            uint32_t segment_uid[4];

            AVLFG lfg;



            av_lfg_init(&lfg, av_get_random_seed());



            for (i = 0; i < 4; i++)

                segment_uid[i] = av_lfg_get(&lfg);



            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);

        }

    } else {

        const char *ident = "Lavf";

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);

        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);

    }



    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {

        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.

        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;

        uint8_t date_utc_buf[8];

        AV_WB64(date_utc_buf, date_utc);

        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);

    }



    // reserve space for the duration

    mkv->duration = 0;

    mkv->duration_offset = avio_tell(pb);

    if (!mkv->is_live) {

        int64_t metadata_duration = get_metadata_duration(s);



        if (s->duration > 0) {

            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration);

        } else if (metadata_duration > 0) {

            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration);

        } else {

            put_ebml_void(pb, 11);              // assumes double-precision float to be written

        }

    }

    if (s->pb->seekable && !mkv->is_live)

        put_ebml_void(s->pb, avio_tell(pb));

    else

        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);

    pb = s->pb;



    // initialize stream_duration fields

    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));

    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));



    ret = mkv_write_tracks(s);

    if (ret < 0)

        goto fail;



    for (i = 0; i < s->nb_chapters; i++)

        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);



    if (mkv->mode != MODE_WEBM) {

        ret = mkv_write_chapters(s);

        if (ret < 0)

            goto fail;



        ret = mkv_write_attachments(s);

        if (ret < 0)

            goto fail;



        ret = mkv_write_tags(s);

        if (ret < 0)

            goto fail;

    }



    if (!s->pb->seekable && !mkv->is_live)

        mkv_write_seekhead(pb, mkv);



    mkv->cues = mkv_start_cues(mkv->segment_offset);

    if (!mkv->cues) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    if (pb->seekable && mkv->reserve_cues_space) {

        mkv->cues_pos = avio_tell(pb);

        put_ebml_void(pb, mkv->reserve_cues_space);

    }



    av_init_packet(&mkv->cur_audio_pkt);

    mkv->cur_audio_pkt.size = 0;

    mkv->cluster_pos = -1;



    avio_flush(pb);



    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or

    // after 4k and on a keyframe

    if (pb->seekable) {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 5000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 5 * 1024 * 1024;

    } else {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 1000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 32 * 1024;

    }



    return 0;

fail:

    mkv_free(mkv);

    return ret;

}
 and probability:0.4166666666666667
code:static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    uint32_t tmp;



    if (n < CPU_NB_REGS) {

        env->regs[gpr_map[n]] = ldtul_p(mem_buf);

        return sizeof(target_ulong);

    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {

#ifdef USE_X86LDOUBLE

        /* FIXME: byteswap float values - after fixing fpregs layout. */

        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);

#endif

        return 10;

    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {

        n -= IDX_XMM_REGS;

        env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);

        env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);

        return 16;

    } else {

        switch (n) {

        case IDX_IP_REG:

            env->eip = ldtul_p(mem_buf);

            return sizeof(target_ulong);

        case IDX_FLAGS_REG:

            env->eflags = ldl_p(mem_buf);

            return 4;



#if defined(CONFIG_USER_ONLY)

#define LOAD_SEG(index, sreg)\

            tmp = ldl_p(mem_buf);\

            if (tmp != env->segs[sreg].selector)\

                cpu_x86_load_seg(env, sreg, tmp);\

            return 4

#else

/* FIXME: Honor segment registers.  Needs to avoid raising an exception

   when the selector is invalid.  */

#define LOAD_SEG(index, sreg) return 4

#endif

        case IDX_SEG_REGS:     LOAD_SEG(10, R_CS);

        case IDX_SEG_REGS + 1: LOAD_SEG(11, R_SS);

        case IDX_SEG_REGS + 2: LOAD_SEG(12, R_DS);

        case IDX_SEG_REGS + 3: LOAD_SEG(13, R_ES);

        case IDX_SEG_REGS + 4: LOAD_SEG(14, R_FS);

        case IDX_SEG_REGS + 5: LOAD_SEG(15, R_GS);



        case IDX_FP_REGS + 8:

            env->fpuc = ldl_p(mem_buf);

            return 4;

        case IDX_FP_REGS + 9:

            tmp = ldl_p(mem_buf);

            env->fpstt = (tmp >> 11) & 7;

            env->fpus = tmp & ~0x3800;

            return 4;

        case IDX_FP_REGS + 10: /* ftag */  return 4;

        case IDX_FP_REGS + 11: /* fiseg */ return 4;

        case IDX_FP_REGS + 12: /* fioff */ return 4;

        case IDX_FP_REGS + 13: /* foseg */ return 4;

        case IDX_FP_REGS + 14: /* fooff */ return 4;

        case IDX_FP_REGS + 15: /* fop */   return 4;



        case IDX_MXCSR_REG:

            env->mxcsr = ldl_p(mem_buf);

            return 4;

        }

    }

    /* Unrecognised register.  */

    return 0;

}
 and probability:0.421875
code:static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *set, CPUS390XState *env)

{

    int i;

    rt_sigframe *frame;

    abi_ulong frame_addr;



    frame_addr = get_sigframe(ka, env, sizeof *frame);

    qemu_log("%s: frame_addr 0x%llx\n", __FUNCTION__,

             (unsigned long long)frame_addr);

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    qemu_log("%s: 1\n", __FUNCTION__);

    copy_siginfo_to_user(&frame->info, info);



    /* Create the ucontext.  */

    __put_user(0, &frame->uc.tuc_flags);

    __put_user((abi_ulong)0, (abi_ulong *)&frame->uc.tuc_link);

    __put_user(target_sigaltstack_used.ss_sp, &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(get_sp_from_cpustate(env)),

                      &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size, &frame->uc.tuc_stack.ss_size);

    save_sigregs(env, &frame->uc.tuc_mcontext);

    for (i = 0; i < TARGET_NSIG_WORDS; i++) {

        __put_user((abi_ulong)set->sig[i],

        (abi_ulong *)&frame->uc.tuc_sigmask.sig[i]);

    }



    /* Set up to return from userspace.  If provided, use a stub

       already in userspace.  */

    if (ka->sa_flags & TARGET_SA_RESTORER) {

        env->regs[14] = (unsigned long) ka->sa_restorer | PSW_ADDR_AMODE;

    } else {

        env->regs[14] = (unsigned long) frame->retcode | PSW_ADDR_AMODE;

        if (__put_user(S390_SYSCALL_OPCODE | TARGET_NR_rt_sigreturn,

                       (uint16_t *)(frame->retcode))) {

            goto give_sigsegv;

        }

    }



    /* Set up backchain. */

    if (__put_user(env->regs[15], (abi_ulong *) frame)) {

        goto give_sigsegv;

    }



    /* Set up registers for signal handler */

    env->regs[15] = frame_addr;

    env->psw.addr = (target_ulong) ka->_sa_handler | PSW_ADDR_AMODE;



    env->regs[2] = sig; //map_signal(sig);

    env->regs[3] = frame_addr + offsetof(typeof(*frame), info);

    env->regs[4] = frame_addr + offsetof(typeof(*frame), uc);

    return;



give_sigsegv:

    qemu_log("%s: give_sigsegv\n", __FUNCTION__);

    unlock_user_struct(frame, frame_addr, 1);

    force_sig(TARGET_SIGSEGV);

}
 and probability:0.3888888888888889
code:static int dxv_decompress_dxt5(AVCodecContext *avctx)

{

    DXVContext *ctx = avctx->priv_data;

    GetByteContext *gbc = &ctx->gbc;

    uint32_t value, op;

    int idx, prev, state = 0;

    int pos = 4;

    int run = 0;

    int probe, check;



    /* Copy the first four elements */

    AV_WL32(ctx->tex_data +  0, bytestream2_get_le32(gbc));

    AV_WL32(ctx->tex_data +  4, bytestream2_get_le32(gbc));

    AV_WL32(ctx->tex_data +  8, bytestream2_get_le32(gbc));

    AV_WL32(ctx->tex_data + 12, bytestream2_get_le32(gbc));



    /* Process input until the whole texture has been filled */

    while (pos + 2 <= ctx->tex_size / 4) {

        if (run) {

            run--;



            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

            prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

        } else {



            if (state == 0) {

                value = bytestream2_get_le32(gbc);

                state = 16;

            }

            op = value & 0x3;

            value >>= 2;

            state--;



            switch (op) {

            case 0:

                /* Long copy */

                check = bytestream2_get_byte(gbc) + 1;

                if (check == 256) {

                    do {

                        probe = bytestream2_get_le16(gbc);

                        check += probe;

                    } while (probe == 0xFFFF);

                }

                while (check && pos + 4 <= ctx->tex_size / 4) {

                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                    AV_WL32(ctx->tex_data + 4 * pos, prev);

                    pos++;



                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                    AV_WL32(ctx->tex_data + 4 * pos, prev);

                    pos++;



                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                    AV_WL32(ctx->tex_data + 4 * pos, prev);

                    pos++;



                    prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                    AV_WL32(ctx->tex_data + 4 * pos, prev);

                    pos++;



                    check--;

                }



                /* Restart (or exit) the loop */

                continue;

                break;

            case 1:

                /* Load new run value */

                run = bytestream2_get_byte(gbc);

                if (run == 255) {

                    do {

                        probe = bytestream2_get_le16(gbc);

                        run += probe;

                    } while (probe == 0xFFFF);

                }



                /* Copy two dwords from previous data */

                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;



                prev = AV_RL32(ctx->tex_data + 4 * (pos - 4));

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;

                break;

            case 2:

                /* Copy two dwords from a previous index */

                idx = 8 + bytestream2_get_le16(gbc);

                if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)


                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;



                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;

                break;

            case 3:

                /* Copy two dwords from input */

                prev = bytestream2_get_le32(gbc);

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;



                prev = bytestream2_get_le32(gbc);

                AV_WL32(ctx->tex_data + 4 * pos, prev);

                pos++;

                break;

            }

        }



        CHECKPOINT(4);

        if (pos + 2 > ctx->tex_size / 4)




        /* Copy two elements from a previous offset or from the input buffer */

        if (op) {

            if (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4)


            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;



            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

        } else {

            CHECKPOINT(4);



            if (op && (idx > pos || (unsigned int)(pos - idx) + 2 > ctx->tex_size / 4))


            if (op)

                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            else

                prev = bytestream2_get_le32(gbc);

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;



            CHECKPOINT(4);



            if (op)

                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            else

                prev = bytestream2_get_le32(gbc);

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

        }

    }



    return 0;

} and probability:0.5
code:static void gd_update_geometry_hints(VirtualConsole *vc)

{

    GtkDisplayState *s = vc->s;

    GdkWindowHints mask = 0;

    GdkGeometry geo = {};

    GtkWidget *geo_widget = NULL;

    GtkWindow *geo_window;



    if (vc->type == GD_VC_GFX) {

        if (!vc->gfx.ds) {

            return;

        }

        if (s->free_scale) {

            geo.min_width  = surface_width(vc->gfx.ds) * VC_SCALE_MIN;

            geo.min_height = surface_height(vc->gfx.ds) * VC_SCALE_MIN;

            mask |= GDK_HINT_MIN_SIZE;

        } else {

            geo.min_width  = surface_width(vc->gfx.ds) * vc->gfx.scale_x;

            geo.min_height = surface_height(vc->gfx.ds) * vc->gfx.scale_y;

            mask |= GDK_HINT_MIN_SIZE;

        }

        geo_widget = vc->gfx.drawing_area;

        gtk_widget_set_size_request(geo_widget, geo.min_width, geo.min_height);



#if defined(CONFIG_VTE)

    } else if (vc->type == GD_VC_VTE) {

        VteTerminal *term = VTE_TERMINAL(vc->vte.terminal);

        GtkBorder *ib;



        geo.width_inc  = vte_terminal_get_char_width(term);

        geo.height_inc = vte_terminal_get_char_height(term);

        mask |= GDK_HINT_RESIZE_INC;

        geo.base_width  = geo.width_inc;

        geo.base_height = geo.height_inc;

        mask |= GDK_HINT_BASE_SIZE;

        geo.min_width  = geo.width_inc * VC_TERM_X_MIN;

        geo.min_height = geo.height_inc * VC_TERM_Y_MIN;

        mask |= GDK_HINT_MIN_SIZE;

        gtk_widget_style_get(vc->vte.terminal, "inner-border", &ib, NULL);

        geo.base_width  += ib->left + ib->right;

        geo.base_height += ib->top + ib->bottom;

        geo.min_width   += ib->left + ib->right;

        geo.min_height  += ib->top + ib->bottom;

        geo_widget = vc->vte.terminal;

#endif

    }



    geo_window = GTK_WINDOW(vc->window ? vc->window : s->window);

    gtk_window_set_geometry_hints(geo_window, geo_widget, &geo, mask);

}
 and probability:0.43478260869565216
code:static uint32_t cc_calc_abs_64(int64_t dst)

{

    if ((uint64_t)dst == 0x8000000000000000ULL) {

        return 3;

    } else if (dst) {

        return 1;

    } else {

        return 0;

    }

}
 and probability:0.0
code:static void virtio_serial_device_unrealize(DeviceState *dev, Error **errp)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
    VirtIOSerial *vser = VIRTIO_SERIAL(dev);
    QLIST_REMOVE(vser, next);
    g_free(vser->ivqs);
    g_free(vser->ovqs);
    g_free(vser->ports_map);
    if (vser->post_load) {
        g_free(vser->post_load->connected);
        timer_del(vser->post_load->timer);
        timer_free(vser->post_load->timer);
        g_free(vser->post_load);
    }
    virtio_cleanup(vdev);
} and probability:0.5
code:static int flashsv2_prime(FlashSVContext *s, uint8_t *src, int size)
{
    z_stream zs;
    int zret; // Zlib return code
    zs.zalloc = NULL;
    zs.zfree  = NULL;
    zs.opaque = NULL;
    s->zstream.next_in   = src;
    s->zstream.avail_in  = size;
    s->zstream.next_out  = s->tmpblock;
    s->zstream.avail_out = s->block_size * 3;
    inflate(&s->zstream, Z_SYNC_FLUSH);
    if (deflateInit(&zs, 0) != Z_OK)
        return -1;
    zs.next_in   = s->tmpblock;
    zs.avail_in  = s->block_size * 3 - s->zstream.avail_out;
    zs.next_out  = s->deflate_block;
    zs.avail_out = s->deflate_block_size;
    deflate(&zs, Z_SYNC_FLUSH);
    deflateEnd(&zs);
    if ((zret = inflateReset(&s->zstream)) != Z_OK) {
        av_log(s->avctx, AV_LOG_ERROR, "Inflate reset error: %d\n", zret);
        return AVERROR_UNKNOWN;
    }
    s->zstream.next_in   = s->deflate_block;
    s->zstream.avail_in  = s->deflate_block_size - zs.avail_out;
    s->zstream.next_out  = s->tmpblock;
    s->zstream.avail_out = s->block_size * 3;
    inflate(&s->zstream, Z_SYNC_FLUSH);
    return 0;
} and probability:0.5161290322580645
code:static void sbr_hf_assemble(int Y1[38][64][2],

                            const int X_high[64][40][2],

                            SpectralBandReplication *sbr, SBRData *ch_data,

                            const int e_a[2])

{

    int e, i, j, m;

    const int h_SL = 4 * !sbr->bs_smoothing_mode;

    const int kx = sbr->kx[1];

    const int m_max = sbr->m[1];

    static const SoftFloat h_smooth[5] = {

      { 715827883, -1 },

      { 647472402, -1 },

      { 937030863, -2 },

      { 989249804, -3 },

      { 546843842, -4 },

    };

    SoftFloat (*g_temp)[48] = ch_data->g_temp, (*q_temp)[48] = ch_data->q_temp;

    int indexnoise = ch_data->f_indexnoise;

    int indexsine  = ch_data->f_indexsine;



    if (sbr->reset) {

        for (i = 0; i < h_SL; i++) {

            memcpy(g_temp[i + 2*ch_data->t_env[0]], sbr->gain[0], m_max * sizeof(sbr->gain[0][0]));

            memcpy(q_temp[i + 2*ch_data->t_env[0]], sbr->q_m[0],  m_max * sizeof(sbr->q_m[0][0]));

        }

    } else if (h_SL) {

        for (i = 0; i < 4; i++) {

            memcpy(g_temp[i + 2 * ch_data->t_env[0]],

                   g_temp[i + 2 * ch_data->t_env_num_env_old],

                   sizeof(g_temp[0]));

            memcpy(q_temp[i + 2 * ch_data->t_env[0]],

                   q_temp[i + 2 * ch_data->t_env_num_env_old],

                   sizeof(q_temp[0]));

        }

    }



    for (e = 0; e < ch_data->bs_num_env; e++) {

        for (i = 2 * ch_data->t_env[e]; i < 2 * ch_data->t_env[e + 1]; i++) {

            memcpy(g_temp[h_SL + i], sbr->gain[e], m_max * sizeof(sbr->gain[0][0]));

            memcpy(q_temp[h_SL + i], sbr->q_m[e],  m_max * sizeof(sbr->q_m[0][0]));

        }

    }



    for (e = 0; e < ch_data->bs_num_env; e++) {

        for (i = 2 * ch_data->t_env[e]; i < 2 * ch_data->t_env[e + 1]; i++) {

            SoftFloat g_filt_tab[48];

            SoftFloat q_filt_tab[48];

            SoftFloat *g_filt, *q_filt;



            if (h_SL && e != e_a[0] && e != e_a[1]) {

                g_filt = g_filt_tab;

                q_filt = q_filt_tab;

                for (m = 0; m < m_max; m++) {

                    const int idx1 = i + h_SL;

                    g_filt[m].mant = g_filt[m].exp = 0;

                    q_filt[m].mant = q_filt[m].exp = 0;

                    for (j = 0; j <= h_SL; j++) {

                        g_filt[m] = av_add_sf(g_filt[m],

                                        av_mul_sf(g_temp[idx1 - j][m],

                                            h_smooth[j]));

                        q_filt[m] = av_add_sf(q_filt[m],

                                        av_mul_sf(q_temp[idx1 - j][m],

                                            h_smooth[j]));

                    }

                }

            } else {

                g_filt = g_temp[i + h_SL];

                q_filt = q_temp[i];

            }



            sbr->dsp.hf_g_filt(Y1[i] + kx, X_high + kx, g_filt, m_max,

                               i + ENVELOPE_ADJUSTMENT_OFFSET);



            if (e != e_a[0] && e != e_a[1]) {

                sbr->dsp.hf_apply_noise[indexsine](Y1[i] + kx, sbr->s_m[e],

                                                   q_filt, indexnoise,

                                                   kx, m_max);

            } else {

                int idx = indexsine&1;

                int A = (1-((indexsine+(kx & 1))&2));

                int B = (A^(-idx)) + idx;

                int *out = &Y1[i][kx][idx];

                int shift, round;



                SoftFloat *in  = sbr->s_m[e];

                for (m = 0; m+1 < m_max; m+=2) {

                    shift = 22 - in[m  ].exp;

                    if (shift < 32) {

                        round = 1 << (shift-1);

                        out[2*m  ] += (in[m  ].mant * A + round) >> shift;

                    }



                    shift = 22 - in[m+1].exp;

                    if (shift < 32) {

                        round = 1 << (shift-1);

                        out[2*m+2] += (in[m+1].mant * B + round) >> shift;

                    }

                }

                if(m_max&1)

                {

                    shift = 22 - in[m  ].exp;

                    if (shift < 32) {

                        round = 1 << (shift-1);

                        out[2*m  ] += (in[m  ].mant * A + round) >> shift;

                    }

                }

            }

            indexnoise = (indexnoise + m_max) & 0x1ff;

            indexsine = (indexsine + 1) & 3;

        }

    }

    ch_data->f_indexnoise = indexnoise;

    ch_data->f_indexsine  = indexsine;

}
 and probability:0.5566037735849056
code:static int vid_probe(AVProbeData *p)

{

    // little endian VID tag, file starts with "VID\0"

    if (p->buf_size < 4 || AV_RL32(p->buf) != MKTAG('V', 'I', 'D', 0))

        return 0;



    return AVPROBE_SCORE_MAX;

}
 and probability:0.14285714285714285
code:static inline void gen_intermediate_code_internal(X86CPU *cpu,

                                                  TranslationBlock *tb,

                                                  bool search_pc)

{

    CPUState *cs = CPU(cpu);

    CPUX86State *env = &cpu->env;

    DisasContext dc1, *dc = &dc1;

    target_ulong pc_ptr;

    uint16_t *gen_opc_end;

    CPUBreakpoint *bp;

    int j, lj;

    uint64_t flags;

    target_ulong pc_start;

    target_ulong cs_base;

    int num_insns;

    int max_insns;



    /* generate intermediate code */

    pc_start = tb->pc;

    cs_base = tb->cs_base;

    flags = tb->flags;



    dc->pe = (flags >> HF_PE_SHIFT) & 1;

    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;

    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;

    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;

    dc->f_st = 0;

    dc->vm86 = (flags >> VM_SHIFT) & 1;

    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;

    dc->iopl = (flags >> IOPL_SHIFT) & 3;

    dc->tf = (flags >> TF_SHIFT) & 1;

    dc->singlestep_enabled = cs->singlestep_enabled;

    dc->cc_op = CC_OP_DYNAMIC;

    dc->cc_op_dirty = false;

    dc->cs_base = cs_base;

    dc->tb = tb;

    dc->popl_esp_hack = 0;

    /* select memory access functions */

    dc->mem_index = 0;

    if (flags & HF_SOFTMMU_MASK) {

        dc->mem_index = cpu_mmu_index(env);

    }

    dc->cpuid_features = env->features[FEAT_1_EDX];

    dc->cpuid_ext_features = env->features[FEAT_1_ECX];

    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];

    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];

    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];

#ifdef TARGET_X86_64

    dc->lma = (flags >> HF_LMA_SHIFT) & 1;

    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;

#endif

    dc->flags = flags;

    dc->jmp_opt = !(dc->tf || cs->singlestep_enabled ||

                    (flags & HF_INHIBIT_IRQ_MASK)

#ifndef CONFIG_SOFTMMU

                    || (flags & HF_SOFTMMU_MASK)

#endif

                    );

#if 0

    /* check addseg logic */

    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))

        printf("ERROR addseg\n");

#endif



    cpu_T[0] = tcg_temp_new();

    cpu_T[1] = tcg_temp_new();

    cpu_A0 = tcg_temp_new();



    cpu_tmp0 = tcg_temp_new();

    cpu_tmp1_i64 = tcg_temp_new_i64();

    cpu_tmp2_i32 = tcg_temp_new_i32();

    cpu_tmp3_i32 = tcg_temp_new_i32();

    cpu_tmp4 = tcg_temp_new();

    cpu_ptr0 = tcg_temp_new_ptr();

    cpu_ptr1 = tcg_temp_new_ptr();

    cpu_cc_srcT = tcg_temp_local_new();



    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;



    dc->is_jmp = DISAS_NEXT;

    pc_ptr = pc_start;

    lj = -1;

    num_insns = 0;

    max_insns = tb->cflags & CF_COUNT_MASK;

    if (max_insns == 0)

        max_insns = CF_COUNT_MASK;



    gen_tb_start();

    for(;;) {

        if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {

            QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {

                if (bp->pc == pc_ptr &&

                    !((bp->flags & BP_CPU) && (tb->flags & HF_RF_MASK))) {

                    gen_debug(dc, pc_ptr - dc->cs_base);

                    break;

                }

            }

        }

        if (search_pc) {

            j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;

            if (lj < j) {

                lj++;

                while (lj < j)

                    tcg_ctx.gen_opc_instr_start[lj++] = 0;

            }

            tcg_ctx.gen_opc_pc[lj] = pc_ptr;

            gen_opc_cc_op[lj] = dc->cc_op;

            tcg_ctx.gen_opc_instr_start[lj] = 1;

            tcg_ctx.gen_opc_icount[lj] = num_insns;

        }

        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))

            gen_io_start();



        pc_ptr = disas_insn(env, dc, pc_ptr);

        num_insns++;

        /* stop translation if indicated */

        if (dc->is_jmp)

            break;

        /* if single step mode, we generate only one instruction and

           generate an exception */

        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear

           the flag and abort the translation to give the irqs a

           change to be happen */

        if (dc->tf || dc->singlestep_enabled ||

            (flags & HF_INHIBIT_IRQ_MASK)) {

            gen_jmp_im(pc_ptr - dc->cs_base);

            gen_eob(dc);

            break;

        }

        /* if too long translation, stop generation too */

        if (tcg_ctx.gen_opc_ptr >= gen_opc_end ||

            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||

            num_insns >= max_insns) {

            gen_jmp_im(pc_ptr - dc->cs_base);

            gen_eob(dc);

            break;

        }

        if (singlestep) {

            gen_jmp_im(pc_ptr - dc->cs_base);

            gen_eob(dc);

            break;

        }

    }

    if (tb->cflags & CF_LAST_IO)

        gen_io_end();

    gen_tb_end(tb, num_insns);

    *tcg_ctx.gen_opc_ptr = INDEX_op_end;

    /* we don't forget to fill the last values */

    if (search_pc) {

        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;

        lj++;

        while (lj <= j)

            tcg_ctx.gen_opc_instr_start[lj++] = 0;

    }



#ifdef DEBUG_DISAS

    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {

        int disas_flags;

        qemu_log("----------------\n");

        qemu_log("IN: %s\n", lookup_symbol(pc_start));

#ifdef TARGET_X86_64

        if (dc->code64)

            disas_flags = 2;

        else

#endif

            disas_flags = !dc->code32;

        log_target_disas(env, pc_start, pc_ptr - pc_start, disas_flags);

        qemu_log("\n");

    }

#endif



    if (!search_pc) {

        tb->size = pc_ptr - pc_start;

        tb->icount = num_insns;

    }

}
 and probability:0.39759036144578314
code:static always_inline void gen_op_subfo (void)

{

    gen_op_move_T2_T0();

    gen_op_subf();

    gen_op_check_subfo();

}
 and probability:0.0
code:static void fd_accept_incoming_migration(void *opaque)

{

    QEMUFile *f = opaque;



    qemu_set_fd_handler2(qemu_get_fd(f), NULL, NULL, NULL, NULL);

    process_incoming_migration(f);

}
 and probability:0.0
code:hwaddr ppc_hash64_get_phys_page_debug(PowerPCCPU *cpu, target_ulong addr)

{

    CPUPPCState *env = &cpu->env;

    ppc_slb_t *slb;

    hwaddr pte_offset;

    ppc_hash_pte64_t pte;

    unsigned apshift;



    if (msr_dr == 0) {

        /* In real mode the top 4 effective address bits are ignored */

        return addr & 0x0FFFFFFFFFFFFFFFULL;

    }



    slb = slb_lookup(cpu, addr);

    if (!slb) {

        return -1;

    }



    pte_offset = ppc_hash64_htab_lookup(cpu, slb, addr, &pte);

    if (pte_offset == -1) {

        return -1;

    }



    apshift = hpte_page_shift(slb->sps, pte.pte0, pte.pte1);

    if (!apshift) {

        return -1;

    }



    return deposit64(pte.pte1 & HPTE64_R_RPN, 0, apshift, addr)

        & TARGET_PAGE_MASK;

}
 and probability:0.07692307692307693
code:static int adx_read_header(AVFormatContext *s)

{

    ADXDemuxerContext *c = s->priv_data;

    AVCodecParameters *par;



    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return AVERROR(ENOMEM);

    par = s->streams[0]->codecpar;



    if (avio_rb16(s->pb) != 0x8000)

        return AVERROR_INVALIDDATA;

    c->header_size = avio_rb16(s->pb) + 4;

    avio_seek(s->pb, -4, SEEK_CUR);



    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)

        return AVERROR(ENOMEM);



    if (par->extradata_size < 12) {

        av_log(s, AV_LOG_ERROR, "Invalid extradata size.\n");

        return AVERROR_INVALIDDATA;

    }

    par->channels    = AV_RB8 (par->extradata + 7);

    par->sample_rate = AV_RB32(par->extradata + 8);



    if (par->channels <= 0) {

        av_log(s, AV_LOG_ERROR, "invalid number of channels %d\n", par->channels);

        return AVERROR_INVALIDDATA;

    }



    if (par->sample_rate <= 0) {

        av_log(s, AV_LOG_ERROR, "Invalid sample rate %d\n", par->sample_rate);

        return AVERROR_INVALIDDATA;

    }



    par->codec_type  = AVMEDIA_TYPE_AUDIO;

    par->codec_id    = s->iformat->raw_codec_id;

    par->bit_rate    = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;



    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);



    return 0;

}
 and probability:0.5
code:static void virgl_cmd_get_capset(VirtIOGPU *g,

                                 struct virtio_gpu_ctrl_command *cmd)

{

    struct virtio_gpu_get_capset gc;

    struct virtio_gpu_resp_capset *resp;

    uint32_t max_ver, max_size;

    VIRTIO_GPU_FILL_CMD(gc);



    virgl_renderer_get_cap_set(gc.capset_id, &max_ver,

                               &max_size);

    if (!max_size) {

        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;

        return;

    }



    resp = g_malloc(sizeof(*resp) + max_size);

    resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET;

    virgl_renderer_fill_caps(gc.capset_id,

                             gc.capset_version,

                             (void *)resp->capset_data);

    virtio_gpu_ctrl_response(g, cmd, &resp->hdr, sizeof(*resp) + max_size);

    g_free(resp);

}
 and probability:0.23809523809523808
code:static int qcow2_open(BlockDriverState *bs, QDict *options, int flags)
{
    BDRVQcowState *s = bs->opaque;
    int len, i, ret = 0;
    QCowHeader header;
    QemuOpts *opts;
    Error *local_err = NULL;
    uint64_t ext_end;
    uint64_t l1_vm_state_index;
    ret = bdrv_pread(bs->file, 0, &header, sizeof(header));
    if (ret < 0) {
    be32_to_cpus(&header.magic);
    be32_to_cpus(&header.version);
    be64_to_cpus(&header.backing_file_offset);
    be32_to_cpus(&header.backing_file_size);
    be64_to_cpus(&header.size);
    be32_to_cpus(&header.cluster_bits);
    be32_to_cpus(&header.crypt_method);
    be64_to_cpus(&header.l1_table_offset);
    be32_to_cpus(&header.l1_size);
    be64_to_cpus(&header.refcount_table_offset);
    be32_to_cpus(&header.refcount_table_clusters);
    be64_to_cpus(&header.snapshots_offset);
    be32_to_cpus(&header.nb_snapshots);
    if (header.magic != QCOW_MAGIC) {
        ret = -EMEDIUMTYPE;
    if (header.version < 2 || header.version > 3) {
        report_unsupported(bs, "QCOW version %d", header.version);
        ret = -ENOTSUP;
    s->qcow_version = header.version;
    /* Initialise version 3 header fields */
    if (header.version == 2) {
        header.incompatible_features    = 0;
        header.compatible_features      = 0;
        header.autoclear_features       = 0;
        header.refcount_order           = 4;
        header.header_length            = 72;
    } else {
        be64_to_cpus(&header.incompatible_features);
        be64_to_cpus(&header.compatible_features);
        be64_to_cpus(&header.autoclear_features);
        be32_to_cpus(&header.refcount_order);
        be32_to_cpus(&header.header_length);
    if (header.header_length > sizeof(header)) {
        s->unknown_header_fields_size = header.header_length - sizeof(header);
        s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);
        ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,
                         s->unknown_header_fields_size);
        if (ret < 0) {
    if (header.backing_file_offset) {
        ext_end = header.backing_file_offset;
    } else {
        ext_end = 1 << header.cluster_bits;
    /* Handle feature bits */
    s->incompatible_features    = header.incompatible_features;
    s->compatible_features      = header.compatible_features;
    s->autoclear_features       = header.autoclear_features;
    if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {
        void *feature_table = NULL;
        qcow2_read_extensions(bs, header.header_length, ext_end,
                              &feature_table);
        report_unsupported_feature(bs, feature_table,
                                   s->incompatible_features &
                                   ~QCOW2_INCOMPAT_MASK);
        ret = -ENOTSUP;
    /* Check support for various header values */
    if (header.refcount_order != 4) {
        report_unsupported(bs, "%d bit reference counts",
                           1 << header.refcount_order);
        ret = -ENOTSUP;
    if (header.cluster_bits < MIN_CLUSTER_BITS ||
        header.cluster_bits > MAX_CLUSTER_BITS) {
        ret = -EINVAL;
    if (header.crypt_method > QCOW_CRYPT_AES) {
        ret = -EINVAL;
    s->crypt_method_header = header.crypt_method;
    if (s->crypt_method_header) {
        bs->encrypted = 1;
    s->cluster_bits = header.cluster_bits;
    s->cluster_size = 1 << s->cluster_bits;
    s->cluster_sectors = 1 << (s->cluster_bits - 9);
    s->l2_bits = s->cluster_bits - 3; /* L2 is always one cluster */
    s->l2_size = 1 << s->l2_bits;
    bs->total_sectors = header.size / 512;
    s->csize_shift = (62 - (s->cluster_bits - 8));
    s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;
    s->cluster_offset_mask = (1LL << s->csize_shift) - 1;
    s->refcount_table_offset = header.refcount_table_offset;
    s->refcount_table_size =
        header.refcount_table_clusters << (s->cluster_bits - 3);
    s->snapshots_offset = header.snapshots_offset;
    s->nb_snapshots = header.nb_snapshots;
    /* read the level 1 table */
    s->l1_size = header.l1_size;
    l1_vm_state_index = size_to_l1(s, header.size);
    if (l1_vm_state_index > INT_MAX) {
        ret = -EFBIG;
    s->l1_vm_state_index = l1_vm_state_index;
    /* the L1 table must contain at least enough entries to put
       header.size bytes */
    if (s->l1_size < s->l1_vm_state_index) {
        ret = -EINVAL;
    s->l1_table_offset = header.l1_table_offset;
    if (s->l1_size > 0) {
        s->l1_table = g_malloc0(
            align_offset(s->l1_size * sizeof(uint64_t), 512));
        ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,
                         s->l1_size * sizeof(uint64_t));
        if (ret < 0) {
        for(i = 0;i < s->l1_size; i++) {
            be64_to_cpus(&s->l1_table[i]);
    /* alloc L2 table/refcount block cache */
    s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);
    s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);
    s->cluster_cache = g_malloc(s->cluster_size);
    /* one more sector for decompressed data alignment */
    s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size
                                  + 512);
    s->cluster_cache_offset = -1;
    s->flags = flags;
    ret = qcow2_refcount_init(bs);
    if (ret != 0) {
    QLIST_INIT(&s->cluster_allocs);
    QTAILQ_INIT(&s->discards);
    /* read qcow2 extensions */
    if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL)) {
        ret = -EINVAL;
    /* read the backing file name */
    if (header.backing_file_offset != 0) {
        len = header.backing_file_size;
        if (len > 1023) {
            len = 1023;
        ret = bdrv_pread(bs->file, header.backing_file_offset,
                         bs->backing_file, len);
        if (ret < 0) {
        bs->backing_file[len] = '\0';
    ret = qcow2_read_snapshots(bs);
    if (ret < 0) {
    /* Clear unknown autoclear feature bits */
    if (!bs->read_only && s->autoclear_features != 0) {
        s->autoclear_features = 0;
        ret = qcow2_update_header(bs);
        if (ret < 0) {
    /* Initialise locks */
    qemu_co_mutex_init(&s->lock);
    /* Repair image if dirty */
    if (!(flags & BDRV_O_CHECK) && !bs->read_only &&
        (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {
        BdrvCheckResult result = {0};
        ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);
        if (ret < 0) {
    /* Enable lazy_refcounts according to image and command line options */
    opts = qemu_opts_create_nofail(&qcow2_runtime_opts);
    qemu_opts_absorb_qdict(opts, options, &local_err);
    if (error_is_set(&local_err)) {
        qerror_report_err(local_err);
        error_free(local_err);
        ret = -EINVAL;
    s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,
        (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));
    s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;
    s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;
    s->discard_passthrough[QCOW2_DISCARD_REQUEST] =
        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,
                          flags & BDRV_O_UNMAP);
    s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =
        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);
    s->discard_passthrough[QCOW2_DISCARD_OTHER] =
        qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);
    qemu_opts_del(opts);
    if (s->use_lazy_refcounts && s->qcow_version < 3) {
        qerror_report(ERROR_CLASS_GENERIC_ERROR, "Lazy refcounts require "
            "a qcow2 image with at least qemu 1.1 compatibility level");
        ret = -EINVAL;
#ifdef DEBUG_ALLOC
    {
        BdrvCheckResult result = {0};
        qcow2_check_refcounts(bs, &result, 0);
#endif
    return ret;
 fail:
    g_free(s->unknown_header_fields);
    cleanup_unknown_header_ext(bs);
    qcow2_free_snapshots(bs);
    qcow2_refcount_close(bs);
    g_free(s->l1_table);
    if (s->l2_table_cache) {
        qcow2_cache_destroy(bs, s->l2_table_cache);
    g_free(s->cluster_cache);
    qemu_vfree(s->cluster_data);
    return ret; and probability:0.36649214659685864
code:static void decode_subband(DiracContext *s, GetBitContext *gb, int quant,

                           int slice_x, int slice_y, int bits_end,

                           SubBand *b1, SubBand *b2)

{

    int left   = b1->width  * slice_x    / s->num_x;

    int right  = b1->width  *(slice_x+1) / s->num_x;

    int top    = b1->height * slice_y    / s->num_y;

    int bottom = b1->height *(slice_y+1) / s->num_y;



    int qfactor = qscale_tab[quant & 0x7f];

    int qoffset = qoffset_intra_tab[quant & 0x7f] + 2;



    uint8_t *buf1 =      b1->ibuf + top * b1->stride;

    uint8_t *buf2 = b2 ? b2->ibuf + top * b2->stride: NULL;

    int x, y;

    /* we have to constantly check for overread since the spec explicitly

       requires this, with the meaning that all remaining coeffs are set to 0 */

    if (get_bits_count(gb) >= bits_end)

        return;



    if (s->pshift) {

        for (y = top; y < bottom; y++) {

            for (x = left; x < right; x++) {

                PARSE_VALUES(int32_t, x, gb, bits_end, buf1, buf2);

            }

            buf1 += b1->stride;

            if (buf2)

                buf2 += b2->stride;

        }

    }

    else {

        for (y = top; y < bottom; y++) {

            for (x = left; x < right; x++) {

                PARSE_VALUES(int16_t, x, gb, bits_end, buf1, buf2);

            }

            buf1 += b1->stride;

            if (buf2)

                buf2 += b2->stride;

        }

    }

}
 and probability:0.4473684210526316
code:int spapr_h_cas_compose_response(sPAPRMachineState *spapr,

                                 target_ulong addr, target_ulong size,

                                 bool cpu_update,

                                 sPAPROptionVector *ov5_updates)

{

    void *fdt, *fdt_skel;

    sPAPRDeviceTreeUpdateHeader hdr = { .version_id = 1 };



    size -= sizeof(hdr);



    /* Create sceleton */

    fdt_skel = g_malloc0(size);

    _FDT((fdt_create(fdt_skel, size)));

    _FDT((fdt_begin_node(fdt_skel, "")));

    _FDT((fdt_end_node(fdt_skel)));

    _FDT((fdt_finish(fdt_skel)));

    fdt = g_malloc0(size);

    _FDT((fdt_open_into(fdt_skel, fdt, size)));

    g_free(fdt_skel);



    /* Fixup cpu nodes */

    if (cpu_update) {

        _FDT((spapr_fixup_cpu_dt(fdt, spapr)));

    }



    if (spapr_dt_cas_updates(spapr, fdt, ov5_updates)) {

        return -1;

    }



    /* Pack resulting tree */

    _FDT((fdt_pack(fdt)));



    if (fdt_totalsize(fdt) + sizeof(hdr) > size) {

        trace_spapr_cas_failed(size);

        return -1;

    }



    cpu_physical_memory_write(addr, &hdr, sizeof(hdr));

    cpu_physical_memory_write(addr + sizeof(hdr), fdt, fdt_totalsize(fdt));

    trace_spapr_cas_continue(fdt_totalsize(fdt) + sizeof(hdr));

    g_free(fdt);



    return 0;

}
 and probability:0.1111111111111111
code:void kvmppc_hash64_write_pte(CPUPPCState *env, target_ulong pte_index,

                             target_ulong pte0, target_ulong pte1)

{

    int htab_fd;

    struct kvm_get_htab_fd ghf;

    struct kvm_get_htab_buf hpte_buf;



    ghf.flags = 0;

    ghf.start_index = 0;     /* Ignored */

    htab_fd = kvm_vm_ioctl(kvm_state, KVM_PPC_GET_HTAB_FD, &ghf);

    if (htab_fd < 0) {

        goto error_out;

    }



    hpte_buf.header.n_valid = 1;

    hpte_buf.header.n_invalid = 0;

    hpte_buf.header.index = pte_index;

    hpte_buf.hpte[0] = pte0;

    hpte_buf.hpte[1] = pte1;

    /*

     * Write the hpte entry.

     * CAUTION: write() has the warn_unused_result attribute. Hence we

     * need to check the return value, even though we do nothing.

     */

    if (write(htab_fd, &hpte_buf, sizeof(hpte_buf)) < 0) {

        goto out_close;

    }



out_close:

    close(htab_fd);

    return;



error_out:

    return;

}
 and probability:0.06451612903225806
code:int tcp_start_outgoing_migration(MigrationState *s, const char *host_port,

                                 Error **errp)

{

    s->get_error = socket_errno;

    s->write = socket_write;

    s->close = tcp_close;



    s->fd = inet_connect(host_port, false, errp);



    if (!error_is_set(errp)) {

        migrate_fd_connect(s);

    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_IN_PROGRESS)) {

        DPRINTF("connect in progress\n");

        qemu_set_fd_handler2(s->fd, NULL, NULL, tcp_wait_for_connect, s);

    } else if (error_is_type(*errp, QERR_SOCKET_CREATE_FAILED)) {

        DPRINTF("connect failed\n");

        return -1;

    } else if (error_is_type(*errp, QERR_SOCKET_CONNECT_FAILED)) {

        DPRINTF("connect failed\n");

        migrate_fd_error(s);

        return -1;

    } else {

        DPRINTF("unknown error\n");

        return -1;

    }



    return 0;

}
 and probability:0.32
code:static void virtio_9p_device_realize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    if (v9fs_device_realize_common(s, errp)) {

        goto out;

    }



    v->config_size = sizeof(struct virtio_9p_config) + strlen(s->fsconf.tag);

    virtio_init(vdev, "virtio-9p", VIRTIO_ID_9P, v->config_size);

    v->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);

    v9fs_register_transport(s, &virtio_9p_transport);



out:

    return;

}
 and probability:0.26666666666666666
code:static void trigger_access_exception(CPUS390XState *env, uint32_t type,

                                     uint32_t ilen, uint64_t tec)

{

    S390CPU *cpu = s390_env_get_cpu(env);



    if (kvm_enabled()) {

        kvm_s390_access_exception(cpu, type, tec);

    } else {

        CPUState *cs = CPU(cpu);

        stq_phys(cs->as, env->psa + offsetof(LowCore, trans_exc_code), tec);

        trigger_pgm_exception(env, type, ilen);

    }

}
 and probability:0.08333333333333333
code:static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,

                                        DeviceState *dev, Error **errp)

{

    sPAPRMachineState *spapr = SPAPR_MACHINE(hotplug_dev);

    Error *local_err = NULL;

    PCDIMMDevice *dimm = PC_DIMM(dev);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);

    MemoryRegion *mr = ddc->get_memory_region(dimm);

    uint64_t size = memory_region_size(mr);

    uint32_t nr_lmbs = size / SPAPR_MEMORY_BLOCK_SIZE;

    uint64_t addr_start, addr;

    int i;

    sPAPRDRConnector *drc;

    sPAPRDRConnectorClass *drck;

    sPAPRDIMMState *ds;



    addr_start = object_property_get_int(OBJECT(dimm), PC_DIMM_ADDR_PROP,

                                         &local_err);

    if (local_err) {

        goto out;

    }



    ds = g_malloc0(sizeof(sPAPRDIMMState));

    ds->nr_lmbs = nr_lmbs;

    ds->dimm = dimm;

    spapr_pending_dimm_unplugs_add(spapr, ds);



    addr = addr_start;

    for (i = 0; i < nr_lmbs; i++) {

        drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,

                addr / SPAPR_MEMORY_BLOCK_SIZE);

        g_assert(drc);



        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

        drck->detach(drc, dev, spapr_lmb_release, NULL, errp);

        addr += SPAPR_MEMORY_BLOCK_SIZE;

    }



    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,

                                   addr_start / SPAPR_MEMORY_BLOCK_SIZE);

    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    spapr_hotplug_req_remove_by_count_indexed(SPAPR_DR_CONNECTOR_TYPE_LMB,

                                              nr_lmbs,

                                              drck->get_index(drc));

out:

    error_propagate(errp, local_err);

}
 and probability:0.23809523809523808
code:static void l2x0_priv_write(void *opaque, target_phys_addr_t offset,

                            uint64_t value, unsigned size)

{

    l2x0_state *s = (l2x0_state *)opaque;

    offset &= 0xfff;

    if (offset >= 0x730 && offset < 0x800) {

        /* ignore */

        return;

    }

    switch (offset) {

    case 0x100:

        s->ctrl = value & 1;

        break;

    case 0x104:

        s->aux_ctrl = value;

        break;

    case 0x108:

        s->tag_ctrl = value;

        break;

    case 0x10C:

        s->data_ctrl = value;

        break;

    case 0xC00:

        s->filter_start = value;

        break;

    case 0xC04:

        s->filter_end = value;

        break;

    case 0xF40:

        return;

    case 0xF60:

        return;

    case 0xF80:

        return;

    default:

        fprintf(stderr, "l2x0_priv_write: Bad offset %x\n", (int)offset);

        break;

    }

}
 and probability:0.15384615384615385
code:static void json_emit_element(QJSON *json, const char *name)

{

    /* Check whether we need to print a , before an element */

    if (json->omit_comma) {

        json->omit_comma = false;

    } else {

        qstring_append(json->str, ", ");

    }



    if (name) {

        qstring_append(json->str, "\"");

        qstring_append(json->str, name);

        qstring_append(json->str, "\" : ");

    }

}
 and probability:0.42857142857142855
code:static bool vfio_pci_host_match(PCIHostDeviceAddress *host1,

                                PCIHostDeviceAddress *host2)

{

    return (host1->domain == host2->domain && host1->bus == host2->bus &&

            host1->slot == host2->slot && host1->function == host2->function);

}
 and probability:0.3333333333333333
code:int ff_ivi_dec_huff_desc(GetBitContext *gb, int desc_coded, int which_tab,

                         IVIHuffTab *huff_tab, AVCodecContext *avctx)

{

    int         i, result;

    IVIHuffDesc new_huff;



    if (!desc_coded) {

        /* select default table */

        huff_tab->tab = (which_tab) ? &ff_ivi_blk_vlc_tabs[7]

            : &ff_ivi_mb_vlc_tabs [7];

    } else {

        huff_tab->tab_sel = get_bits(gb, 3);

        if (huff_tab->tab_sel == 7) {

            /* custom huffman table (explicitly encoded) */

            new_huff.num_rows = get_bits(gb, 4);



            for (i = 0; i < new_huff.num_rows; i++)

                new_huff.xbits[i] = get_bits(gb, 4);



            /* Have we got the same custom table? Rebuild if not. */

            if (ff_ivi_huff_desc_cmp(&new_huff, &huff_tab->cust_desc)) {

                ff_ivi_huff_desc_copy(&huff_tab->cust_desc, &new_huff);



                if (huff_tab->cust_tab.table)

                    ff_free_vlc(&huff_tab->cust_tab);

                result = ff_ivi_create_huff_from_desc(&huff_tab->cust_desc,

                        &huff_tab->cust_tab, 0);

                if (result) {

                    av_log(avctx, AV_LOG_ERROR,

                           "Error while initializing custom vlc table!\n");

                    return -1;

                }

            }

            huff_tab->tab = &huff_tab->cust_tab;

        } else {

            /* select one of predefined tables */

            huff_tab->tab = (which_tab) ? &ff_ivi_blk_vlc_tabs[huff_tab->tab_sel]

                : &ff_ivi_mb_vlc_tabs [huff_tab->tab_sel];

        }

    }



    return 0;

}
 and probability:0.39473684210526316
code:int check_params(char *buf, int buf_size,

                 const char * const *params, const char *str)

{

    const char *p;

    int i;



    p = str;

    while (*p != '\0') {

        p = get_opt_name(buf, buf_size, p, '=');

        if (*p != '=') {

            return -1;

        }

        p++;

        for (i = 0; params[i] != NULL; i++) {

            if (!strcmp(params[i], buf)) {

                break;

            }

        }

        if (params[i] == NULL) {

            return -1;

        }

        p = get_opt_value(NULL, 0, p);

        if (*p != ',') {

            break;

        }

        p++;

    }

    return 0;

}
 and probability:0.2857142857142857
code:static void memory_region_update_container_subregions(MemoryRegion *subregion)

{

    hwaddr offset = subregion->addr;

    MemoryRegion *mr = subregion->container;

    MemoryRegion *other;



    memory_region_transaction_begin();



    memory_region_ref(subregion);

    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {

        if (subregion->may_overlap || other->may_overlap) {

            continue;

        }

        if (int128_ge(int128_make64(offset),

                      int128_add(int128_make64(other->addr), other->size))

            || int128_le(int128_add(int128_make64(offset), subregion->size),

                         int128_make64(other->addr))) {

            continue;

        }

#if 0

        printf("warning: subregion collision %llx/%llx (%s) "

               "vs %llx/%llx (%s)\n",

               (unsigned long long)offset,

               (unsigned long long)int128_get64(subregion->size),

               subregion->name,

               (unsigned long long)other->addr,

               (unsigned long long)int128_get64(other->size),

               other->name);

#endif

    }

    QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {

        if (subregion->priority >= other->priority) {

            QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);

            goto done;

        }

    }

    QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);

done:

    memory_region_update_pending |= mr->enabled && subregion->enabled;

    memory_region_transaction_commit();

}
 and probability:0.41025641025641024
code:static int64_t coroutine_fn bdrv_qed_co_get_block_status(BlockDriverState *bs,

                                                 int64_t sector_num,

                                                 int nb_sectors, int *pnum)

{

    BDRVQEDState *s = bs->opaque;

    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;

    QEDIsAllocatedCB cb = {

        .bs = bs,

        .pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE,

        .status = BDRV_BLOCK_OFFSET_MASK,

        .pnum = pnum,

    };

    QEDRequest request = { .l2_table = NULL };



    qed_find_cluster(s, &request, cb.pos, len, qed_is_allocated_cb, &cb);



    /* Now sleep if the callback wasn't invoked immediately */

    while (cb.status == BDRV_BLOCK_OFFSET_MASK) {

        cb.co = qemu_coroutine_self();

        qemu_coroutine_yield();

    }



    qed_unref_l2_cache_entry(request.l2_table);



    return cb.status;

}
 and probability:0.13636363636363635
code:static sPAPRPHBState *find_phb(sPAPREnvironment *spapr, uint64_t buid)

{

    sPAPRPHBState *sphb;



    QLIST_FOREACH(sphb, &spapr->phbs, list) {

        if (sphb->buid != buid) {

            continue;

        }

        return sphb;

    }



    return NULL;

}
 and probability:0.18181818181818182
code:static void ahci_mem_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    AHCIState *s = opaque;



    /* Only aligned reads are allowed on AHCI */

    if (addr & 3) {

        fprintf(stderr, "ahci: Mis-aligned write to addr 0x"

                TARGET_FMT_plx "\n", addr);

        return;

    }



    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {

        DPRINTF(-1, "(addr 0x%08X), val 0x%08"PRIX64"\n", (unsigned) addr, val);



        switch (addr) {

            case HOST_CAP: /* R/WO, RO */

                /* FIXME handle R/WO */

                break;

            case HOST_CTL: /* R/W */

                if (val & HOST_CTL_RESET) {

                    DPRINTF(-1, "HBA Reset\n");

                    ahci_reset(s);

                } else {

                    s->control_regs.ghc = (val & 0x3) | HOST_CTL_AHCI_EN;

                    ahci_check_irq(s);

                }

                break;

            case HOST_IRQ_STAT: /* R/WC, RO */

                s->control_regs.irqstatus &= ~val;

                ahci_check_irq(s);

                break;

            case HOST_PORTS_IMPL: /* R/WO, RO */

                /* FIXME handle R/WO */

                break;

            case HOST_VERSION: /* RO */

                /* FIXME report write? */

                break;

            default:

                DPRINTF(-1, "write to unknown register 0x%x\n", (unsigned)addr);

        }

    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&

               (addr < (AHCI_PORT_REGS_START_ADDR +

                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {

        ahci_port_write(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,

                        addr & AHCI_PORT_ADDR_OFFSET_MASK, val);

    }



}
 and probability:0.1111111111111111
code:static void jpeg_term_destination(j_compress_ptr cinfo)

{

    VncState *vs = cinfo->client_data;

    Buffer *buffer = &vs->tight_jpeg;



    buffer->offset = buffer->capacity - cinfo->dest->free_in_buffer;

}
 and probability:0.5
code:static void qdict_destroy_obj(QObject *obj)

{

    int i;

    QDict *qdict;



    assert(obj != NULL);

    qdict = qobject_to_qdict(obj);



    for (i = 0; i < QDICT_BUCKET_MAX; i++) {

        QDictEntry *entry = QLIST_FIRST(&qdict->table[i]);

        while (entry) {

            QDictEntry *tmp = QLIST_NEXT(entry, next);

            QLIST_REMOVE(entry, next);

            qentry_destroy(entry);

            entry = tmp;

        }

    }



    g_free(qdict);

}
 and probability:0.11764705882352941
code:static int pte64_check (mmu_ctx_t *ctx,

                        target_ulong pte0, target_ulong pte1, int h, int rw)

{

    return _pte_check(ctx, 1, pte0, pte1, h, rw);

}
 and probability:0.0
code:static GenericList *qobject_input_next_list(Visitor *v, GenericList *tail,

                                            size_t size)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    StackObject *so = QSLIST_FIRST(&qiv->stack);



    if (!so->entry) {

        return NULL;

    }

    tail->next = g_malloc0(size);

    return tail->next;

}
 and probability:0.36363636363636365
code:static int coroutine_fn v9fs_do_readdir_with_stat(V9fsPDU *pdu,

                                                  V9fsFidState *fidp,

                                                  uint32_t max_count)

{

    V9fsPath path;

    V9fsStat v9stat;

    int len, err = 0;

    int32_t count = 0;

    struct stat stbuf;

    off_t saved_dir_pos;

    struct dirent *dent;



    /* save the directory position */

    saved_dir_pos = v9fs_co_telldir(pdu, fidp);

    if (saved_dir_pos < 0) {

        return saved_dir_pos;

    }



    while (1) {

        v9fs_path_init(&path);



        v9fs_readdir_lock(&fidp->fs.dir);



        err = v9fs_co_readdir(pdu, fidp, &dent);

        if (err || !dent) {

            break;

        }

        err = v9fs_co_name_to_path(pdu, &fidp->path, dent->d_name, &path);

        if (err < 0) {

            break;

        }

        err = v9fs_co_lstat(pdu, &path, &stbuf);

        if (err < 0) {

            break;

        }

        err = stat_to_v9stat(pdu, &path, dent->d_name, &stbuf, &v9stat);

        if (err < 0) {

            break;

        }

        /* 11 = 7 + 4 (7 = start offset, 4 = space for storing count) */

        len = pdu_marshal(pdu, 11 + count, "S", &v9stat);



        v9fs_readdir_unlock(&fidp->fs.dir);



        if ((len != (v9stat.size + 2)) || ((count + len) > max_count)) {

            /* Ran out of buffer. Set dir back to old position and return */

            v9fs_co_seekdir(pdu, fidp, saved_dir_pos);

            v9fs_stat_free(&v9stat);

            v9fs_path_free(&path);

            return count;

        }

        count += len;

        v9fs_stat_free(&v9stat);

        v9fs_path_free(&path);

        saved_dir_pos = dent->d_off;

    }



    v9fs_readdir_unlock(&fidp->fs.dir);



    v9fs_path_free(&path);

    if (err < 0) {

        return err;

    }

    return count;

}
 and probability:0.15789473684210525
code:static int decode_block_refinement(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,

                        int ac_index, int16_t *quant_matrix,

                        int ss, int se, int Al, int *EOBRUN)

{

    int code, i=ss, j, sign, val, run;

    int last = FFMIN(se, *last_nnz);



    OPEN_READER(re, &s->gb);

    if(*EOBRUN)

        (*EOBRUN)--;

    else {

        for(;;i++) {

            UPDATE_CACHE(re, &s->gb);

            GET_VLC(code, re, &s->gb, s->vlcs[1][ac_index].table, 9, 2)

            /* Progressive JPEG use AC coeffs from zero and this decoder sets offset 16 by default */

            code -= 16;

            if(code & 0xF) {

                run = ((unsigned) code) >> 4;

                UPDATE_CACHE(re, &s->gb);

                val = SHOW_UBITS(re, &s->gb, 1);

                LAST_SKIP_BITS(re, &s->gb, 1);

                ZERO_RUN;

                j = s->scantable.permutated[i];

                val--;

                block[j] = ((quant_matrix[j]^val)-val) << Al;

                if(i == se) {

                    if(i > *last_nnz)

                        *last_nnz = i;

                    CLOSE_READER(re, &s->gb)

                    return 0;

                }

            }else{

                run = ((unsigned) code) >> 4;

                if(run == 0xF){

                    ZERO_RUN;

                }else{

                    val = run;

                    run = (1 << run);

                    if(val) {

                        UPDATE_CACHE(re, &s->gb);

                        run += SHOW_UBITS(re, &s->gb, val);

                        LAST_SKIP_BITS(re, &s->gb, val);

                    }

                    *EOBRUN = run - 1;

                    break;

                }

            }

        }



        if(i > *last_nnz)

            *last_nnz = i;

    }



    for(;i<=last;i++) {

        j = s->scantable.permutated[i];

        if(block[j])

            REFINE_BIT(j)

    }

    CLOSE_READER(re, &s->gb);



    return 0;

}
 and probability:0.4482758620689655
code:static void destroy_buffers(SANMVideoContext *ctx)

{

    av_freep(&ctx->frm0);

    av_freep(&ctx->frm1);

    av_freep(&ctx->frm2);

    av_freep(&ctx->stored_frame);

    av_freep(&ctx->rle_buf);

    ctx->frm0_size =

    ctx->frm1_size =

    ctx->frm2_size = 0;


} and probability:0.7272727272727273
code:void cpu_state_reset(CPUMIPSState *env)
{
    MIPSCPU *cpu = mips_env_get_cpu(env);
    CPUState *cs = CPU(cpu);
    /* Reset registers to their default values */
    env->CP0_PRid = env->cpu_model->CP0_PRid;
    env->CP0_Config0 = env->cpu_model->CP0_Config0;
#ifdef TARGET_WORDS_BIGENDIAN
    env->CP0_Config0 |= (1 << CP0C0_BE);
#endif
    env->CP0_Config1 = env->cpu_model->CP0_Config1;
    env->CP0_Config2 = env->cpu_model->CP0_Config2;
    env->CP0_Config3 = env->cpu_model->CP0_Config3;
    env->CP0_Config4 = env->cpu_model->CP0_Config4;
    env->CP0_Config4_rw_bitmask = env->cpu_model->CP0_Config4_rw_bitmask;
    env->CP0_Config5 = env->cpu_model->CP0_Config5;
    env->CP0_Config5_rw_bitmask = env->cpu_model->CP0_Config5_rw_bitmask;
    env->CP0_Config6 = env->cpu_model->CP0_Config6;
    env->CP0_Config7 = env->cpu_model->CP0_Config7;
    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask
                                 << env->cpu_model->CP0_LLAddr_shift;
    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;
    env->SYNCI_Step = env->cpu_model->SYNCI_Step;
    env->CCRes = env->cpu_model->CCRes;
    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;
    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;
    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;
    env->current_tc = 0;
    env->SEGBITS = env->cpu_model->SEGBITS;
    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);
#if defined(TARGET_MIPS64)
    if (env->cpu_model->insn_flags & ISA_MIPS3) {
        env->SEGMask |= 3ULL << 62;
    }
#endif
    env->PABITS = env->cpu_model->PABITS;
    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;
    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;
    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;
    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;
    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;
    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;
    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;
    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;
    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;
    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;
    env->CP0_PageGrain_rw_bitmask = env->cpu_model->CP0_PageGrain_rw_bitmask;
    env->CP0_PageGrain = env->cpu_model->CP0_PageGrain;
    env->CP0_EBaseWG_rw_bitmask = env->cpu_model->CP0_EBaseWG_rw_bitmask;
    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;
    env->active_fpu.fcr31_rw_bitmask = env->cpu_model->CP1_fcr31_rw_bitmask;
    env->active_fpu.fcr31 = env->cpu_model->CP1_fcr31;
    env->msair = env->cpu_model->MSAIR;
    env->insn_flags = env->cpu_model->insn_flags;
#if defined(CONFIG_USER_ONLY)
    env->CP0_Status = (MIPS_HFLAG_UM << CP0St_KSU);
# ifdef TARGET_MIPS64
    /* Enable 64-bit register mode.  */
    env->CP0_Status |= (1 << CP0St_PX);
# endif
# ifdef TARGET_ABI_MIPSN64
    /* Enable 64-bit address mode.  */
    env->CP0_Status |= (1 << CP0St_UX);
# endif
    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR
       hardware registers.  */
    env->CP0_HWREna |= 0x0000000F;
    if (env->CP0_Config1 & (1 << CP0C1_FP)) {
        env->CP0_Status |= (1 << CP0St_CU1);
    }
    if (env->CP0_Config3 & (1 << CP0C3_DSPP)) {
        env->CP0_Status |= (1 << CP0St_MX);
    }
# if defined(TARGET_MIPS64)
    /* For MIPS64, init FR bit to 1 if FPU unit is there and bit is writable. */
    if ((env->CP0_Config1 & (1 << CP0C1_FP)) &&
        (env->CP0_Status_rw_bitmask & (1 << CP0St_FR))) {
        env->CP0_Status |= (1 << CP0St_FR);
    }
# endif
#else
    if (env->hflags & MIPS_HFLAG_BMASK) {
        /* If the exception was raised from a delay slot,
           come back to the jump.  */
        env->CP0_ErrorEPC = (env->active_tc.PC
                             - (env->hflags & MIPS_HFLAG_B16 ? 2 : 4));
    } else {
        env->CP0_ErrorEPC = env->active_tc.PC;
    }
    env->active_tc.PC = env->exception_base;
    env->CP0_Random = env->tlb->nb_tlb - 1;
    env->tlb->tlb_in_use = env->tlb->nb_tlb;
    env->CP0_Wired = 0;
    env->CP0_GlobalNumber = (cs->cpu_index & 0xFF) << CP0GN_VPId;
    env->CP0_EBase = (cs->cpu_index & 0x3FF);
    if (kvm_enabled()) {
        env->CP0_EBase |= 0x40000000;
    } else {
        env->CP0_EBase |= (int32_t)0x80000000;
    }
    if (env->CP0_Config3 & (1 << CP0C3_CMGCR)) {
        env->CP0_CMGCRBase = 0x1fbf8000 >> 4;
    }
    env->CP0_EntryHi_ASID_mask = (env->CP0_Config4 & (1 << CP0C4_AE)) ?
                                 0x3ff : 0xff;
    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);
    /* vectored interrupts not implemented, timer on int 7,
       no performance counters. */
    env->CP0_IntCtl = 0xe0000000;
    {
        int i;
        for (i = 0; i < 7; i++) {
            env->CP0_WatchLo[i] = 0;
            env->CP0_WatchHi[i] = 0x80000000;
        }
        env->CP0_WatchLo[7] = 0;
        env->CP0_WatchHi[7] = 0;
    }
    /* Count register increments in debug mode, EJTAG version 1 */
    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);
    cpu_mips_store_count(env, 1);
    if (env->CP0_Config3 & (1 << CP0C3_MT)) {
        int i;
        /* Only TC0 on VPE 0 starts as active.  */
        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {
            env->tcs[i].CP0_TCBind = cs->cpu_index << CP0TCBd_CurVPE;
            env->tcs[i].CP0_TCHalt = 1;
        }
        env->active_tc.CP0_TCHalt = 1;
        cs->halted = 1;
        if (cs->cpu_index == 0) {
            /* VPE0 starts up enabled.  */
            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);
            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);
            /* TC0 starts up unhalted.  */
            cs->halted = 0;
            env->active_tc.CP0_TCHalt = 0;
            env->tcs[0].CP0_TCHalt = 0;
            /* With thread 0 active.  */
            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);
            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);
        }
    }
#endif
    if ((env->insn_flags & ISA_MIPS32R6) &&
        (env->active_fpu.fcr0 & (1 << FCR0_F64))) {
        /* Status.FR = 0 mode in 64-bit FPU not allowed in R6 */
        env->CP0_Status |= (1 << CP0St_FR);
    }
    /* MSA */
    if (env->CP0_Config3 & (1 << CP0C3_MSAP)) {
        msa_reset(env);
    }
    compute_hflags(env);
    restore_fp_status(env);
    restore_pamask(env);
    cs->exception_index = EXCP_NONE;
    if (semihosting_get_argc()) {
        /* UHI interface can be used to obtain argc and argv */
        env->active_tc.gpr[4] = -1;
    }
} and probability:0.6049382716049383
code:static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)

{

    dev->flags &= ~VIO_PAPR_FLAG_DMA_BYPASS;



    if (dev->rtce_table) {

        size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)

            * sizeof(VIOsPAPR_RTCE);

        memset(dev->rtce_table, 0, size);

    }



    dev->crq.qladdr = 0;

    dev->crq.qsize = 0;

    dev->crq.qnext = 0;

}
 and probability:0.5833333333333334
code:int av_image_alloc(uint8_t *pointers[4], int linesizes[4],
                   int w, int h, enum AVPixelFormat pix_fmt, int align)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
    int i, ret;
    uint8_t *buf;
    if (!desc)
        return AVERROR(EINVAL);
    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)
        return ret;
    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, align>7 ? FFALIGN(w, 8) : w)) < 0)
        return ret;
    for (i = 0; i < 4; i++)
        linesizes[i] = FFALIGN(linesizes[i], align);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)
        return ret;
    buf = av_malloc(ret + align);
    if (!buf)
        return AVERROR(ENOMEM);
    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {
        av_free(buf);
        return ret;
    if (desc->flags & AV_PIX_FMT_FLAG_PAL || desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)
        avpriv_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);
    return ret; and probability:0.2
code:static void do_dcbz(CPUPPCState *env, target_ulong addr, int dcache_line_size,

                    uintptr_t raddr)

{

    int i;



    addr &= ~(dcache_line_size - 1);

    for (i = 0; i < dcache_line_size; i += 4) {

        cpu_stl_data_ra(env, addr + i, 0, raddr);

    }

    if (env->reserve_addr == addr) {

        env->reserve_addr = (target_ulong)-1ULL;

    }

}
 and probability:0.4166666666666667
code:static int32_t ide_nop_int32(IDEDMA *dma, int x)

{

    return 0;

}
 and probability:0.0
code:static int read_password(char *buf, int buf_size)

{

    int c, i;

    printf("Password: ");

    fflush(stdout);

    i = 0;

    for(;;) {

        c = getchar();

        if (c == '\n')

            break;

        if (i < (buf_size - 1))

            buf[i++] = c;

    }

    buf[i] = '\0';

    return 0;

}
 and probability:0.1875
code:long do_rt_sigreturn(CPUARMState *env)

{

    struct target_rt_sigframe *frame;

    abi_ulong frame_addr = env->xregs[31];



    if (frame_addr & 15) {

        goto badframe;

    }



    if  (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {

        goto badframe;

    }



    if (target_restore_sigframe(env, frame)) {

        goto badframe;

    }



    if (do_sigaltstack(frame_addr +

            offsetof(struct target_rt_sigframe, uc.tuc_stack),

            0, get_sp_from_cpustate(env)) == -EFAULT) {

        goto badframe;

    }



    unlock_user_struct(frame, frame_addr, 0);

    return env->xregs[0];



 badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
 and probability:0.12
code:tcp_sockclosed(struct tcpcb *tp)

{



	DEBUG_CALL("tcp_sockclosed");

	DEBUG_ARG("tp = %p", tp);



	switch (tp->t_state) {



	case TCPS_CLOSED:

	case TCPS_LISTEN:

	case TCPS_SYN_SENT:

		tp->t_state = TCPS_CLOSED;

		tp = tcp_close(tp);

		break;



	case TCPS_SYN_RECEIVED:

	case TCPS_ESTABLISHED:

		tp->t_state = TCPS_FIN_WAIT_1;

		break;



	case TCPS_CLOSE_WAIT:

		tp->t_state = TCPS_LAST_ACK;

		break;

	}

	if (tp)

		tcp_output(tp);

}
 and probability:0.18181818181818182
code:static void icp_pit_write(void *opaque, target_phys_addr_t offset,

                          uint64_t value, unsigned size)

{

    icp_pit_state *s = (icp_pit_state *)opaque;

    int n;



    n = offset >> 8;

    if (n > 3) {

        hw_error("sp804_write: Bad timer %d\n", n);

    }



    arm_timer_write(s->timer[n], offset & 0xff, value);

}
 and probability:0.09090909090909091
code:static int exynos4210_combiner_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    Exynos4210CombinerState *s = EXYNOS4210_COMBINER(dev);

    unsigned int i;



    /* Allocate general purpose input signals and connect a handler to each of

     * them */

    qdev_init_gpio_in(dev, exynos4210_combiner_handler, IIC_NIRQ);



    /* Connect SysBusDev irqs to device specific irqs */

    for (i = 0; i < IIC_NIRQ; i++) {

        sysbus_init_irq(sbd, &s->output_irq[i]);

    }



    memory_region_init_io(&s->iomem, OBJECT(s), &exynos4210_combiner_ops, s,

                          "exynos4210-combiner", IIC_REGION_SIZE);

    sysbus_init_mmio(sbd, &s->iomem);



    return 0;

}
 and probability:0.23529411764705882
code:static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part = (1 << porder);

    all_bits = 0;



    cnt = (n >> porder) - pred_order;

    for(i=0; i<part; i++) {

        if(i == 1) cnt = (n >> porder);

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

    }

    all_bits += (4 * part);



    rc->porder = porder;



    return all_bits;

}
 and probability:0.3684210526315789
code:static void raw_decode(uint8_t *dst, const int8_t *src, int src_size)

{

    while (src_size--)

        *dst++ = *src++ + 128;

}
 and probability:0.4
code:static int dxtory_decode_v1_410(AVCodecContext *avctx, AVFrame *pic,

                                const uint8_t *src, int src_size)

{

    int h, w;

    uint8_t *Y1, *Y2, *Y3, *Y4, *U, *V;

    int ret;



    if (src_size < avctx->width * avctx->height * 9LL / 8) {

        av_log(avctx, AV_LOG_ERROR, "packet too small\n");

        return AVERROR_INVALIDDATA;

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV410P;

    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    Y1 = pic->data[0];

    Y2 = pic->data[0] + pic->linesize[0];

    Y3 = pic->data[0] + pic->linesize[0] * 2;

    Y4 = pic->data[0] + pic->linesize[0] * 3;

    U  = pic->data[1];

    V  = pic->data[2];

    for (h = 0; h < avctx->height; h += 4) {

        for (w = 0; w < avctx->width; w += 4) {

            AV_COPY32U(Y1 + w, src);

            AV_COPY32U(Y2 + w, src + 4);

            AV_COPY32U(Y3 + w, src + 8);

            AV_COPY32U(Y4 + w, src + 12);

            U[w >> 2] = src[16] + 0x80;

            V[w >> 2] = src[17] + 0x80;

            src += 18;

        }

        Y1 += pic->linesize[0] << 2;

        Y2 += pic->linesize[0] << 2;

        Y3 += pic->linesize[0] << 2;

        Y4 += pic->linesize[0] << 2;

        U  += pic->linesize[1];

        V  += pic->linesize[2];

    }



    return 0;

}
 and probability:0.6052631578947368
code:static int ff_filter_frame_framed(AVFilterLink *link, AVFilterBufferRef *frame)

{

    int (*filter_frame)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *src = link->srcpad;

    AVFilterPad *dst = link->dstpad;

    AVFilterBufferRef *out;

    int perms, ret;

    AVFilterCommand *cmd= link->dst->command_queue;

    int64_t pts;



    if (link->closed) {

        avfilter_unref_buffer(frame);

        return AVERROR_EOF;

    }



    if (!(filter_frame = dst->filter_frame))

        filter_frame = default_filter_frame;



    av_assert1((frame->perms & src->min_perms) == src->min_perms);

    frame->perms &= ~ src->rej_perms;

    perms = frame->perms;



    if (frame->linesize[0] < 0)

        perms |= AV_PERM_NEG_LINESIZES;



    /* prepare to copy the frame if the buffer has insufficient permissions */

    if ((dst->min_perms & perms) != dst->min_perms ||

        dst->rej_perms & perms) {

        av_log(link->dst, AV_LOG_DEBUG,

               "Copying data in avfilter (have perms %x, need %x, reject %x)\n",

               perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        /* Maybe use ff_copy_buffer_ref instead? */

        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            out = ff_get_video_buffer(link, dst->min_perms,

                                      link->w, link->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            out = ff_get_audio_buffer(link, dst->min_perms,

                                      frame->audio->nb_samples);

            break;

        default: return AVERROR(EINVAL);

        }

        if (!out) {

            avfilter_unref_buffer(frame);

            return AVERROR(ENOMEM);

        }

        avfilter_copy_buffer_ref_props(out, frame);



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,

                          frame->format, frame->video->w, frame->video->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            av_samples_copy(out->extended_data, frame->extended_data,

                            0, 0, frame->audio->nb_samples,

                            av_get_channel_layout_nb_channels(frame->audio->channel_layout),

                            frame->format);

            break;

        default: return AVERROR(EINVAL);

        }



        avfilter_unref_buffer(frame);

    } else

        out = frame;



    while(cmd && cmd->time <= frame->pts * av_q2d(link->time_base)){

        av_log(link->dst, AV_LOG_DEBUG,

               "Processing command time:%f command:%s arg:%s\n",

               cmd->time, cmd->command, cmd->arg);

        avfilter_process_command(link->dst, cmd->command, cmd->arg, 0, 0, cmd->flags);

        ff_command_queue_pop(link->dst);

        cmd= link->dst->command_queue;

    }



    pts = out->pts;

    ret = filter_frame(link, out);

    ff_update_link_current_pts(link, pts);

    return ret;

}
 and probability:0.4444444444444444
code:void bdrv_get_backing_filename(BlockDriverState *bs,

                               char *filename, int filename_size)

{

    if (!bs->backing_hd) {

        pstrcpy(filename, filename_size, "");

    } else {

        pstrcpy(filename, filename_size, bs->backing_file);

    }

}
 and probability:0.2222222222222222
code:static uint32_t e1000e_macreg_read(e1000e_device *d, uint32_t reg)

{

    return qpci_io_readl(d->pci_dev, d->mac_regs + reg);

}
 and probability:0.25
code:static inline void direct_ref_list_init(H264Context * const h){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    Picture * const cur = s->current_picture_ptr;

    int list, i, j;

    if(cur->pict_type == I_TYPE)

        cur->ref_count[0] = 0;

    if(cur->pict_type != B_TYPE)

        cur->ref_count[1] = 0;

    for(list=0; list<2; list++){

        cur->ref_count[list] = h->ref_count[list];

        for(j=0; j<h->ref_count[list]; j++)

            cur->ref_poc[list][j] = h->ref_list[list][j].poc;

    }

    if(cur->pict_type != B_TYPE || h->direct_spatial_mv_pred)

        return;

    for(list=0; list<2; list++){

        for(i=0; i<ref1->ref_count[list]; i++){

            const int poc = ref1->ref_poc[list][i];

            h->map_col_to_list0[list][i] = PART_NOT_AVAILABLE;

            for(j=0; j<h->ref_count[list]; j++)

                if(h->ref_list[list][j].poc == poc){

                    h->map_col_to_list0[list][i] = j;

                    break;

                }

        }

    }

}
 and probability:0.6785714285714286
code:static void encode_rgb48_10bit(AVCodecContext *avctx, const AVPicture *pic, uint8_t *dst)

{

    DPXContext *s = avctx->priv_data;

    const uint8_t *src = pic->data[0];

    int x, y;



    for (y = 0; y < avctx->height; y++) {

        for (x = 0; x < avctx->width; x++) {

            int value;

            if (s->big_endian) {

                value = ((AV_RB16(src + 6*x + 4) & 0xFFC0) >> 4)

                      | ((AV_RB16(src + 6*x + 2) & 0xFFC0) << 6)

                      | ((AV_RB16(src + 6*x + 0) & 0xFFC0) << 16);

            } else {

                value = ((AV_RL16(src + 6*x + 4) & 0xFFC0) >> 4)

                      | ((AV_RL16(src + 6*x + 2) & 0xFFC0) << 6)

                      | ((AV_RL16(src + 6*x + 0) & 0xFFC0) << 16);

            }

            write32(dst, value);

            dst += 4;

        }

        src += pic->linesize[0];

    }

}
 and probability:0.5652173913043478
code:static int tgv_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    TgvContext *s = avctx->priv_data;

    const uint8_t *buf_end = buf + buf_size;

    int chunk_type;



    if (buf_end - buf < EA_PREAMBLE_SIZE)

        return AVERROR_INVALIDDATA;



    chunk_type = AV_RL32(&buf[0]);

    buf += EA_PREAMBLE_SIZE;



    if (chunk_type==kVGT_TAG) {

        int pal_count, i;

        if(buf_end - buf < 12) {

            av_log(avctx, AV_LOG_WARNING, "truncated header\n");

            return -1;

        }



        s->width  = AV_RL16(&buf[0]);

        s->height = AV_RL16(&buf[2]);

        if (s->avctx->width!=s->width || s->avctx->height!=s->height) {

            avcodec_set_dimensions(s->avctx, s->width, s->height);

            cond_release_buffer(&s->frame);

            cond_release_buffer(&s->last_frame);

        }



        pal_count = AV_RL16(&buf[6]);

        buf += 12;

        for(i=0; i<pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {

            s->palette[i] = 0xFF << 24 | AV_RB24(buf);

            buf += 3;

        }

    }



    if (av_image_check_size(s->width, s->height, 0, avctx))

        return -1;



    /* shuffle */

    FFSWAP(AVFrame, s->frame, s->last_frame);

    if (!s->frame.data[0]) {

        s->frame.reference = 3;

        s->frame.buffer_hints = FF_BUFFER_HINTS_VALID;

        s->frame.linesize[0] = s->width;



        /* allocate additional 12 bytes to accommodate av_memcpy_backptr() OUTBUF_PADDED optimisation */

        s->frame.data[0] = av_malloc(s->width*s->height + 12);

        if (!s->frame.data[0])

            return AVERROR(ENOMEM);

        s->frame.data[1] = av_malloc(AVPALETTE_SIZE);

        if (!s->frame.data[1]) {

            av_freep(&s->frame.data[0]);

            return AVERROR(ENOMEM);

        }

    }

    memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);



    if(chunk_type==kVGT_TAG) {

        s->frame.key_frame = 1;

        s->frame.pict_type = AV_PICTURE_TYPE_I;

        if (unpack(buf, buf_end, s->frame.data[0], s->avctx->width, s->avctx->height)<0) {

            av_log(avctx, AV_LOG_WARNING, "truncated intra frame\n");

            return -1;

        }

    }else{

        if (!s->last_frame.data[0]) {

            av_log(avctx, AV_LOG_WARNING, "inter frame without corresponding intra frame\n");

            return buf_size;

        }

        s->frame.key_frame = 0;

        s->frame.pict_type = AV_PICTURE_TYPE_P;

        if (tgv_decode_inter(s, buf, buf_end)<0) {

            av_log(avctx, AV_LOG_WARNING, "truncated inter frame\n");

            return -1;

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;



    return buf_size;

}
 and probability:0.52
code:static void adjust_frame_information(ChannelElement *cpe, int chans)

{

    int i, w, w2, g, ch;

    int start, maxsfb, cmaxsfb;



    for (ch = 0; ch < chans; ch++) {

        IndividualChannelStream *ics = &cpe->ch[ch].ics;

        start = 0;

        maxsfb = 0;

        cpe->ch[ch].pulse.num_pulse = 0;

        for (w = 0; w < ics->num_windows*16; w += 16) {

            for (g = 0; g < ics->num_swb; g++) {

                //apply M/S

                if (cpe->common_window && !ch && cpe->ms_mask[w + g]) {

                    for (i = 0; i < ics->swb_sizes[g]; i++) {

                        cpe->ch[0].coeffs[start+i] = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) / 2.0;

                        cpe->ch[1].coeffs[start+i] =  cpe->ch[0].coeffs[start+i] - cpe->ch[1].coeffs[start+i];

                    }

                }

                start += ics->swb_sizes[g];

            }

            for (cmaxsfb = ics->num_swb; cmaxsfb > 0 && cpe->ch[ch].zeroes[w+cmaxsfb-1]; cmaxsfb--)

                ;

            maxsfb = FFMAX(maxsfb, cmaxsfb);

        }

        ics->max_sfb = maxsfb;



        //adjust zero bands for window groups

        for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {

            for (g = 0; g < ics->max_sfb; g++) {

                i = 1;

                for (w2 = w; w2 < w + ics->group_len[w]; w2++) {

                    if (!cpe->ch[ch].zeroes[w2*16 + g]) {

                        i = 0;

                        break;

                    }

                }

                cpe->ch[ch].zeroes[w*16 + g] = i;

            }

        }

    }



    if (chans > 1 && cpe->common_window) {

        IndividualChannelStream *ics0 = &cpe->ch[0].ics;

        IndividualChannelStream *ics1 = &cpe->ch[1].ics;

        int msc = 0;

        ics0->max_sfb = FFMAX(ics0->max_sfb, ics1->max_sfb);

        ics1->max_sfb = ics0->max_sfb;

        for (w = 0; w < ics0->num_windows*16; w += 16)

            for (i = 0; i < ics0->max_sfb; i++)

                if (cpe->ms_mask[w+i])

                    msc++;

        if (msc == 0 || ics0->max_sfb == 0)

            cpe->ms_mode = 0;

        else

            cpe->ms_mode = msc < ics0->max_sfb * ics0->num_windows ? 1 : 2;

    }

}
 and probability:0.5272727272727272
code:int ff_img_read_header(AVFormatContext *s1)

{

    VideoDemuxData *s = s1->priv_data;

    int first_index, last_index;

    AVStream *st;

    enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;



    s1->ctx_flags |= AVFMTCTX_NOHEADER;



    st = avformat_new_stream(s1, NULL);

    if (!st) {

        return AVERROR(ENOMEM);

    }



    if (s->pixel_format &&

        (pix_fmt = av_get_pix_fmt(s->pixel_format)) == AV_PIX_FMT_NONE) {

        av_log(s1, AV_LOG_ERROR, "No such pixel format: %s.\n",

               s->pixel_format);

        return AVERROR(EINVAL);

    }



    av_strlcpy(s->path, s1->filename, sizeof(s->path));

    s->img_number = 0;

    s->img_count  = 0;



    /* find format */

    if (s1->iformat->flags & AVFMT_NOFILE)

        s->is_pipe = 0;

    else {

        s->is_pipe       = 1;

        st->need_parsing = AVSTREAM_PARSE_FULL;

    }



    if (s->ts_from_file == 2) {

#if !HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC

        av_log(s1, AV_LOG_ERROR, "POSIX.1-2008 not supported, nanosecond file timestamps unavailable\n");

        return AVERROR(ENOSYS);

#endif

        avpriv_set_pts_info(st, 64, 1, 1000000000);

    } else if (s->ts_from_file)

        avpriv_set_pts_info(st, 64, 1, 1);

    else

        avpriv_set_pts_info(st, 64, s->framerate.den, s->framerate.num);



    if (s->width && s->height) {

        st->codec->width  = s->width;

        st->codec->height = s->height;

    }



    if (!s->is_pipe) {

        if (s->pattern_type == PT_GLOB_SEQUENCE) {

        s->use_glob = is_glob(s->path);

        if (s->use_glob) {

#if HAVE_GLOB

            char *p = s->path, *q, *dup;

            int gerr;

#endif



            av_log(s1, AV_LOG_WARNING, "Pattern type 'glob_sequence' is deprecated: "

                   "use pattern_type 'glob' instead\n");

#if HAVE_GLOB

            dup = q = av_strdup(p);

            while (*q) {

                /* Do we have room for the next char and a \ insertion? */

                if ((p - s->path) >= (sizeof(s->path) - 2))

                  break;

                if (*q == '%' && strspn(q + 1, "%*?[]{}"))

                    ++q;

                else if (strspn(q, "\\*?[]{}"))

                    *p++ = '\\';

                *p++ = *q++;

            }

            *p = 0;

            av_free(dup);



            gerr = glob(s->path, GLOB_NOCHECK|GLOB_BRACE|GLOB_NOMAGIC, NULL, &s->globstate);

            if (gerr != 0) {

                return AVERROR(ENOENT);

            }

            first_index = 0;

            last_index = s->globstate.gl_pathc - 1;

#endif

        }

        }

        if ((s->pattern_type == PT_GLOB_SEQUENCE && !s->use_glob) || s->pattern_type == PT_SEQUENCE) {

            if (find_image_range(&first_index, &last_index, s->path,

                                 s->start_number, s->start_number_range) < 0) {

                av_log(s1, AV_LOG_ERROR,

                       "Could find no file with path '%s' and index in the range %d-%d\n",

                       s->path, s->start_number, s->start_number + s->start_number_range - 1);

                return AVERROR(ENOENT);

            }

        } else if (s->pattern_type == PT_GLOB) {

#if HAVE_GLOB

            int gerr;

            gerr = glob(s->path, GLOB_NOCHECK|GLOB_BRACE|GLOB_NOMAGIC, NULL, &s->globstate);

            if (gerr != 0) {

                return AVERROR(ENOENT);

            }

            first_index = 0;

            last_index = s->globstate.gl_pathc - 1;

            s->use_glob = 1;

#else

            av_log(s1, AV_LOG_ERROR,

                   "Pattern type 'glob' was selected but globbing "

                   "is not supported by this libavformat build\n");

            return AVERROR(ENOSYS);

#endif

        } else if (s->pattern_type != PT_GLOB_SEQUENCE) {

            av_log(s1, AV_LOG_ERROR,

                   "Unknown value '%d' for pattern_type option\n", s->pattern_type);

            return AVERROR(EINVAL);

        }

        s->img_first  = first_index;

        s->img_last   = last_index;

        s->img_number = first_index;

        /* compute duration */

        if (!s->ts_from_file) {

            st->start_time = 0;

            st->duration   = last_index - first_index + 1;

        }

    }



    if (s1->video_codec_id) {

        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

        st->codec->codec_id   = s1->video_codec_id;

    } else if (s1->audio_codec_id) {

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_id   = s1->audio_codec_id;

    } else if (s1->iformat->raw_codec_id) {

        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

        st->codec->codec_id   = s1->iformat->raw_codec_id;

    } else {

        const char *str = strrchr(s->path, '.');

        s->split_planes       = str && !av_strcasecmp(str + 1, "y");

        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

        if (s1->pb) {

            int probe_buffer_size = 2048;

            uint8_t *probe_buffer = av_realloc(NULL, probe_buffer_size + AVPROBE_PADDING_SIZE);

            AVInputFormat *fmt = NULL;

            AVProbeData pd = { 0 };



            if (!probe_buffer)

                return AVERROR(ENOMEM);



            probe_buffer_size = avio_read(s1->pb, probe_buffer, probe_buffer_size);

            if (probe_buffer_size < 0) {

                av_free(probe_buffer);

                return probe_buffer_size;

            }

            memset(probe_buffer + probe_buffer_size, 0, AVPROBE_PADDING_SIZE);



            pd.buf = probe_buffer;

            pd.buf_size = probe_buffer_size;

            pd.filename = s1->filename;



            while ((fmt = av_iformat_next(fmt))) {

                if (fmt->read_header != ff_img_read_header ||

                    !fmt->read_probe ||

                    (fmt->flags & AVFMT_NOFILE) ||

                    !fmt->raw_codec_id)

                    continue;

                if (fmt->read_probe(&pd) > 0) {

                    st->codec->codec_id = fmt->raw_codec_id;

                    break;

                }

            }

            ffio_rewind_with_probe_data(s1->pb, &probe_buffer, probe_buffer_size);

        }

        if (st->codec->codec_id == AV_CODEC_ID_NONE)

            st->codec->codec_id = ff_guess_image2_codec(s->path);

        if (st->codec->codec_id == AV_CODEC_ID_LJPEG)

            st->codec->codec_id = AV_CODEC_ID_MJPEG;

        if (st->codec->codec_id == AV_CODEC_ID_ALIAS_PIX) // we cannot distingiush this from BRENDER_PIX

            st->codec->codec_id = AV_CODEC_ID_NONE;

    }

    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

        pix_fmt != AV_PIX_FMT_NONE)

        st->codec->pix_fmt = pix_fmt;



    return 0;

}
 and probability:0.4819277108433735
code:static void hpet_ram_write(void *opaque, hwaddr addr,

                           uint64_t value, unsigned size)

{

    int i;

    HPETState *s = opaque;

    uint64_t old_val, new_val, val, index;



    DPRINTF("qemu: Enter hpet_ram_writel at %" PRIx64 " = %#x\n", addr, value);

    index = addr;

    old_val = hpet_ram_read(opaque, addr, 4);

    new_val = value;



    /*address range of all TN regs*/

    if (index >= 0x100 && index <= 0x3ff) {

        uint8_t timer_id = (addr - 0x100) / 0x20;

        HPETTimer *timer = &s->timer[timer_id];



        DPRINTF("qemu: hpet_ram_writel timer_id = %#x\n", timer_id);

        if (timer_id > s->num_timers) {

            DPRINTF("qemu: timer id out of range\n");

            return;

        }

        switch ((addr - 0x100) % 0x20) {

        case HPET_TN_CFG:

            DPRINTF("qemu: hpet_ram_writel HPET_TN_CFG\n");

            if (activating_bit(old_val, new_val, HPET_TN_FSB_ENABLE)) {

                update_irq(timer, 0);

            }

            val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);

            timer->config = (timer->config & 0xffffffff00000000ULL) | val;

            if (new_val & HPET_TN_32BIT) {

                timer->cmp = (uint32_t)timer->cmp;

                timer->period = (uint32_t)timer->period;

            }

            if (activating_bit(old_val, new_val, HPET_TN_ENABLE)) {

                hpet_set_timer(timer);

            } else if (deactivating_bit(old_val, new_val, HPET_TN_ENABLE)) {

                hpet_del_timer(timer);

            }

            break;

        case HPET_TN_CFG + 4: // Interrupt capabilities

            DPRINTF("qemu: invalid HPET_TN_CFG+4 write\n");

            break;

        case HPET_TN_CMP: // comparator register

            DPRINTF("qemu: hpet_ram_writel HPET_TN_CMP\n");

            if (timer->config & HPET_TN_32BIT) {

                new_val = (uint32_t)new_val;

            }

            if (!timer_is_periodic(timer)

                || (timer->config & HPET_TN_SETVAL)) {

                timer->cmp = (timer->cmp & 0xffffffff00000000ULL) | new_val;

            }

            if (timer_is_periodic(timer)) {

                /*

                 * FIXME: Clamp period to reasonable min value?

                 * Clamp period to reasonable max value

                 */

                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;

                timer->period =

                    (timer->period & 0xffffffff00000000ULL) | new_val;

            }

            timer->config &= ~HPET_TN_SETVAL;

            if (hpet_enabled(s)) {

                hpet_set_timer(timer);

            }

            break;

        case HPET_TN_CMP + 4: // comparator register high order

            DPRINTF("qemu: hpet_ram_writel HPET_TN_CMP + 4\n");

            if (!timer_is_periodic(timer)

                || (timer->config & HPET_TN_SETVAL)) {

                timer->cmp = (timer->cmp & 0xffffffffULL) | new_val << 32;

            } else {

                /*

                 * FIXME: Clamp period to reasonable min value?

                 * Clamp period to reasonable max value

                 */

                new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;

                timer->period =

                    (timer->period & 0xffffffffULL) | new_val << 32;

                }

                timer->config &= ~HPET_TN_SETVAL;

                if (hpet_enabled(s)) {

                    hpet_set_timer(timer);

                }

                break;

        case HPET_TN_ROUTE:

            timer->fsb = (timer->fsb & 0xffffffff00000000ULL) | new_val;

            break;

        case HPET_TN_ROUTE + 4:

            timer->fsb = (new_val << 32) | (timer->fsb & 0xffffffff);

            break;

        default:

            DPRINTF("qemu: invalid hpet_ram_writel\n");

            break;

        }

        return;

    } else {

        switch (index) {

        case HPET_ID:

            return;

        case HPET_CFG:

            val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);

            s->config = (s->config & 0xffffffff00000000ULL) | val;

            if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {

                /* Enable main counter and interrupt generation. */

                s->hpet_offset =

                    ticks_to_ns(s->hpet_counter) - qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);

                for (i = 0; i < s->num_timers; i++) {

                    if ((&s->timer[i])->cmp != ~0ULL) {

                        hpet_set_timer(&s->timer[i]);

                    }

                }

            } else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {

                /* Halt main counter and disable interrupt generation. */

                s->hpet_counter = hpet_get_ticks(s);

                for (i = 0; i < s->num_timers; i++) {

                    hpet_del_timer(&s->timer[i]);

                }

            }

            /* i8254 and RTC output pins are disabled

             * when HPET is in legacy mode */

            if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {

                qemu_set_irq(s->pit_enabled, 0);

                qemu_irq_lower(s->irqs[0]);

                qemu_irq_lower(s->irqs[RTC_ISA_IRQ]);

            } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {

                qemu_irq_lower(s->irqs[0]);

                qemu_set_irq(s->pit_enabled, 1);

                qemu_set_irq(s->irqs[RTC_ISA_IRQ], s->rtc_irq_level);

            }

            break;

        case HPET_CFG + 4:

            DPRINTF("qemu: invalid HPET_CFG+4 write\n");

            break;

        case HPET_STATUS:

            val = new_val & s->isr;

            for (i = 0; i < s->num_timers; i++) {

                if (val & (1 << i)) {

                    update_irq(&s->timer[i], 0);

                }

            }

            break;

        case HPET_COUNTER:

            if (hpet_enabled(s)) {

                DPRINTF("qemu: Writing counter while HPET enabled!\n");

            }

            s->hpet_counter =

                (s->hpet_counter & 0xffffffff00000000ULL) | value;

            DPRINTF("qemu: HPET counter written. ctr = %#x -> %" PRIx64 "\n",

                    value, s->hpet_counter);

            break;

        case HPET_COUNTER + 4:

            if (hpet_enabled(s)) {

                DPRINTF("qemu: Writing counter while HPET enabled!\n");

            }

            s->hpet_counter =

                (s->hpet_counter & 0xffffffffULL) | (((uint64_t)value) << 32);

            DPRINTF("qemu: HPET counter + 4 written. ctr = %#x -> %" PRIx64 "\n",

                    value, s->hpet_counter);

            break;

        default:

            DPRINTF("qemu: invalid hpet_ram_writel\n");

            break;

        }

    }

}
 and probability:0.3128834355828221
code:static abi_ulong copy_elf_strings(int argc,char ** argv, void **page,

                                  abi_ulong p)

{

    char *tmp, *tmp1, *pag = NULL;

    int len, offset = 0;



    if (!p) {

        return 0;       /* bullet-proofing */

    }

    while (argc-- > 0) {

        tmp = argv[argc];

        if (!tmp) {

            fprintf(stderr, "VFS: argc is wrong");

            exit(-1);

        }

        tmp1 = tmp;

        while (*tmp++);

        len = tmp - tmp1;

        if (p < len) {  /* this shouldn't happen - 128kB */

            return 0;

        }

        while (len) {

            --p; --tmp; --len;

            if (--offset < 0) {

                offset = p % TARGET_PAGE_SIZE;

                pag = (char *)page[p/TARGET_PAGE_SIZE];

                if (!pag) {

                    pag = (char *)malloc(TARGET_PAGE_SIZE);

                    memset(pag, 0, TARGET_PAGE_SIZE);

                    page[p/TARGET_PAGE_SIZE] = pag;

                    if (!pag)

                        return 0;

                }

            }

            if (len == 0 || offset == 0) {

                *(pag + offset) = *tmp;

            }

            else {

                int bytes_to_copy = (len > offset) ? offset : len;

                tmp -= bytes_to_copy;

                p -= bytes_to_copy;

                offset -= bytes_to_copy;

                len -= bytes_to_copy;

                memcpy_fromfs(pag + offset, tmp, bytes_to_copy + 1);

            }

        }

    }

    return p;

}
 and probability:0.3333333333333333
code:static int mov_text_decode_close(AVCodecContext *avctx)

{

    MovTextContext *m = avctx->priv_data;

    mov_text_cleanup_ftab(m);


    return 0;

} and probability:0.16666666666666666
code:static void xhci_intr_raise(XHCIState *xhci, int v)

{

    PCIDevice *pci_dev = PCI_DEVICE(xhci);




    xhci->intr[v].erdp_low |= ERDP_EHB;

    xhci->intr[v].iman |= IMAN_IP;

    xhci->usbsts |= USBSTS_EINT;






    if (!(xhci->intr[v].iman & IMAN_IE)) {





    if (!(xhci->usbcmd & USBCMD_INTE)) {





    if (msix_enabled(pci_dev)) {

        trace_usb_xhci_irq_msix(v);

        msix_notify(pci_dev, v);





    if (msi_enabled(pci_dev)) {

        trace_usb_xhci_irq_msi(v);

        msi_notify(pci_dev, v);





    if (v == 0) {

        trace_usb_xhci_irq_intx(1);

        pci_irq_assert(pci_dev);

 and probability:0.29411764705882354
code:int qemu_chr_fe_get_msgfd(CharDriverState *s)

{

    int fd;

    return (qemu_chr_fe_get_msgfds(s, &fd, 1) >= 0) ? fd : -1;

}
 and probability:0.0
code:void qemu_set_dfilter_ranges(const char *filter_spec)
{
    gchar **ranges = g_strsplit(filter_spec, ",", 0);
    if (ranges) {
        gchar **next = ranges;
        gchar *r = *next++;
        debug_regions = g_array_sized_new(FALSE, FALSE,
                                          sizeof(Range), g_strv_length(ranges));
        while (r) {
            char *range_op = strstr(r, "-");
            char *r2 = range_op ? range_op + 1 : NULL;
            if (!range_op) {
                range_op = strstr(r, "+");
                r2 = range_op ? range_op + 1 : NULL;
            if (!range_op) {
                range_op = strstr(r, "..");
                r2 = range_op ? range_op + 2 : NULL;
            if (range_op) {
                const char *e = NULL;
                uint64_t r1val, r2val;
                if ((qemu_strtoull(r, &e, 0, &r1val) == 0) &&
                    (qemu_strtoull(r2, NULL, 0, &r2val) == 0) &&
                    r2val > 0) {
                    struct Range range;
                    g_assert(e == range_op);
                    switch (*range_op) {
                    case '+':
                    {
                        range.begin = r1val;
                        range.end = r1val + (r2val - 1);
                        break;
                    case '-':
                    {
                        range.end = r1val;
                        range.begin = r1val - (r2val - 1);
                        break;
                    case '.':
                        range.begin = r1val;
                        range.end = r2val;
                        break;
                    default:
                        g_assert_not_reached();
                    g_array_append_val(debug_regions, range);
                } else {
                    g_error("Failed to parse range in: %s", r);
            } else {
                g_error("Bad range specifier in: %s", r);
            r = *next++;
        g_strfreev(ranges); and probability:0.16326530612244897
code:static void flush(AVCodecContext *avctx)

{

    WmallDecodeCtx *s    = avctx->priv_data;

    s->packet_loss       = 1;

    s->packet_done       = 0;

    s->num_saved_bits    = 0;

    s->frame_offset      = 0;

    s->next_packet_start = 0;

    s->cdlms[0][0].order = 0;

    s->frame.nb_samples  = 0;

    init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);

}
 and probability:0.75
code:avs_decode_frame(AVCodecContext * avctx,

                 void *data, int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    const uint8_t *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    AvsContext *const avs = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame *const p =  &avs->picture;

    const uint8_t *table, *vect;

    uint8_t *out;

    int i, j, x, y, stride, vect_w = 3, vect_h = 3;

    AvsVideoSubType sub_type;

    AvsBlockType type;

    GetBitContext change_map;



    if (avctx->reget_buffer(avctx, p)) {

        av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n");

        return -1;

    }

    p->reference = 3;

    p->pict_type = AV_PICTURE_TYPE_P;

    p->key_frame = 0;



    out = avs->picture.data[0];

    stride = avs->picture.linesize[0];



    if (buf_end - buf < 4)

        return AVERROR_INVALIDDATA;

    sub_type = buf[0];

    type = buf[1];

    buf += 4;



    if (type == AVS_PALETTE) {

        int first, last;

        uint32_t *pal = (uint32_t *) avs->picture.data[1];



        first = AV_RL16(buf);

        last = first + AV_RL16(buf + 2);

        if (first >= 256 || last > 256 || buf_end - buf < 4 + 4 + 3 * (last - first))

            return AVERROR_INVALIDDATA;

        buf += 4;

        for (i=first; i<last; i++, buf+=3) {

            pal[i] = (buf[0] << 18) | (buf[1] << 10) | (buf[2] << 2);

            pal[i] |= 0xFF << 24 | (pal[i] >> 6) & 0x30303;

        }



        sub_type = buf[0];

        type = buf[1];

        buf += 4;

    }



    if (type != AVS_VIDEO)

        return -1;



    switch (sub_type) {

    case AVS_I_FRAME:

        p->pict_type = AV_PICTURE_TYPE_I;

        p->key_frame = 1;

    case AVS_P_FRAME_3X3:

        vect_w = 3;

        vect_h = 3;

        break;



    case AVS_P_FRAME_2X2:

        vect_w = 2;

        vect_h = 2;

        break;



    case AVS_P_FRAME_2X3:

        vect_w = 2;

        vect_h = 3;

        break;



    default:

      return -1;

    }



    if (buf_end - buf < 256 * vect_w * vect_h)

        return AVERROR_INVALIDDATA;

    table = buf + (256 * vect_w * vect_h);

    if (sub_type != AVS_I_FRAME) {

        int map_size = ((318 / vect_w + 7) / 8) * (198 / vect_h);

        if (buf_end - table < map_size)

            return AVERROR_INVALIDDATA;

        init_get_bits(&change_map, table, map_size * 8);

        table += map_size;

    }



    for (y=0; y<198; y+=vect_h) {

        for (x=0; x<318; x+=vect_w) {

            if (sub_type == AVS_I_FRAME || get_bits1(&change_map)) {

                if (buf_end - table < 1)

                    return AVERROR_INVALIDDATA;

                vect = &buf[*table++ * (vect_w * vect_h)];

                for (j=0; j<vect_w; j++) {

                    out[(y + 0) * stride + x + j] = vect[(0 * vect_w) + j];

                    out[(y + 1) * stride + x + j] = vect[(1 * vect_w) + j];

                    if (vect_h == 3)

                        out[(y + 2) * stride + x + j] =

                            vect[(2 * vect_w) + j];

                }

            }

        }

        if (sub_type != AVS_I_FRAME)

            align_get_bits(&change_map);

    }



    *picture   = avs->picture;

    *data_size = sizeof(AVPicture);



    return buf_size;

}
 and probability:0.46938775510204084
code:static void uc32_cpu_realizefn(DeviceState *dev, Error **errp)
{
    UniCore32CPUClass *ucc = UNICORE32_CPU_GET_CLASS(dev);
    ucc->parent_realize(dev, errp);
} and probability:0.2
code:void parse_option_size(const char *name, const char *value,

                       uint64_t *ret, Error **errp)

{

    char *postfix;

    double sizef;



    sizef = strtod(value, &postfix);

    if (sizef < 0 || sizef > UINT64_MAX) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name,

                   "a non-negative number below 2^64");

        return;

    }

    switch (*postfix) {

    case 'T':

        sizef *= 1024;

        /* fall through */

    case 'G':

        sizef *= 1024;

        /* fall through */

    case 'M':

        sizef *= 1024;

        /* fall through */

    case 'K':

    case 'k':

        sizef *= 1024;

        /* fall through */

    case 'b':

    case '\0':

        *ret = (uint64_t) sizef;

        break;

    default:

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name, "a size");

        error_append_hint(errp, "You may use k, M, G or T suffixes for "

                          "kilobytes, megabytes, gigabytes and terabytes.\n");

        return;

    }

}
 and probability:0.05555555555555555
code:static void gen_ove_cy(DisasContext *dc, TCGv cy)

{

    if (dc->tb_flags & SR_OVE) {

        gen_helper_ove(cpu_env, cy);

    }

}
 and probability:0.16666666666666666
code:static void limits_nesting(void)

{

    enum { max_nesting = 1024 }; /* see qobject/json-streamer.c */

    char buf[2 * (max_nesting + 1) + 1];

    QObject *obj;



    obj = qobject_from_json(make_nest(buf, max_nesting), NULL);

    g_assert(obj != NULL);

    qobject_decref(obj);



    obj = qobject_from_json(make_nest(buf, max_nesting + 1), NULL);

    g_assert(obj == NULL);

}
 and probability:0.18181818181818182
code:static int decode_end(AVCodecContext *avctx)

{

    H264Context *h = avctx->priv_data;

    MpegEncContext *s = &h->s;

    


    free_tables(h); //FIXME cleanup init stuff perhaps

    MPV_common_end(s);



//    memset(h, 0, sizeof(H264Context));

        

    return 0;

} and probability:0.2222222222222222
code:static av_cold int validate_options(AVCodecContext *avctx, AC3EncodeContext *s)

{

    int i, j;



    if (!avctx->channel_layout) {

        av_log(avctx, AV_LOG_WARNING, "No channel layout specified. The "

                                      "encoder will guess the layout, but it "

                                      "might be incorrect.\n");

    }

    if (set_channel_info(s, avctx->channels, &avctx->channel_layout)) {

        av_log(avctx, AV_LOG_ERROR, "invalid channel layout\n");

        return -1;

    }



    /* frequency */

    for (i = 0; i < 3; i++) {

        for (j = 0; j < 3; j++)

            if ((ff_ac3_sample_rate_tab[j] >> i) == avctx->sample_rate)

                goto found;

    }

    return -1;

 found:

    s->sample_rate        = avctx->sample_rate;

    s->bit_alloc.sr_shift = i;

    s->bit_alloc.sr_code  = j;

    s->bitstream_id       = 8 + s->bit_alloc.sr_shift;

    s->bitstream_mode     = 0; /* complete main audio service */



    /* bitrate & frame size */

    for (i = 0; i < 19; i++) {

        if ((ff_ac3_bitrate_tab[i] >> s->bit_alloc.sr_shift)*1000 == avctx->bit_rate)

            break;

    }

    if (i == 19)

        return -1;

    s->bit_rate        = avctx->bit_rate;

    s->frame_size_code = i << 1;



    return 0;

}
 and probability:0.3888888888888889
code:static NvencSurface *get_free_frame(NvencContext *ctx)

{

    int i;



    for (i = 0; i < ctx->nb_surfaces; i++) {

        if (!ctx->surfaces[i].lockCount) {

            ctx->surfaces[i].lockCount = 1;

            return &ctx->surfaces[i];

        }

    }



    return NULL;

}
 and probability:0.36363636363636365
code:int ff_ccitt_unpack(AVCodecContext *avctx,

                    const uint8_t *src, int srcsize,

                    uint8_t *dst, int height, int stride,

                    enum TiffCompr compr, int opts)

{

    int j;

    GetBitContext gb;

    int *runs, *ref, *runend;

    int ret;

    int runsize= avctx->width + 2;



    runs = av_malloc(runsize * sizeof(runs[0]));

    ref  = av_malloc(runsize * sizeof(ref[0]));

    ref[0] = avctx->width;

    ref[1] = 0;

    ref[2] = 0;

    init_get_bits(&gb, src, srcsize*8);

    for(j = 0; j < height; j++){

        runend = runs + runsize;

        if(compr == TIFF_G4){

            ret = decode_group3_2d_line(avctx, &gb, avctx->width, runs, runend, ref);

            if(ret < 0){

                av_free(runs);

                av_free(ref);

                return -1;

            }

        }else{

            int g3d1 = (compr == TIFF_G3) && !(opts & 1);

            if(compr!=TIFF_CCITT_RLE && find_group3_syncmarker(&gb, srcsize*8) < 0)

                break;

            if(compr==TIFF_CCITT_RLE || g3d1 || get_bits1(&gb))

                ret = decode_group3_1d_line(avctx, &gb, avctx->width, runs, runend);

            else

                ret = decode_group3_2d_line(avctx, &gb, avctx->width, runs, runend, ref);

            if(compr==TIFF_CCITT_RLE)

                align_get_bits(&gb);

        }

        if(ret < 0){

            put_line(dst, stride, avctx->width, ref);

        }else{

            put_line(dst, stride, avctx->width, runs);

            FFSWAP(int*, runs, ref);

        }

        dst += stride;

    }

    av_free(runs);

    av_free(ref);

    return 0;

}
 and probability:0.3333333333333333
code:static int exif_decode_tag(void *logctx, GetByteContext *gbytes, int le,

                           int depth, AVDictionary **metadata)

{

    int ret, cur_pos;

    unsigned id, count;

    enum TiffTypes type;



    if (depth > 2) {

        return 0;

    }



    ff_tread_tag(gbytes, le, &id, &type, &count, &cur_pos);



    if (!bytestream2_tell(gbytes)) {

        bytestream2_seek(gbytes, cur_pos, SEEK_SET);

        return 0;

    }



    // read count values and add it metadata

    // store metadata or proceed with next IFD

    ret = ff_tis_ifd(id);

    if (ret) {

        ret = avpriv_exif_decode_ifd(logctx, gbytes, le, depth + 1, metadata);

    } else {

        const char *name = exif_get_tag_name(id);

        char *use_name   = (char*) name;



        if (!use_name) {

            use_name = av_malloc(7);

            if (!use_name) {

                return AVERROR(ENOMEM);

            }

            snprintf(use_name, 7, "0x%04X", id);

        }



        ret = exif_add_metadata(logctx, count, type, use_name, NULL,

                                gbytes, le, metadata);



        if (!name) {

            av_freep(&use_name);

        }

    }



    bytestream2_seek(gbytes, cur_pos, SEEK_SET);



    return ret;

}
 and probability:0.02631578947368421
code:static int pci_bridge_dev_initfn(PCIDevice *dev)

{

    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);

    PCIBridgeDev *bridge_dev = DO_UPCAST(PCIBridgeDev, bridge, br);

    int err;

    pci_bridge_map_irq(br, NULL, pci_bridge_dev_map_irq_fn);

    err = pci_bridge_initfn(dev);

    if (err) {

        goto bridge_error;

    }

    memory_region_init(&bridge_dev->bar, "shpc-bar", shpc_bar_size(dev));

    err = shpc_init(dev, &br->sec_bus, &bridge_dev->bar, 0);

    if (err) {

        goto shpc_error;

    }

    err = slotid_cap_init(dev, 0, bridge_dev->chassis_nr, 0);

    if (err) {

        goto slotid_error;

    }

    if ((bridge_dev->flags & (1 << PCI_BRIDGE_DEV_F_MSI_REQ)) &&

        msi_supported) {

        err = msi_init(dev, 0, 1, true, true);

        if (err < 0) {

            goto msi_error;

        }

    }

    /* TODO: spec recommends using 64 bit prefetcheable BAR.

     * Check whether that works well. */

    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY |

		     PCI_BASE_ADDRESS_MEM_TYPE_64, &bridge_dev->bar);

    dev->config[PCI_INTERRUPT_PIN] = 0x1;

    return 0;

msi_error:

    slotid_cap_cleanup(dev);

slotid_error:

    shpc_cleanup(dev, &bridge_dev->bar);

shpc_error:

    memory_region_destroy(&bridge_dev->bar);

bridge_error:

    return err;

}
 and probability:0.1951219512195122
code:static const AVClass *urlcontext_child_class_next(const AVClass *prev)

{

    URLProtocol *p = NULL;



    /* find the protocol that corresponds to prev */

    while (prev && (p = ffurl_protocol_next(p)))

        if (p->priv_data_class == prev)

            break;



    /* find next protocol with priv options */

    while (p = ffurl_protocol_next(p))

        if (p->priv_data_class)

            return p->priv_data_class;

    return NULL;

}
 and probability:0.23076923076923078
code:static void do_change_vnc(const char *target)

{

    if (strcmp(target, "passwd") == 0 ||

	strcmp(target, "password") == 0) {

	char password[9];

	monitor_readline("Password: ", 1, password, sizeof(password)-1);

	password[sizeof(password)-1] = '\0';

	if (vnc_display_password(NULL, password) < 0)

	    term_printf("could not set VNC server password\n");

    } else {

	if (vnc_display_open(NULL, target) < 0)

	    term_printf("could not start VNC server on %s\n", target);

    }

}
 and probability:0.14285714285714285
code:int ff_get_cpu_flags_x86(void)

{

    int rval = 0;

    int eax, ebx, ecx, edx;

    int max_std_level, max_ext_level, std_caps=0, ext_caps=0;

    int family=0, model=0;

    union { int i[3]; char c[12]; } vendor;



#if ARCH_X86_32

    x86_reg a, c;

    __asm__ volatile (

        /* See if CPUID instruction is supported ... */

        /* ... Get copies of EFLAGS into eax and ecx */

        "pushfl\n\t"

        "pop %0\n\t"

        "mov %0, %1\n\t"



        /* ... Toggle the ID bit in one copy and store */

        /*     to the EFLAGS reg */

        "xor $0x200000, %0\n\t"

        "push %0\n\t"

        "popfl\n\t"



        /* ... Get the (hopefully modified) EFLAGS */

        "pushfl\n\t"

        "pop %0\n\t"

        : "=a" (a), "=c" (c)

        :

        : "cc"

        );



    if (a == c)

        return 0; /* CPUID not supported */

#endif



    cpuid(0, max_std_level, vendor.i[0], vendor.i[2], vendor.i[1]);



    if(max_std_level >= 1){

        cpuid(1, eax, ebx, ecx, std_caps);

        family = ((eax>>8)&0xf) + ((eax>>20)&0xff);

        model  = ((eax>>4)&0xf) + ((eax>>12)&0xf0);

        if (std_caps & (1<<23))

            rval |= AV_CPU_FLAG_MMX;

        if (std_caps & (1<<25))

            rval |= AV_CPU_FLAG_MMX2

#if HAVE_SSE

                  | AV_CPU_FLAG_SSE;

        if (std_caps & (1<<26))

            rval |= AV_CPU_FLAG_SSE2;

        if (ecx & 1)

            rval |= AV_CPU_FLAG_SSE3;

        if (ecx & 0x00000200 )

            rval |= AV_CPU_FLAG_SSSE3;

        if (ecx & 0x00080000 )

            rval |= AV_CPU_FLAG_SSE4;

        if (ecx & 0x00100000 )

            rval |= AV_CPU_FLAG_SSE42;

#if HAVE_AVX

        /* Check OXSAVE and AVX bits */

        if ((ecx & 0x18000000) == 0x18000000) {

            /* Check for OS support */

            xgetbv(0, eax, edx);

            if ((eax & 0x6) == 0x6)

                rval |= AV_CPU_FLAG_AVX;

        }

#endif

#endif

                  ;

    }



    cpuid(0x80000000, max_ext_level, ebx, ecx, edx);



    if(max_ext_level >= 0x80000001){

        cpuid(0x80000001, eax, ebx, ecx, ext_caps);

        if (ext_caps & (1<<31))

            rval |= AV_CPU_FLAG_3DNOW;

        if (ext_caps & (1<<30))

            rval |= AV_CPU_FLAG_3DNOWEXT;

        if (ext_caps & (1<<23))

            rval |= AV_CPU_FLAG_MMX;

        if (ext_caps & (1<<22))

            rval |= AV_CPU_FLAG_MMX2;



        /* Allow for selectively disabling SSE2 functions on AMD processors

           with SSE2 support but not SSE4a. This includes Athlon64, some

           Opteron, and some Sempron processors. MMX, SSE, or 3DNow! are faster

           than SSE2 often enough to utilize this special-case flag.

           AV_CPU_FLAG_SSE2 and AV_CPU_FLAG_SSE2SLOW are both set in this case

           so that SSE2 is used unless explicitly disabled by checking

           AV_CPU_FLAG_SSE2SLOW. */

        if (!strncmp(vendor.c, "AuthenticAMD", 12) &&

            rval & AV_CPU_FLAG_SSE2 && !(ecx & 0x00000040)) {

            rval |= AV_CPU_FLAG_SSE2SLOW;

        }

    }



    if (!strncmp(vendor.c, "GenuineIntel", 12)) {

        if (family == 6 && (model == 9 || model == 13 || model == 14)) {

            /* 6/9 (pentium-m "banias"), 6/13 (pentium-m "dothan"), and 6/14 (core1 "yonah")

            * theoretically support sse2, but it's usually slower than mmx,

            * so let's just pretend they don't. AV_CPU_FLAG_SSE2 is disabled and

            * AV_CPU_FLAG_SSE2SLOW is enabled so that SSE2 is not used unless

            * explicitly enabled by checking AV_CPU_FLAG_SSE2SLOW. The same

            * situation applies for AV_CPU_FLAG_SSE3 and AV_CPU_FLAG_SSE3SLOW. */

            if (rval & AV_CPU_FLAG_SSE2) rval ^= AV_CPU_FLAG_SSE2SLOW|AV_CPU_FLAG_SSE2;

            if (rval & AV_CPU_FLAG_SSE3) rval ^= AV_CPU_FLAG_SSE3SLOW|AV_CPU_FLAG_SSE3;

        }

        /* The Atom processor has SSSE3 support, which is useful in many cases,

         * but sometimes the SSSE3 version is slower than the SSE2 equivalent

         * on the Atom, but is generally faster on other processors supporting

         * SSSE3. This flag allows for selectively disabling certain SSSE3

         * functions on the Atom. */

        if (family == 6 && model == 28)

            rval |= AV_CPU_FLAG_ATOM;

    }



    return rval;

}
 and probability:0.028037383177570093
code:static inline void cvtyuvtoRGB (SwsContext *c,

			   vector signed short Y, vector signed short U, vector signed short V,

			   vector signed short *R, vector signed short *G, vector signed short *B)

{

  vector signed   short vx,ux,uvx;



  Y = vec_mradds (Y, c->CY, c->OY);

  U  = vec_sub (U,(vector signed short)

  			vec_splat((vector signed short)AVV(128),0));

  V  = vec_sub (V,(vector signed short)

  			vec_splat((vector signed short)AVV(128),0));



  //   ux  = (CBU*(u<<c->CSHIFT)+0x4000)>>15;

  ux = vec_sl (U, c->CSHIFT);

  *B = vec_mradds (ux, c->CBU, Y);



  // vx  = (CRV*(v<<c->CSHIFT)+0x4000)>>15;

  vx = vec_sl (V, c->CSHIFT);

  *R = vec_mradds (vx, c->CRV, Y);



  // uvx = ((CGU*u) + (CGV*v))>>15;

  uvx = vec_mradds (U, c->CGU, Y);

  *G = vec_mradds (V, c->CGV, uvx);

}
 and probability:0.35
code:void usb_generic_async_ctrl_complete(USBDevice *s, USBPacket *p)

{

    if (p->len < 0) {

        s->setup_state = SETUP_STATE_IDLE;

    }



    switch (s->setup_state) {

    case SETUP_STATE_SETUP:

        if (p->len < s->setup_len) {

            s->setup_len = p->len;

        }

        s->setup_state = SETUP_STATE_DATA;

        p->len = 8;

        break;



    case SETUP_STATE_ACK:

        s->setup_state = SETUP_STATE_IDLE;

        p->len = 0;

        break;



    default:

        break;

    }

    usb_packet_complete(s, p);

}
 and probability:0.4090909090909091
code:static int encode_audio_frame(AVFormatContext *s, OutputStream *ost,

                              const uint8_t *buf, int buf_size)

{

    AVCodecContext *enc = ost->st->codec;

    AVFrame *frame = NULL;

    AVPacket pkt;

    int ret, got_packet;



    av_init_packet(&pkt);

    pkt.data = NULL;

    pkt.size = 0;



    if (buf && buf_size) {

        if (!ost->output_frame) {

            ost->output_frame = avcodec_alloc_frame();

            if (!ost->output_frame) {

                av_log(NULL, AV_LOG_FATAL, "out-of-memory in encode_audio_frame()\n");

                exit_program(1);

            }

        }

        frame = ost->output_frame;

        if (frame->extended_data != frame->data)

            av_freep(&frame->extended_data);

        avcodec_get_frame_defaults(frame);



        frame->nb_samples  = buf_size /

                             (enc->channels * av_get_bytes_per_sample(enc->sample_fmt));

        if ((ret = avcodec_fill_audio_frame(frame, enc->channels, enc->sample_fmt,

                                            buf, buf_size, 1)) < 0) {

            av_log(NULL, AV_LOG_FATAL, "Audio encoding failed (avcodec_fill_audio_frame)\n");

            exit_program(1);

        }



        frame->pts = ost->sync_opts;

        ost->sync_opts += frame->nb_samples;

    }



    got_packet = 0;

    update_benchmark(NULL);

    if (avcodec_encode_audio2(enc, &pkt, frame, &got_packet) < 0) {

        av_log(NULL, AV_LOG_FATAL, "Audio encoding failed (avcodec_encode_audio2)\n");

        exit_program(1);

    }

    update_benchmark("encode_audio %d.%d", ost->file_index, ost->index);



    ret = pkt.size;



    if (got_packet) {

        if (pkt.pts != AV_NOPTS_VALUE)

            pkt.pts      = av_rescale_q(pkt.pts,      enc->time_base, ost->st->time_base);

        if (pkt.dts != AV_NOPTS_VALUE) {

            int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);

            pkt.dts      = av_rescale_q(pkt.dts,      enc->time_base, ost->st->time_base);

            if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt.dts) {

                av_log(s, max - pkt.dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, "Audio timestamp %"PRId64" < %"PRId64" invalid, cliping\n", pkt.dts, max);

                pkt.pts = pkt.dts = max;

            }

        }

        if (pkt.duration > 0)

            pkt.duration = av_rescale_q(pkt.duration, enc->time_base, ost->st->time_base);



        write_frame(s, &pkt, ost);



        audio_size += pkt.size;



        av_free_packet(&pkt);

    }



    if (debug_ts) {

        av_log(NULL, AV_LOG_INFO, "encoder -> type:audio "

               "pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s\n",

               av_ts2str(pkt.pts), av_ts2timestr(pkt.pts, &ost->st->time_base),

               av_ts2str(pkt.dts), av_ts2timestr(pkt.dts, &ost->st->time_base));

    }



    return ret;

}
 and probability:0.3384615384615385
code:static void rng_egd_opened(RngBackend *b, Error **errp)
{
    RngEgd *s = RNG_EGD(b);
    if (s->chr_name == NULL) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE,
                  "chardev", "a valid character device");
    s->chr = qemu_chr_find(s->chr_name);
    if (s->chr == NULL) {
        error_set(errp, QERR_DEVICE_NOT_FOUND, s->chr_name);
    /* FIXME we should resubmit pending requests when the CDS reconnects. */
    qemu_chr_add_handlers(s->chr, rng_egd_chr_can_read, rng_egd_chr_read,
                          NULL, s); and probability:0.4166666666666667
code:static int64_t mpegts_get_pcr(AVFormatContext *s, int stream_index,

                              int64_t *ppos, int64_t pos_limit)

{

    MpegTSContext *ts = s->priv_data;

    int64_t pos, timestamp;

    uint8_t buf[TS_PACKET_SIZE];

    int pcr_l, pcr_pid = ((PESContext*)s->streams[stream_index]->priv_data)->pcr_pid;

    pos = ((*ppos  + ts->raw_packet_size - 1 - ts->pos47) / ts->raw_packet_size) * ts->raw_packet_size + ts->pos47;

        while(pos < pos_limit) {

            avio_seek(s->pb, pos, SEEK_SET);

            if (avio_read(s->pb, buf, TS_PACKET_SIZE) != TS_PACKET_SIZE)

                return AV_NOPTS_VALUE;

            if ((pcr_pid < 0 || (AV_RB16(buf + 1) & 0x1fff) == pcr_pid) &&

                parse_pcr(&timestamp, &pcr_l, buf) == 0) {

                *ppos = pos;

                return timestamp;

            }

            pos += ts->raw_packet_size;

        }



    return AV_NOPTS_VALUE;

}
 and probability:0.38095238095238093
code:static enum AVPixelFormat get_pixel_format(H264Context *h)

{

#define HWACCEL_MAX (CONFIG_H264_DXVA2_HWACCEL + \

                     CONFIG_H264_D3D11VA_HWACCEL + \

                     CONFIG_H264_VAAPI_HWACCEL + \

                     (CONFIG_H264_VDA_HWACCEL * 2) + \

                     CONFIG_H264_VDPAU_HWACCEL)

    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;

    const enum AVPixelFormat *choices = pix_fmts;



    switch (h->sps.bit_depth_luma) {

    case 9:

        if (CHROMA444(h)) {

            if (h->avctx->colorspace == AVCOL_SPC_RGB) {

                *fmt++ = AV_PIX_FMT_GBRP9;

            } else

                *fmt++ = AV_PIX_FMT_YUV444P9;

        } else if (CHROMA422(h))

            *fmt++ = AV_PIX_FMT_YUV422P9;

        else

            *fmt++ = AV_PIX_FMT_YUV420P9;

        break;

    case 10:

        if (CHROMA444(h)) {

            if (h->avctx->colorspace == AVCOL_SPC_RGB) {

                *fmt++ = AV_PIX_FMT_GBRP10;

            } else

                *fmt++ = AV_PIX_FMT_YUV444P10;

        } else if (CHROMA422(h))

            *fmt++ = AV_PIX_FMT_YUV422P10;

        else

            *fmt++ = AV_PIX_FMT_YUV420P10;

        break;

    case 8:

#if CONFIG_H264_VDPAU_HWACCEL

        *fmt++ = AV_PIX_FMT_VDPAU;

#endif

        if (CHROMA444(h)) {

            if (h->avctx->colorspace == AVCOL_SPC_RGB)

                *fmt++ = AV_PIX_FMT_GBRP;

            else if (h->avctx->color_range == AVCOL_RANGE_JPEG)

                *fmt++ = AV_PIX_FMT_YUVJ444P;

            else

                *fmt++ = AV_PIX_FMT_YUV444P;

        } else if (CHROMA422(h)) {

            if (h->avctx->color_range == AVCOL_RANGE_JPEG)

                *fmt++ = AV_PIX_FMT_YUVJ422P;

            else

                *fmt++ = AV_PIX_FMT_YUV422P;

        } else {

#if CONFIG_H264_DXVA2_HWACCEL

            *fmt++ = AV_PIX_FMT_DXVA2_VLD;

#endif

#if CONFIG_H264_D3D11VA_HWACCEL

            *fmt++ = AV_PIX_FMT_D3D11VA_VLD;

#endif

#if CONFIG_H264_VAAPI_HWACCEL

            *fmt++ = AV_PIX_FMT_VAAPI;

#endif

#if CONFIG_H264_VDA_HWACCEL

            *fmt++ = AV_PIX_FMT_VDA_VLD;

            *fmt++ = AV_PIX_FMT_VDA;

#endif

            if (h->avctx->codec->pix_fmts)

                choices = h->avctx->codec->pix_fmts;

            else if (h->avctx->color_range == AVCOL_RANGE_JPEG)

                *fmt++ = AV_PIX_FMT_YUVJ420P;

            else

                *fmt++ = AV_PIX_FMT_YUV420P;

        }

        break;

    default:

        av_log(h->avctx, AV_LOG_ERROR,

               "Unsupported bit depth %d\n", h->sps.bit_depth_luma);

        return AVERROR_INVALIDDATA;

    }



    *fmt = AV_PIX_FMT_NONE;



    return ff_get_format(h->avctx, choices);

}
 and probability:0.47435897435897434
code:static void mv88w8618_eth_init(NICInfo *nd, uint32_t base, qemu_irq irq)

{

    mv88w8618_eth_state *s;

    int iomemtype;



    qemu_check_nic_model(nd, "mv88w8618");



    s = qemu_mallocz(sizeof(mv88w8618_eth_state));

    s->irq = irq;

    s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,

                                 eth_receive, eth_can_receive, s);

    iomemtype = cpu_register_io_memory(0, mv88w8618_eth_readfn,

                                       mv88w8618_eth_writefn, s);

    cpu_register_physical_memory(base, MP_ETH_SIZE, iomemtype);

}
 and probability:0.15384615384615385
code:static int vnc_update_client_sync(VncState *vs, int has_dirty)

{

    int ret = vnc_update_client(vs, has_dirty);

    vnc_jobs_join(vs);

    return ret;

}
 and probability:0.0
code:static struct omap_tipb_bridge_s *omap_tipb_bridge_init(

    MemoryRegion *memory, hwaddr base,

    qemu_irq abort_irq, omap_clk clk)

{

    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)

            g_malloc0(sizeof(struct omap_tipb_bridge_s));



    s->abort = abort_irq;

    omap_tipb_bridge_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_tipb_bridge_ops, s,

                          "omap-tipb-bridge", 0x100);

    memory_region_add_subregion(memory, base, &s->iomem);



    return s;

}
 and probability:0.23076923076923078
code:static void seqvideo_decode(SeqVideoContext *seq, const unsigned char *data, int data_size)

{

    GetBitContext gb;

    int flags, i, j, x, y, op;

    unsigned char c[3];

    unsigned char *dst;

    uint32_t *palette;



    flags = *data++;



    if (flags & 1) {

        palette = (uint32_t *)seq->frame.data[1];

        for (i = 0; i < 256; i++) {

            for (j = 0; j < 3; j++, data++)

                c[j] = (*data << 2) | (*data >> 4);

            palette[i] = AV_RB24(c);

        }

        seq->frame.palette_has_changed = 1;

    }



    if (flags & 2) {

        init_get_bits(&gb, data, 128 * 8); data += 128;

        for (y = 0; y < 128; y += 8)

            for (x = 0; x < 256; x += 8) {

                dst = &seq->frame.data[0][y * seq->frame.linesize[0] + x];

                op = get_bits(&gb, 2);

                switch (op) {

                case 1:

                    data = seq_decode_op1(seq, data, dst);

                    break;

                case 2:

                    data = seq_decode_op2(seq, data, dst);

                    break;

                case 3:

                    data = seq_decode_op3(seq, data, dst);

                    break;

                }

            }

    }

}
 and probability:0.2972972972972973
code:static int get_video_buffer(AVFrame *frame, int align)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

    int ret, i;



    if (!desc)

        return AVERROR(EINVAL);



    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)

        return ret;



    if (!frame->linesize[0]) {

        ret = av_image_fill_linesizes(frame->linesize, frame->format,

                                      frame->width);

        if (ret < 0)

            return ret;



        for (i = 0; i < 4 && frame->linesize[i]; i++)

            frame->linesize[i] = FFALIGN(frame->linesize[i], align);

    }



    for (i = 0; i < 4 && frame->linesize[i]; i++) {

        int h = frame->height;

        if (i == 1 || i == 2)

            h = -((-h) >> desc->log2_chroma_h);



        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);

        if (!frame->buf[i])

            goto fail;



        frame->data[i] = frame->buf[i]->data;

    }

    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {

        av_buffer_unref(&frame->buf[1]);

        frame->buf[1] = av_buffer_alloc(1024);

        if (!frame->buf[1])

            goto fail;

        frame->data[1] = frame->buf[1]->data;

    }



    frame->extended_data = frame->data;



    return 0;

fail:

    av_frame_unref(frame);

    return AVERROR(ENOMEM);

}
 and probability:0.5
code:static int build_table(VLC *vlc, int table_nb_bits, int nb_codes,

                       VLCcode *codes, int flags)

{

    int table_size, table_index, index, code_prefix, symbol, subtable_bits;

    int i, j, k, n, nb, inc;

    uint32_t code;

    VLC_TYPE (*table)[2];



    table_size = 1 << table_nb_bits;

    if (table_nb_bits > 30)

       return -1;

    table_index = alloc_table(vlc, table_size, flags & INIT_VLC_USE_NEW_STATIC);

    av_dlog(NULL, "new table index=%d size=%d\n", table_index, table_size);

    if (table_index < 0)

        return table_index;

    table = &vlc->table[table_index];



    for (i = 0; i < table_size; i++) {

        table[i][1] = 0; //bits

        table[i][0] = -1; //codes

    }



    /* first pass: map codes and compute auxiliary table sizes */

    for (i = 0; i < nb_codes; i++) {

        n      = codes[i].bits;

        code   = codes[i].code;

        symbol = codes[i].symbol;

        av_dlog(NULL, "i=%d n=%d code=0x%x\n", i, n, code);

        if (n <= table_nb_bits) {

            /* no need to add another table */

            j = code >> (32 - table_nb_bits);

            nb = 1 << (table_nb_bits - n);

            inc = 1;

            if (flags & INIT_VLC_LE) {

                j = bitswap_32(code);

                inc = 1 << n;

            }

            for (k = 0; k < nb; k++) {

                av_dlog(NULL, "%4x: code=%d n=%d\n", j, i, n);

                if (table[j][1] /*bits*/ != 0) {

                    av_log(NULL, AV_LOG_ERROR, "incorrect codes\n");

                    return AVERROR_INVALIDDATA;

                }

                table[j][1] = n; //bits

                table[j][0] = symbol;

                j += inc;

            }

        } else {

            /* fill auxiliary table recursively */

            n -= table_nb_bits;

            code_prefix = code >> (32 - table_nb_bits);

            subtable_bits = n;

            codes[i].bits = n;

            codes[i].code = code << table_nb_bits;

            for (k = i+1; k < nb_codes; k++) {

                n = codes[k].bits - table_nb_bits;

                if (n <= 0)

                    break;

                code = codes[k].code;

                if (code >> (32 - table_nb_bits) != code_prefix)

                    break;

                codes[k].bits = n;

                codes[k].code = code << table_nb_bits;

                subtable_bits = FFMAX(subtable_bits, n);

            }

            subtable_bits = FFMIN(subtable_bits, table_nb_bits);

            j = (flags & INIT_VLC_LE) ? bitswap_32(code_prefix) >> (32 - table_nb_bits) : code_prefix;

            table[j][1] = -subtable_bits;

            av_dlog(NULL, "%4x: n=%d (subtable)\n",

                    j, codes[i].bits + table_nb_bits);

            index = build_table(vlc, subtable_bits, k-i, codes+i, flags);

            if (index < 0)

                return index;

            /* note: realloc has been done, so reload tables */

            table = &vlc->table[table_index];

            table[j][0] = index; //code

            av_assert0(table[j][0] == index);

            i = k-1;

        }

    }

    return table_index;

}
 and probability:0.43037974683544306
code:static void h264_h_loop_filter_luma_intra_c(uint8_t *pix, int stride, int alpha, int beta)

{

    h264_loop_filter_luma_intra_c(pix, 1, stride, alpha, beta);

}
 and probability:0.0
code:static inline void do_imdct(AC3DecodeContext *s, int channels)

{

    int ch;



    for (ch=1; ch<=channels; ch++) {

        if (s->block_switch[ch]) {

            int i;

            float *x = s->tmp_output+128;

            for(i=0; i<128; i++)

                x[i] = s->transform_coeffs[ch][2*i];

            ff_imdct_half(&s->imdct_256, s->tmp_output, x);

            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);

            for(i=0; i<128; i++)

                x[i] = s->transform_coeffs[ch][2*i+1];

            ff_imdct_half(&s->imdct_256, s->delay[ch-1], x);

        } else {

            ff_imdct_half(&s->imdct_512, s->tmp_output, s->transform_coeffs[ch]);

            s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);

            memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));

        }

    }

}
 and probability:0.6190476190476191
code:static void parse_header_digest(struct iscsi_context *iscsi, const char *target)

{

    QemuOptsList *list;

    QemuOpts *opts;

    const char *digest = NULL;



    list = qemu_find_opts("iscsi");

    if (!list) {

        return;

    }



    opts = qemu_opts_find(list, target);

    if (opts == NULL) {

        opts = QTAILQ_FIRST(&list->head);

        if (!opts) {

            return;

        }

    }



    digest = qemu_opt_get(opts, "header-digest");

    if (!digest) {

        return;

    }



    if (!strcmp(digest, "CRC32C")) {

        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C);

    } else if (!strcmp(digest, "NONE")) {

        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE);

    } else if (!strcmp(digest, "CRC32C-NONE")) {

        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C_NONE);

    } else if (!strcmp(digest, "NONE-CRC32C")) {

        iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);

    } else {

        error_report("Invalid header-digest setting : %s", digest);

    }

}
 and probability:0.03125
code:void visit_type_str(Visitor *v, char **obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_str(v, obj, name, errp);

    }

}
 and probability:0.16666666666666666
code:static int http_send_data(HTTPContext *c)

{

    int len, ret;



    while (c->buffer_ptr >= c->buffer_end) {

        ret = http_prepare_data(c);

        if (ret < 0)

            return -1;

        else if (ret == 0) {

            break;

        } else {

            /* state change requested */

            return 0;

        }

    }



    if (c->buffer_end > c->buffer_ptr) {

        len = write(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr);

        if (len < 0) {

            if (errno != EAGAIN && errno != EINTR) {

                /* error : close connection */

                return -1;

            }

        } else {

            c->buffer_ptr += len;

            c->data_count += len;

        }

    }

    return 0;

}
 and probability:0.17857142857142858
code:static void m68060_cpu_initfn(Object *obj)

{

    M68kCPU *cpu = M68K_CPU(obj);

    CPUM68KState *env = &cpu->env;



    m68k_set_feature(env, M68K_FEATURE_M68000);

    m68k_set_feature(env, M68K_FEATURE_USP);

    m68k_set_feature(env, M68K_FEATURE_WORD_INDEX);

    m68k_set_feature(env, M68K_FEATURE_BRAL);

    m68k_set_feature(env, M68K_FEATURE_BCCL);

    m68k_set_feature(env, M68K_FEATURE_BITFIELD);

    m68k_set_feature(env, M68K_FEATURE_EXT_FULL);

    m68k_set_feature(env, M68K_FEATURE_SCALED_INDEX);

    m68k_set_feature(env, M68K_FEATURE_LONG_MULDIV);

    m68k_set_feature(env, M68K_FEATURE_FPU);

    m68k_set_feature(env, M68K_FEATURE_CAS);

    m68k_set_feature(env, M68K_FEATURE_BKPT);

    m68k_set_feature(env, M68K_FEATURE_RTD);


} and probability:0.05555555555555555
code:void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,

                    const char *boot_device,

                    const char *kernel_filename, const char *kernel_cmdline,

                    const char *initrd_filename, const char *cpu_model)

{

    char buf[1024];

    unsigned long bios_offset;

    int bios_size;

    CPUState *env;

    RTCState *rtc_state;

    int i;

    qemu_irq *i8259;

    int index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];



    /* init CPUs */

    if (cpu_model == NULL) {

#ifdef TARGET_MIPS64

        cpu_model = "R4000";

#else

        cpu_model = "24Kf";

#endif


    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, "Unable to find CPU definition\n");



    qemu_register_reset(main_cpu_reset, env);



    /* allocate RAM */







    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);



    if (!mips_qemu_iomemtype) {

        mips_qemu_iomemtype = cpu_register_io_memory(0, mips_qemu_read,

                                                     mips_qemu_write, NULL);


    cpu_register_physical_memory(0x1fbf0000, 0x10000, mips_qemu_iomemtype);



    /* Try to load a BIOS image. If this fails, we continue regardless,

       but initialize the hardware ourselves. When a kernel gets

       preloaded we also initialize the hardware, since the BIOS wasn't

       run. */

    bios_offset = ram_size + vga_ram_size;

    if (bios_name == NULL)

        bios_name = BIOS_FILENAME;

    snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name);

    bios_size = load_image(buf, phys_ram_base + bios_offset);

    if ((bios_size > 0) && (bios_size <= BIOS_SIZE)) {

	cpu_register_physical_memory(0x1fc00000,

				     BIOS_SIZE, bios_offset | IO_MEM_ROM);

    } else if ((index = drive_get_index(IF_PFLASH, 0, 0)) > -1) {

        uint32_t mips_rom = 0x00400000;

        cpu_register_physical_memory(0x1fc00000, mips_rom,

	                     qemu_ram_alloc(mips_rom) | IO_MEM_ROM);

        if (!pflash_cfi01_register(0x1fc00000, qemu_ram_alloc(mips_rom),

            drives_table[index].bdrv, sector_len, mips_rom / sector_len,

            4, 0, 0, 0, 0)) {

            fprintf(stderr, "qemu: Error registering flash memory.\n");



    else {

	/* not fatal */

        fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",

		buf);




    if (kernel_filename) {

        loaderparams.ram_size = ram_size;

        loaderparams.kernel_filename = kernel_filename;

        loaderparams.kernel_cmdline = kernel_cmdline;

        loaderparams.initrd_filename = initrd_filename;

        load_kernel (env);




    /* Init CPU internal devices */

    cpu_mips_irq_init_cpu(env);

    cpu_mips_clock_init(env);



    /* The PIC is attached to the MIPS CPU INT0 pin */

    i8259 = i8259_init(env->irq[2]);



    rtc_state = rtc_init(0x70, i8259[8]);



    /* Register 64 KB of ISA IO space at 0x14000000 */

    isa_mmio_init(0x14000000, 0x00010000);

    isa_mem_base = 0x10000000;



    pit = pit_init(0x40, i8259[0]);



    for(i = 0; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,

                        serial_hds[i]);





    isa_vga_init(phys_ram_base + ram_size, ram_size,

                 vga_ram_size);



    if (nd_table[0].vlan)

        isa_ne2000_init(0x300, i8259[9], &nd_table[0]);



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, "qemu: too many IDE bus\n");





    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

        if (index != -1)

            hd[i] = drives_table[index].bdrv;

        else

            hd[i] = NULL;




    for(i = 0; i < MAX_IDE_BUS; i++)

        isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],

                     hd[MAX_IDE_DEVS * i],

		     hd[MAX_IDE_DEVS * i + 1]);



    i8042_init(i8259[1], i8259[12], 0x60);
 and probability:0.25
code:static void windowing_and_mdct_ltp(AACContext *ac, float *out,

                                   float *in, IndividualChannelStream *ics)

{

    const float *lwindow      = ics->use_kb_window[0] ? ff_aac_kbd_long_1024 : ff_sine_1024;

    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;

    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;

    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;



    if (ics->window_sequence[0] != LONG_STOP_SEQUENCE) {

        ac->dsp.vector_fmul(in, in, lwindow_prev, 1024);

    } else {

        memset(in, 0, 448 * sizeof(float));

        ac->dsp.vector_fmul(in + 448, in + 448, swindow_prev, 128);

        memcpy(in + 576, in + 576, 448 * sizeof(float));

    }

    if (ics->window_sequence[0] != LONG_START_SEQUENCE) {

        ac->dsp.vector_fmul_reverse(in + 1024, in + 1024, lwindow, 1024);

    } else {

        memcpy(in + 1024, in + 1024, 448 * sizeof(float));

        ac->dsp.vector_fmul_reverse(in + 1024 + 448, in + 1024 + 448, swindow, 128);

        memset(in + 1024 + 576, 0, 448 * sizeof(float));

    }

    ac->mdct_ltp.mdct_calc(&ac->mdct_ltp, out, in);

}
 and probability:0.6521739130434783
code:static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    int ret;



    st = avformat_new_stream(c->fc, NULL);

    if (!st) return AVERROR(ENOMEM);

    st->id = c->fc->nb_streams;

    sc = av_mallocz(sizeof(MOVStreamContext));

    if (!sc) return AVERROR(ENOMEM);



    st->priv_data = sc;

    st->codec->codec_type = AVMEDIA_TYPE_DATA;

    sc->ffindex = st->index;

    c->trak_index = st->index;



    if ((ret = mov_read_default(c, pb, atom)) < 0)

        return ret;



    c->trak_index = -1;



    /* sanity checks */

    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||

                            (!sc->sample_size && !sc->sample_count))) {

        av_log(c->fc, AV_LOG_ERROR, "stream %d, missing mandatory atoms, broken header\n",

               st->index);

        return 0;

    }



    fix_timescale(c, sc);



    avpriv_set_pts_info(st, 64, 1, sc->time_scale);



    mov_build_index(c, st);



    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {

        MOVDref *dref = &sc->drefs[sc->dref_id - 1];

        if (mov_open_dref(c, &sc->pb, c->fc->filename, dref,

                          &c->fc->interrupt_callback) < 0)

            av_log(c->fc, AV_LOG_ERROR,

                   "stream %d, error opening alias: path='%s', dir='%s', "

                   "filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\n",

                   st->index, dref->path, dref->dir, dref->filename,

                   dref->volume, dref->nlvl_from, dref->nlvl_to);

    } else {

        sc->pb = c->fc->pb;

        sc->pb_is_copied = 1;

    }



    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

        if (!st->sample_aspect_ratio.num && st->codec->width && st->codec->height &&

            sc->height && sc->width &&

            (st->codec->width != sc->width || st->codec->height != sc->height)) {

            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /

                                             ((double)st->codec->width * sc->height), INT_MAX);

        }



#if FF_API_R_FRAME_RATE

        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))

            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,

                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);

#endif

    }



    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.

    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&

        TAG_IS_AVCI(st->codec->codec_tag)) {

        ret = ff_generate_avci_extradata(st);

        if (ret < 0)

            return ret;

    }



    switch (st->codec->codec_id) {

#if CONFIG_H261_DECODER

    case AV_CODEC_ID_H261:

#endif

#if CONFIG_H263_DECODER

    case AV_CODEC_ID_H263:

#endif

#if CONFIG_MPEG4_DECODER

    case AV_CODEC_ID_MPEG4:

#endif

        st->codec->width = 0; /* let decoder init width/height */

        st->codec->height= 0;

        break;

    }



    // If the duration of the mp3 packets is not constant, then they could need a parser

    if (st->codec->codec_id == AV_CODEC_ID_MP3

        && sc->stts_count > 3

        && sc->stts_count*10 > st->nb_frames

        && sc->time_scale == st->codec->sample_rate) {

            st->need_parsing = AVSTREAM_PARSE_FULL;

    }

    /* Do not need those anymore. */

    av_freep(&sc->chunk_offsets);

    av_freep(&sc->stsc_data);

    av_freep(&sc->sample_sizes);

    av_freep(&sc->keyframes);

    av_freep(&sc->stts_data);

    av_freep(&sc->stps_data);

    av_freep(&sc->elst_data);

    av_freep(&sc->rap_group);



    return 0;

}
 and probability:0.5217391304347826
code:static int mxg_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    int ret;

    unsigned int size;

    uint8_t *startmarker_ptr, *end, *search_end, marker;

    MXGContext *mxg = s->priv_data;



    while (!avio_feof(s->pb) && !s->pb->error){

        if (mxg->cache_size <= OVERREAD_SIZE) {

            /* update internal buffer */

            ret = mxg_update_cache(s, DEFAULT_PACKET_SIZE + OVERREAD_SIZE);

            if (ret < 0)

                return ret;

        }

        end = mxg->buffer_ptr + mxg->cache_size;



        /* find start marker - 0xff */

        if (mxg->cache_size > OVERREAD_SIZE) {

            search_end = end - OVERREAD_SIZE;

            startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);

        } else {

            search_end = end;

            startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);

            if (startmarker_ptr >= search_end - 1 ||

                *(startmarker_ptr + 1) != EOI) break;

        }



        if (startmarker_ptr != search_end) { /* start marker found */

            marker = *(startmarker_ptr + 1);

            mxg->buffer_ptr = startmarker_ptr + 2;

            mxg->cache_size = end - mxg->buffer_ptr;



            if (marker == SOI) {

                mxg->soi_ptr = startmarker_ptr;

            } else if (marker == EOI) {

                if (!mxg->soi_ptr) {

                    av_log(s, AV_LOG_WARNING, "Found EOI before SOI, skipping\n");

                    continue;

                }



                pkt->pts = pkt->dts = mxg->dts;

                pkt->stream_index = 0;

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

                pkt->destruct = NULL;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

                pkt->buf  = NULL;

                pkt->size = mxg->buffer_ptr - mxg->soi_ptr;

                pkt->data = mxg->soi_ptr;



                if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) {

                    if (mxg->cache_size > 0) {

                        memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);

                    }



                    mxg->buffer_ptr = mxg->buffer;

                }

                mxg->soi_ptr = 0;



                return pkt->size;

            } else if ( (SOF0 <= marker && marker <= SOF15) ||

                        (SOS  <= marker && marker <= COM) ) {

                /* all other markers that start marker segment also contain

                   length value (see specification for JPEG Annex B.1) */

                size = AV_RB16(mxg->buffer_ptr);

                if (size < 2)

                    return AVERROR(EINVAL);



                if (mxg->cache_size < size) {

                    ret = mxg_update_cache(s, size);

                    if (ret < 0)

                        return ret;

                    startmarker_ptr = mxg->buffer_ptr - 2;

                    mxg->cache_size = 0;

                } else {

                    mxg->cache_size -= size;

                }



                mxg->buffer_ptr += size;



                if (marker == APP13 && size >= 16) { /* audio data */

                    /* time (GMT) of first sample in usec since 1970, little-endian */

                    pkt->pts = pkt->dts = AV_RL64(startmarker_ptr + 8);

                    pkt->stream_index = 1;

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

                    pkt->destruct = NULL;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

                    pkt->buf  = NULL;

                    pkt->size = size - 14;

                    pkt->data = startmarker_ptr + 16;



                    if (startmarker_ptr - mxg->buffer > mxg->cache_size) {

                        if (mxg->cache_size > 0) {

                            memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);

                        }

                        mxg->buffer_ptr = mxg->buffer;

                    }



                    return pkt->size;

                } else if (marker == COM && size >= 18 &&

                           !strncmp(startmarker_ptr + 4, "MXF", 3)) {

                    /* time (GMT) of video frame in usec since 1970, little-endian */

                    mxg->dts = AV_RL64(startmarker_ptr + 12);

                }

            }

        } else {

            /* start marker not found */

            mxg->buffer_ptr = search_end;

            mxg->cache_size = OVERREAD_SIZE;

        }

    }



    return AVERROR_EOF;

}
 and probability:0.4563106796116505
code:static uint32_t pci_unin_config_readl (void *opaque,

                                       target_phys_addr_t addr)

{

    UNINState *s = opaque;



    return s->config_reg;

}
 and probability:0.16666666666666666
code:static int amf_parse_object(AVFormatContext *s, AVStream *astream,

                            AVStream *vstream, const char *key,

                            int64_t max_pos, int depth)

{

    AVCodecContext *acodec, *vcodec;

    FLVContext *flv = s->priv_data;

    AVIOContext *ioc;

    AMFDataType amf_type;

    char str_val[256];

    double num_val;



    num_val  = 0;

    ioc      = s->pb;

    amf_type = avio_r8(ioc);



    switch (amf_type) {

    case AMF_DATA_TYPE_NUMBER:

        num_val = av_int2double(avio_rb64(ioc));

        break;

    case AMF_DATA_TYPE_BOOL:

        num_val = avio_r8(ioc);

        break;

    case AMF_DATA_TYPE_STRING:

        if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0)

            return -1;

        break;

    case AMF_DATA_TYPE_OBJECT:

        if ((vstream || astream) && key &&

            ioc->seekable &&

            !strcmp(KEYFRAMES_TAG, key) && depth == 1)

            if (parse_keyframes_index(s, ioc, vstream ? vstream : astream,

                                      max_pos) < 0)

                av_log(s, AV_LOG_ERROR, "Keyframe index parsing failed\n");



        while (avio_tell(ioc) < max_pos - 2 &&

               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)

            if (amf_parse_object(s, astream, vstream, str_val, max_pos,

                                 depth + 1) < 0)

                return -1;     // if we couldn't skip, bomb out.

        if (avio_r8(ioc) != AMF_END_OF_OBJECT)

            return -1;

        break;

    case AMF_DATA_TYPE_NULL:

    case AMF_DATA_TYPE_UNDEFINED:

    case AMF_DATA_TYPE_UNSUPPORTED:

        break;     // these take up no additional space

    case AMF_DATA_TYPE_MIXEDARRAY:

        avio_skip(ioc, 4);     // skip 32-bit max array index

        while (avio_tell(ioc) < max_pos - 2 &&

               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)

            // this is the only case in which we would want a nested

            // parse to not skip over the object

            if (amf_parse_object(s, astream, vstream, str_val, max_pos,

                                 depth + 1) < 0)

                return -1;

        if (avio_r8(ioc) != AMF_END_OF_OBJECT)

            return -1;

        break;

    case AMF_DATA_TYPE_ARRAY:

    {

        unsigned int arraylen, i;



        arraylen = avio_rb32(ioc);

        for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++)

            if (amf_parse_object(s, NULL, NULL, NULL, max_pos,

                                 depth + 1) < 0)

                return -1;      // if we couldn't skip, bomb out.

    }

    break;

    case AMF_DATA_TYPE_DATE:

        avio_skip(ioc, 8 + 2);  // timestamp (double) and UTC offset (int16)

        break;

    default:                    // unsupported type, we couldn't skip

        return -1;

    }



    if (key) {

        // stream info doesn't live any deeper than the first object

        if (depth == 1) {

            acodec = astream ? astream->codec : NULL;

            vcodec = vstream ? vstream->codec : NULL;



            if (amf_type == AMF_DATA_TYPE_NUMBER ||

                amf_type == AMF_DATA_TYPE_BOOL) {

                if (!strcmp(key, "duration"))

                    s->duration = num_val * AV_TIME_BASE;

                else if (!strcmp(key, "videodatarate") && vcodec &&

                         0 <= (int)(num_val * 1024.0))

                    vcodec->bit_rate = num_val * 1024.0;

                else if (!strcmp(key, "audiodatarate") && acodec &&

                         0 <= (int)(num_val * 1024.0))

                    acodec->bit_rate = num_val * 1024.0;

                else if (!strcmp(key, "datastream")) {

                    AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);

                    if (!st)

                        return AVERROR(ENOMEM);

                    st->codec->codec_id = AV_CODEC_ID_TEXT;

                } else if (flv->trust_metadata) {

                    if (!strcmp(key, "videocodecid") && vcodec) {

                        flv_set_video_codec(s, vstream, num_val, 0);

                    } else if (!strcmp(key, "audiocodecid") && acodec) {

                        int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;

                        flv_set_audio_codec(s, astream, acodec, id);

                    } else if (!strcmp(key, "audiosamplerate") && acodec) {

                        acodec->sample_rate = num_val;

                    } else if (!strcmp(key, "audiosamplesize") && acodec) {

                        acodec->bits_per_coded_sample = num_val;

                    } else if (!strcmp(key, "stereo") && acodec) {

                        acodec->channels       = num_val + 1;

                        acodec->channel_layout = acodec->channels == 2 ?

                                                 AV_CH_LAYOUT_STEREO :

                                                 AV_CH_LAYOUT_MONO;

                    } else if (!strcmp(key, "width") && vcodec) {

                        vcodec->width = num_val;

                    } else if (!strcmp(key, "height") && vcodec) {

                        vcodec->height = num_val;

                    }

                }

            }

        }



        if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 &&

           ((!acodec && !strcmp(key, "audiocodecid")) ||

            (!vcodec && !strcmp(key, "videocodecid"))))

                s->ctx_flags &= ~AVFMTCTX_NOHEADER; //If there is either audio/video missing, codecid will be an empty object



        if (!strcmp(key, "duration")        ||

            !strcmp(key, "filesize")        ||

            !strcmp(key, "width")           ||

            !strcmp(key, "height")          ||

            !strcmp(key, "videodatarate")   ||

            !strcmp(key, "framerate")       ||

            !strcmp(key, "videocodecid")    ||

            !strcmp(key, "audiodatarate")   ||

            !strcmp(key, "audiosamplerate") ||

            !strcmp(key, "audiosamplesize") ||

            !strcmp(key, "stereo")          ||

            !strcmp(key, "audiocodecid")    ||

            !strcmp(key, "datastream"))

            return 0;



        s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;

        if (amf_type == AMF_DATA_TYPE_BOOL) {

            av_strlcpy(str_val, num_val > 0 ? "true" : "false",

                       sizeof(str_val));

            av_dict_set(&s->metadata, key, str_val, 0);

        } else if (amf_type == AMF_DATA_TYPE_NUMBER) {

            snprintf(str_val, sizeof(str_val), "%.f", num_val);

            av_dict_set(&s->metadata, key, str_val, 0);

        } else if (amf_type == AMF_DATA_TYPE_STRING)

            av_dict_set(&s->metadata, key, str_val, 0);

    }



    return 0;

}
 and probability:0.21379310344827587
code:static TCGv_i64 gen_subq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_sub_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
 and probability:0.0
code:static void decode_component(DiracContext *s, int comp)

{

    AVCodecContext *avctx = s->avctx;

    SubBand *bands[3*MAX_DWT_LEVELS+1];

    enum dirac_subband orientation;

    int level, num_bands = 0;



    /* Unpack all subbands at all levels. */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            SubBand *b = &s->plane[comp].band[level][orientation];

            bands[num_bands++] = b;



            align_get_bits(&s->gb);

            /* [DIRAC_STD] 13.4.2 subband() */

            b->length = svq3_get_ue_golomb(&s->gb);

            if (b->length) {

                b->quant = svq3_get_ue_golomb(&s->gb);

                align_get_bits(&s->gb);

                b->coeff_data = s->gb.buffer + get_bits_count(&s->gb)/8;

                b->length = FFMIN(b->length, get_bits_left(&s->gb)/8);

                skip_bits_long(&s->gb, b->length*8);

            }

        }

        /* arithmetic coding has inter-level dependencies, so we can only execute one level at a time */

        if (s->is_arith)

            avctx->execute(avctx, decode_subband_arith, &s->plane[comp].band[level][!!level],

                           NULL, 4-!!level, sizeof(SubBand));

    }

    /* golomb coding has no inter-level dependencies, so we can execute all subbands in parallel */

    if (!s->is_arith)

        avctx->execute(avctx, decode_subband_golomb, bands, NULL, num_bands, sizeof(SubBand*));

}
 and probability:0.6129032258064516
code:static void ppc_heathrow_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    const char *boot_device = machine->boot_order;

    MemoryRegion *sysmem = get_system_memory();

    PowerPCCPU *cpu = NULL;

    CPUPPCState *env = NULL;

    char *filename;

    qemu_irq *pic, **heathrow_irqs;

    int linux_boot, i;

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *bios = g_new(MemoryRegion, 1);

    MemoryRegion *isa = g_new(MemoryRegion, 1);

    uint32_t kernel_base, initrd_base, cmdline_base = 0;

    int32_t kernel_size, initrd_size;

    PCIBus *pci_bus;

    PCIDevice *macio;

    MACIOIDEState *macio_ide;

    DeviceState *dev;

    BusState *adb_bus;

    int bios_size;

    MemoryRegion *pic_mem;

    MemoryRegion *escc_mem, *escc_bar = g_new(MemoryRegion, 1);

    uint16_t ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    void *fw_cfg;

    uint64_t tbfreq;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

        cpu_model = "G3";

    for (i = 0; i < smp_cpus; i++) {

        cpu = cpu_ppc_init(cpu_model);

        if (cpu == NULL) {

            fprintf(stderr, "Unable to find PowerPC CPU definition\n");

            exit(1);

        }

        env = &cpu->env;



        /* Set time-base frequency to 16.6 Mhz */

        cpu_ppc_tb_init(env,  TBFREQ);

        qemu_register_reset(ppc_heathrow_reset, cpu);

    }



    /* allocate RAM */

    if (ram_size > (2047 << 20)) {

        fprintf(stderr,

                "qemu: Too much memory for this machine: %d MB, maximum 2047 MB\n",

                ((unsigned int)ram_size / (1 << 20)));

        exit(1);

    }



    memory_region_allocate_system_memory(ram, NULL, "ppc_heathrow.ram",

                                         ram_size);

    memory_region_add_subregion(sysmem, 0, ram);



    /* allocate and load BIOS */

    memory_region_init_ram(bios, NULL, "ppc_heathrow.bios", BIOS_SIZE);

    vmstate_register_ram_global(bios);



    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    memory_region_set_readonly(bios, true);

    memory_region_add_subregion(sysmem, PROM_ADDR, bios);



    /* Load OpenBIOS (ELF) */

    if (filename) {

        bios_size = load_elf(filename, 0, NULL, NULL, NULL, NULL,

                             1, ELF_MACHINE, 0);

        g_free(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error("qemu: could not load PowerPC bios '%s'\n", bios_name);

        exit(1);

    }



    if (linux_boot) {

        uint64_t lowaddr = 0;

        int bswap_needed;



#ifdef BSWAP_NEEDED

        bswap_needed = 1;

#else

        bswap_needed = 0;

#endif

        kernel_base = KERNEL_LOAD_ADDR;

        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, kernel_base,

                                    ram_size - kernel_base, bswap_needed,

                                    TARGET_PAGE_SIZE);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              kernel_base,

                                              ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error("qemu: could not load kernel '%s'\n",

                      kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = round_page(kernel_base + kernel_size + KERNEL_GAP);

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error("qemu: could not load initial ram disk '%s'\n",

                         initrd_filename);

                exit(1);

            }

            cmdline_base = round_page(initrd_base + initrd_size);

        } else {

            initrd_base = 0;

            initrd_size = 0;

            cmdline_base = round_page(kernel_base + kernel_size + KERNEL_GAP);

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        for (i = 0; boot_device[i] != '\0'; i++) {

            /* TOFIX: for now, the second IDE channel is not properly

             *        used by OHW. The Mac floppy disk are not emulated.

             *        For now, OHW cannot boot from the network.

             */

#if 0

            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {

                ppc_boot_device = boot_device[i];

                break;

            }

#else

            if (boot_device[i] >= 'c' && boot_device[i] <= 'd') {

                ppc_boot_device = boot_device[i];

                break;

            }

#endif

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, "No valid boot device for G3 Beige machine\n");

            exit(1);

        }

    }



    /* Register 2 MB of ISA IO space */

    memory_region_init_alias(isa, NULL, "isa_mmio",

                             get_system_io(), 0, 0x00200000);

    memory_region_add_subregion(sysmem, 0xfe000000, isa);



    /* XXX: we register only 1 output pin for heathrow PIC */

    heathrow_irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));

    heathrow_irqs[0] =

        g_malloc0(smp_cpus * sizeof(qemu_irq) * 1);

    /* Connect the heathrow PIC outputs to the 6xx bus */

    for (i = 0; i < smp_cpus; i++) {

        switch (PPC_INPUT(env)) {

        case PPC_FLAGS_INPUT_6xx:

            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);

            heathrow_irqs[i][0] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            break;

        default:

            hw_error("Bus model not supported on OldWorld Mac machine\n");

        }

    }



    /* Timebase Frequency */

    if (kvm_enabled()) {

        tbfreq = kvmppc_get_tbfreq();

    } else {

        tbfreq = TBFREQ;

    }



    /* init basic PC hardware */

    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {

        hw_error("Only 6xx bus is supported on heathrow machine\n");

    }

    pic = heathrow_pic_init(&pic_mem, 1, heathrow_irqs);

    pci_bus = pci_grackle_init(0xfec00000, pic,

                               get_system_memory(),

                               get_system_io());

    pci_vga_init(pci_bus);



    escc_mem = escc_init(0, pic[0x0f], pic[0x10], serial_hds[0],

                               serial_hds[1], ESCC_CLOCK, 4);

    memory_region_init_alias(escc_bar, NULL, "escc-bar",

                             escc_mem, 0, memory_region_size(escc_mem));



    for(i = 0; i < nb_nics; i++)

        pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);





    ide_drive_get(hd, MAX_IDE_BUS);



    macio = pci_create(pci_bus, -1, TYPE_OLDWORLD_MACIO);

    dev = DEVICE(macio);

    qdev_connect_gpio_out(dev, 0, pic[0x12]); /* CUDA */

    qdev_connect_gpio_out(dev, 1, pic[0x0D]); /* IDE-0 */

    qdev_connect_gpio_out(dev, 2, pic[0x02]); /* IDE-0 DMA */

    qdev_connect_gpio_out(dev, 3, pic[0x0E]); /* IDE-1 */

    qdev_connect_gpio_out(dev, 4, pic[0x03]); /* IDE-1 DMA */


    macio_init(macio, pic_mem, escc_bar);



    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),

                                                        "ide[0]"));

    macio_ide_init_drives(macio_ide, hd);



    macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),

                                                        "ide[1]"));

    macio_ide_init_drives(macio_ide, &hd[MAX_IDE_DEVS]);



    dev = DEVICE(object_resolve_path_component(OBJECT(macio), "cuda"));

    adb_bus = qdev_get_child_bus(dev, "adb.0");

    dev = qdev_create(adb_bus, TYPE_ADB_KEYBOARD);

    qdev_init_nofail(dev);

    dev = qdev_create(adb_bus, TYPE_ADB_MOUSE);

    qdev_init_nofail(dev);



    if (usb_enabled(false)) {

        pci_create_simple(pci_bus, -1, "pci-ohci");

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    /* No PCI init: the BIOS will do it */



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, ARCH_HEATHROW);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, cmdline_base);

        pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);



    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);



    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());

    if (kvm_enabled()) {

#ifdef CONFIG_KVM

        uint8_t *hypercall;



        hypercall = g_malloc(16);

        kvmppc_get_hypercall(env, hypercall, 16);

        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());

#endif

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, tbfreq);

    /* Mac OS X requires a "known good" clock-frequency value; pass it one. */

    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_CLOCKFREQ, CLOCKFREQ);

    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_BUSFREQ, BUSFREQ);



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

} and probability:0.15725806451612903
code:static int unpack_dct_coeffs(Vp3DecodeContext *s, GetBitContext *gb)

{

    int i;

    int dc_y_table;

    int dc_c_table;

    int ac_y_table;

    int ac_c_table;

    int residual_eob_run = 0;

    VLC *y_tables[64];

    VLC *c_tables[64];



    s->dct_tokens[0][0] = s->dct_tokens_base;



    if (get_bits_left(gb) < 16)




    /* fetch the DC table indexes */

    dc_y_table = get_bits(gb, 4);

    dc_c_table = get_bits(gb, 4);



    /* unpack the Y plane DC coefficients */

    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_y_table], 0,

                                   0, residual_eob_run);

    if (residual_eob_run < 0)

        return residual_eob_run;





    /* reverse prediction of the Y-plane DC coefficients */

    reverse_dc_prediction(s, 0, s->fragment_width[0], s->fragment_height[0]);



    /* unpack the C plane DC coefficients */

    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_c_table], 0,

                                   1, residual_eob_run);

    if (residual_eob_run < 0)

        return residual_eob_run;

    residual_eob_run = unpack_vlcs(s, gb, &s->dc_vlc[dc_c_table], 0,

                                   2, residual_eob_run);

    if (residual_eob_run < 0)

        return residual_eob_run;



    /* reverse prediction of the C-plane DC coefficients */

    if (!(s->avctx->flags & AV_CODEC_FLAG_GRAY)) {

        reverse_dc_prediction(s, s->fragment_start[1],

                              s->fragment_width[1], s->fragment_height[1]);

        reverse_dc_prediction(s, s->fragment_start[2],

                              s->fragment_width[1], s->fragment_height[1]);

    }





    /* fetch the AC table indexes */

    ac_y_table = get_bits(gb, 4);

    ac_c_table = get_bits(gb, 4);



    /* build tables of AC VLC tables */

    for (i = 1; i <= 5; i++) {

        y_tables[i] = &s->ac_vlc_1[ac_y_table];

        c_tables[i] = &s->ac_vlc_1[ac_c_table];

    }

    for (i = 6; i <= 14; i++) {

        y_tables[i] = &s->ac_vlc_2[ac_y_table];

        c_tables[i] = &s->ac_vlc_2[ac_c_table];

    }

    for (i = 15; i <= 27; i++) {

        y_tables[i] = &s->ac_vlc_3[ac_y_table];

        c_tables[i] = &s->ac_vlc_3[ac_c_table];

    }

    for (i = 28; i <= 63; i++) {

        y_tables[i] = &s->ac_vlc_4[ac_y_table];

        c_tables[i] = &s->ac_vlc_4[ac_c_table];

    }



    /* decode all AC coefficients */

    for (i = 1; i <= 63; i++) {

        residual_eob_run = unpack_vlcs(s, gb, y_tables[i], i,

                                       0, residual_eob_run);

        if (residual_eob_run < 0)

            return residual_eob_run;



        residual_eob_run = unpack_vlcs(s, gb, c_tables[i], i,

                                       1, residual_eob_run);

        if (residual_eob_run < 0)

            return residual_eob_run;

        residual_eob_run = unpack_vlcs(s, gb, c_tables[i], i,

                                       2, residual_eob_run);

        if (residual_eob_run < 0)

            return residual_eob_run;

    }



    return 0;

} and probability:0.3466666666666667
code:static void free_device_list(AVOpenCLDeviceList *device_list)

{

    int i, j;

    if (!device_list)

        return;

    for (i = 0; i < device_list->platform_num; i++) {

        if (!device_list->platform_node[i])

            continue;

        for (j = 0; j < device_list->platform_node[i]->device_num; j++) {

            av_freep(&(device_list->platform_node[i]->device_node[j]->device_name));

            av_freep(&(device_list->platform_node[i]->device_node[j]));

        }

        av_freep(&device_list->platform_node[i]->device_node);

        av_freep(&(device_list->platform_node[i]->platform_name));

        av_freep(&device_list->platform_node[i]);

    }

    av_freep(&device_list->platform_node);

    device_list->platform_num = 0;

}
 and probability:0.5263157894736842
code:void qemu_cond_init(QemuCond *cond)

{

    memset(cond, 0, sizeof(*cond));



    cond->sema = CreateSemaphore(NULL, 0, LONG_MAX, NULL);

    if (!cond->sema) {

        error_exit(GetLastError(), __func__);

    }

    cond->continue_event = CreateEvent(NULL,    /* security */

                                       FALSE,   /* auto-reset */

                                       FALSE,   /* not signaled */

                                       NULL);   /* name */

    if (!cond->continue_event) {

        error_exit(GetLastError(), __func__);

    }

}
 and probability:0.3333333333333333
code:void helper_rfdi(CPUPPCState *env)

{

    do_rfi(env, env->spr[SPR_BOOKE_DSRR0], SPR_BOOKE_DSRR1,

           ~((target_ulong)0x3FFF0000), 0);

}
 and probability:0.2
code:static void choose_sample_rate(AVStream *st, AVCodec *codec)

{

    if(codec && codec->supported_samplerates){

        const int *p= codec->supported_samplerates;

        int best;

        int best_dist=INT_MAX;

        for(; *p; p++){

            int dist= abs(st->codec->sample_rate - *p);

            if(dist < best_dist){

                best_dist= dist;

                best= *p;

            }

        }

        if(best_dist){

            av_log(st->codec, AV_LOG_WARNING, "Requested sampling rate unsupported using closest supported (%d)\n", best);

        }

        st->codec->sample_rate= best;

    }

}
 and probability:0.3684210526315789
code:unsigned iov_copy(struct iovec *dst_iov, unsigned int dst_iov_cnt,

                 const struct iovec *iov, unsigned int iov_cnt,

                 size_t offset, size_t bytes)

{

    size_t len;

    unsigned int i, j;

    for (i = 0, j = 0; i < iov_cnt && j < dst_iov_cnt && bytes; i++) {

        if (offset >= iov[i].iov_len) {

            offset -= iov[i].iov_len;

            continue;

        }

        len = MIN(bytes, iov[i].iov_len - offset);



        dst_iov[j].iov_base = iov[i].iov_base + offset;

        dst_iov[j].iov_len = len;

        j++;

        bytes -= len;

        offset = 0;

    }

    assert(offset == 0);

    return j;

}
 and probability:0.38095238095238093
code:static int tty_serial_ioctl(CharDriverState *chr, int cmd, void *arg)


    FDCharDriver *s = chr->opaque;



    switch(cmd) {

    case CHR_IOCTL_SERIAL_SET_PARAMS:


            QEMUSerialSetParams *ssp = arg;

            tty_serial_init(s->fd_in, ssp->speed, ssp->parity,

                            ssp->data_bits, ssp->stop_bits);



    case CHR_IOCTL_SERIAL_SET_BREAK:


            int enable = *(int *)arg;

            if (enable)

                tcsendbreak(s->fd_in, 1);


































    default:

        return -ENOTSUP;


    return 0;
 and probability:0.35714285714285715
code:static int spapr_populate_drconf_memory(sPAPRMachineState *spapr, void *fdt)

{

    MachineState *machine = MACHINE(spapr);

    int ret, i, offset;

    uint64_t lmb_size = SPAPR_MEMORY_BLOCK_SIZE;

    uint32_t prop_lmb_size[] = {0, cpu_to_be32(lmb_size)};

    uint32_t nr_lmbs = (machine->maxram_size - machine->ram_size)/lmb_size;

    uint32_t *int_buf, *cur_index, buf_len;

    int nr_nodes = nb_numa_nodes ? nb_numa_nodes : 1;



    /* Allocate enough buffer size to fit in ibm,dynamic-memory */

    buf_len = nr_lmbs * SPAPR_DR_LMB_LIST_ENTRY_SIZE * sizeof(uint32_t) +

                sizeof(uint32_t);

    cur_index = int_buf = g_malloc0(buf_len);



    offset = fdt_add_subnode(fdt, 0, "ibm,dynamic-reconfiguration-memory");



    ret = fdt_setprop(fdt, offset, "ibm,lmb-size", prop_lmb_size,

                    sizeof(prop_lmb_size));

    if (ret < 0) {

        goto out;

    }



    ret = fdt_setprop_cell(fdt, offset, "ibm,memory-flags-mask", 0xff);

    if (ret < 0) {

        goto out;

    }



    ret = fdt_setprop_cell(fdt, offset, "ibm,memory-preservation-time", 0x0);

    if (ret < 0) {

        goto out;

    }



    /* ibm,dynamic-memory */

    int_buf[0] = cpu_to_be32(nr_lmbs);

    cur_index++;

    for (i = 0; i < nr_lmbs; i++) {

        sPAPRDRConnector *drc;

        sPAPRDRConnectorClass *drck;

        uint64_t addr = i * lmb_size + spapr->hotplug_memory.base;;

        uint32_t *dynamic_memory = cur_index;



        drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_LMB,

                                       addr/lmb_size);

        g_assert(drc);

        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



        dynamic_memory[0] = cpu_to_be32(addr >> 32);

        dynamic_memory[1] = cpu_to_be32(addr & 0xffffffff);

        dynamic_memory[2] = cpu_to_be32(drck->get_index(drc));

        dynamic_memory[3] = cpu_to_be32(0); /* reserved */

        dynamic_memory[4] = cpu_to_be32(numa_get_node(addr, NULL));

        if (addr < machine->ram_size ||

                    memory_region_present(get_system_memory(), addr)) {

            dynamic_memory[5] = cpu_to_be32(SPAPR_LMB_FLAGS_ASSIGNED);

        } else {

            dynamic_memory[5] = cpu_to_be32(0);

        }



        cur_index += SPAPR_DR_LMB_LIST_ENTRY_SIZE;

    }

    ret = fdt_setprop(fdt, offset, "ibm,dynamic-memory", int_buf, buf_len);

    if (ret < 0) {

        goto out;

    }



    /* ibm,associativity-lookup-arrays */

    cur_index = int_buf;

    int_buf[0] = cpu_to_be32(nr_nodes);

    int_buf[1] = cpu_to_be32(4); /* Number of entries per associativity list */

    cur_index += 2;

    for (i = 0; i < nr_nodes; i++) {

        uint32_t associativity[] = {

            cpu_to_be32(0x0),

            cpu_to_be32(0x0),

            cpu_to_be32(0x0),

            cpu_to_be32(i)

        };

        memcpy(cur_index, associativity, sizeof(associativity));

        cur_index += 4;

    }

    ret = fdt_setprop(fdt, offset, "ibm,associativity-lookup-arrays", int_buf,

            (cur_index - int_buf) * sizeof(uint32_t));

out:

    g_free(int_buf);

    return ret;

}
 and probability:0.2857142857142857
code:static int http_server(struct sockaddr_in my_addr)

{

    int server_fd, tmp, ret;

    struct sockaddr_in from_addr;

    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 1], *poll_entry;

    HTTPContext *c, **cp;

    long cur_time;



    server_fd = socket(AF_INET,SOCK_STREAM,0);

    if (server_fd < 0) {

        perror ("socket");

        return -1;

    }

        

    tmp = 1;

    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(tmp));



    if (bind (server_fd, (struct sockaddr *) &my_addr, sizeof (my_addr)) < 0) {

        perror ("bind");

        close(server_fd);

        return -1;

    }

  

    if (listen (server_fd, 5) < 0) {

        perror ("listen");

        close(server_fd);

        return -1;

    }



    http_log("ffserver started.\n");



    start_children(first_feed);



    fcntl(server_fd, F_SETFL, O_NONBLOCK);

    first_http_ctx = NULL;

    nb_connections = 0;

    first_http_ctx = NULL;

    for(;;) {

        poll_entry = poll_table;

        poll_entry->fd = server_fd;

        poll_entry->events = POLLIN;

        poll_entry++;



        /* wait for events on each HTTP handle */

        c = first_http_ctx;

        while (c != NULL) {

            int fd;

            fd = c->fd;

            switch(c->state) {

            case HTTPSTATE_WAIT_REQUEST:

                c->poll_entry = poll_entry;

                poll_entry->fd = fd;

                poll_entry->events = POLLIN;

                poll_entry++;

                break;

            case HTTPSTATE_SEND_HEADER:

            case HTTPSTATE_SEND_DATA_HEADER:

            case HTTPSTATE_SEND_DATA:

            case HTTPSTATE_SEND_DATA_TRAILER:

                c->poll_entry = poll_entry;

                poll_entry->fd = fd;

                poll_entry->events = POLLOUT;

                poll_entry++;

                break;

            case HTTPSTATE_RECEIVE_DATA:

                c->poll_entry = poll_entry;

                poll_entry->fd = fd;

                poll_entry->events = POLLIN;

                poll_entry++;

                break;

            case HTTPSTATE_WAIT_FEED:

                /* need to catch errors */

                c->poll_entry = poll_entry;

                poll_entry->fd = fd;

                poll_entry->events = POLLIN;/* Maybe this will work */

                poll_entry++;

                break;

            default:

                c->poll_entry = NULL;

                break;

            }

            c = c->next;

        }



        /* wait for an event on one connection. We poll at least every

           second to handle timeouts */

        do {

            ret = poll(poll_table, poll_entry - poll_table, 1000);

        } while (ret == -1);

        

        cur_time = gettime_ms();



        /* now handle the events */



        cp = &first_http_ctx;

        while ((*cp) != NULL) {

            c = *cp;

            if (handle_http (c, cur_time) < 0) {

                /* close and free the connection */

                log_connection(c);

                close(c->fd);

                if (c->fmt_in)

                    av_close_input_file(c->fmt_in);

                *cp = c->next;

                nb_bandwidth -= c->bandwidth;

                av_free(c->buffer);

                av_free(c->pbuffer);

                av_free(c);

                nb_connections--;

            } else {

                cp = &c->next;

            }

        }



        /* new connection request ? */

        poll_entry = poll_table;

        if (poll_entry->revents & POLLIN) {

            int fd, len;



            len = sizeof(from_addr);

            fd = accept(server_fd, (struct sockaddr *)&from_addr, 

                        &len);

            if (fd >= 0) {

                fcntl(fd, F_SETFL, O_NONBLOCK);

                /* XXX: should output a warning page when coming

                   close to the connection limit */

                if (nb_connections >= nb_max_connections) {

                    c = NULL;

                } else {

                    /* add a new connection */

                    c = av_mallocz(sizeof(HTTPContext));

                    if (c) {

                        c->next = first_http_ctx;

                        first_http_ctx = c;

                        c->fd = fd;

                        c->poll_entry = NULL;

                        c->from_addr = from_addr;

                        c->state = HTTPSTATE_WAIT_REQUEST;

                        c->buffer = av_malloc(c->buffer_size = IOBUFFER_INIT_SIZE);

                        c->pbuffer = av_malloc(c->pbuffer_size = PBUFFER_INIT_SIZE);

                        if (!c->buffer || !c->pbuffer) {

                            av_free(c->buffer);

                            av_free(c->pbuffer);

                            av_freep(&c);

                        } else {

                            c->buffer_ptr = c->buffer;

                            c->buffer_end = c->buffer + c->buffer_size;

                            c->timeout = cur_time + REQUEST_TIMEOUT;

                            c->start_time = cur_time;

                            nb_connections++;

                        }

                    }

                }

                if (!c) {

                    close(fd);

                }

            }

        }

        poll_entry++;

    }

}
 and probability:0.36054421768707484
code:int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{

    uint8_t t[sizeof(diag_501)];



    if (cpu_memory_rw_debug(cs, bp->pc, t, sizeof(diag_501), 0)) {

        return -EINVAL;

    } else if (memcmp(t, diag_501, sizeof(diag_501))) {

        return -EINVAL;

    } else if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                                   sizeof(diag_501), 1)) {

        return -EINVAL;

    }



    return 0;

}
 and probability:0.15384615384615385
code:static int kvm_get_dirty_pages_log_range(MemoryRegionSection *section,

                                         unsigned long *bitmap)

{

    unsigned int i, j;

    unsigned long page_number, addr, addr1, c;

    unsigned int len = ((section->size / TARGET_PAGE_SIZE) + HOST_LONG_BITS - 1) / HOST_LONG_BITS;



    /*

     * bitmap-traveling is faster than memory-traveling (for addr...)

     * especially when most of the memory is not dirty.

     */

    for (i = 0; i < len; i++) {

        if (bitmap[i] != 0) {

            c = leul_to_cpu(bitmap[i]);

            do {

                j = ffsl(c) - 1;

                c &= ~(1ul << j);

                page_number = i * HOST_LONG_BITS + j;

                addr1 = page_number * TARGET_PAGE_SIZE;

                addr = section->offset_within_region + addr1;

                memory_region_set_dirty(section->mr, addr);

            } while (c != 0);

        }

    }

    return 0;

}
 and probability:0.36
code:static int ppc_hash64_pte_prot(PowerPCCPU *cpu,

                               ppc_slb_t *slb, ppc_hash_pte64_t pte)

{

    CPUPPCState *env = &cpu->env;

    unsigned pp, key;

    /* Some pp bit combinations have undefined behaviour, so default

     * to no access in those cases */

    int prot = 0;



    key = !!(msr_pr ? (slb->vsid & SLB_VSID_KP)

             : (slb->vsid & SLB_VSID_KS));

    pp = (pte.pte1 & HPTE64_R_PP) | ((pte.pte1 & HPTE64_R_PP0) >> 61);



    if (key == 0) {

        switch (pp) {

        case 0x0:

        case 0x1:

        case 0x2:

            prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;

            break;



        case 0x3:

        case 0x6:

            prot = PAGE_READ | PAGE_EXEC;

            break;

        }

    } else {

        switch (pp) {

        case 0x0:

        case 0x6:

            break;



        case 0x1:

        case 0x3:

            prot = PAGE_READ | PAGE_EXEC;

            break;



        case 0x2:

            prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;

            break;

        }

    }



    /* No execute if either noexec or guarded bits set */

    if (!(pte.pte1 & HPTE64_R_N) || (pte.pte1 & HPTE64_R_G)

        || (slb->vsid & SLB_VSID_N)) {

        prot |= PAGE_EXEC;

    }



    return prot;

}
 and probability:0.09090909090909091
code:static int rd_frame(CinepakEncContext *s, AVFrame *frame, unsigned char *buf, int buf_size)

{

    int num_strips, strip, h, i, y, size, temp_size, best_size;

    AVPicture last_pict, pict, scratch_pict;

    int64_t best_score = 0, score, score_temp;



    //TODO: support encoding zero strips (meaning skip the whole frame)

    for(num_strips = MIN_STRIPS; num_strips <= MAX_STRIPS && num_strips <= s->h / MB_SIZE; num_strips++) {

        score = 0;

        size = 0;

        h = s->h / num_strips;

        //make h into next multiple of 4

        h += 4 - (h & 3);



        for(strip = 0; strip < num_strips; strip++) {

            y = strip*h;



            get_sub_picture(s, 0, y, (AVPicture*)frame,            &pict);

            get_sub_picture(s, 0, y, (AVPicture*)&s->last_frame,    &last_pict);

            get_sub_picture(s, 0, y, (AVPicture*)&s->scratch_frame, &scratch_pict);



            if((temp_size = rd_strip(s, y, FFMIN(h, s->h - y), frame->key_frame, &last_pict, &pict, &scratch_pict, s->frame_buf + CVID_HEADER_SIZE, &score_temp)) < 0)

                return temp_size;



            score += score_temp;

            size += temp_size;

        }



        if(best_score == 0 || score < best_score) {

            best_score = score;

            best_size = size + write_cvid_header(s, s->frame_buf, num_strips, size);

            av_log(s->avctx, AV_LOG_INFO, "best number of strips so far: %2i, %12li, %i B\n", num_strips, score, best_size);



            FFSWAP(AVFrame, s->best_frame, s->scratch_frame);

        }

    }



    memcpy(buf, s->frame_buf, best_size);



    return best_size;

}
 and probability:0.4375
code:void ff_hevc_set_qPy(HEVCContext *s, int xC, int yC,

                     int xBase, int yBase, int log2_cb_size)

{

    int qp_y = get_qPy_pred(s, xC, yC, xBase, yBase, log2_cb_size);



    if (s->HEVClc->tu.cu_qp_delta != 0) {

        int off = s->sps->qp_bd_offset;

        s->HEVClc->qp_y = ((qp_y + s->HEVClc->tu.cu_qp_delta + 52 + 2 * off) %

                          (52 + off)) - off;

    } else

        s->HEVClc->qp_y = qp_y;

}
 and probability:0.45454545454545453
code:static void sdhci_sysbus_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->vmsd = &sdhci_vmstate;

    dc->props = sdhci_sysbus_properties;

    dc->realize = sdhci_sysbus_realize;

    dc->reset = sdhci_poweron_reset;






} and probability:0.5
code:grlib_gptimer_writel(void *opaque, target_phys_addr_t addr, uint32_t value)

{

    GPTimerUnit        *unit = opaque;

    target_phys_addr_t  timer_addr;

    int                 id;



    addr &= 0xff;



    /* Unit registers */

    switch (addr) {

    case SCALER_OFFSET:

        value &= 0xFFFF; /* clean up the value */

        unit->scaler = value;

        trace_grlib_gptimer_writel(-1, "scaler:", unit->scaler);

        return;



    case SCALER_RELOAD_OFFSET:

        value &= 0xFFFF; /* clean up the value */

        unit->reload = value;

        trace_grlib_gptimer_writel(-1, "reload:", unit->reload);

        grlib_gptimer_set_scaler(unit, value);

        return;



    case CONFIG_OFFSET:

        /* Read Only (disable timer freeze not supported) */

        trace_grlib_gptimer_writel(-1, "config (Read Only):", 0);

        return;



    default:

        break;

    }



    timer_addr = (addr % TIMER_BASE);

    id         = (addr - TIMER_BASE) / TIMER_BASE;



    if (id >= 0 && id < unit->nr_timers) {



        /* GPTimer registers */

        switch (timer_addr) {

        case COUNTER_OFFSET:

            trace_grlib_gptimer_writel(id, "counter:", value);

            unit->timers[id].counter = value;

            grlib_gptimer_enable(&unit->timers[id]);

            return;



        case COUNTER_RELOAD_OFFSET:

            trace_grlib_gptimer_writel(id, "reload:", value);

            unit->timers[id].reload = value;

            return;



        case CONFIG_OFFSET:

            trace_grlib_gptimer_writel(id, "config:", value);



            if (value & GPTIMER_INT_PENDING) {

                /* clear pending bit */

                value &= ~GPTIMER_INT_PENDING;

            } else {

                /* keep pending bit */

                value |= unit->timers[id].config & GPTIMER_INT_PENDING;

            }



            unit->timers[id].config = value;



            /* gptimer_restart calls gptimer_enable, so if "enable" and "load"

               bits are present, we just have to call restart. */



            if (value & GPTIMER_LOAD) {

                grlib_gptimer_restart(&unit->timers[id]);

            } else if (value & GPTIMER_ENABLE) {

                grlib_gptimer_enable(&unit->timers[id]);

            }



            /* These fields must always be read as 0 */

            value &= ~(GPTIMER_LOAD & GPTIMER_DEBUG_HALT);



            unit->timers[id].config = value;

            return;



        default:

            break;

        }



    }



    trace_grlib_gptimer_unknown_register("write", addr);

}
 and probability:0.23880597014925373
code:static void check_watchpoint(int offset, int len, MemTxAttrs attrs, int flags)

{

    CPUState *cpu = current_cpu;

    CPUClass *cc = CPU_GET_CLASS(cpu);

    CPUArchState *env = cpu->env_ptr;

    target_ulong pc, cs_base;

    target_ulong vaddr;

    CPUWatchpoint *wp;

    uint32_t cpu_flags;



    if (cpu->watchpoint_hit) {

        /* We re-entered the check after replacing the TB. Now raise

         * the debug interrupt so that is will trigger after the

         * current instruction. */

        cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);

        return;

    }

    vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;

    vaddr = cc->adjust_watchpoint_address(cpu, vaddr, len);

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        if (cpu_watchpoint_address_matches(wp, vaddr, len)

            && (wp->flags & flags)) {

            if (flags == BP_MEM_READ) {

                wp->flags |= BP_WATCHPOINT_HIT_READ;

            } else {

                wp->flags |= BP_WATCHPOINT_HIT_WRITE;

            }

            wp->hitaddr = vaddr;

            wp->hitattrs = attrs;

            if (!cpu->watchpoint_hit) {

                if (wp->flags & BP_CPU &&

                    !cc->debug_check_watchpoint(cpu, wp)) {

                    wp->flags &= ~BP_WATCHPOINT_HIT;

                    continue;

                }

                cpu->watchpoint_hit = wp;



                /* The tb_lock will be reset when cpu_loop_exit or

                 * cpu_loop_exit_noexc longjmp back into the cpu_exec

                 * main loop.

                 */

                tb_lock();

                tb_check_watchpoint(cpu);

                if (wp->flags & BP_STOP_BEFORE_ACCESS) {

                    cpu->exception_index = EXCP_DEBUG;

                    cpu_loop_exit(cpu);

                } else {

                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);

                    tb_gen_code(cpu, pc, cs_base, cpu_flags, 1);

                    cpu_loop_exit_noexc(cpu);

                }

            }

        } else {

            wp->flags &= ~BP_WATCHPOINT_HIT;

        }

    }

}
 and probability:0.32727272727272727
code:DISAS_INSN(shift_im)

{

    TCGv reg;

    int tmp;

    TCGv shift;



    set_cc_op(s, CC_OP_FLAGS);



    reg = DREG(insn, 0);

    tmp = (insn >> 9) & 7;

    if (tmp == 0)

        tmp = 8;

    shift = tcg_const_i32(tmp);

    /* No need to flush flags becuse we know we will set C flag.  */

    if (insn & 0x100) {

        gen_helper_shl_cc(reg, cpu_env, reg, shift);

    } else {

        if (insn & 8) {

            gen_helper_shr_cc(reg, cpu_env, reg, shift);

        } else {

            gen_helper_sar_cc(reg, cpu_env, reg, shift);

        }

    }

}
 and probability:0.0
code:static target_ulong h_protect(PowerPCCPU *cpu, sPAPRMachineState *spapr,

                              target_ulong opcode, target_ulong *args)

{

    CPUPPCState *env = &cpu->env;

    target_ulong flags = args[0];

    target_ulong pte_index = args[1];

    target_ulong avpn = args[2];

    uint64_t token;

    target_ulong v, r, rb;



    if (!valid_pte_index(env, pte_index)) {

        return H_PARAMETER;

    }



    token = ppc_hash64_start_access(cpu, pte_index);

    v = ppc_hash64_load_hpte0(cpu, token, 0);

    r = ppc_hash64_load_hpte1(cpu, token, 0);

    ppc_hash64_stop_access(token);



    if ((v & HPTE64_V_VALID) == 0 ||

        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn)) {

        return H_NOT_FOUND;

    }



    r &= ~(HPTE64_R_PP0 | HPTE64_R_PP | HPTE64_R_N |

           HPTE64_R_KEY_HI | HPTE64_R_KEY_LO);

    r |= (flags << 55) & HPTE64_R_PP0;

    r |= (flags << 48) & HPTE64_R_KEY_HI;

    r |= flags & (HPTE64_R_PP | HPTE64_R_N | HPTE64_R_KEY_LO);

    rb = compute_tlbie_rb(v, r, pte_index);

    ppc_hash64_store_hpte(cpu, pte_index,

                          (v & ~HPTE64_V_VALID) | HPTE64_V_HPTE_DIRTY, 0);

    ppc_tlb_invalidate_one(env, rb);

    /* Don't need a memory barrier, due to qemu's global lock */

    ppc_hash64_store_hpte(cpu, pte_index, v | HPTE64_V_HPTE_DIRTY, r);

    return H_SUCCESS;

}
 and probability:0.12121212121212122
code:static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_ASYNC_PF)) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_PV_EOI)) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_STEAL_TIME)) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (cpu->hyperv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (cpu->hyperv_time) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (env->features[FEAT_1_EDX] & CPUID_MTRR) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    if (ret < cpu->kvm_msr_buf->nmsrs) {

        struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];

        error_report("error: failed to get MSR 0x%" PRIx32,

                     (uint32_t)e->index);

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
 and probability:0.27320954907161804
code:static void blk_mig_unlock(void)

{

    qemu_mutex_unlock(&block_mig_state.lock);

}
 and probability:0.0
code:static void do_tb_flush(CPUState *cpu, void *data)

{

    unsigned tb_flush_req = (unsigned) (uintptr_t) data;



    tb_lock();



    /* If it's already been done on request of another CPU,

     * just retry.

     */

    if (tcg_ctx.tb_ctx.tb_flush_count != tb_flush_req) {

        goto done;

    }



#if defined(DEBUG_FLUSH)

    printf("qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\n",

           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),

           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?

           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /

           tcg_ctx.tb_ctx.nb_tbs : 0);

#endif

    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)

        > tcg_ctx.code_gen_buffer_size) {

        cpu_abort(cpu, "Internal error: code buffer overflow\n");

    }



    CPU_FOREACH(cpu) {

        int i;



        for (i = 0; i < TB_JMP_CACHE_SIZE; ++i) {

            atomic_set(&cpu->tb_jmp_cache[i], NULL);

        }

    }



    tcg_ctx.tb_ctx.nb_tbs = 0;

    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);

    page_flush_tb();



    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;

    /* XXX: flush processor icache at this point if cache flush is

       expensive */

    atomic_mb_set(&tcg_ctx.tb_ctx.tb_flush_count,

                  tcg_ctx.tb_ctx.tb_flush_count + 1);



done:

    tb_unlock();

}
 and probability:0.15789473684210525
code:static int decode_gusa(DisasContext *ctx, CPUSH4State *env, int *pmax_insns)

{

    uint16_t insns[5];

    int ld_adr, ld_dst, ld_mop;

    int op_dst, op_src, op_opc;

    int mv_src, mt_dst, st_src, st_mop;

    TCGv op_arg;



    uint32_t pc = ctx->pc;

    uint32_t pc_end = ctx->tb->cs_base;

    int backup = sextract32(ctx->tbflags, GUSA_SHIFT, 8);

    int max_insns = (pc_end - pc) / 2;

    int i;



    if (pc != pc_end + backup || max_insns < 2) {

        /* This is a malformed gUSA region.  Don't do anything special,

           since the interpreter is likely to get confused.  */

        ctx->envflags &= ~GUSA_MASK;

        return 0;

    }



    if (ctx->tbflags & GUSA_EXCLUSIVE) {

        /* Regardless of single-stepping or the end of the page,

           we must complete execution of the gUSA region while

           holding the exclusive lock.  */

        *pmax_insns = max_insns;

        return 0;

    }



    /* The state machine below will consume only a few insns.

       If there are more than that in a region, fail now.  */

    if (max_insns > ARRAY_SIZE(insns)) {

        goto fail;

    }



    /* Read all of the insns for the region.  */

    for (i = 0; i < max_insns; ++i) {

        insns[i] = cpu_lduw_code(env, pc + i * 2);

    }



    ld_adr = ld_dst = ld_mop = -1;

    mv_src = -1;

    op_dst = op_src = op_opc = -1;

    mt_dst = -1;

    st_src = st_mop = -1;

    TCGV_UNUSED(op_arg);

    i = 0;



#define NEXT_INSN \

    do { if (i >= max_insns) goto fail; ctx->opcode = insns[i++]; } while (0)



    /*

     * Expect a load to begin the region.

     */

    NEXT_INSN;

    switch (ctx->opcode & 0xf00f) {

    case 0x6000: /* mov.b @Rm,Rn */

        ld_mop = MO_SB;

        break;

    case 0x6001: /* mov.w @Rm,Rn */

        ld_mop = MO_TESW;

        break;

    case 0x6002: /* mov.l @Rm,Rn */

        ld_mop = MO_TESL;

        break;

    default:

        goto fail;

    }

    ld_adr = B7_4;

    ld_dst = B11_8;

    if (ld_adr == ld_dst) {

        goto fail;

    }

    /* Unless we see a mov, any two-operand operation must use ld_dst.  */

    op_dst = ld_dst;



    /*

     * Expect an optional register move.

     */

    NEXT_INSN;

    switch (ctx->opcode & 0xf00f) {

    case 0x6003: /* mov Rm,Rn */

        /* Here we want to recognize ld_dst being saved for later consumtion,

           or for another input register being copied so that ld_dst need not

           be clobbered during the operation.  */

        op_dst = B11_8;

        mv_src = B7_4;

        if (op_dst == ld_dst) {

            /* Overwriting the load output.  */

            goto fail;

        }

        if (mv_src != ld_dst) {

            /* Copying a new input; constrain op_src to match the load.  */

            op_src = ld_dst;

        }

        break;



    default:

        /* Put back and re-examine as operation.  */

        --i;

    }



    /*

     * Expect the operation.

     */

    NEXT_INSN;

    switch (ctx->opcode & 0xf00f) {

    case 0x300c: /* add Rm,Rn */

        op_opc = INDEX_op_add_i32;

        goto do_reg_op;

    case 0x2009: /* and Rm,Rn */

        op_opc = INDEX_op_and_i32;

        goto do_reg_op;

    case 0x200a: /* xor Rm,Rn */

        op_opc = INDEX_op_xor_i32;

        goto do_reg_op;

    case 0x200b: /* or Rm,Rn */

        op_opc = INDEX_op_or_i32;

    do_reg_op:

        /* The operation register should be as expected, and the

           other input cannot depend on the load.  */

        if (op_dst != B11_8) {

            goto fail;

        }

        if (op_src < 0) {

            /* Unconstrainted input.  */

            op_src = B7_4;

        } else if (op_src == B7_4) {

            /* Constrained input matched load.  All operations are

               commutative; "swap" them by "moving" the load output

               to the (implicit) first argument and the move source

               to the (explicit) second argument.  */

            op_src = mv_src;

        } else {

            goto fail;

        }

        op_arg = REG(op_src);

        break;



    case 0x6007: /* not Rm,Rn */

        if (ld_dst != B7_4 || mv_src >= 0) {

            goto fail;

        }

        op_dst = B11_8;

        op_opc = INDEX_op_xor_i32;

        op_arg = tcg_const_i32(-1);

        break;



    case 0x7000 ... 0x700f: /* add #imm,Rn */

        if (op_dst != B11_8 || mv_src >= 0) {

            goto fail;

        }

        op_opc = INDEX_op_add_i32;

        op_arg = tcg_const_i32(B7_0s);

        break;



    case 0x3000: /* cmp/eq Rm,Rn */

        /* Looking for the middle of a compare-and-swap sequence,

           beginning with the compare.  Operands can be either order,

           but with only one overlapping the load.  */

        if ((ld_dst == B11_8) + (ld_dst == B7_4) != 1 || mv_src >= 0) {

            goto fail;

        }

        op_opc = INDEX_op_setcond_i32;  /* placeholder */

        op_src = (ld_dst == B11_8 ? B7_4 : B11_8);

        op_arg = REG(op_src);



        NEXT_INSN;

        switch (ctx->opcode & 0xff00) {

        case 0x8b00: /* bf label */

        case 0x8f00: /* bf/s label */

            if (pc + (i + 1 + B7_0s) * 2 != pc_end) {

                goto fail;

            }

            if ((ctx->opcode & 0xff00) == 0x8b00) { /* bf label */

                break;

            }

            /* We're looking to unconditionally modify Rn with the

               result of the comparison, within the delay slot of

               the branch.  This is used by older gcc.  */

            NEXT_INSN;

            if ((ctx->opcode & 0xf0ff) == 0x0029) { /* movt Rn */

                mt_dst = B11_8;

            } else {

                goto fail;

            }

            break;



        default:

            goto fail;

        }

        break;



    case 0x2008: /* tst Rm,Rn */

        /* Looking for a compare-and-swap against zero.  */

        if (ld_dst != B11_8 || ld_dst != B7_4 || mv_src >= 0) {

            goto fail;

        }

        op_opc = INDEX_op_setcond_i32;

        op_arg = tcg_const_i32(0);



        NEXT_INSN;

        if ((ctx->opcode & 0xff00) != 0x8900 /* bt label */

            || pc + (i + 1 + B7_0s) * 2 != pc_end) {

            goto fail;

        }

        break;



    default:

        /* Put back and re-examine as store.  */

        --i;

    }



    /*

     * Expect the store.

     */

    /* The store must be the last insn.  */

    if (i != max_insns - 1) {

        goto fail;

    }

    NEXT_INSN;

    switch (ctx->opcode & 0xf00f) {

    case 0x2000: /* mov.b Rm,@Rn */

        st_mop = MO_UB;

        break;

    case 0x2001: /* mov.w Rm,@Rn */

        st_mop = MO_UW;

        break;

    case 0x2002: /* mov.l Rm,@Rn */

        st_mop = MO_UL;

        break;

    default:

        goto fail;

    }

    /* The store must match the load.  */

    if (ld_adr != B11_8 || st_mop != (ld_mop & MO_SIZE)) {

        goto fail;

    }

    st_src = B7_4;



#undef NEXT_INSN



    /*

     * Emit the operation.

     */

    tcg_gen_insn_start(pc, ctx->envflags);

    switch (op_opc) {

    case -1:

        /* No operation found.  Look for exchange pattern.  */

        if (st_src == ld_dst || mv_src >= 0) {

            goto fail;

        }

        tcg_gen_atomic_xchg_i32(REG(ld_dst), REG(ld_adr), REG(st_src),

                                ctx->memidx, ld_mop);

        break;



    case INDEX_op_add_i32:

        if (op_dst != st_src) {

            goto fail;

        }

        if (op_dst == ld_dst && st_mop == MO_UL) {

            tcg_gen_atomic_add_fetch_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

        } else {

            tcg_gen_atomic_fetch_add_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

            if (op_dst != ld_dst) {

                /* Note that mop sizes < 4 cannot use add_fetch

                   because it won't carry into the higher bits.  */

                tcg_gen_add_i32(REG(op_dst), REG(ld_dst), op_arg);

            }

        }

        break;



    case INDEX_op_and_i32:

        if (op_dst != st_src) {

            goto fail;

        }

        if (op_dst == ld_dst) {

            tcg_gen_atomic_and_fetch_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

        } else {

            tcg_gen_atomic_fetch_and_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

            tcg_gen_and_i32(REG(op_dst), REG(ld_dst), op_arg);

        }

        break;



    case INDEX_op_or_i32:

        if (op_dst != st_src) {

            goto fail;

        }

        if (op_dst == ld_dst) {

            tcg_gen_atomic_or_fetch_i32(REG(ld_dst), REG(ld_adr),

                                        op_arg, ctx->memidx, ld_mop);

        } else {

            tcg_gen_atomic_fetch_or_i32(REG(ld_dst), REG(ld_adr),

                                        op_arg, ctx->memidx, ld_mop);

            tcg_gen_or_i32(REG(op_dst), REG(ld_dst), op_arg);

        }

        break;



    case INDEX_op_xor_i32:

        if (op_dst != st_src) {

            goto fail;

        }

        if (op_dst == ld_dst) {

            tcg_gen_atomic_xor_fetch_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

        } else {

            tcg_gen_atomic_fetch_xor_i32(REG(ld_dst), REG(ld_adr),

                                         op_arg, ctx->memidx, ld_mop);

            tcg_gen_xor_i32(REG(op_dst), REG(ld_dst), op_arg);

        }

        break;



    case INDEX_op_setcond_i32:

        if (st_src == ld_dst) {

            goto fail;

        }

        tcg_gen_atomic_cmpxchg_i32(REG(ld_dst), REG(ld_adr), op_arg,

                                   REG(st_src), ctx->memidx, ld_mop);

        tcg_gen_setcond_i32(TCG_COND_EQ, cpu_sr_t, REG(ld_dst), op_arg);

        if (mt_dst >= 0) {

            tcg_gen_mov_i32(REG(mt_dst), cpu_sr_t);

        }

        break;



    default:

        g_assert_not_reached();

    }



    /* If op_src is not a valid register, then op_arg was a constant.  */

    if (op_src < 0) {

        tcg_temp_free_i32(op_arg);

    }



    /* The entire region has been translated.  */

    ctx->envflags &= ~GUSA_MASK;

    ctx->pc = pc_end;

    return max_insns;



 fail:

    qemu_log_mask(LOG_UNIMP, "Unrecognized gUSA sequence %08x-%08x\n",

                  pc, pc_end);



    /* Restart with the EXCLUSIVE bit set, within a TB run via

       cpu_exec_step_atomic holding the exclusive lock.  */

    tcg_gen_insn_start(pc, ctx->envflags);

    ctx->envflags |= GUSA_EXCLUSIVE;

    gen_save_cpu_state(ctx, false);

    gen_helper_exclusive(cpu_env);

    ctx->bstate = BS_EXCP;



    /* We're not executing an instruction, but we must report one for the

       purposes of accounting within the TB.  We might as well report the

       entire region consumed via ctx->pc so that it's immediately available

       in the disassembly dump.  */

    ctx->pc = pc_end;

    return 1;

}
 and probability:0.125
code:static int yop_read_header(AVFormatContext *s)

{

    YopDecContext *yop = s->priv_data;

    AVIOContext *pb  = s->pb;



    AVCodecContext *audio_dec, *video_dec;

    AVStream *audio_stream, *video_stream;



    int frame_rate, ret;



    audio_stream = avformat_new_stream(s, NULL);

    video_stream = avformat_new_stream(s, NULL);





    // Extra data that will be passed to the decoder

    video_stream->codec->extradata_size = 8;



    video_stream->codec->extradata = av_mallocz(video_stream->codec->extradata_size +

                                                FF_INPUT_BUFFER_PADDING_SIZE);



    if (!video_stream->codec->extradata)




    // Audio

    audio_dec               = audio_stream->codec;

    audio_dec->codec_type   = AVMEDIA_TYPE_AUDIO;

    audio_dec->codec_id     = AV_CODEC_ID_ADPCM_IMA_APC;

    audio_dec->channels     = 1;

    audio_dec->sample_rate  = 22050;



    // Video

    video_dec               = video_stream->codec;

    video_dec->codec_type   = AVMEDIA_TYPE_VIDEO;

    video_dec->codec_id     = AV_CODEC_ID_YOP;



    avio_skip(pb, 6);



    frame_rate              = avio_r8(pb);

    yop->frame_size         = avio_r8(pb) * 2048;

    video_dec->width        = avio_rl16(pb);

    video_dec->height       = avio_rl16(pb);



    video_stream->sample_aspect_ratio = (AVRational){1, 2};



    ret = avio_read(pb, video_dec->extradata, 8);

    if (ret < 8)

        return ret < 0 ? ret : AVERROR_EOF;



    yop->palette_size       = video_dec->extradata[0] * 3 + 4;

    yop->audio_block_length = AV_RL16(video_dec->extradata + 6);



    // 1840 samples per frame, 1 nibble per sample; hence 1840/2 = 920

    if (yop->audio_block_length < 920 ||

        yop->audio_block_length + yop->palette_size >= yop->frame_size) {

        av_log(s, AV_LOG_ERROR, "YOP has invalid header\n");

        return AVERROR_INVALIDDATA;

    }



    avio_seek(pb, 2048, SEEK_SET);



    avpriv_set_pts_info(video_stream, 32, 1, frame_rate);



    return 0;

} and probability:0.4888888888888889
code:int64_t bdrv_get_block_status_above(BlockDriverState *bs,

                                    BlockDriverState *base,

                                    int64_t sector_num,

                                    int nb_sectors, int *pnum,

                                    BlockDriverState **file)

{

    Coroutine *co;

    BdrvCoGetBlockStatusData data = {

        .bs = bs,

        .base = base,

        .file = file,

        .sector_num = sector_num,

        .nb_sectors = nb_sectors,

        .pnum = pnum,

        .done = false,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_get_block_status_above_co_entry(&data);

    } else {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        co = qemu_coroutine_create(bdrv_get_block_status_above_co_entry);

        qemu_coroutine_enter(co, &data);

        while (!data.done) {

            aio_poll(aio_context, true);

        }

    }

    return data.ret;

}
 and probability:0.0
code:static int add_string_metadata(int count, const char *name,

                               TiffContext *s)

{

    char *value;



    if (bytestream2_get_bytes_left(&s->gb) < count || count < 0)

        return AVERROR_INVALIDDATA;



    value = av_malloc(count + 1);

    if (!value)

        return AVERROR(ENOMEM);



    bytestream2_get_bufferu(&s->gb, value, count);

    value[count] = 0;



    av_dict_set(avpriv_frame_get_metadatap(&s->picture), name, value, AV_DICT_DONT_STRDUP_VAL);

    return 0;

}
 and probability:0.35714285714285715
code:static void pc_q35_init_1_6(QEMUMachineInitArgs *args)

{

    has_pci_info = false;


    pc_q35_init(args);

} and probability:0.0
code:static void dvbsub_parse_clut_segment(AVCodecContext *avctx,

                                        const uint8_t *buf, int buf_size)

{

    DVBSubContext *ctx = avctx->priv_data;



    const uint8_t *buf_end = buf + buf_size;

    int i, clut_id;

    DVBSubCLUT *clut;

    int entry_id, depth , full_range;

    int y, cr, cb, alpha;

    int r, g, b, r_add, g_add, b_add;



    av_dlog(avctx, "DVB clut packet:\n");



    for (i=0; i < buf_size; i++) {

        av_dlog(avctx, "%02x ", buf[i]);

        if (i % 16 == 15)

            av_dlog(avctx, "\n");

    }



    if (i % 16)

        av_dlog(avctx, "\n");



    clut_id = *buf++;

    buf += 1;



    clut = get_clut(ctx, clut_id);



    if (!clut) {

        clut = av_malloc(sizeof(DVBSubCLUT));



        memcpy(clut, &default_clut, sizeof(DVBSubCLUT));



        clut->id = clut_id;



        clut->next = ctx->clut_list;

        ctx->clut_list = clut;

    }



    while (buf + 4 < buf_end) {

        entry_id = *buf++;



        depth = (*buf) & 0xe0;



        if (depth == 0) {

            av_log(avctx, AV_LOG_ERROR, "Invalid clut depth 0x%x!\n", *buf);

            return;

        }



        full_range = (*buf++) & 1;



        if (full_range) {

            y = *buf++;

            cr = *buf++;

            cb = *buf++;

            alpha = *buf++;

        } else {

            y = buf[0] & 0xfc;

            cr = (((buf[0] & 3) << 2) | ((buf[1] >> 6) & 3)) << 4;

            cb = (buf[1] << 2) & 0xf0;

            alpha = (buf[1] << 6) & 0xc0;



            buf += 2;

        }



        if (y == 0)

            alpha = 0xff;



        YUV_TO_RGB1_CCIR(cb, cr);

        YUV_TO_RGB2_CCIR(r, g, b, y);



        av_dlog(avctx, "clut %d := (%d,%d,%d,%d)\n", entry_id, r, g, b, alpha);



        if (depth & 0x80)

            clut->clut4[entry_id] = RGBA(r,g,b,255 - alpha);

        if (depth & 0x40)

            clut->clut16[entry_id] = RGBA(r,g,b,255 - alpha);

        if (depth & 0x20)

            clut->clut256[entry_id] = RGBA(r,g,b,255 - alpha);

    }

}
 and probability:0.45901639344262296
code:static void intra_predict_mad_cow_dc_l0t_8x8_msa(uint8_t *src, int32_t stride)

{

    uint8_t lp_cnt;

    uint32_t src0, src1, src2 = 0;

    uint32_t out0, out1, out2;

    v16u8 src_top;

    v8u16 add;

    v4u32 sum;



    src_top = LD_UB(src - stride);

    add = __msa_hadd_u_h(src_top, src_top);

    sum = __msa_hadd_u_w(add, add);

    src0 = __msa_copy_u_w((v4i32) sum, 0);

    src1 = __msa_copy_u_w((v4i32) sum, 1);



    for (lp_cnt = 0; lp_cnt < 4; lp_cnt++) {

        src2 += src[lp_cnt * stride - 1];

    }

    src2 = (src0 + src2 + 4) >> 3;

    src0 = (src0 + 2) >> 2;

    src1 = (src1 + 2) >> 2;

    out0 = src0 * 0x01010101;

    out1 = src1 * 0x01010101;

    out2 = src2 * 0x01010101;



    for (lp_cnt = 4; lp_cnt--;) {

        SW(out2, src);

        SW(out1, src + 4);

        SW(out0, src + stride * 4);

        SW(out1, src + stride * 4 + 4);

        src += stride;

    }

}
 and probability:0.4666666666666667
code:static int write_streamheader(AVFormatContext *avctx, AVIOContext *bc, AVStream *st, int i){

    NUTContext *nut = avctx->priv_data;

    AVCodecContext *codec = st->codec;

    unsigned codec_tag = av_codec_get_tag(ff_nut_codec_tags, codec->codec_id);



    ff_put_v(bc, i);

    switch(codec->codec_type){

    case AVMEDIA_TYPE_VIDEO: ff_put_v(bc, 0); break;

    case AVMEDIA_TYPE_AUDIO: ff_put_v(bc, 1); break;

    case AVMEDIA_TYPE_SUBTITLE: ff_put_v(bc, 2); break;

    default              : ff_put_v(bc, 3); break;

    }

    ff_put_v(bc, 4);



    if (!codec_tag)

        codec_tag = codec->codec_tag;



    if (codec_tag) {

        avio_wl32(bc, codec_tag);

    } else {

        av_log(avctx, AV_LOG_ERROR, "No codec tag defined for stream %d\n", i);

        return AVERROR(EINVAL);

    }



    ff_put_v(bc, nut->stream[i].time_base - nut->time_base);

    ff_put_v(bc, nut->stream[i].msb_pts_shift);

    ff_put_v(bc, nut->stream[i].max_pts_distance);

    ff_put_v(bc, codec->has_b_frames);

    avio_w8(bc, 0); /* flags: 0x1 - fixed_fps, 0x2 - index_present */



    ff_put_v(bc, codec->extradata_size);

    avio_write(bc, codec->extradata, codec->extradata_size);



    switch(codec->codec_type){

    case AVMEDIA_TYPE_AUDIO:

        ff_put_v(bc, codec->sample_rate);

        ff_put_v(bc, 1);

        ff_put_v(bc, codec->channels);

        break;

    case AVMEDIA_TYPE_VIDEO:

        ff_put_v(bc, codec->width);

        ff_put_v(bc, codec->height);



        if(st->sample_aspect_ratio.num<=0 || st->sample_aspect_ratio.den<=0){

            ff_put_v(bc, 0);

            ff_put_v(bc, 0);

        }else{

            ff_put_v(bc, st->sample_aspect_ratio.num);

            ff_put_v(bc, st->sample_aspect_ratio.den);

        }

        ff_put_v(bc, 0); /* csp type -- unknown */

        break;

    default:

        break;

    }

    return 0;

}
 and probability:0.38
code:SYNTH_FILTER_FUNC(sse2)

SYNTH_FILTER_FUNC(avx)

SYNTH_FILTER_FUNC(fma3)

#endif /* HAVE_YASM */



av_cold void ff_synth_filter_init_x86(SynthFilterContext *s)

{

#if HAVE_YASM

    int cpu_flags = av_get_cpu_flags();



#if ARCH_X86_32

    if (EXTERNAL_SSE(cpu_flags)) {

        s->synth_filter_float = synth_filter_sse;

    }

#endif

    if (EXTERNAL_SSE2(cpu_flags)) {

        s->synth_filter_float = synth_filter_sse2;

    }

    if (EXTERNAL_AVX(cpu_flags)) {

        s->synth_filter_float = synth_filter_avx;

    }

    if (EXTERNAL_FMA3(cpu_flags)) {

        s->synth_filter_float = synth_filter_fma3;

    }

#endif /* HAVE_YASM */

}
 and probability:0.16666666666666666
code:static BlockDriverAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,

        unsigned long int req, void *buf,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    IscsiLun *iscsilun = bs->opaque;

    struct iscsi_context *iscsi = iscsilun->iscsi;

    struct iscsi_data data;

    IscsiAIOCB *acb;



    assert(req == SG_IO);



    acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);



    acb->iscsilun = iscsilun;

    acb->canceled    = 0;

    acb->bh          = NULL;

    acb->status      = -EINPROGRESS;

    acb->buf         = NULL;

    acb->ioh         = buf;



    acb->task = malloc(sizeof(struct scsi_task));

    if (acb->task == NULL) {

        error_report("iSCSI: Failed to allocate task for scsi command. %s",

                     iscsi_get_error(iscsi));

        qemu_aio_release(acb);

        return NULL;

    }

    memset(acb->task, 0, sizeof(struct scsi_task));



    switch (acb->ioh->dxfer_direction) {

    case SG_DXFER_TO_DEV:

        acb->task->xfer_dir = SCSI_XFER_WRITE;

        break;

    case SG_DXFER_FROM_DEV:

        acb->task->xfer_dir = SCSI_XFER_READ;

        break;

    default:

        acb->task->xfer_dir = SCSI_XFER_NONE;

        break;

    }



    acb->task->cdb_size = acb->ioh->cmd_len;

    memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);

    acb->task->expxferlen = acb->ioh->dxfer_len;



    data.size = 0;

    if (acb->task->xfer_dir == SCSI_XFER_WRITE) {

        if (acb->ioh->iovec_count == 0) {

            data.data = acb->ioh->dxferp;

            data.size = acb->ioh->dxfer_len;

        } else {

#if defined(LIBISCSI_FEATURE_IOVECTOR)

            scsi_task_set_iov_out(acb->task,

                                 (struct scsi_iovec *) acb->ioh->dxferp,

                                 acb->ioh->iovec_count);

#else

            struct iovec *iov = (struct iovec *)acb->ioh->dxferp;



            acb->buf = g_malloc(acb->ioh->dxfer_len);

            data.data = acb->buf;

            data.size = iov_to_buf(iov, acb->ioh->iovec_count, 0,

                                   acb->buf, acb->ioh->dxfer_len);

#endif

        }

    }



    if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,

                                 iscsi_aio_ioctl_cb,

                                 (data.size > 0) ? &data : NULL,

                                 acb) != 0) {

        scsi_free_scsi_task(acb->task);

        qemu_aio_release(acb);

        return NULL;

    }



    /* tell libiscsi to read straight into the buffer we got from ioctl */

    if (acb->task->xfer_dir == SCSI_XFER_READ) {

        if (acb->ioh->iovec_count == 0) {

            scsi_task_add_data_in_buffer(acb->task,

                                         acb->ioh->dxfer_len,

                                         acb->ioh->dxferp);

        } else {

#if defined(LIBISCSI_FEATURE_IOVECTOR)

            scsi_task_set_iov_in(acb->task,

                                 (struct scsi_iovec *) acb->ioh->dxferp,

                                 acb->ioh->iovec_count);

#else

            int i;

            for (i = 0; i < acb->ioh->iovec_count; i++) {

                struct iovec *iov = (struct iovec *)acb->ioh->dxferp;



                scsi_task_add_data_in_buffer(acb->task,

                    iov[i].iov_len,

                    iov[i].iov_base);

            }

#endif

        }

    }



    iscsi_set_events(iscsilun);



    return &acb->common;

}
 and probability:0.5111111111111111
code:static void esp_pci_dma_memory_rw(PCIESPState *pci, uint8_t *buf, int len,

                                  DMADirection dir)

{

    dma_addr_t addr;

    DMADirection expected_dir;



    if (pci->dma_regs[DMA_CMD] & DMA_CMD_DIR) {

        expected_dir = DMA_DIRECTION_FROM_DEVICE;

    } else {

        expected_dir = DMA_DIRECTION_TO_DEVICE;

    }



    if (dir != expected_dir) {

        trace_esp_pci_error_invalid_dma_direction();

        return;

    }



    if (pci->dma_regs[DMA_STAT] & DMA_CMD_MDL) {

        qemu_log_mask(LOG_UNIMP, "am53c974: MDL transfer not implemented\n");

    }



    addr = pci->dma_regs[DMA_SPA];

    if (pci->dma_regs[DMA_WBC] < len) {

        len = pci->dma_regs[DMA_WBC];

    }



    pci_dma_rw(PCI_DEVICE(pci), addr, buf, len, dir);



    /* update status registers */

    pci->dma_regs[DMA_WBC] -= len;

    pci->dma_regs[DMA_WAC] += len;



} and probability:0.2692307692307692
code:void qemu_fflush(QEMUFile *f)

{

    ssize_t ret = 0;



    if (!qemu_file_is_writable(f)) {

        return;

    }



    if (f->ops->writev_buffer) {

        if (f->iovcnt > 0) {

            ret = f->ops->writev_buffer(f->opaque, f->iov, f->iovcnt, f->pos);

        }

    } else {

        if (f->buf_index > 0) {

            ret = f->ops->put_buffer(f->opaque, f->buf, f->pos, f->buf_index);

        }

    }

    if (ret >= 0) {

        f->pos += ret;

    }

    f->buf_index = 0;

    f->iovcnt = 0;

    if (ret < 0) {

        qemu_file_set_error(f, ret);

    }

}
 and probability:0.3333333333333333
code:int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)

{

    int64_t offset1;

    int64_t pos;

    int force = whence & AVSEEK_FORCE;

    int buffer_size;

    int short_seek;

    whence &= ~AVSEEK_FORCE;



    if(!s)




    buffer_size = s->buf_end - s->buffer;

    // pos is the absolute position that the beginning of s->buffer corresponds to in the file

    pos = s->pos - (s->write_flag ? 0 : buffer_size);



    if (whence != SEEK_CUR && whence != SEEK_SET)




    if (whence == SEEK_CUR) {

        offset1 = pos + (s->buf_ptr - s->buffer);

        if (offset == 0)

            return offset1;



        offset += offset1;

    }

    if (offset < 0)




    if (s->short_seek_get) {

        short_seek = s->short_seek_get(s->opaque);

        /* fallback to default short seek */

        if (short_seek <= 0)

            short_seek = s->short_seek_threshold;

    } else

        short_seek = s->short_seek_threshold;



    offset1 = offset - pos; // "offset1" is the relative offset from the beginning of s->buffer

    s->buf_ptr_max = FFMAX(s->buf_ptr_max, s->buf_ptr);

    if ((!s->direct || !s->seek) &&

        offset1 >= 0 && offset1 <= (s->write_flag ? s->buf_ptr_max - s->buffer : buffer_size)) {

        /* can do the seek inside the buffer */

        s->buf_ptr = s->buffer + offset1;

    } else if ((!(s->seekable & AVIO_SEEKABLE_NORMAL) ||

               offset1 <= buffer_size + short_seek) &&

               !s->write_flag && offset1 >= 0 &&

               (!s->direct || !s->seek) &&

              (whence != SEEK_END || force)) {

        while(s->pos < offset && !s->eof_reached)

            fill_buffer(s);

        if (s->eof_reached)

            return AVERROR_EOF;

        s->buf_ptr = s->buf_end - (s->pos - offset);

    } else if(!s->write_flag && offset1 < 0 && -offset1 < buffer_size>>1 && s->seek && offset > 0) {

        int64_t res;



        pos -= FFMIN(buffer_size>>1, pos);

        if ((res = s->seek(s->opaque, pos, SEEK_SET)) < 0)

            return res;

        s->buf_end =

        s->buf_ptr = s->buffer;

        s->pos = pos;

        s->eof_reached = 0;

        fill_buffer(s);

        return avio_seek(s, offset, SEEK_SET | force);

    } else {

        int64_t res;

        if (s->write_flag) {

            flush_buffer(s);

        }

        if (!s->seek)

            return AVERROR(EPIPE);

        if ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)

            return res;

        s->seek_count ++;

        if (!s->write_flag)

            s->buf_end = s->buffer;

        s->buf_ptr = s->buf_ptr_max = s->buffer;

        s->pos = offset;

    }

    s->eof_reached = 0;

    return offset;

} and probability:0.5
code:static void coroutine_fn v9fs_rename(void *opaque)

{

    int32_t fid;

    ssize_t err = 0;

    size_t offset = 7;

    V9fsString name;

    int32_t newdirfid;

    V9fsFidState *fidp;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    v9fs_string_init(&name);

    err = pdu_unmarshal(pdu, offset, "dds", &fid, &newdirfid, &name);

    if (err < 0) {

        goto out_nofid;

    }



    if (name_is_illegal(name.data)) {

        err = -ENOENT;

        goto out_nofid;

    }



    if (!strcmp(".", name.data) || !strcmp("..", name.data)) {

        err = -EISDIR;

        goto out_nofid;

    }



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    BUG_ON(fidp->fid_type != P9_FID_NONE);

    /* if fs driver is not path based, return EOPNOTSUPP */

    if (!(pdu->s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT)) {

        err = -EOPNOTSUPP;

        goto out;

    }

    v9fs_path_write_lock(s);

    err = v9fs_complete_rename(pdu, fidp, newdirfid, &name);

    v9fs_path_unlock(s);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, fidp);

out_nofid:

    pdu_complete(pdu, err);

    v9fs_string_free(&name);

}
 and probability:0.06521739130434782
code:AVVDPAUContext *av_vdpau_alloc_context(void)

{

    return av_mallocz(sizeof(AVVDPAUContext));

}
 and probability:0.0
code:static AVBufferRef *pool_alloc_buffer(AVBufferPool *pool)

{

    BufferPoolEntry *buf;

    AVBufferRef     *ret;



    ret = pool->alloc(pool->size);

    if (!ret)

        return NULL;



    buf = av_mallocz(sizeof(*buf));

    if (!buf) {

        av_buffer_unref(&ret);

        return NULL;

    }



    buf->data   = ret->buffer->data;

    buf->opaque = ret->buffer->opaque;

    buf->free   = ret->buffer->free;

    buf->pool   = pool;



    ret->buffer->opaque = buf;

    ret->buffer->free   = pool_release_buffer;



    avpriv_atomic_int_add_and_fetch(&pool->refcount, 1);




    return ret;

} and probability:0.42857142857142855
code:static void compute_frame_duration(int *pnum, int *pden, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        if(st->time_base.num*1000 > st->time_base.den){

            *pnum = st->time_base.num;

            *pden = st->time_base.den;

        }else if(st->codec.time_base.num*1000 > st->codec.time_base.den){

            *pnum = st->codec.time_base.num;

            *pden = st->codec.time_base.den;

            if (pc && pc->repeat_pict) {

                *pden *= 2;

                *pnum = (*pnum) * (2 + pc->repeat_pict);

            }

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
 and probability:0.4838709677419355
code:static int vdi_check(BlockDriverState *bs)

{

    /* TODO: additional checks possible. */

    BDRVVdiState *s = (BDRVVdiState *)bs->opaque;

    int n_errors = 0;

    uint32_t blocks_allocated = 0;

    uint32_t block;

    uint32_t *bmap;

    logout("\n");



    bmap = qemu_malloc(s->header.blocks_in_image * sizeof(uint32_t));

    memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));



    /* Check block map and value of blocks_allocated. */

    for (block = 0; block < s->header.blocks_in_image; block++) {

        uint32_t bmap_entry = le32_to_cpu(s->bmap[block]);

        if (bmap_entry != VDI_UNALLOCATED) {

            if (bmap_entry < s->header.blocks_in_image) {

                blocks_allocated++;

                if (bmap[bmap_entry] == VDI_UNALLOCATED) {

                    bmap[bmap_entry] = bmap_entry;

                } else {

                    fprintf(stderr, "ERROR: block index %" PRIu32

                            " also used by %" PRIu32 "\n", bmap[bmap_entry], bmap_entry);

                }

            } else {

                fprintf(stderr, "ERROR: block index %" PRIu32

                        " too large, is %" PRIu32 "\n", block, bmap_entry);

                n_errors++;

            }

        }

    }

    if (blocks_allocated != s->header.blocks_allocated) {

        fprintf(stderr, "ERROR: allocated blocks mismatch, is %" PRIu32

               ", should be %" PRIu32 "\n",

               blocks_allocated, s->header.blocks_allocated);

        n_errors++;

    }



    qemu_free(bmap);



    return n_errors;

}
 and probability:0.358974358974359
code:static void submit_pdu(V9fsState *s, V9fsPDU *pdu)

{

    pdu_handler_t *handler;



    if (debug_9p_pdu) {

        pprint_pdu(pdu);

    }



    BUG_ON(pdu->id >= ARRAY_SIZE(pdu_handlers));



    handler = pdu_handlers[pdu->id];

    BUG_ON(handler == NULL);



    handler(s, pdu);

}
 and probability:0.18181818181818182
code:uint64_t helper_addqv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 += op2;

    if (unlikely((tmp ^ op2 ^ (-1ULL)) & (tmp ^ op1) & (1ULL << 63))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
 and probability:0.1111111111111111
code:static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,

					     unsigned mode,

					     unsigned offset,

					     uint32_t mem_value)

{

    int x;

    unsigned val = mem_value;

    uint8_t *dst;



    dst = s->vram_ptr + offset;

    for (x = 0; x < 8; x++) {

	if (val & 0x80) {

	    *dst = s->cirrus_shadow_gr1;

	} else if (mode == 5) {

	    *dst = s->cirrus_shadow_gr0;

	}

	val <<= 1;

	dst++;

    }

    cpu_physical_memory_set_dirty(s->vram_offset + offset);

    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);

}
 and probability:0.3333333333333333
code:void translator_loop(const TranslatorOps *ops, DisasContextBase *db,

                     CPUState *cpu, TranslationBlock *tb)

{

    int max_insns;



    /* Initialize DisasContext */

    db->tb = tb;

    db->pc_first = tb->pc;

    db->pc_next = db->pc_first;

    db->is_jmp = DISAS_NEXT;

    db->num_insns = 0;

    db->singlestep_enabled = cpu->singlestep_enabled;



    /* Instruction counting */

    max_insns = db->tb->cflags & CF_COUNT_MASK;

    if (max_insns == 0) {

        max_insns = CF_COUNT_MASK;

    }

    if (max_insns > TCG_MAX_INSNS) {

        max_insns = TCG_MAX_INSNS;

    }

    if (db->singlestep_enabled || singlestep) {

        max_insns = 1;

    }



    max_insns = ops->init_disas_context(db, cpu, max_insns);

    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */



    /* Reset the temp count so that we can identify leaks */

    tcg_clear_temp_count();



    /* Start translating.  */

    gen_tb_start(db->tb);

    ops->tb_start(db, cpu);

    tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */



    while (true) {

        db->num_insns++;

        ops->insn_start(db, cpu);

        tcg_debug_assert(db->is_jmp == DISAS_NEXT);  /* no early exit */



        /* Pass breakpoint hits to target for further processing */

        if (unlikely(!QTAILQ_EMPTY(&cpu->breakpoints))) {

            CPUBreakpoint *bp;

            QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

                if (bp->pc == db->pc_next) {

                    if (ops->breakpoint_check(db, cpu, bp)) {

                        break;

                    }

                }

            }

            /* The breakpoint_check hook may use DISAS_TOO_MANY to indicate

               that only one more instruction is to be executed.  Otherwise

               it should use DISAS_NORETURN when generating an exception,

               but may use a DISAS_TARGET_* value for Something Else.  */

            if (db->is_jmp > DISAS_TOO_MANY) {

                break;

            }

        }



        /* Disassemble one instruction.  The translate_insn hook should

           update db->pc_next and db->is_jmp to indicate what should be

           done next -- either exiting this loop or locate the start of

           the next instruction.  */

        if (db->num_insns == max_insns && (db->tb->cflags & CF_LAST_IO)) {

            /* Accept I/O on the last instruction.  */

            gen_io_start();

            ops->translate_insn(db, cpu);

            gen_io_end();

        } else {

            ops->translate_insn(db, cpu);

        }



        /* Stop translation if translate_insn so indicated.  */

        if (db->is_jmp != DISAS_NEXT) {

            break;

        }



        /* Stop translation if the output buffer is full,

           or we have executed all of the allowed instructions.  */

        if (tcg_op_buf_full() || db->num_insns >= max_insns) {

            db->is_jmp = DISAS_TOO_MANY;

            break;

        }

    }



    /* Emit code to exit the TB, as indicated by db->is_jmp.  */

    ops->tb_stop(db, cpu);

    gen_tb_end(db->tb, db->num_insns);



    /* The disas_log hook may use these values rather than recompute.  */

    db->tb->size = db->pc_next - db->pc_first;

    db->tb->icount = db->num_insns;



#ifdef DEBUG_DISAS

    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)

        && qemu_log_in_addr_range(db->pc_first)) {

        qemu_log_lock();

        qemu_log("----------------\n");

        ops->disas_log(db, cpu);

        qemu_log("\n");

        qemu_log_unlock();

    }

#endif

}
 and probability:0.358695652173913
code:static int load_apply_palette(FFFrameSync *fs)

{

    AVFilterContext *ctx = fs->parent;

    AVFilterLink *inlink = ctx->inputs[0];

    PaletteUseContext *s = ctx->priv;

    AVFrame *master, *second, *out = NULL;

    int ret;



    // writable for error diffusal dithering

    ret = ff_framesync_dualinput_get_writable(fs, &master, &second);

    if (ret < 0)

        return ret;

    if (!master || !second) {

        ret = AVERROR_BUG;

        goto error;

    }

    if (!s->palette_loaded) {

        load_palette(s, second);

    }

    ret = apply_palette(inlink, master, &out);

    if (ret < 0)

        goto error;

    return ff_filter_frame(ctx->outputs[0], out);



error:

    av_frame_free(&master);

    av_frame_free(&second);

    return ret;

}
 and probability:0.18518518518518517
code:void avfilter_uninit(void)

{

    memset(registered_avfilters, 0, sizeof(registered_avfilters));

    next_registered_avfilter_idx = 0;

}
 and probability:0.0
code:int pcm_read_seek(AVFormatContext *s,

                  int stream_index, int64_t timestamp, int flags)

{

    AVStream *st;

    int block_align, byte_rate;

    int64_t pos;



    st = s->streams[0];



    block_align = st->codec->block_align ? st->codec->block_align :

        (av_get_bits_per_sample(st->codec->codec_id) * st->codec->channels) >> 3;

    byte_rate = st->codec->bit_rate ? st->codec->bit_rate >> 3 :

        block_align * st->codec->sample_rate;



    if (block_align <= 0 || byte_rate <= 0)

        return -1;



    /* compute the position by aligning it to block_align */

    pos = av_rescale_rnd(timestamp * byte_rate,

                         st->time_base.num,

                         st->time_base.den * (int64_t)block_align,

                         (flags & AVSEEK_FLAG_BACKWARD) ? AV_ROUND_DOWN : AV_ROUND_UP);

    pos *= block_align;



    /* recompute exact position */

    st->cur_dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num);

    url_fseek(s->pb, pos + s->data_offset, SEEK_SET);

    return 0;

}
 and probability:0.4166666666666667
code:void show_pix_fmts(void)

{

    list_fmts(avcodec_pix_fmt_string, PIX_FMT_NB);

}
 and probability:0.0
code:static int spdif_get_offset_and_codec(AVFormatContext *s,

                                      enum IEC61937DataType data_type,

                                      const char *buf, int *offset,

                                      enum AVCodecID *codec)

{

    AACADTSHeaderInfo aac_hdr;

    GetBitContext gbc;



    switch (data_type & 0xff) {

    case IEC61937_AC3:

        *offset = AC3_FRAME_SIZE << 2;

        *codec = AV_CODEC_ID_AC3;

        break;

    case IEC61937_MPEG1_LAYER1:

        *offset = spdif_mpeg_pkt_offset[1][0];

        *codec = AV_CODEC_ID_MP1;

        break;

    case IEC61937_MPEG1_LAYER23:

        *offset = spdif_mpeg_pkt_offset[1][0];

        *codec = AV_CODEC_ID_MP3;

        break;

    case IEC61937_MPEG2_EXT:

        *offset = 4608;

        *codec = AV_CODEC_ID_MP3;

        break;

    case IEC61937_MPEG2_AAC:

        init_get_bits(&gbc, buf, AAC_ADTS_HEADER_SIZE * 8);

        if (avpriv_aac_parse_header(&gbc, &aac_hdr)) {

            if (s) /* be silent during a probe */

                av_log(s, AV_LOG_ERROR, "Invalid AAC packet in IEC 61937\n");

            return AVERROR_INVALIDDATA;

        }

        *offset = aac_hdr.samples << 2;

        *codec = AV_CODEC_ID_AAC;

        break;

    case IEC61937_MPEG2_LAYER1_LSF:

        *offset = spdif_mpeg_pkt_offset[0][0];

        *codec = AV_CODEC_ID_MP1;

        break;

    case IEC61937_MPEG2_LAYER2_LSF:

        *offset = spdif_mpeg_pkt_offset[0][1];

        *codec = AV_CODEC_ID_MP2;

        break;

    case IEC61937_MPEG2_LAYER3_LSF:

        *offset = spdif_mpeg_pkt_offset[0][2];

        *codec = AV_CODEC_ID_MP3;

        break;

    case IEC61937_DTS1:

        *offset = 2048;

        *codec = AV_CODEC_ID_DTS;

        break;

    case IEC61937_DTS2:

        *offset = 4096;

        *codec = AV_CODEC_ID_DTS;

        break;

    case IEC61937_DTS3:

        *offset = 8192;

        *codec = AV_CODEC_ID_DTS;

        break;

    default:

        if (s) { /* be silent during a probe */

            avpriv_request_sample(s, "Data type 0x%04x in IEC 61937",

                                  data_type);

        }

        return AVERROR_PATCHWELCOME;

    }

    return 0;

}
 and probability:0.34328358208955223
code:static av_cold int seqvideo_decode_init(AVCodecContext *avctx)

{

    SeqVideoContext *seq = avctx->priv_data;



    seq->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_PAL8;



    seq->frame.data[0] = NULL;



    return 0;

}
 and probability:0.5
code:void set_context_opts(void *ctx, void *opts_ctx, int flags, AVCodec *codec)

{

    int i;

    void *priv_ctx=NULL;

    if(!strcmp("AVCodecContext", (*(AVClass**)ctx)->class_name)){

        AVCodecContext *avctx= ctx;

        if(codec && codec->priv_class && avctx->priv_data){

            priv_ctx= avctx->priv_data;

        }

    } else if (!strcmp("AVFormatContext", (*(AVClass**)ctx)->class_name)) {

        AVFormatContext *avctx = ctx;

        if (avctx->oformat && avctx->oformat->priv_class) {

            priv_ctx = avctx->priv_data;

        }

    }



    for(i=0; i<opt_name_count; i++){

        char buf[256];

        const AVOption *opt;

        const char *str= av_get_string(opts_ctx, opt_names[i], &opt, buf, sizeof(buf));

        /* if an option with name opt_names[i] is present in opts_ctx then str is non-NULL */

        if(str && ((opt->flags & flags) == flags))

            av_set_string3(ctx, opt_names[i], str, 1, NULL);

        /* We need to use a differnt system to pass options to the private context because

           it is not known which codec and thus context kind that will be when parsing options

           we thus use opt_values directly instead of opts_ctx */

        if(!str && priv_ctx) {

            if (av_find_opt(priv_ctx, opt_names[i], NULL, flags, flags))

                av_set_string3(priv_ctx, opt_names[i], opt_values[i], 0, NULL);

        }

    }

}
 and probability:0.3870967741935484
code:int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame,

                             int64_t pts, AVRational pixel_aspect)

{

    BufferSourceContext *c = buffer_filter->priv;

    AVFilterBufferRef *buf;

    int ret;



    if (!buf) {

        c->eof = 1;

        return 0;

    } else if (c->eof)

        return AVERROR(EINVAL);



    if (!av_fifo_space(c->fifo) &&

        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +

                                         sizeof(buf))) < 0)

        return ret;



    CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format);



    buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE,

                                    c->w, c->h);

    av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize,

                  c->pix_fmt, c->w, c->h);



    avfilter_copy_frame_props(buf, frame);

    buf->pts                    = pts;

    buf->video->pixel_aspect    = pixel_aspect;



    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {

        avfilter_unref_buffer(buf);

        return ret;

    }



    return 0;

}
 and probability:0.4482758620689655
code:static int decode_byterun(uint8_t *dst, int dst_size,

                          const uint8_t *buf, const uint8_t *const buf_end)

{

    const uint8_t *const buf_start = buf;

    unsigned x;

    for (x = 0; x < dst_size && buf < buf_end;) {

        unsigned length;

        const int8_t value = *buf++;

        if (value >= 0) {

            length = value + 1;

            memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf));

            buf += length;

        } else if (value > -128) {

            length = -value + 1;

            memset(dst + x, *buf++, FFMIN(length, dst_size - x));

        } else { // noop

            continue;

        }

        x += length;

    }

    if (x < dst_size) {

        av_log(NULL, AV_LOG_WARNING, "decode_byterun ended before plane size\n");

        memset(dst+x, 0, dst_size - x);

    }

    return buf - buf_start;

}
 and probability:0.34615384615384615
code:uint64_t blk_mig_bytes_total(void)

{

    BlkMigDevState *bmds;

    uint64_t sum = 0;



    QSIMPLEQ_FOREACH(bmds, &block_mig_state.bmds_list, entry) {

        sum += bmds->total_sectors;

    }

    return sum << BDRV_SECTOR_BITS;

}
 and probability:0.1111111111111111
code:theora_header (AVFormatContext * s, int idx)

{

    struct ogg *ogg = s->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    AVStream *st = s->streams[idx];

    struct theora_params *thp = os->private;

    int cds = st->codec->extradata_size + os->psize + 2;

    uint8_t *cdp;



    if(!(os->buf[os->pstart] & 0x80))

        return 0;



    if(!thp){

        thp = av_mallocz(sizeof(*thp));

        os->private = thp;




    if (os->buf[os->pstart] == 0x80) {

        GetBitContext gb;

        int width, height;



        init_get_bits(&gb, os->buf + os->pstart, os->psize*8);



        skip_bits_long(&gb, 7*8); /* 0x80"theora" */



        thp->version = get_bits_long(&gb, 24);

        if (thp->version < 0x030100)

        {

            av_log(s, AV_LOG_ERROR,

                "Too old or unsupported Theora (%x)\n", thp->version);

            return -1;




        width  = get_bits(&gb, 16) << 4;

        height = get_bits(&gb, 16) << 4;

        avcodec_set_dimensions(st->codec, width, height);



        if (thp->version >= 0x030400)

            skip_bits(&gb, 100);



        if (thp->version >= 0x030200) {

            width  = get_bits_long(&gb, 24);

            height = get_bits_long(&gb, 24);

            if (   width  <= st->codec->width  && width  > st->codec->width-16

                && height <= st->codec->height && height > st->codec->height-16)

                avcodec_set_dimensions(st->codec, width, height);



            skip_bits(&gb, 16);


        st->codec->time_base.den = get_bits_long(&gb, 32);

        st->codec->time_base.num = get_bits_long(&gb, 32);






        st->time_base = st->codec->time_base;



        st->sample_aspect_ratio.num = get_bits_long(&gb, 24);

        st->sample_aspect_ratio.den = get_bits_long(&gb, 24);



        if (thp->version >= 0x030200)

            skip_bits_long(&gb, 38);

        if (thp->version >= 0x304000)

            skip_bits(&gb, 2);



        thp->gpshift = get_bits(&gb, 5);

        thp->gpmask = (1 << thp->gpshift) - 1;



        st->codec->codec_type = CODEC_TYPE_VIDEO;

        st->codec->codec_id = CODEC_ID_THEORA;



    } else if (os->buf[os->pstart] == 0x83) {

        vorbis_comment (s, os->buf + os->pstart + 7, os->psize - 8);




    st->codec->extradata = av_realloc (st->codec->extradata,

                                       cds + FF_INPUT_BUFFER_PADDING_SIZE);

    cdp = st->codec->extradata + st->codec->extradata_size;

    *cdp++ = os->psize >> 8;

    *cdp++ = os->psize & 0xff;

    memcpy (cdp, os->buf + os->pstart, os->psize);

    st->codec->extradata_size = cds;



    return 1;
 and probability:0.6949152542372882
code:static TAPState *net_tap_fd_init(VLANState *vlan,

                                 const char *model,

                                 const char *name,

                                 int fd)

{

    TAPState *s;



    s = qemu_mallocz(sizeof(TAPState));

    s->fd = fd;

    s->vc = qemu_new_vlan_client(vlan, model, name, tap_receive, NULL, s);

    s->vc->fd_readv = tap_receive_iov;

    qemu_set_fd_handler(s->fd, tap_send, NULL, s);

    snprintf(s->vc->info_str, sizeof(s->vc->info_str), "fd=%d", fd);

    return s;

}
 and probability:0.35714285714285715
code:static int write_refcount_block_entries(BlockDriverState *bs,

    int64_t refcount_block_offset, int first_index, int last_index)

{

    BDRVQcowState *s = bs->opaque;

    size_t size;

    int ret;



    if (cache_refcount_updates) {

        return 0;

    }



    if (first_index < 0) {

        return 0;

    }



    first_index &= ~(REFCOUNTS_PER_SECTOR - 1);

    last_index = (last_index + REFCOUNTS_PER_SECTOR)

        & ~(REFCOUNTS_PER_SECTOR - 1);



    size = (last_index - first_index) << REFCOUNT_SHIFT;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_UPDATE_PART);

    ret = bdrv_pwrite(bs->file,

        refcount_block_offset + (first_index << REFCOUNT_SHIFT),

        &s->refcount_block_cache[first_index], size);

    if (ret < 0) {

        return ret;

    }



    return 0;

}
 and probability:0.36
code:static int t15(InterplayACMContext *s, unsigned ind, unsigned col)

{

    GetBitContext *gb = &s->gb;

    unsigned i, b;

    int n1, n2, n3;



    for (i = 0; i < s->rows; i++) {

        /* b = (x1) + (x2 * 3) + (x3 * 9) */

        b = get_bits(gb, 5);







        n1 =  (mul_3x3[b] & 0x0F) - 1;

        n2 = ((mul_3x3[b] >> 4) & 0x0F) - 1;

        n3 = ((mul_3x3[b] >> 8) & 0x0F) - 1;



        set_pos(s, i++, col, n1);

        if (i >= s->rows)

            break;

        set_pos(s, i++, col, n2);

        if (i >= s->rows)

            break;

        set_pos(s, i, col, n3);


    return 0;
 and probability:0.47368421052631576
code:void do_load_6xx_tlb (int is_code)

{

    target_ulong RPN, CMP, EPN;

    int way;

    

    RPN = env->spr[SPR_RPA];

    if (is_code) {

        CMP = env->spr[SPR_ICMP];

        EPN = env->spr[SPR_IMISS];

    } else {

        CMP = env->spr[SPR_DCMP];

        EPN = env->spr[SPR_DMISS];

    }

    way = (env->spr[SPR_SRR1] >> 17) & 1;

#if defined (DEBUG_SOFTWARE_TLB)

    if (loglevel != 0) {

        fprintf(logfile, "%s: EPN %08lx %08lx PTE0 %08lx PTE1 %08lx way %d\n",

                __func__, (unsigned long)T0, (unsigned long)EPN,

                (unsigned long)CMP, (unsigned long)RPN, way);

    }

#endif

    /* Store this TLB */

    ppc6xx_tlb_store(env, T0 & TARGET_PAGE_MASK, way, is_code, CMP, RPN);

}
 and probability:0.2608695652173913
code:void helper_dcbz(CPUPPCState *env, target_ulong addr, uint32_t is_dcbzl)

{

    int dcbz_size = env->dcache_line_size;



#if defined(TARGET_PPC64)

    if (!is_dcbzl &&

        (env->excp_model == POWERPC_EXCP_970) &&

        ((env->spr[SPR_970_HID5] >> 7) & 0x3) == 1) {

        dcbz_size = 32;

    }

#endif



    /* XXX add e500mc support */



    do_dcbz(env, addr, dcbz_size, GETPC());

}
 and probability:0.23076923076923078
code:envlist_create(void)

{

	envlist_t *envlist;



	if ((envlist = malloc(sizeof (*envlist))) == NULL)

		return (NULL);



	QLIST_INIT(&envlist->el_entries);

	envlist->el_count = 0;



	return (envlist);

}
 and probability:0.3333333333333333
code:static void gen_ori(DisasContext *ctx)

{

    target_ulong uimm = UIMM(ctx->opcode);



    if (rS(ctx->opcode) == rA(ctx->opcode) && uimm == 0) {

        /* NOP */

        /* XXX: should handle special NOPs for POWER series */

        return;

    }

    tcg_gen_ori_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rS(ctx->opcode)], uimm);

}
 and probability:0.3
code:static void close(AVCodecParserContext *s)

{

    H264Context *h = s->priv_data;

    ParseContext *pc = &h->s.parse_context;



    av_free(pc->buffer);


} and probability:0.5
code:static void sch_handle_start_func(SubchDev *sch, ORB *orb)

{



    PMCW *p = &sch->curr_status.pmcw;

    SCSW *s = &sch->curr_status.scsw;

    int path;

    int ret;



    /* Path management: In our simple css, we always choose the only path. */

    path = 0x80;



    if (!(s->ctrl & SCSW_ACTL_SUSP)) {



        /* Look at the orb and try to execute the channel program. */

        assert(orb != NULL); /* resume does not pass an orb */

        p->intparm = orb->intparm;

        if (!(orb->lpm & path)) {

            /* Generate a deferred cc 3 condition. */

            s->flags |= SCSW_FLAGS_MASK_CC;

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);

            return;

        }

        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);

        sch->ccw_no_data_cnt = 0;

    } else {

        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);

    }

    sch->last_cmd_valid = false;

    do {

        ret = css_interpret_ccw(sch, sch->channel_prog);

        switch (ret) {

        case -EAGAIN:

            /* ccw chain, continue processing */

            break;

        case 0:

            /* success */

            s->ctrl &= ~SCSW_ACTL_START_PEND;

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |

                    SCSW_STCTL_STATUS_PEND;

            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;

            s->cpa = sch->channel_prog + 8;

            break;

        case -ENOSYS:

            /* unsupported command, generate unit check (command reject) */

            s->ctrl &= ~SCSW_ACTL_START_PEND;

            s->dstat = SCSW_DSTAT_UNIT_CHECK;

            /* Set sense bit 0 in ecw0. */

            sch->sense_data[0] = 0x80;

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |

                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;

            s->cpa = sch->channel_prog + 8;

            break;

        case -EFAULT:

            /* memory problem, generate channel data check */

            s->ctrl &= ~SCSW_ACTL_START_PEND;

            s->cstat = SCSW_CSTAT_DATA_CHECK;

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |

                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;

            s->cpa = sch->channel_prog + 8;

            break;

        case -EBUSY:

            /* subchannel busy, generate deferred cc 1 */

            s->flags &= ~SCSW_FLAGS_MASK_CC;

            s->flags |= (1 << 8);

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;

            break;

        case -EINPROGRESS:

            /* channel program has been suspended */

            s->ctrl &= ~SCSW_ACTL_START_PEND;

            s->ctrl |= SCSW_ACTL_SUSP;

            break;

        default:

            /* error, generate channel program check */

            s->ctrl &= ~SCSW_ACTL_START_PEND;

            s->cstat = SCSW_CSTAT_PROG_CHECK;

            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;

            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |

                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;

            s->cpa = sch->channel_prog + 8;

            break;

        }

    } while (ret == -EAGAIN);



} and probability:0.47619047619047616
code:static int net_vhost_chardev_opts(void *opaque,

                                  const char *name, const char *value,

                                  Error **errp)

{

    VhostUserChardevProps *props = opaque;



    if (strcmp(name, "backend") == 0 && strcmp(value, "socket") == 0) {

        props->is_socket = true;

    } else if (strcmp(name, "path") == 0) {

        props->is_unix = true;

    } else if (strcmp(name, "server") == 0) {

    } else {

        error_setg(errp,

                   "vhost-user does not support a chardev with option %s=%s",

                   name, value);

        return -1;

    }

    return 0;

}
 and probability:0.1111111111111111
code:static int decode_frame(AVCodecContext *avctx,

                        void *data,

                        int *data_size,

                        AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    const uint8_t *buf_end = avpkt->data + avpkt->size;

    int buf_size       = avpkt->size;

    DPXContext *const s = avctx->priv_data;

    AVFrame *picture  = data;

    AVFrame *const p = &s->picture;

    uint8_t *ptr;



    int magic_num, offset, endian;

    int x, y;

    int w, h, stride, bits_per_color, descriptor, elements, target_packet_size, source_packet_size;



    unsigned int rgbBuffer;



    magic_num = AV_RB32(buf);

    buf += 4;



    /* Check if the files "magic number" is "SDPX" which means it uses

     * big-endian or XPDS which is for little-endian files */

    if (magic_num == AV_RL32("SDPX")) {

        endian = 0;

    } else if (magic_num == AV_RB32("SDPX")) {

        endian = 1;

    } else {

        av_log(avctx, AV_LOG_ERROR, "DPX marker not found\n");





    offset = read32(&buf, endian);

    // Need to end in 0x304 offset from start of file

    buf = avpkt->data + 0x304;

    w = read32(&buf, endian);

    h = read32(&buf, endian);



    // Need to end in 0x320 to read the descriptor

    buf += 20;

    descriptor = buf[0];



    // Need to end in 0x323 to read the bits per color

    buf += 3;

    avctx->bits_per_raw_sample =

    bits_per_color = buf[0];



    switch (descriptor) {

        case 51: // RGBA

            elements = 4;

            break;

        case 50: // RGB

            elements = 3;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, "Unsupported descriptor %d\n", descriptor);





    switch (bits_per_color) {

        case 8:

            if (elements == 4) {

                avctx->pix_fmt = PIX_FMT_RGBA;

            } else {

                avctx->pix_fmt = PIX_FMT_RGB24;


            source_packet_size = elements;

            target_packet_size = elements;

            break;

        case 10:

            avctx->pix_fmt = PIX_FMT_RGB48;

            target_packet_size = 6;

            source_packet_size = elements * 2;

            break;

        case 12:

        case 16:

            if (endian) {

                avctx->pix_fmt = PIX_FMT_RGB48BE;

            } else {

                avctx->pix_fmt = PIX_FMT_RGB48LE;


            target_packet_size = 6;

            source_packet_size = elements * 2;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, "Unsupported color depth : %d\n", bits_per_color);





    if (s->picture.data[0])

        avctx->release_buffer(avctx, &s->picture);

    if (av_image_check_size(w, h, 0, avctx))


    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");





    // Move pointer to offset from start of file

    buf =  avpkt->data + offset;



    ptr    = p->data[0];

    stride = p->linesize[0];



    switch (bits_per_color) {

        case 10:

            for (x = 0; x < avctx->height; x++) {

               uint16_t *dst = (uint16_t*)ptr;

               for (y = 0; y < avctx->width; y++) {

                   rgbBuffer = read32(&buf, endian);

                   // Read out the 10-bit colors and convert to 16-bit

                   *dst++ = make_16bit(rgbBuffer >> 16);

                   *dst++ = make_16bit(rgbBuffer >>  6);

                   *dst++ = make_16bit(rgbBuffer <<  4);


               ptr += stride;


            break;

        case 8:

        case 12: // Treat 12-bit as 16-bit

        case 16:





            if (source_packet_size == target_packet_size) {

                for (x = 0; x < avctx->height; x++) {

                    memcpy(ptr, buf, target_packet_size*avctx->width);

                    ptr += stride;

                    buf += source_packet_size*avctx->width;


            } else {

                for (x = 0; x < avctx->height; x++) {

                    uint8_t *dst = ptr;

                    for (y = 0; y < avctx->width; y++) {

                        memcpy(dst, buf, target_packet_size);

                        dst += target_packet_size;

                        buf += source_packet_size;


                    ptr += stride;



            break;




    *picture   = s->picture;

    *data_size = sizeof(AVPicture);



    return buf_size;
 and probability:0.3739130434782609
code:static int mpeg_decode_mb(MpegEncContext *s,

                          DCTELEM block[12][64])

{

    int i, j, k, cbp, val, mb_type, motion_type;

    const int mb_block_count = 4 + (1<< s->chroma_format)



    dprintf("decode_mb: x=%d y=%d\n", s->mb_x, s->mb_y);



    assert(s->mb_skiped==0);



    if (s->mb_skip_run-- != 0) {

        if(s->pict_type == I_TYPE){

            av_log(s->avctx, AV_LOG_ERROR, "skiped MB in I frame at %d %d\n", s->mb_x, s->mb_y);

            return -1;

        }

    

        /* skip mb */

        s->mb_intra = 0;

        for(i=0;i<12;i++)

            s->block_last_index[i] = -1;

        if(s->picture_structure == PICT_FRAME)

            s->mv_type = MV_TYPE_16X16;

        else

            s->mv_type = MV_TYPE_FIELD;

        if (s->pict_type == P_TYPE) {

            /* if P type, zero motion vector is implied */

            s->mv_dir = MV_DIR_FORWARD;

            s->mv[0][0][0] = s->mv[0][0][1] = 0;

            s->last_mv[0][0][0] = s->last_mv[0][0][1] = 0;

            s->last_mv[0][1][0] = s->last_mv[0][1][1] = 0;

            s->field_select[0][0]= s->picture_structure - 1;

            s->mb_skiped = 1;

            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16;

        } else {

            /* if B type, reuse previous vectors and directions */

            s->mv[0][0][0] = s->last_mv[0][0][0];

            s->mv[0][0][1] = s->last_mv[0][0][1];

            s->mv[1][0][0] = s->last_mv[1][0][0];

            s->mv[1][0][1] = s->last_mv[1][0][1];



            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= 

                s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1] | MB_TYPE_SKIP;

//            assert(s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1]&(MB_TYPE_16x16|MB_TYPE_16x8));



            if((s->mv[0][0][0]|s->mv[0][0][1]|s->mv[1][0][0]|s->mv[1][0][1])==0) 

                s->mb_skiped = 1;

        }



        return 0;

    }



    switch(s->pict_type) {

    default:

    case I_TYPE:

        if (get_bits1(&s->gb) == 0) {

            if (get_bits1(&s->gb) == 0){

                av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in I Frame at %d %d\n", s->mb_x, s->mb_y);

                return -1;

            }

            mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA;

        } else {

            mb_type = MB_TYPE_INTRA;

        }

        break;

    case P_TYPE:

        mb_type = get_vlc2(&s->gb, mb_ptype_vlc.table, MB_PTYPE_VLC_BITS, 1);

        if (mb_type < 0){

            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in P Frame at %d %d\n", s->mb_x, s->mb_y);

            return -1;

        }

        mb_type = ptype2mb_type[ mb_type ];

        break;

    case B_TYPE:

        mb_type = get_vlc2(&s->gb, mb_btype_vlc.table, MB_BTYPE_VLC_BITS, 1);

        if (mb_type < 0){

            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in B Frame at %d %d\n", s->mb_x, s->mb_y);

            return -1;

        }

        mb_type = btype2mb_type[ mb_type ];

        break;

    }

    dprintf("mb_type=%x\n", mb_type);

//    motion_type = 0; /* avoid warning */

    if (IS_INTRA(mb_type)) {

        /* compute dct type */

        if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?

            !s->frame_pred_frame_dct) {

            s->interlaced_dct = get_bits1(&s->gb);

        }



        if (IS_QUANT(mb_type))

            s->qscale = get_qscale(s);

        

        if (s->concealment_motion_vectors) {

            /* just parse them */

            if (s->picture_structure != PICT_FRAME) 

                skip_bits1(&s->gb); /* field select */

            

            s->mv[0][0][0]= s->last_mv[0][0][0]= s->last_mv[0][1][0] = 

                mpeg_decode_motion(s, s->mpeg_f_code[0][0], s->last_mv[0][0][0]);

            s->mv[0][0][1]= s->last_mv[0][0][1]= s->last_mv[0][1][1] = 

                mpeg_decode_motion(s, s->mpeg_f_code[0][1], s->last_mv[0][0][1]);



            skip_bits1(&s->gb); /* marker */

        }else

            memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */

        s->mb_intra = 1;

#ifdef HAVE_XVMC

        //one 1 we memcpy blocks in xvmcvideo

        if(s->avctx->xvmc_acceleration > 1){

            XVMC_pack_pblocks(s,-1);//inter are always full blocks

            if(s->swap_uv){

                exchange_uv(s);

            }

        }

#endif



        if (s->codec_id == CODEC_ID_MPEG2VIDEO) {

            for(i=0;i<mb_block_count;i++) {

                if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)

                    return -1;

            }

        } else {

            for(i=0;i<6;i++) {

                if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)

                    return -1;

            }

        }

    } else {

        if (mb_type & MB_TYPE_ZERO_MV){

            assert(mb_type & MB_TYPE_CBP);



            /* compute dct type */

            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?

                !s->frame_pred_frame_dct) {

                s->interlaced_dct = get_bits1(&s->gb);

            }



            if (IS_QUANT(mb_type))

                s->qscale = get_qscale(s);



            s->mv_dir = MV_DIR_FORWARD;

            if(s->picture_structure == PICT_FRAME)

                s->mv_type = MV_TYPE_16X16;

            else{

                s->mv_type = MV_TYPE_FIELD;

                mb_type |= MB_TYPE_INTERLACED;

                s->field_select[0][0]= s->picture_structure - 1;

            }

            s->last_mv[0][0][0] = 0;

            s->last_mv[0][0][1] = 0;

            s->last_mv[0][1][0] = 0;

            s->last_mv[0][1][1] = 0;

            s->mv[0][0][0] = 0;

            s->mv[0][0][1] = 0;

        }else{

            assert(mb_type & MB_TYPE_L0L1);

//FIXME decide if MBs in field pictures are MB_TYPE_INTERLACED

            /* get additionnal motion vector type */

            if (s->frame_pred_frame_dct) 

                motion_type = MT_FRAME;

            else{

                motion_type = get_bits(&s->gb, 2);

            }



            /* compute dct type */

            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?

                !s->frame_pred_frame_dct && HAS_CBP(mb_type)) {

                s->interlaced_dct = get_bits1(&s->gb);

            }



            if (IS_QUANT(mb_type))

                s->qscale = get_qscale(s);



            /* motion vectors */

            s->mv_dir = 0;

            for(i=0;i<2;i++) {

                if (USES_LIST(mb_type, i)) {

                    s->mv_dir |= (MV_DIR_FORWARD >> i);

                    dprintf("motion_type=%d\n", motion_type);

                    switch(motion_type) {

                    case MT_FRAME: /* or MT_16X8 */

                        if (s->picture_structure == PICT_FRAME) {

                            /* MT_FRAME */

                            mb_type |= MB_TYPE_16x16; 

                            s->mv_type = MV_TYPE_16X16;

                            s->mv[i][0][0]= s->last_mv[i][0][0]= s->last_mv[i][1][0] = 

                                mpeg_decode_motion(s, s->mpeg_f_code[i][0], s->last_mv[i][0][0]);

                            s->mv[i][0][1]= s->last_mv[i][0][1]= s->last_mv[i][1][1] = 

                                mpeg_decode_motion(s, s->mpeg_f_code[i][1], s->last_mv[i][0][1]);

                            /* full_pel: only for mpeg1 */

                            if (s->full_pel[i]){

                                s->mv[i][0][0] <<= 1;

                                s->mv[i][0][1] <<= 1;

                            }

                        } else {

                            /* MT_16X8 */

                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED; 

                            s->mv_type = MV_TYPE_16X8;

                            for(j=0;j<2;j++) {

                                s->field_select[i][j] = get_bits1(&s->gb);

                                for(k=0;k<2;k++) {

                                    val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],

                                                             s->last_mv[i][j][k]);

                                    s->last_mv[i][j][k] = val;

                                    s->mv[i][j][k] = val;

                                }

                            }

                        }

                        break;

                    case MT_FIELD:

                        s->mv_type = MV_TYPE_FIELD;

                        if (s->picture_structure == PICT_FRAME) {

                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED; 

                            for(j=0;j<2;j++) {

                                s->field_select[i][j] = get_bits1(&s->gb);

                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][0],

                                                         s->last_mv[i][j][0]);

                                s->last_mv[i][j][0] = val;

                                s->mv[i][j][0] = val;

                                dprintf("fmx=%d\n", val);

                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][1],

                                                         s->last_mv[i][j][1] >> 1);

                                s->last_mv[i][j][1] = val << 1;

                                s->mv[i][j][1] = val;

                                dprintf("fmy=%d\n", val);

                            }

                        } else {

                            mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED; 

                            s->field_select[i][0] = get_bits1(&s->gb);

                            for(k=0;k<2;k++) {

                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],

                                                         s->last_mv[i][0][k]);

                                s->last_mv[i][0][k] = val;

                                s->last_mv[i][1][k] = val;

                                s->mv[i][0][k] = val;

                            }

                        }

                        break;

                    case MT_DMV:

                        {

                            int dmx, dmy, mx, my, m;



                            mx = mpeg_decode_motion(s, s->mpeg_f_code[i][0], 

                                                    s->last_mv[i][0][0]);

                            s->last_mv[i][0][0] = mx;

                            s->last_mv[i][1][0] = mx;

                            dmx = get_dmv(s);

                            my = mpeg_decode_motion(s, s->mpeg_f_code[i][1], 

                                                    s->last_mv[i][0][1] >> 1);

                            dmy = get_dmv(s);

                            s->mv_type = MV_TYPE_DMV;





                            s->last_mv[i][0][1] = my<<1;

                            s->last_mv[i][1][1] = my<<1;



                            s->mv[i][0][0] = mx;

                            s->mv[i][0][1] = my;

                            s->mv[i][1][0] = mx;//not used

                            s->mv[i][1][1] = my;//not used



                            if (s->picture_structure == PICT_FRAME) {

                                mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED; 



                                //m = 1 + 2 * s->top_field_first;

                                m = s->top_field_first ? 1 : 3;



                                /* top -> top pred */

                                s->mv[i][2][0] = ((mx * m + (mx > 0)) >> 1) + dmx;

                                s->mv[i][2][1] = ((my * m + (my > 0)) >> 1) + dmy - 1;

                                m = 4 - m;

                                s->mv[i][3][0] = ((mx * m + (mx > 0)) >> 1) + dmx;

                                s->mv[i][3][1] = ((my * m + (my > 0)) >> 1) + dmy + 1;

                            } else {

                                mb_type |= MB_TYPE_16x16;



                                s->mv[i][2][0] = ((mx + (mx > 0)) >> 1) + dmx;

                                s->mv[i][2][1] = ((my + (my > 0)) >> 1) + dmy;

                                if(s->picture_structure == PICT_TOP_FIELD)

                                    s->mv[i][2][1]--;

                                else 

                                    s->mv[i][2][1]++;

                            }

                        }

                        break;

                    default:

                        av_log(s->avctx, AV_LOG_ERROR, "00 motion_type at %d %d\n", s->mb_x, s->mb_y);

                        return -1;

                    }

                }

            }

        }

        

        s->mb_intra = 0;



        if (HAS_CBP(mb_type)) {

            cbp = get_vlc2(&s->gb, mb_pat_vlc.table, MB_PAT_VLC_BITS, 1);

            if (cbp < 0 || ((cbp == 0) && (s->chroma_format < 2)) ){

                av_log(s->avctx, AV_LOG_ERROR, "invalid cbp at %d %d\n", s->mb_x, s->mb_y);

                return -1;

            }

            if(mb_block_count > 6){

	         cbp<<= mb_block_count-6;

		 cbp |= get_bits(&s->gb, mb_block_count-6);

            }



#ifdef HAVE_XVMC

            //on 1 we memcpy blocks in xvmcvideo

            if(s->avctx->xvmc_acceleration > 1){

                XVMC_pack_pblocks(s,cbp);

                if(s->swap_uv){

                    exchange_uv(s);

                }

            }    

#endif



            if (s->codec_id == CODEC_ID_MPEG2VIDEO) {

                if(s->flags2 & CODEC_FLAG2_FAST){

                    for(i=0;i<6;i++) {

                        if(cbp & 32) {

                            mpeg2_fast_decode_block_non_intra(s, s->pblocks[i], i);

                        } else {

                            s->block_last_index[i] = -1;

                        }

                        cbp+=cbp;

                    }

                }else{

                    cbp<<= 12-mb_block_count;

    

                    for(i=0;i<mb_block_count;i++) {

                        if ( cbp & (1<<11) ) {

                            if (mpeg2_decode_block_non_intra(s, s->pblocks[i], i) < 0)

                                return -1;

                        } else {

                            s->block_last_index[i] = -1;

                        }

                        cbp+=cbp;

                    }

                }

            } else {

                if(s->flags2 & CODEC_FLAG2_FAST){

                    for(i=0;i<6;i++) {

                        if (cbp & 32) {

                            mpeg1_fast_decode_block_inter(s, s->pblocks[i], i);

                        } else {

                            s->block_last_index[i] = -1;

                        }

                        cbp+=cbp;

                    }

                }else{

                    for(i=0;i<6;i++) {

                        if (cbp & 32) {

                            if (mpeg1_decode_block_inter(s, s->pblocks[i], i) < 0)

                                return -1;

                        } else {

                            s->block_last_index[i] = -1;

                        }

                        cbp+=cbp;

                    }

                }

            }

        }else{

            for(i=0;i<6;i++)

                s->block_last_index[i] = -1;

        }

    }



    s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= mb_type;



    return 0;

}
 and probability:0.5207100591715976
code:void op_subo (void)

{

    target_ulong tmp;



    tmp = T0;

    T0 = (int32_t)T0 - (int32_t)T1;

    if (!((T0 >> 31) ^ (T1 >> 31) ^ (tmp >> 31))) {

        CALL_FROM_TB1(do_raise_exception_direct, EXCP_OVERFLOW);

    }

    RETURN();

}
 and probability:0.1
code:int get_physical_address (CPUState *env, mmu_ctx_t *ctx, target_ulong eaddr,

                          int rw, int access_type, int check_BATs)

{

    int ret;

#if 0

    if (loglevel != 0) {

        fprintf(logfile, "%s\n", __func__);

    }

#endif

    if ((access_type == ACCESS_CODE && msr_ir == 0) ||

        (access_type != ACCESS_CODE && msr_dr == 0)) {

        /* No address translation */

        ret = check_physical(env, ctx, eaddr, rw);

    } else {

        ret = -1;

        switch (env->mmu_model) {

        case POWERPC_MMU_32B:

        case POWERPC_MMU_SOFT_6xx:

        case POWERPC_MMU_SOFT_74xx:

            /* Try to find a BAT */

            if (check_BATs)

                ret = get_bat(env, ctx, eaddr, rw, access_type);

            /* No break here */

#if defined(TARGET_PPC64)

        case POWERPC_MMU_64B:

        case POWERPC_MMU_64BRIDGE:

#endif

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment(env, ctx, eaddr, rw, access_type);

            }

            break;

        case POWERPC_MMU_SOFT_4xx:

        case POWERPC_MMU_SOFT_4xx_Z:

            ret = mmu40x_get_physical_address(env, ctx, eaddr,

                                              rw, access_type);

            break;

        case POWERPC_MMU_601:

            /* XXX: TODO */

            cpu_abort(env, "601 MMU model not implemented\n");

            return -1;

        case POWERPC_MMU_BOOKE:

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

            break;

        case POWERPC_MMU_BOOKE_FSL:

            /* XXX: TODO */

            cpu_abort(env, "BookE FSL MMU model not implemented\n");

            return -1;

        case POWERPC_MMU_REAL_4xx:

            cpu_abort(env, "PowerPC 401 does not do any translation\n");

            return -1;

        default:

            cpu_abort(env, "Unknown or invalid MMU model\n");

            return -1;

        }

    }

#if 0

    if (loglevel != 0) {

        fprintf(logfile, "%s address " ADDRX " => %d " PADDRX "\n",

                __func__, eaddr, ret, ctx->raddr);

    }

#endif



    return ret;

}
 and probability:0.03076923076923077
code:uint32_t HELPER(neon_min_f32)(uint32_t a, uint32_t b)

{

    float32 f0 = make_float32(a);

    float32 f1 = make_float32(b);

    return (float32_compare_quiet(f0, f1, NFS) == -1) ? a : b;

}
 and probability:0.0
code:static void test_primitive_lists(gconstpointer opaque)

{

    TestArgs *args = (TestArgs *) opaque;

    const SerializeOps *ops = args->ops;

    PrimitiveType *pt = args->test_data;

    PrimitiveList pl = { .value = { NULL } };

    PrimitiveList pl_copy = { .value = { NULL } };

    PrimitiveList *pl_copy_ptr = &pl_copy;

    Error *err = NULL;

    void *serialize_data;

    void *cur_head = NULL;

    int i;



    pl.type = pl_copy.type = pt->type;



    /* build up our list of primitive types */

    for (i = 0; i < 32; i++) {

        switch (pl.type) {

        case PTYPE_STRING: {

            strList *tmp = g_new0(strList, 1);

            tmp->value = g_strdup(pt->value.string);

            if (pl.value.strings == NULL) {

                pl.value.strings = tmp;

            } else {

                tmp->next = pl.value.strings;

                pl.value.strings = tmp;

            }

            break;

        }

        case PTYPE_INTEGER: {

            intList *tmp = g_new0(intList, 1);

            tmp->value = pt->value.integer;

            if (pl.value.integers == NULL) {

                pl.value.integers = tmp;

            } else {

                tmp->next = pl.value.integers;

                pl.value.integers = tmp;

            }

            break;

        }

        case PTYPE_S8: {

            int8List *tmp = g_new0(int8List, 1);

            tmp->value = pt->value.s8;

            if (pl.value.s8_integers == NULL) {

                pl.value.s8_integers = tmp;

            } else {

                tmp->next = pl.value.s8_integers;

                pl.value.s8_integers = tmp;

            }

            break;

        }

        case PTYPE_S16: {

            int16List *tmp = g_new0(int16List, 1);

            tmp->value = pt->value.s16;

            if (pl.value.s16_integers == NULL) {

                pl.value.s16_integers = tmp;

            } else {

                tmp->next = pl.value.s16_integers;

                pl.value.s16_integers = tmp;

            }

            break;

        }

        case PTYPE_S32: {

            int32List *tmp = g_new0(int32List, 1);

            tmp->value = pt->value.s32;

            if (pl.value.s32_integers == NULL) {

                pl.value.s32_integers = tmp;

            } else {

                tmp->next = pl.value.s32_integers;

                pl.value.s32_integers = tmp;

            }

            break;

        }

        case PTYPE_S64: {

            int64List *tmp = g_new0(int64List, 1);

            tmp->value = pt->value.s64;

            if (pl.value.s64_integers == NULL) {

                pl.value.s64_integers = tmp;

            } else {

                tmp->next = pl.value.s64_integers;

                pl.value.s64_integers = tmp;

            }

            break;

        }

        case PTYPE_U8: {

            uint8List *tmp = g_new0(uint8List, 1);

            tmp->value = pt->value.u8;

            if (pl.value.u8_integers == NULL) {

                pl.value.u8_integers = tmp;

            } else {

                tmp->next = pl.value.u8_integers;

                pl.value.u8_integers = tmp;

            }

            break;

        }

        case PTYPE_U16: {

            uint16List *tmp = g_new0(uint16List, 1);

            tmp->value = pt->value.u16;

            if (pl.value.u16_integers == NULL) {

                pl.value.u16_integers = tmp;

            } else {

                tmp->next = pl.value.u16_integers;

                pl.value.u16_integers = tmp;

            }

            break;

        }

        case PTYPE_U32: {

            uint32List *tmp = g_new0(uint32List, 1);

            tmp->value = pt->value.u32;

            if (pl.value.u32_integers == NULL) {

                pl.value.u32_integers = tmp;

            } else {

                tmp->next = pl.value.u32_integers;

                pl.value.u32_integers = tmp;

            }

            break;

        }

        case PTYPE_U64: {

            uint64List *tmp = g_new0(uint64List, 1);

            tmp->value = pt->value.u64;

            if (pl.value.u64_integers == NULL) {

                pl.value.u64_integers = tmp;

            } else {

                tmp->next = pl.value.u64_integers;

                pl.value.u64_integers = tmp;

            }

            break;

        }

        case PTYPE_NUMBER: {

            numberList *tmp = g_new0(numberList, 1);

            tmp->value = pt->value.number;

            if (pl.value.numbers == NULL) {

                pl.value.numbers = tmp;

            } else {

                tmp->next = pl.value.numbers;

                pl.value.numbers = tmp;

            }

            break;

        }

        case PTYPE_BOOLEAN: {

            boolList *tmp = g_new0(boolList, 1);

            tmp->value = pt->value.boolean;

            if (pl.value.booleans == NULL) {

                pl.value.booleans = tmp;

            } else {

                tmp->next = pl.value.booleans;

                pl.value.booleans = tmp;

            }

            break;

        }

        default:

            g_assert_not_reached();

        }

    }



    ops->serialize((void **)&pl, &serialize_data, visit_primitive_list, &err);

    ops->deserialize((void **)&pl_copy_ptr, serialize_data, visit_primitive_list, &err);



    g_assert(err == NULL);

    i = 0;



    /* compare our deserialized list of primitives to the original */

    do {

        switch (pl_copy.type) {

        case PTYPE_STRING: {

            strList *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.strings;

            }

            g_assert_cmpstr(pt->value.string, ==, ptr->value);

            break;

        }

        case PTYPE_INTEGER: {

            intList *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.integers;

            }

            g_assert_cmpint(pt->value.integer, ==, ptr->value);

            break;

        }

        case PTYPE_S8: {

            int8List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.s8_integers;

            }

            g_assert_cmpint(pt->value.s8, ==, ptr->value);

            break;

        }

        case PTYPE_S16: {

            int16List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.s16_integers;

            }

            g_assert_cmpint(pt->value.s16, ==, ptr->value);

            break;

        }

        case PTYPE_S32: {

            int32List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.s32_integers;

            }

            g_assert_cmpint(pt->value.s32, ==, ptr->value);

            break;

        }

        case PTYPE_S64: {

            int64List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.s64_integers;

            }

            g_assert_cmpint(pt->value.s64, ==, ptr->value);

            break;

        }

        case PTYPE_U8: {

            uint8List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.u8_integers;

            }

            g_assert_cmpint(pt->value.u8, ==, ptr->value);

            break;

        }

        case PTYPE_U16: {

            uint16List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.u16_integers;

            }

            g_assert_cmpint(pt->value.u16, ==, ptr->value);

            break;

        }

        case PTYPE_U32: {

            uint32List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.u32_integers;

            }

            g_assert_cmpint(pt->value.u32, ==, ptr->value);

            break;

        }

        case PTYPE_U64: {

            uint64List *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.u64_integers;

            }

            g_assert_cmpint(pt->value.u64, ==, ptr->value);

            break;

        }

        case PTYPE_NUMBER: {

            numberList *ptr;

            GString *double_expected = g_string_new("");

            GString *double_actual = g_string_new("");

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.numbers;

            }

            /* we serialize with %f for our reference visitors, so rather than

             * fuzzy floating math to test "equality", just compare the

             * formatted values

             */

            g_string_printf(double_expected, "%.6f", pt->value.number);

            g_string_printf(double_actual, "%.6f", ptr->value);

            g_assert_cmpstr(double_actual->str, ==, double_expected->str);

            g_string_free(double_expected, true);

            g_string_free(double_actual, true);

            break;

        }

        case PTYPE_BOOLEAN: {

            boolList *ptr;

            if (cur_head) {

                ptr = cur_head;

                cur_head = ptr->next;

            } else {

                cur_head = ptr = pl_copy.value.booleans;

            }

            g_assert_cmpint(!!pt->value.boolean, ==, !!ptr->value);

            break;

        }

        default:

            g_assert_not_reached();

        }

        i++;

    } while (cur_head);



    g_assert_cmpint(i, ==, 33);



    ops->cleanup(serialize_data);

    dealloc_helper(&pl, visit_primitive_list, &err);

    g_assert(!err);

    dealloc_helper(&pl_copy, visit_primitive_list, &err);

    g_assert(!err);

    g_free(args);

}
 and probability:0.18471337579617833
code:static struct omap_pwl_s *omap_pwl_init(MemoryRegion *system_memory,

                                        target_phys_addr_t base,

                                        omap_clk clk)

{

    struct omap_pwl_s *s = g_malloc0(sizeof(*s));



    omap_pwl_reset(s);



    memory_region_init_io(&s->iomem, &omap_pwl_ops, s,

                          "omap-pwl", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    omap_clk_adduser(clk, qemu_allocate_irqs(omap_pwl_clk_update, s, 1)[0]);

    return s;

}
 and probability:0.3333333333333333
code:static void gem_transmit(GemState *s)

{

    unsigned    desc[2];

    target_phys_addr_t packet_desc_addr;

    uint8_t     tx_packet[2048];

    uint8_t     *p;

    unsigned    total_bytes;



    /* Do nothing if transmit is not enabled. */

    if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {

        return;

    }



    DB_PRINT("\n");



    /* The packet we will hand off to qemu.

     * Packets scattered across multiple descriptors are gathered to this

     * one contiguous buffer first.

     */

    p = tx_packet;

    total_bytes = 0;



    /* read current descriptor */

    packet_desc_addr = s->tx_desc_addr;

    cpu_physical_memory_read(packet_desc_addr,

                             (uint8_t *)&desc[0], sizeof(desc));

    /* Handle all descriptors owned by hardware */

    while (tx_desc_get_used(desc) == 0) {



        /* Do nothing if transmit is not enabled. */

        if (!(s->regs[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {

            return;

        }

        print_gem_tx_desc(desc);



        /* The real hardware would eat this (and possibly crash).

         * For QEMU let's lend a helping hand.

         */

        if ((tx_desc_get_buffer(desc) == 0) ||

            (tx_desc_get_length(desc) == 0)) {

            DB_PRINT("Invalid TX descriptor @ 0x%x\n", packet_desc_addr);

            break;

        }



        /* Gather this fragment of the packet from "dma memory" to our contig.

         * buffer.

         */

        cpu_physical_memory_read(tx_desc_get_buffer(desc), p,

                                 tx_desc_get_length(desc));

        p += tx_desc_get_length(desc);

        total_bytes += tx_desc_get_length(desc);



        /* Last descriptor for this packet; hand the whole thing off */

        if (tx_desc_get_last(desc)) {

            /* Modify the 1st descriptor of this packet to be owned by

             * the processor.

             */

            cpu_physical_memory_read(s->tx_desc_addr,

                                     (uint8_t *)&desc[0], sizeof(desc));

            tx_desc_set_used(desc);

            cpu_physical_memory_write(s->tx_desc_addr,

                                      (uint8_t *)&desc[0], sizeof(desc));

            /* Advance the hardare current descriptor past this packet */

            if (tx_desc_get_wrap(desc)) {

                s->tx_desc_addr = s->regs[GEM_TXQBASE];

            } else {

                s->tx_desc_addr = packet_desc_addr + 8;

            }

            DB_PRINT("TX descriptor next: 0x%08x\n", s->tx_desc_addr);



            s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;



            /* Handle interrupt consequences */

            gem_update_int_status(s);



            /* Is checksum offload enabled? */

            if (s->regs[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {

                net_checksum_calculate(tx_packet, total_bytes);

            }



            /* Update MAC statistics */

            gem_transmit_updatestats(s, tx_packet, total_bytes);



            /* Send the packet somewhere */

            if (s->phy_loop) {

                gem_receive(&s->nic->nc, tx_packet, total_bytes);

            } else {

                qemu_send_packet(&s->nic->nc, tx_packet, total_bytes);

            }



            /* Prepare for next packet */

            p = tx_packet;

            total_bytes = 0;

        }



        /* read next descriptor */

        if (tx_desc_get_wrap(desc)) {

            packet_desc_addr = s->regs[GEM_TXQBASE];

        } else {

            packet_desc_addr += 8;

        }

        cpu_physical_memory_read(packet_desc_addr,

                                 (uint8_t *)&desc[0], sizeof(desc));

    }



    if (tx_desc_get_used(desc)) {

        s->regs[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;

        gem_update_int_status(s);

    }

}
 and probability:0.23404255319148937
code:static void rx_init_frame(eTSEC *etsec, const uint8_t *buf, size_t size)

{

    uint32_t fcb_size = 0;

    uint8_t  prsdep   = (etsec->regs[RCTRL].value >> RCTRL_PRSDEP_OFFSET)

        & RCTRL_PRSDEP_MASK;



    if (prsdep != 0) {

        /* Prepend FCB (FCB size + RCTRL[PAL]) */

        fcb_size = 8 + ((etsec->regs[RCTRL].value >> 16) & 0x1F);



        etsec->rx_fcb_size = fcb_size;



        /* TODO: fill_FCB(etsec); */

        memset(etsec->rx_fcb, 0x0, sizeof(etsec->rx_fcb));



    } else {

        etsec->rx_fcb_size = 0;

    }



    if (etsec->rx_buffer != NULL) {

        g_free(etsec->rx_buffer);

    }



    /* Do not copy the frame for now */

    etsec->rx_buffer     = (uint8_t *)buf;

    etsec->rx_buffer_len = size;



    /* CRC padding (We don't have to compute the CRC) */

    etsec->rx_padding = 4;



    etsec->rx_first_in_frame = 1;

    etsec->rx_remaining_data = etsec->rx_buffer_len;

    RING_DEBUG("%s: rx_buffer_len:%u rx_padding+crc:%u\n", __func__,

               etsec->rx_buffer_len, etsec->rx_padding);

}
 and probability:0.48148148148148145
code:static uint32_t qpci_spapr_io_readl(QPCIBus *bus, void *addr)

{

    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);

    uint64_t port = (uintptr_t)addr;

    uint32_t v;

    if (port < s->pio.size) {

        v = readl(s->pio_cpu_base + port);

    } else {

        v = readl(s->mmio_cpu_base + port);

    }

    return bswap32(v);

}
 and probability:0.25
code:void cpu_io_recompile(CPUState *cpu, uintptr_t retaddr)

{

#if defined(TARGET_MIPS) || defined(TARGET_SH4)

    CPUArchState *env = cpu->env_ptr;

#endif

    TranslationBlock *tb;

    uint32_t n, cflags;

    target_ulong pc, cs_base;

    uint32_t flags;



    tb_lock();

    tb = tb_find_pc(retaddr);

    if (!tb) {

        cpu_abort(cpu, "cpu_io_recompile: could not find TB for pc=%p",

                  (void *)retaddr);

    }

    n = cpu->icount_decr.u16.low + tb->icount;

    cpu_restore_state_from_tb(cpu, tb, retaddr);

    /* Calculate how many instructions had been executed before the fault

       occurred.  */

    n = n - cpu->icount_decr.u16.low;

    /* Generate a new TB ending on the I/O insn.  */

    n++;

    /* On MIPS and SH, delay slot instructions can only be restarted if

       they were already the first instruction in the TB.  If this is not

       the first instruction in a TB then re-execute the preceding

       branch.  */

#if defined(TARGET_MIPS)

    if ((env->hflags & MIPS_HFLAG_BMASK) != 0 && n > 1) {

        env->active_tc.PC -= (env->hflags & MIPS_HFLAG_B16 ? 2 : 4);

        cpu->icount_decr.u16.low++;

        env->hflags &= ~MIPS_HFLAG_BMASK;

    }

#elif defined(TARGET_SH4)

    if ((env->flags & ((DELAY_SLOT | DELAY_SLOT_CONDITIONAL))) != 0

            && n > 1) {

        env->pc -= 2;

        cpu->icount_decr.u16.low++;

        env->flags &= ~(DELAY_SLOT | DELAY_SLOT_CONDITIONAL);

    }

#endif

    /* This should never happen.  */

    if (n > CF_COUNT_MASK) {

        cpu_abort(cpu, "TB too big during recompile");

    }



    cflags = n | CF_LAST_IO;

    cflags |= curr_cflags();

    pc = tb->pc;

    cs_base = tb->cs_base;

    flags = tb->flags;

    tb_phys_invalidate(tb, -1);

    if (tb->cflags & CF_NOCACHE) {

        if (tb->orig_tb) {

            /* Invalidate original TB if this TB was generated in

             * cpu_exec_nocache() */

            tb_phys_invalidate(tb->orig_tb, -1);

        }

        tb_free(tb);

    }

    /* FIXME: In theory this could raise an exception.  In practice

       we have already translated the block once so it's probably ok.  */

    tb_gen_code(cpu, pc, cs_base, flags, cflags);



    /* TODO: If env->pc != tb->pc (i.e. the faulting instruction was not

     * the first in the TB) then we end up generating a whole new TB and

     *  repeating the fault, which is horribly inefficient.

     *  Better would be to execute just this insn uncached, or generate a

     *  second new TB.

     *

     * cpu_loop_exit_noexc will longjmp back to cpu_exec where the

     * tb_lock gets reset.

     */

    cpu_loop_exit_noexc(cpu);

}
 and probability:0.25
code:START_TEST(unterminated_array)

{

    QObject *obj = qobject_from_json("[32");

    fail_unless(obj == NULL);

}
 and probability:0.0
code:static void imx_fec_reset(DeviceState *d)

{

    IMXFECState *s = IMX_FEC(d);



    /* Reset the FEC */

    s->eir = 0;

    s->eimr = 0;

    s->rx_enabled = 0;

    s->ecr = 0;

    s->mscr = 0;

    s->mibc = 0xc0000000;

    s->rcr = 0x05ee0001;

    s->tcr = 0;

    s->tfwr = 0;

    s->frsr = 0x500;

    s->miigsk_cfgr = 0;

    s->miigsk_enr = 0x6;



    /* We also reset the PHY */

    phy_reset(s);

}
 and probability:0.631578947368421
code:struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irq(omap_mmc_cover_cb, s, 0);

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
 and probability:0.4583333333333333
code:int vmstate_register(int instance_id, const VMStateDescription *vmsd,

                     void *opaque)

{

    SaveStateEntry *se;



    se = qemu_malloc(sizeof(SaveStateEntry));

    pstrcpy(se->idstr, sizeof(se->idstr), vmsd->name);

    se->version_id = vmsd->version_id;

    se->section_id = global_section_id++;

    se->save_live_state = NULL;

    se->save_state = NULL;

    se->load_state = NULL;

    se->opaque = opaque;

    se->vmsd = vmsd;



    if (instance_id == -1) {

        se->instance_id = calculate_new_instance_id(vmsd->name);

    } else {

        se->instance_id = instance_id;

    }

    /* add at the end of list */

    TAILQ_INSERT_TAIL(&savevm_handlers, se, entry);

    return 0;

}
 and probability:0.45454545454545453
code:bool qemu_clock_expired(QEMUClockType type)

{

    return timerlist_expired(

        main_loop_tlg.tl[type]);

}
 and probability:0.2
code:static int proxy_opendir(FsContext *ctx,

                         V9fsPath *fs_path, V9fsFidOpenState *fs)

{

    int serrno, fd;



    fs->dir = NULL;

    fd = v9fs_request(ctx->private, T_OPEN, NULL, "sd", fs_path, O_DIRECTORY);

    if (fd < 0) {

        errno = -fd;

        return -1;

    }

    fs->dir = fdopendir(fd);

    if (!fs->dir) {

        serrno = errno;

        close(fd);

        errno = serrno;

        return -1;

    }

    return 0;

}
 and probability:0.21052631578947367
code:static sd_rsp_type_t sd_normal_command(SDState *sd,

                                       SDRequest req)

{

    uint32_t rca = 0x0000;

    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;



    /* Not interpreting this as an app command */

    sd->card_status &= ~APP_CMD;



    if (sd_cmd_type[req.cmd] == sd_ac || sd_cmd_type[req.cmd] == sd_adtc)

        rca = req.arg >> 16;



    DPRINTF("CMD%d 0x%08x state %d\n", req.cmd, req.arg, sd->state);

    switch (req.cmd) {

    /* Basic commands (Class 0 and Class 1) */

    case 0:	/* CMD0:   GO_IDLE_STATE */

        switch (sd->state) {

        case sd_inactive_state:

            return sd->spi ? sd_r1 : sd_r0;



        default:

            sd->state = sd_idle_state;

            sd_reset(sd, sd->bdrv);

            return sd->spi ? sd_r1 : sd_r0;

        }

        break;



    case 1:	/* CMD1:   SEND_OP_CMD */

        if (!sd->spi)

            goto bad_cmd;



        sd->state = sd_transfer_state;

        return sd_r1;



    case 2:	/* CMD2:   ALL_SEND_CID */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_ready_state:

            sd->state = sd_identification_state;

            return sd_r2_i;



        default:

            break;

        }

        break;



    case 3:	/* CMD3:   SEND_RELATIVE_ADDR */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_identification_state:

        case sd_standby_state:

            sd->state = sd_standby_state;

            sd_set_rca(sd);

            return sd_r6;



        default:

            break;

        }

        break;



    case 4:	/* CMD4:   SEND_DSR */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_standby_state:

            break;



        default:

            break;

        }

        break;



    case 5: /* CMD5: reserved for SDIO cards */

        return sd_illegal;



    case 6:	/* CMD6:   SWITCH_FUNCTION */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->mode) {

        case sd_data_transfer_mode:

            sd_function_switch(sd, req.arg);

            sd->state = sd_sendingdata_state;

            sd->data_start = 0;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    case 7:	/* CMD7:   SELECT/DESELECT_CARD */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_standby_state:

            if (sd->rca != rca)

                return sd_r0;



            sd->state = sd_transfer_state;

            return sd_r1b;



        case sd_transfer_state:

        case sd_sendingdata_state:

            if (sd->rca == rca)

                break;



            sd->state = sd_standby_state;

            return sd_r1b;



        case sd_disconnect_state:

            if (sd->rca != rca)

                return sd_r0;



            sd->state = sd_programming_state;

            return sd_r1b;



        case sd_programming_state:

            if (sd->rca == rca)

                break;



            sd->state = sd_disconnect_state;

            return sd_r1b;



        default:

            break;

        }

        break;



    case 8:	/* CMD8:   SEND_IF_COND */

        /* Physical Layer Specification Version 2.00 command */

        switch (sd->state) {

        case sd_idle_state:

            sd->vhs = 0;



            /* No response if not exactly one VHS bit is set.  */

            if (!(req.arg >> 8) || (req.arg >> ffs(req.arg & ~0xff)))

                return sd->spi ? sd_r7 : sd_r0;



            /* Accept.  */

            sd->vhs = req.arg;

            return sd_r7;



        default:

            break;

        }

        break;



    case 9:	/* CMD9:   SEND_CSD */

        switch (sd->state) {

        case sd_standby_state:

            if (sd->rca != rca)

                return sd_r0;



            return sd_r2_s;



        case sd_transfer_state:

            if (!sd->spi)

                break;

            sd->state = sd_sendingdata_state;

            memcpy(sd->data, sd->csd, 16);

            sd->data_start = addr;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    case 10:	/* CMD10:  SEND_CID */

        switch (sd->state) {

        case sd_standby_state:

            if (sd->rca != rca)

                return sd_r0;



            return sd_r2_i;



        case sd_transfer_state:

            if (!sd->spi)

                break;

            sd->state = sd_sendingdata_state;

            memcpy(sd->data, sd->cid, 16);

            sd->data_start = addr;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    case 11:	/* CMD11:  READ_DAT_UNTIL_STOP */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_sendingdata_state;

            sd->data_start = req.arg;

            sd->data_offset = 0;



            if (sd->data_start + sd->blk_len > sd->size)

                sd->card_status |= ADDRESS_ERROR;

            return sd_r0;



        default:

            break;

        }

        break;



    case 12:	/* CMD12:  STOP_TRANSMISSION */

        switch (sd->state) {

        case sd_sendingdata_state:

            sd->state = sd_transfer_state;

            return sd_r1b;



        case sd_receivingdata_state:

            sd->state = sd_programming_state;

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

            return sd_r1b;



        default:

            break;

        }

        break;



    case 13:	/* CMD13:  SEND_STATUS */

        switch (sd->mode) {

        case sd_data_transfer_mode:

            if (sd->rca != rca)

                return sd_r0;



            return sd_r1;



        default:

            break;

        }

        break;



    case 15:	/* CMD15:  GO_INACTIVE_STATE */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->mode) {

        case sd_data_transfer_mode:

            if (sd->rca != rca)

                return sd_r0;



            sd->state = sd_inactive_state;

            return sd_r0;



        default:

            break;

        }

        break;



    /* Block read commands (Classs 2) */

    case 16:	/* CMD16:  SET_BLOCKLEN */

        switch (sd->state) {

        case sd_transfer_state:

            if (req.arg > (1 << HWBLOCK_SHIFT))

                sd->card_status |= BLOCK_LEN_ERROR;

            else

                sd->blk_len = req.arg;



            return sd_r1;



        default:

            break;

        }

        break;



    case 17:	/* CMD17:  READ_SINGLE_BLOCK */

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_sendingdata_state;

            sd->data_start = addr;

            sd->data_offset = 0;



            if (sd->data_start + sd->blk_len > sd->size)

                sd->card_status |= ADDRESS_ERROR;

            return sd_r1;



        default:

            break;

        }

        break;



    case 18:	/* CMD18:  READ_MULTIPLE_BLOCK */

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_sendingdata_state;

            sd->data_start = addr;

            sd->data_offset = 0;



            if (sd->data_start + sd->blk_len > sd->size)

                sd->card_status |= ADDRESS_ERROR;

            return sd_r1;



        default:

            break;

        }

        break;



    /* Block write commands (Class 4) */

    case 24:	/* CMD24:  WRITE_SINGLE_BLOCK */

        if (sd->spi)

            goto unimplemented_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            /* Writing in SPI mode not implemented.  */

            if (sd->spi)

                break;

            sd->state = sd_receivingdata_state;

            sd->data_start = addr;

            sd->data_offset = 0;

            sd->blk_written = 0;



            if (sd->data_start + sd->blk_len > sd->size)

                sd->card_status |= ADDRESS_ERROR;

            if (sd_wp_addr(sd, sd->data_start))

                sd->card_status |= WP_VIOLATION;

            if (sd->csd[14] & 0x30)

                sd->card_status |= WP_VIOLATION;

            return sd_r1;



        default:

            break;

        }

        break;



    case 25:	/* CMD25:  WRITE_MULTIPLE_BLOCK */

        if (sd->spi)

            goto unimplemented_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            /* Writing in SPI mode not implemented.  */

            if (sd->spi)

                break;

            sd->state = sd_receivingdata_state;

            sd->data_start = addr;

            sd->data_offset = 0;

            sd->blk_written = 0;



            if (sd->data_start + sd->blk_len > sd->size)

                sd->card_status |= ADDRESS_ERROR;

            if (sd_wp_addr(sd, sd->data_start))

                sd->card_status |= WP_VIOLATION;

            if (sd->csd[14] & 0x30)

                sd->card_status |= WP_VIOLATION;

            return sd_r1;



        default:

            break;

        }

        break;



    case 26:	/* CMD26:  PROGRAM_CID */

        if (sd->spi)

            goto bad_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_receivingdata_state;

            sd->data_start = 0;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    case 27:	/* CMD27:  PROGRAM_CSD */

        if (sd->spi)

            goto unimplemented_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_receivingdata_state;

            sd->data_start = 0;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    /* Write protection (Class 6) */

    case 28:	/* CMD28:  SET_WRITE_PROT */

        switch (sd->state) {

        case sd_transfer_state:

            if (addr >= sd->size) {

                sd->card_status |= ADDRESS_ERROR;

                return sd_r1b;

            }



            sd->state = sd_programming_state;

            set_bit(sd_addr_to_wpnum(addr), sd->wp_groups);

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

            return sd_r1b;



        default:

            break;

        }

        break;



    case 29:	/* CMD29:  CLR_WRITE_PROT */

        switch (sd->state) {

        case sd_transfer_state:

            if (addr >= sd->size) {

                sd->card_status |= ADDRESS_ERROR;

                return sd_r1b;

            }



            sd->state = sd_programming_state;

            clear_bit(sd_addr_to_wpnum(addr), sd->wp_groups);

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

            return sd_r1b;



        default:

            break;

        }

        break;



    case 30:	/* CMD30:  SEND_WRITE_PROT */

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_sendingdata_state;

            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);

            sd->data_start = addr;

            sd->data_offset = 0;

            return sd_r1b;



        default:

            break;

        }

        break;



    /* Erase commands (Class 5) */

    case 32:	/* CMD32:  ERASE_WR_BLK_START */

        switch (sd->state) {

        case sd_transfer_state:

            sd->erase_start = req.arg;

            return sd_r1;



        default:

            break;

        }

        break;



    case 33:	/* CMD33:  ERASE_WR_BLK_END */

        switch (sd->state) {

        case sd_transfer_state:

            sd->erase_end = req.arg;

            return sd_r1;



        default:

            break;

        }

        break;



    case 38:	/* CMD38:  ERASE */

        switch (sd->state) {

        case sd_transfer_state:

            if (sd->csd[14] & 0x30) {

                sd->card_status |= WP_VIOLATION;

                return sd_r1b;

            }



            sd->state = sd_programming_state;

            sd_erase(sd);

            /* Bzzzzzzztt .... Operation complete.  */

            sd->state = sd_transfer_state;

            return sd_r1b;



        default:

            break;

        }

        break;



    /* Lock card commands (Class 7) */

    case 42:	/* CMD42:  LOCK_UNLOCK */

        if (sd->spi)

            goto unimplemented_cmd;

        switch (sd->state) {

        case sd_transfer_state:

            sd->state = sd_receivingdata_state;

            sd->data_start = 0;

            sd->data_offset = 0;

            return sd_r1;



        default:

            break;

        }

        break;



    case 52:

    case 53:

        /* CMD52, CMD53: reserved for SDIO cards

         * (see the SDIO Simplified Specification V2.0)

         * Handle as illegal command but do not complain

         * on stderr, as some OSes may use these in their

         * probing for presence of an SDIO card.

         */

        return sd_illegal;



    /* Application specific commands (Class 8) */

    case 55:	/* CMD55:  APP_CMD */

        if (sd->rca != rca)

            return sd_r0;



        sd->expecting_acmd = true;

        sd->card_status |= APP_CMD;

        return sd_r1;



    case 56:	/* CMD56:  GEN_CMD */

        fprintf(stderr, "SD: GEN_CMD 0x%08x\n", req.arg);



        switch (sd->state) {

        case sd_transfer_state:

            sd->data_offset = 0;

            if (req.arg & 1)

                sd->state = sd_sendingdata_state;

            else

                sd->state = sd_receivingdata_state;

            return sd_r1;



        default:

            break;

        }

        break;



    default:

    bad_cmd:

        fprintf(stderr, "SD: Unknown CMD%i\n", req.cmd);

        return sd_illegal;



    unimplemented_cmd:

        /* Commands that are recognised but not yet implemented in SPI mode.  */

        fprintf(stderr, "SD: CMD%i not implemented in SPI mode\n", req.cmd);

        return sd_illegal;

    }



    fprintf(stderr, "SD: CMD%i in a wrong state\n", req.cmd);

    return sd_illegal;

}
 and probability:0.34573304157549234
code:static void amdvi_mmio_trace(hwaddr addr, unsigned size)

{

    uint8_t index = (addr & ~0x2000) / 8;



    if ((addr & 0x2000)) {

        /* high table */

        index = index >= AMDVI_MMIO_REGS_HIGH ? AMDVI_MMIO_REGS_HIGH : index;

        trace_amdvi_mmio_read(amdvi_mmio_high[index], addr, size, addr & ~0x07);

    } else {

        index = index >= AMDVI_MMIO_REGS_LOW ? AMDVI_MMIO_REGS_LOW : index;

        trace_amdvi_mmio_read(amdvi_mmio_high[index], addr, size, addr & ~0x07);

    }

}
 and probability:0.25
code:void virtio_cleanup(VirtIODevice *vdev)

{

    qemu_del_vm_change_state_handler(vdev->vmstate);

    g_free(vdev->config);

    g_free(vdev->vq);

    g_free(vdev->vector_queues);

}
 and probability:0.5714285714285714
code:static void gen_pool32axf (CPUMIPSState *env, DisasContext *ctx, int rt, int rs)

{

    int extension = (ctx->opcode >> 6) & 0x3f;

    int minor = (ctx->opcode >> 12) & 0xf;

    uint32_t mips32_op;



    switch (extension) {

    case TEQ:

        mips32_op = OPC_TEQ;

        goto do_trap;

    case TGE:

        mips32_op = OPC_TGE;

        goto do_trap;

    case TGEU:

        mips32_op = OPC_TGEU;

        goto do_trap;

    case TLT:

        mips32_op = OPC_TLT;

        goto do_trap;

    case TLTU:

        mips32_op = OPC_TLTU;

        goto do_trap;

    case TNE:

        mips32_op = OPC_TNE;

    do_trap:

        gen_trap(ctx, mips32_op, rs, rt, -1);

        break;

#ifndef CONFIG_USER_ONLY

    case MFC0:

    case MFC0 + 32:

        check_cp0_enabled(ctx);

        if (rt == 0) {

            /* Treat as NOP. */

            break;

        }

        gen_mfc0(ctx, cpu_gpr[rt], rs, (ctx->opcode >> 11) & 0x7);

        break;

    case MTC0:

    case MTC0 + 32:

        check_cp0_enabled(ctx);

        {

            TCGv t0 = tcg_temp_new();



            gen_load_gpr(t0, rt);

            gen_mtc0(ctx, t0, rs, (ctx->opcode >> 11) & 0x7);

            tcg_temp_free(t0);

        }

        break;

#endif

    case 0x2a:

        switch (minor & 3) {

        case MADD_ACC:

            gen_muldiv(ctx, OPC_MADD, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        case MADDU_ACC:

            gen_muldiv(ctx, OPC_MADDU, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        case MSUB_ACC:

            gen_muldiv(ctx, OPC_MSUB, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        case MSUBU_ACC:

            gen_muldiv(ctx, OPC_MSUBU, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x32:

        switch (minor & 3) {

        case MULT_ACC:

            gen_muldiv(ctx, OPC_MULT, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        case MULTU_ACC:

            gen_muldiv(ctx, OPC_MULTU, (ctx->opcode >> 14) & 3, rs, rt);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x2c:

        switch (minor) {

        case BITSWAP:

            check_insn(ctx, ISA_MIPS32R6);

            gen_bitswap(ctx, OPC_BITSWAP, rs, rt);

            break;

        case SEB:

            gen_bshfl(ctx, OPC_SEB, rs, rt);

            break;

        case SEH:

            gen_bshfl(ctx, OPC_SEH, rs, rt);

            break;

        case CLO:

            mips32_op = OPC_CLO;

            goto do_cl;

        case CLZ:

            mips32_op = OPC_CLZ;

        do_cl:

            check_insn(ctx, ISA_MIPS32);

            gen_cl(ctx, mips32_op, rt, rs);

            break;

        case RDHWR:

            gen_rdhwr(ctx, rt, rs);

            break;

        case WSBH:

            gen_bshfl(ctx, OPC_WSBH, rs, rt);

            break;

        case MULT:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MULT;

            goto do_mul;

        case MULTU:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MULTU;

            goto do_mul;

        case DIV:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_DIV;

            goto do_div;

        case DIVU:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_DIVU;

            goto do_div;

        do_div:

            check_insn(ctx, ISA_MIPS32);

            gen_muldiv(ctx, mips32_op, 0, rs, rt);

            break;

        case MADD:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MADD;

            goto do_mul;

        case MADDU:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MADDU;

            goto do_mul;

        case MSUB:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MSUB;

            goto do_mul;

        case MSUBU:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            mips32_op = OPC_MSUBU;

        do_mul:

            check_insn(ctx, ISA_MIPS32);

            gen_muldiv(ctx, mips32_op, 0, rs, rt);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x34:

        switch (minor) {

        case MFC2:

        case MTC2:

        case MFHC2:

        case MTHC2:

        case CFC2:

        case CTC2:

            generate_exception_err(ctx, EXCP_CpU, 2);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x3c:

        switch (minor) {

        case JALR:    /* JALRC */

        case JALR_HB: /* JALRC_HB */

            if (ctx->insn_flags & ISA_MIPS32R6) {

                /* JALRC, JALRC_HB */

                gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 0);

            } else {

                /* JALR, JALR_HB */

                gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 4);

                ctx->hflags |= MIPS_HFLAG_BDS_STRICT;

            }

            break;

        case JALRS:

        case JALRS_HB:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            gen_compute_branch(ctx, OPC_JALR, 4, rs, rt, 0, 2);

            ctx->hflags |= MIPS_HFLAG_BDS_STRICT;

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x05:

        switch (minor) {

        case RDPGPR:

            check_cp0_enabled(ctx);

            check_insn(ctx, ISA_MIPS32R2);

            gen_load_srsgpr(rs, rt);

            break;

        case WRPGPR:

            check_cp0_enabled(ctx);

            check_insn(ctx, ISA_MIPS32R2);

            gen_store_srsgpr(rs, rt);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

#ifndef CONFIG_USER_ONLY

    case 0x0d:

        switch (minor) {

        case TLBP:

            mips32_op = OPC_TLBP;

            goto do_cp0;

        case TLBR:

            mips32_op = OPC_TLBR;

            goto do_cp0;

        case TLBWI:

            mips32_op = OPC_TLBWI;

            goto do_cp0;

        case TLBWR:

            mips32_op = OPC_TLBWR;

            goto do_cp0;

        case TLBINV:

            mips32_op = OPC_TLBINV;

            goto do_cp0;

        case TLBINVF:

            mips32_op = OPC_TLBINVF;

            goto do_cp0;

        case WAIT:

            mips32_op = OPC_WAIT;

            goto do_cp0;

        case DERET:

            mips32_op = OPC_DERET;

            goto do_cp0;

        case ERET:

            mips32_op = OPC_ERET;

        do_cp0:

            gen_cp0(env, ctx, mips32_op, rt, rs);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x1d:

        switch (minor) {

        case DI:

            check_cp0_enabled(ctx);

            {

                TCGv t0 = tcg_temp_new();



                save_cpu_state(ctx, 1);

                gen_helper_di(t0, cpu_env);

                gen_store_gpr(t0, rs);

                /* Stop translation as we may have switched the execution mode */

                ctx->bstate = BS_STOP;

                tcg_temp_free(t0);

            }

            break;

        case EI:

            check_cp0_enabled(ctx);

            {

                TCGv t0 = tcg_temp_new();



                save_cpu_state(ctx, 1);

                gen_helper_ei(t0, cpu_env);

                gen_store_gpr(t0, rs);

                /* Stop translation as we may have switched the execution mode */

                ctx->bstate = BS_STOP;

                tcg_temp_free(t0);

            }

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

#endif

    case 0x2d:

        switch (minor) {

        case SYNC:

            /* NOP */

            break;

        case SYSCALL:

            generate_exception_end(ctx, EXCP_SYSCALL);

            break;

        case SDBBP:

            if (is_uhi(extract32(ctx->opcode, 16, 10))) {

                gen_helper_do_semihosting(cpu_env);

            } else {

                check_insn(ctx, ISA_MIPS32);

                if (ctx->hflags & MIPS_HFLAG_SBRI) {

                    generate_exception_end(ctx, EXCP_RI);

                } else {

                    generate_exception_end(ctx, EXCP_DBp);

                }

            }

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x01:

        switch (minor & 3) {

        case MFHI_ACC:

            gen_HILO(ctx, OPC_MFHI, minor >> 2, rs);

            break;

        case MFLO_ACC:

            gen_HILO(ctx, OPC_MFLO, minor >> 2, rs);

            break;

        case MTHI_ACC:

            gen_HILO(ctx, OPC_MTHI, minor >> 2, rs);

            break;

        case MTLO_ACC:

            gen_HILO(ctx, OPC_MTLO, minor >> 2, rs);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    case 0x35:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        switch (minor) {

        case MFHI32:

            gen_HILO(ctx, OPC_MFHI, 0, rs);

            break;

        case MFLO32:

            gen_HILO(ctx, OPC_MFLO, 0, rs);

            break;

        case MTHI32:

            gen_HILO(ctx, OPC_MTHI, 0, rs);

            break;

        case MTLO32:

            gen_HILO(ctx, OPC_MTLO, 0, rs);

            break;

        default:

            goto pool32axf_invalid;

        }

        break;

    default:

    pool32axf_invalid:

        MIPS_INVAL("pool32axf");

        generate_exception_end(ctx, EXCP_RI);

        break;

    }

}
 and probability:0.056716417910447764
code:void ff_fix_long_mvs(MpegEncContext * s, uint8_t *field_select_table, int field_select, 

                     int16_t (*mv_table)[2], int f_code, int type, int truncate)

{

    MotionEstContext * const c= &s->me;

    int y, h_range, v_range;



    // RAL: 8 in MPEG-1, 16 in MPEG-4

    int range = (((s->out_format == FMT_MPEG1) ? 8 : 16) << f_code);



    if(s->msmpeg4_version) range= 16;

    if(c->avctx->me_range && range > c->avctx->me_range) range= c->avctx->me_range;



    h_range= range;

    v_range= field_select_table ? range>>1 : range;



    /* clip / convert to intra 16x16 type MVs */

    for(y=0; y<s->mb_height; y++){

        int x;

        int xy= y*s->mb_stride;

        for(x=0; x<s->mb_width; x++){

            if (s->mb_type[xy] & type){    // RAL: "type" test added...

                if(field_select_table==NULL || field_select_table[xy] == field_select){

                    if(   mv_table[xy][0] >=h_range || mv_table[xy][0] <-h_range

                       || mv_table[xy][1] >=v_range || mv_table[xy][1] <-v_range){



                        if(truncate){

                            if     (mv_table[xy][0] > h_range-1) mv_table[xy][0]=  h_range-1;

                            else if(mv_table[xy][0] < -h_range ) mv_table[xy][0]= -h_range;

                            if     (mv_table[xy][1] > v_range-1) mv_table[xy][1]=  v_range-1;

                            else if(mv_table[xy][1] < -v_range ) mv_table[xy][1]= -v_range;

                        }else{

                            s->mb_type[xy] &= ~type;

                            s->mb_type[xy] |= CANDIDATE_MB_TYPE_INTRA;

                            mv_table[xy][0]=

                            mv_table[xy][1]= 0;

                        }

                    }

                }

            }

            xy++;

        }

    }

}
 and probability:0.5263157894736842
code:ThreadPool *thread_pool_new(AioContext *ctx)

{

    ThreadPool *pool = g_new(ThreadPool, 1);

    thread_pool_init_one(pool, ctx);

    return pool;

}
 and probability:0.0
code:static int parse_bootdevices(char *devices)

{

    /* We just do some generic consistency checks */

    const char *p;

    int bitmap = 0;



    for (p = devices; *p != '\0'; p++) {

        /* Allowed boot devices are:

         * a-b: floppy disk drives

         * c-f: IDE disk drives

         * g-m: machine implementation dependant drives

         * n-p: network devices

         * It's up to each machine implementation to check if the given boot

         * devices match the actual hardware implementation and firmware

         * features.

         */

        if (*p < 'a' || *p > 'p') {

            fprintf(stderr, "Invalid boot device '%c'\n", *p);

            exit(1);

        }

        if (bitmap & (1 << (*p - 'a'))) {

            fprintf(stderr, "Boot device '%c' was given twice\n", *p);

            exit(1);

        }

        bitmap |= 1 << (*p - 'a');

    }

    return bitmap;

}
 and probability:0.2222222222222222
code:static void tcg_out_brcond(TCGContext *s, TCGCond cond, TCGReg arg1,

                           TCGReg arg2, int label_index)

{

    static const MIPSInsn b_zero[16] = {

        [TCG_COND_LT] = OPC_BLTZ,

        [TCG_COND_GT] = OPC_BGTZ,

        [TCG_COND_LE] = OPC_BLEZ,

        [TCG_COND_GE] = OPC_BGEZ,

    };



    TCGLabel *l;

    MIPSInsn s_opc = OPC_SLTU;

    MIPSInsn b_opc;

    int cmp_map;



    switch (cond) {

    case TCG_COND_EQ:

        b_opc = OPC_BEQ;

        break;

    case TCG_COND_NE:

        b_opc = OPC_BNE;

        break;



    case TCG_COND_LT:

    case TCG_COND_GT:

    case TCG_COND_LE:

    case TCG_COND_GE:

        if (arg2 == 0) {

            b_opc = b_zero[cond];

            arg2 = arg1;

            arg1 = 0;

            break;

        }

        s_opc = OPC_SLT;

        /* FALLTHRU */



    case TCG_COND_LTU:

    case TCG_COND_GTU:

    case TCG_COND_LEU:

    case TCG_COND_GEU:

        cmp_map = mips_cmp_map[cond];

        if (cmp_map & MIPS_CMP_SWAP) {

            TCGReg t = arg1;

            arg1 = arg2;

            arg2 = t;

        }

        tcg_out_opc_reg(s, s_opc, TCG_TMP0, arg1, arg2);

        b_opc = (cmp_map & MIPS_CMP_INV ? OPC_BEQ : OPC_BNE);

        arg1 = TCG_TMP0;

        arg2 = TCG_REG_ZERO;

        break;



    default:

        tcg_abort();

        break;

    }



    tcg_out_opc_br(s, b_opc, arg1, arg2);

    l = &s->labels[label_index];

    if (l->has_value) {

        reloc_pc16(s->code_ptr - 1, l->u.value_ptr);

    } else {

        tcg_out_reloc(s, s->code_ptr - 1, R_MIPS_PC16, label_index, 0);

    }

    tcg_out_nop(s);

}
 and probability:0.1
code:static unsigned int dec_move_rp(DisasContext *dc)

{

	TCGv t[2];

	DIS(fprintf (logfile, "move $r%u, $p%u\n", dc->op1, dc->op2));

	cris_cc_mask(dc, 0);



	t[0] = tcg_temp_new(TCG_TYPE_TL);

	if (dc->op2 == PR_CCS) {

		cris_evaluate_flags(dc);

		t_gen_mov_TN_reg(t[0], dc->op1);

		if (dc->tb_flags & U_FLAG) {

			t[1] = tcg_temp_new(TCG_TYPE_TL);

			/* User space is not allowed to touch all flags.  */

			tcg_gen_andi_tl(t[0], t[0], 0x39f);

			tcg_gen_andi_tl(t[1], cpu_PR[PR_CCS], ~0x39f);

			tcg_gen_or_tl(t[0], t[1], t[0]);

			tcg_temp_free(t[1]);

		}

	}

	else

		t_gen_mov_TN_reg(t[0], dc->op1);



	t_gen_mov_preg_TN(dc, dc->op2, t[0]);

	if (dc->op2 == PR_CCS) {

		cris_update_cc_op(dc, CC_OP_FLAGS, 4);

		dc->flags_uptodate = 1;

	}

	tcg_temp_free(t[0]);

	return 2;

}
 and probability:0.5357142857142857
code:static uint32_t get_elf_hwcap(void)

{

    ARMCPU *cpu = ARM_CPU(thread_cpu);

    uint32_t hwcaps = 0;



    hwcaps |= ARM_HWCAP_ARM_SWP;

    hwcaps |= ARM_HWCAP_ARM_HALF;

    hwcaps |= ARM_HWCAP_ARM_THUMB;

    hwcaps |= ARM_HWCAP_ARM_FAST_MULT;



    /* probe for the extra features */

#define GET_FEATURE(feat, hwcap) \

    do { if (arm_feature(&cpu->env, feat)) { hwcaps |= hwcap; } } while (0)

    /* EDSP is in v5TE and above, but all our v5 CPUs are v5TE */

    GET_FEATURE(ARM_FEATURE_V5, ARM_HWCAP_ARM_EDSP);

    GET_FEATURE(ARM_FEATURE_VFP, ARM_HWCAP_ARM_VFP);

    GET_FEATURE(ARM_FEATURE_IWMMXT, ARM_HWCAP_ARM_IWMMXT);

    GET_FEATURE(ARM_FEATURE_THUMB2EE, ARM_HWCAP_ARM_THUMBEE);

    GET_FEATURE(ARM_FEATURE_NEON, ARM_HWCAP_ARM_NEON);

    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPv3);

    GET_FEATURE(ARM_FEATURE_V6K, ARM_HWCAP_ARM_TLS);

    GET_FEATURE(ARM_FEATURE_VFP4, ARM_HWCAP_ARM_VFPv4);

    GET_FEATURE(ARM_FEATURE_ARM_DIV, ARM_HWCAP_ARM_IDIVA);

    GET_FEATURE(ARM_FEATURE_THUMB_DIV, ARM_HWCAP_ARM_IDIVT);

    /* All QEMU's VFPv3 CPUs have 32 registers, see VFP_DREG in translate.c.

     * Note that the ARM_HWCAP_ARM_VFPv3D16 bit is always the inverse of

     * ARM_HWCAP_ARM_VFPD32 (and so always clear for QEMU); it is unrelated

     * to our VFP_FP16 feature bit.

     */

    GET_FEATURE(ARM_FEATURE_VFP3, ARM_HWCAP_ARM_VFPD32);

    GET_FEATURE(ARM_FEATURE_LPAE, ARM_HWCAP_ARM_LPAE);

#undef GET_FEATURE



    return hwcaps;

}
 and probability:0.0
code:static void test_visitor_out_native_list_uint64(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U64);

}
 and probability:0.0
code:BlockAIOCB *bdrv_aio_flush(BlockDriverState *bs,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_flush(bs, opaque);



    Coroutine *co;

    BlockAIOCBCoroutine *acb;



    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, bs, cb, opaque);

    acb->need_bh = true;

    acb->req.error = -EINPROGRESS;



    co = qemu_coroutine_create(bdrv_aio_flush_co_entry);

    qemu_coroutine_enter(co, acb);



    bdrv_co_maybe_schedule_bh(acb);

    return &acb->common;

}
 and probability:0.21428571428571427
code:xmit_seg(E1000State *s)

{

    uint16_t len;

    unsigned int frames = s->tx.tso_frames, css, sofar;

    struct e1000_tx *tp = &s->tx;



    if (tp->props.tse && tp->props.cptse) {

        css = tp->props.ipcss;

        DBGOUT(TXSUM, "frames %d size %d ipcss %d\n",

               frames, tp->size, css);

        if (tp->props.ip) {    /* IPv4 */

            stw_be_p(tp->data+css+2, tp->size - css);

            stw_be_p(tp->data+css+4,

                     lduw_be_p(tp->data + css + 4) + frames);

        } else {         /* IPv6 */

            stw_be_p(tp->data+css+4, tp->size - css);

        }

        css = tp->props.tucss;

        len = tp->size - css;

        DBGOUT(TXSUM, "tcp %d tucss %d len %d\n", tp->props.tcp, css, len);

        if (tp->props.tcp) {

            sofar = frames * tp->props.mss;

            stl_be_p(tp->data+css+4, ldl_be_p(tp->data+css+4)+sofar); /* seq */

            if (tp->props.paylen - sofar > tp->props.mss) {

                tp->data[css + 13] &= ~9;    /* PSH, FIN */

            } else if (frames) {

                e1000x_inc_reg_if_not_full(s->mac_reg, TSCTC);

            }

        } else    /* UDP */

            stw_be_p(tp->data+css+4, len);

        if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {

            unsigned int phsum;

            // add pseudo-header length before checksum calculation

            void *sp = tp->data + tp->props.tucso;



            phsum = lduw_be_p(sp) + len;

            phsum = (phsum >> 16) + (phsum & 0xffff);

            stw_be_p(sp, phsum);

        }

        tp->tso_frames++;

    }



    if (tp->props.sum_needed & E1000_TXD_POPTS_TXSM) {

        putsum(tp->data, tp->size, tp->props.tucso,

               tp->props.tucss, tp->props.tucse);

    }

    if (tp->props.sum_needed & E1000_TXD_POPTS_IXSM) {

        putsum(tp->data, tp->size, tp->props.ipcso,

               tp->props.ipcss, tp->props.ipcse);

    }

    if (tp->vlan_needed) {

        memmove(tp->vlan, tp->data, 4);

        memmove(tp->data, tp->data + 4, 8);

        memcpy(tp->data + 8, tp->vlan_header, 4);

        e1000_send_packet(s, tp->vlan, tp->size + 4);

    } else {

        e1000_send_packet(s, tp->data, tp->size);

    }



    e1000x_inc_reg_if_not_full(s->mac_reg, TPT);

    e1000x_grow_8reg_if_not_full(s->mac_reg, TOTL, s->tx.size);

    s->mac_reg[GPTC] = s->mac_reg[TPT];

    s->mac_reg[GOTCL] = s->mac_reg[TOTL];

    s->mac_reg[GOTCH] = s->mac_reg[TOTH];

}
 and probability:0.7049180327868853
code:int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)

{

    int         mbn, blk, num_blocks, num_coeffs, blk_size, scan_pos, run, val,

                pos, is_intra, mc_type, mv_x, mv_y, col_mask;

    uint8_t     col_flags[8];

    int32_t     prev_dc, trvec[64];

    uint32_t    cbp, sym, lo, hi, quant, buf_offs, q;

    IVIMbInfo   *mb;

    RVMapDesc   *rvmap = band->rv_map;

    void (*mc_with_delta_func)(int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);

    void (*mc_no_delta_func)  (int16_t *buf, const int16_t *ref_buf, uint32_t pitch, int mc_type);

    const uint16_t  *base_tab;

    const uint8_t   *scale_tab;



    prev_dc = 0; /* init intra prediction for the DC coefficient */



    blk_size   = band->blk_size;

    col_mask   = blk_size - 1; /* column mask for tracking non-zero coeffs */

    num_blocks = (band->mb_size != blk_size) ? 4 : 1; /* number of blocks per mb */

    num_coeffs = blk_size * blk_size;

    if (blk_size == 8) {

        mc_with_delta_func = ff_ivi_mc_8x8_delta;

        mc_no_delta_func   = ff_ivi_mc_8x8_no_delta;

    } else {

        mc_with_delta_func = ff_ivi_mc_4x4_delta;

        mc_no_delta_func   = ff_ivi_mc_4x4_no_delta;

    }



    for (mbn = 0, mb = tile->mbs; mbn < tile->num_MBs; mb++, mbn++) {

        is_intra = !mb->type;

        cbp      = mb->cbp;

        buf_offs = mb->buf_offs;



        quant = av_clip(band->glob_quant + mb->q_delta, 0, 23);



        base_tab  = is_intra ? band->intra_base  : band->inter_base;

        scale_tab = is_intra ? band->intra_scale : band->inter_scale;

        if (scale_tab)

            quant = scale_tab[quant];



        if (!is_intra) {

            mv_x = mb->mv_x;

            mv_y = mb->mv_y;

            if (!band->is_halfpel) {

                mc_type = 0; /* we have only fullpel vectors */

            } else {

                mc_type = ((mv_y & 1) << 1) | (mv_x & 1);

                mv_x >>= 1;

                mv_y >>= 1; /* convert halfpel vectors into fullpel ones */

            }

        }



        for (blk = 0; blk < num_blocks; blk++) {

            /* adjust block position in the buffer according to its number */

            if (blk & 1) {

                buf_offs += blk_size;

            } else if (blk == 2) {

                buf_offs -= blk_size;

                buf_offs += blk_size * band->pitch;

            }



            if (cbp & 1) { /* block coded ? */

                scan_pos = -1;

                memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */

                memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */



                while (scan_pos <= num_coeffs) {

                    sym = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);

                    if (sym == rvmap->eob_sym)

                        break; /* End of block */



                    if (sym == rvmap->esc_sym) { /* Escape - run/val explicitly coded using 3 vlc codes */

                        run = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1) + 1;

                        lo  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);

                        hi  = get_vlc2(gb, band->blk_vlc.tab->table, IVI_VLC_BITS, 1);

                        val = IVI_TOSIGNED((hi << 6) | lo); /* merge them and convert into signed val */

                    } else {

                        if (sym >= 256U) {

                            av_log(NULL, AV_LOG_ERROR, "Invalid sym encountered: %d.\n", sym);

                            return -1;

                        }

                        run = rvmap->runtab[sym];

                        val = rvmap->valtab[sym];

                    }



                    /* de-zigzag and dequantize */

                    scan_pos += run;

                    if (scan_pos >= num_coeffs)

                        break;

                    pos = band->scan[scan_pos];



                    if (!val)

                        av_dlog(NULL, "Val = 0 encountered!\n");



                    q = (base_tab[pos] * quant) >> 9;

                    if (q > 1)

                        val = val * q + FFSIGN(val) * (((q ^ 1) - 1) >> 1);

                    trvec[pos] = val;

                    col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */

                }// while



                if (scan_pos >= num_coeffs && sym != rvmap->eob_sym)

                    return -1; /* corrupt block data */



                /* undoing DC coeff prediction for intra-blocks */

                if (is_intra && band->is_2d_trans) {

                    prev_dc      += trvec[0];

                    trvec[0]      = prev_dc;

                    col_flags[0] |= !!prev_dc;

                }



                /* apply inverse transform */

                band->inv_transform(trvec, band->buf + buf_offs,

                                    band->pitch, col_flags);



                /* apply motion compensation */

                if (!is_intra)

                    mc_with_delta_func(band->buf + buf_offs,

                                       band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,

                                       band->pitch, mc_type);

            } else {

                /* block not coded */

                /* for intra blocks apply the dc slant transform */

                /* for inter - perform the motion compensation without delta */

                if (is_intra && band->dc_transform) {

                    band->dc_transform(&prev_dc, band->buf + buf_offs,

                                       band->pitch, blk_size);

                } else

                    mc_no_delta_func(band->buf + buf_offs,

                                     band->ref_buf + buf_offs + mv_y * band->pitch + mv_x,

                                     band->pitch, mc_type);

            }



            cbp >>= 1;

        }// for blk

    }// for mbn



    align_get_bits(gb);



    return 0;

}
 and probability:0.4214876033057851
code:static void assigned_dev_ioport_write(void *opaque, target_phys_addr_t addr,

                                      uint64_t data, unsigned size)

{

    assigned_dev_ioport_rw(opaque, addr, size, &data);

}
 and probability:0.0
code:static int kvm_put_fpu(CPUState *env)

{

    struct kvm_fpu fpu;

    int i;



    memset(&fpu, 0, sizeof fpu);

    fpu.fsw = env->fpus & ~(7 << 11);

    fpu.fsw |= (env->fpstt & 7) << 11;

    fpu.fcw = env->fpuc;

    for (i = 0; i < 8; ++i)

	fpu.ftwx |= (!env->fptags[i]) << i;

    memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);

    memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);

    fpu.mxcsr = env->mxcsr;



    return kvm_vcpu_ioctl(env, KVM_SET_FPU, &fpu);

}
 and probability:0.5333333333333333
code:target_read_memory (bfd_vma memaddr,

                    bfd_byte *myaddr,

                    int length,

                    struct disassemble_info *info)

{

    int i;

    for(i = 0; i < length; i++) {

        myaddr[i] = ldub_code(memaddr + i);

    }

    return 0;

}
 and probability:0.18181818181818182
code:static int http_connect(URLContext *h, const char *path, const char *hoststr,

                        const char *auth, int *new_location)

{

    HTTPContext *s = h->priv_data;

    int post, err, ch;

    char line[1024], *q;

    char *auth_b64;

    int auth_b64_len = strlen(auth)* 4 / 3 + 12;

    int64_t off = s->off;





    /* send http header */

    post = h->flags & URL_WRONLY;

    auth_b64 = av_malloc(auth_b64_len);

    av_base64_encode(auth_b64, auth_b64_len, auth, strlen(auth));

    snprintf(s->buffer, sizeof(s->buffer),

             "%s %s HTTP/1.1\r\n"

             "User-Agent: %s\r\n"

             "Accept: */*\r\n"

             "Range: bytes=%"PRId64"-\r\n"

             "Host: %s\r\n"

             "Authorization: Basic %s\r\n"

             "Connection: close\r\n"

             "\r\n",

             post ? "POST" : "GET",

             path,

             LIBAVFORMAT_IDENT,

             s->off,

             hoststr,

             auth_b64);



    av_freep(&auth_b64);

    if (http_write(h, s->buffer, strlen(s->buffer)) < 0)

        return AVERROR(EIO);



    /* init input buffer */

    s->buf_ptr = s->buffer;

    s->buf_end = s->buffer;

    s->line_count = 0;

    s->off = 0;

    s->filesize = -1;

    if (post) {

        return 0;

    }



    /* wait for header */

    q = line;

    for(;;) {

        ch = http_getc(s);

        if (ch < 0)

            return AVERROR(EIO);

        if (ch == '\n') {

            /* process line */

            if (q > line && q[-1] == '\r')

                q--;

            *q = '\0';

#ifdef DEBUG

            printf("header='%s'\n", line);

#endif

            err = process_line(h, line, s->line_count, new_location);

            if (err < 0)

                return err;

            if (err == 0)

                break;

            s->line_count++;

            q = line;

        } else {

            if ((q - line) < sizeof(line) - 1)

                *q++ = ch;

        }

    }



    return (off == s->off) ? 0 : -1;

}
 and probability:0.3088235294117647
code:static void set_guest_connected(VirtIOSerialPort *port, int guest_connected)

{

    VirtConsole *vcon = VIRTIO_CONSOLE(port);

    DeviceState *dev = DEVICE(port);



    if (vcon->chr) {

        qemu_chr_fe_set_open(vcon->chr, guest_connected);

    }



    if (dev->id) {

        qapi_event_send_vserport_change(dev->id, guest_connected,

                                        &error_abort);

    }

}
 and probability:0.3333333333333333
code:void error_setg_errno(Error **errp, int os_errno, const char *fmt, ...)

{

    va_list ap;

    char *msg;

    int saved_errno = errno;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (os_errno != 0) {

        msg = (*errp)->msg;

        (*errp)->msg = g_strdup_printf("%s: %s", msg, strerror(os_errno));

        g_free(msg);

    }



    errno = saved_errno;

}
 and probability:0.1111111111111111
code:void bitmap_set(unsigned long *map, long start, long nr)
{
    unsigned long *p = map + BIT_WORD(start);
    const long size = start + nr;
    int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
    unsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);
    while (nr - bits_to_set >= 0) {
        *p |= mask_to_set;
        nr -= bits_to_set;
        bits_to_set = BITS_PER_LONG;
        mask_to_set = ~0UL;
        p++;
    }
    if (nr) {
        mask_to_set &= BITMAP_LAST_WORD_MASK(size);
        *p |= mask_to_set;
    }
} and probability:0.4444444444444444
code:static void vmdk_free_extents(BlockDriverState *bs)

{

    int i;

    BDRVVmdkState *s = bs->opaque;



    for (i = 0; i < s->num_extents; i++) {

        g_free(s->extents[i].l1_table);

        g_free(s->extents[i].l2_cache);

        g_free(s->extents[i].l1_backup_table);

    }

    g_free(s->extents);

}
 and probability:0.5454545454545454
code:static void console_putchar(TextConsole *s, int ch)

{

    TextCell *c;

    int y1, i;

    int x, y;



    switch(s->state) {

    case TTY_STATE_NORM:

        switch(ch) {

        case '\r':  /* carriage return */

            s->x = 0;

            break;

        case '\n':  /* newline */

            console_put_lf(s);

            break;

        case '\b':  /* backspace */

            if (s->x > 0)

                s->x--;

            break;

        case '\t':  /* tabspace */

            if (s->x + (8 - (s->x % 8)) > s->width) {

                s->x = 0;

                console_put_lf(s);

            } else {

                s->x = s->x + (8 - (s->x % 8));

            }

            break;

        case '\a':  /* alert aka. bell */

            /* TODO: has to be implemented */

            break;

        case 14:

            /* SI (shift in), character set 0 (ignored) */

            break;

        case 15:

            /* SO (shift out), character set 1 (ignored) */

            break;

        case 27:    /* esc (introducing an escape sequence) */

            s->state = TTY_STATE_ESC;

            break;

        default:

            if (s->x >= s->width) {

                /* line wrap */

                s->x = 0;

                console_put_lf(s);

            }

            y1 = (s->y_base + s->y) % s->total_height;

            c = &s->cells[y1 * s->width + s->x];

            c->ch = ch;

            c->t_attrib = s->t_attrib;

            update_xy(s, s->x, s->y);

            s->x++;

            break;

        }

        break;

    case TTY_STATE_ESC: /* check if it is a terminal escape sequence */

        if (ch == '[') {

            for(i=0;i<MAX_ESC_PARAMS;i++)

                s->esc_params[i] = 0;

            s->nb_esc_params = 0;

            s->state = TTY_STATE_CSI;

        } else {

            s->state = TTY_STATE_NORM;

        }

        break;

    case TTY_STATE_CSI: /* handle escape sequence parameters */

        if (ch >= '0' && ch <= '9') {

            if (s->nb_esc_params < MAX_ESC_PARAMS) {

                s->esc_params[s->nb_esc_params] =

                    s->esc_params[s->nb_esc_params] * 10 + ch - '0';

            }

        } else {

            s->nb_esc_params++;

            if (ch == ';')

                break;

#ifdef DEBUG_CONSOLE

            fprintf(stderr, "escape sequence CSI%d;%d%c, %d parameters\n",

                    s->esc_params[0], s->esc_params[1], ch, s->nb_esc_params);

#endif

            s->state = TTY_STATE_NORM;

            switch(ch) {

            case 'A':

                /* move cursor up */

                if (s->esc_params[0] == 0) {

                    s->esc_params[0] = 1;

                }

                s->y -= s->esc_params[0];

                if (s->y < 0) {

                    s->y = 0;

                }

                break;

            case 'B':

                /* move cursor down */

                if (s->esc_params[0] == 0) {

                    s->esc_params[0] = 1;

                }

                s->y += s->esc_params[0];

                if (s->y >= s->height) {

                    s->y = s->height - 1;

                }

                break;

            case 'C':

                /* move cursor right */

                if (s->esc_params[0] == 0) {

                    s->esc_params[0] = 1;

                }

                s->x += s->esc_params[0];

                if (s->x >= s->width) {

                    s->x = s->width - 1;

                }

                break;

            case 'D':

                /* move cursor left */

                if (s->esc_params[0] == 0) {

                    s->esc_params[0] = 1;

                }

                s->x -= s->esc_params[0];

                if (s->x < 0) {

                    s->x = 0;

                }

                break;

            case 'G':

                /* move cursor to column */

                s->x = s->esc_params[0] - 1;

                if (s->x < 0) {

                    s->x = 0;

                }

                break;

            case 'f':

            case 'H':

                /* move cursor to row, column */

                s->x = s->esc_params[1] - 1;

                if (s->x < 0) {

                    s->x = 0;

                }

                s->y = s->esc_params[0] - 1;

                if (s->y < 0) {

                    s->y = 0;

                }

                break;

            case 'J':

                switch (s->esc_params[0]) {

                case 0:

                    /* clear to end of screen */

                    for (y = s->y; y < s->height; y++) {

                        for (x = 0; x < s->width; x++) {

                            if (y == s->y && x < s->x) {

                                continue;

                            }

                            console_clear_xy(s, x, y);

                        }

                    }

                    break;

                case 1:

                    /* clear from beginning of screen */

                    for (y = 0; y <= s->y; y++) {

                        for (x = 0; x < s->width; x++) {

                            if (y == s->y && x > s->x) {

                                break;

                            }

                            console_clear_xy(s, x, y);

                        }

                    }

                    break;

                case 2:

                    /* clear entire screen */

                    for (y = 0; y <= s->height; y++) {

                        for (x = 0; x < s->width; x++) {

                            console_clear_xy(s, x, y);

                        }

                    }

                    break;

                }

                break;

            case 'K':

                switch (s->esc_params[0]) {

                case 0:

                    /* clear to eol */

                    for(x = s->x; x < s->width; x++) {

                        console_clear_xy(s, x, s->y);

                    }

                    break;

                case 1:

                    /* clear from beginning of line */

                    for (x = 0; x <= s->x; x++) {

                        console_clear_xy(s, x, s->y);

                    }

                    break;

                case 2:

                    /* clear entire line */

                    for(x = 0; x < s->width; x++) {

                        console_clear_xy(s, x, s->y);

                    }

                    break;

                }

                break;

            case 'm':

                console_handle_escape(s);

                break;

            case 'n':

                /* report cursor position */

                /* TODO: send ESC[row;colR */

                break;

            case 's':

                /* save cursor position */

                s->x_saved = s->x;

                s->y_saved = s->y;

                break;

            case 'u':

                /* restore cursor position */

                s->x = s->x_saved;

                s->y = s->y_saved;

                break;

            default:

#ifdef DEBUG_CONSOLE

                fprintf(stderr, "unhandled escape character '%c'\n", ch);

#endif

                break;

            }

            break;

        }

    }

}
 and probability:0.3438914027149321
code:static void blkverify_err(BlkverifyAIOCB *acb, const char *fmt, ...)

{

    va_list ap;



    va_start(ap, fmt);

    fprintf(stderr, "blkverify: %s sector_num=%ld nb_sectors=%d ",

            acb->is_write ? "write" : "read", acb->sector_num,

            acb->nb_sectors);

    vfprintf(stderr, fmt, ap);

    fprintf(stderr, "\n");

    va_end(ap);

    exit(1);

}
 and probability:0.16666666666666666
code:static void format_line(void *ptr, int level, const char *fmt, va_list vl,

                        char part[3][512], int part_size, int *print_prefix, int type[2])

{

    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;

    part[0][0] = part[1][0] = part[2][0] = 0;

    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;

    if (*print_prefix && avc) {

        if (avc->parent_log_context_offset) {

            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +

                                   avc->parent_log_context_offset);

            if (parent && *parent) {

                snprintf(part[0], part_size, "[%s @ %p] ",

                         (*parent)->item_name(parent), parent);

                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);

            }

        }

        snprintf(part[1], part_size, "[%s @ %p] ",

                 avc->item_name(ptr), ptr);

        if(type) type[1] = get_category(ptr);

    }



    vsnprintf(part[2], part_size, fmt, vl);



    *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\n';

}
 and probability:0.6956521739130435
code:find_c_packed_planar_out_funcs(SwsContext *c,

                               yuv2planar1_fn *yuv2yuv1,    yuv2planarX_fn *yuv2yuvX,

                               yuv2packed1_fn *yuv2packed1, yuv2packed2_fn *yuv2packed2,

                               yuv2packedX_fn *yuv2packedX)

{

    enum PixelFormat dstFormat = c->dstFormat;



    if (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21) {

        *yuv2yuvX     = yuv2nv12X_c;

    } else if (is16BPS(dstFormat)) {

        *yuv2yuvX     = isBE(dstFormat) ? yuv2yuvX16BE_c  : yuv2yuvX16LE_c;

    } else if (is9_OR_10BPS(dstFormat)) {

        if (av_pix_fmt_descriptors[dstFormat].comp[0].depth_minus1 == 8) {

            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX9BE_c :  yuv2yuvX9LE_c;

        } else {

            *yuv2yuvX = isBE(dstFormat) ? yuv2yuvX10BE_c : yuv2yuvX10LE_c;

        }

    } else {

        *yuv2yuv1     = yuv2yuv1_c;

        *yuv2yuvX     = yuv2yuvX_c;

    }

    if(c->flags & SWS_FULL_CHR_H_INT) {

        switch (dstFormat) {

            case PIX_FMT_RGBA:

#if CONFIG_SMALL

                *yuv2packedX = yuv2rgba32_full_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packedX = yuv2rgba32_full_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packedX = yuv2rgbx32_full_X_c;

                }

#endif /* !CONFIG_SMALL */

                break;

            case PIX_FMT_ARGB:

#if CONFIG_SMALL

                *yuv2packedX = yuv2argb32_full_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packedX = yuv2argb32_full_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packedX = yuv2xrgb32_full_X_c;

                }

#endif /* !CONFIG_SMALL */

                break;

            case PIX_FMT_BGRA:

#if CONFIG_SMALL

                *yuv2packedX = yuv2bgra32_full_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packedX = yuv2bgra32_full_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packedX = yuv2bgrx32_full_X_c;

                }

#endif /* !CONFIG_SMALL */

                break;

            case PIX_FMT_ABGR:

#if CONFIG_SMALL

                *yuv2packedX = yuv2abgr32_full_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packedX = yuv2abgr32_full_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packedX = yuv2xbgr32_full_X_c;

                }

#endif /* !CONFIG_SMALL */

                break;

            case PIX_FMT_RGB24:

            *yuv2packedX = yuv2rgb24_full_X_c;

            break;

        case PIX_FMT_BGR24:

            *yuv2packedX = yuv2bgr24_full_X_c;

            break;

        }

    } else {

        switch (dstFormat) {

        case PIX_FMT_GRAY16BE:

            *yuv2packed1 = yuv2gray16BE_1_c;

            *yuv2packed2 = yuv2gray16BE_2_c;

            *yuv2packedX = yuv2gray16BE_X_c;

            break;

        case PIX_FMT_GRAY16LE:

            *yuv2packed1 = yuv2gray16LE_1_c;

            *yuv2packed2 = yuv2gray16LE_2_c;

            *yuv2packedX = yuv2gray16LE_X_c;

            break;

        case PIX_FMT_MONOWHITE:

            *yuv2packed1 = yuv2monowhite_1_c;

            *yuv2packed2 = yuv2monowhite_2_c;

            *yuv2packedX = yuv2monowhite_X_c;

            break;

        case PIX_FMT_MONOBLACK:

            *yuv2packed1 = yuv2monoblack_1_c;

            *yuv2packed2 = yuv2monoblack_2_c;

            *yuv2packedX = yuv2monoblack_X_c;

            break;

        case PIX_FMT_YUYV422:

            *yuv2packed1 = yuv2yuyv422_1_c;

            *yuv2packed2 = yuv2yuyv422_2_c;

            *yuv2packedX = yuv2yuyv422_X_c;

            break;

        case PIX_FMT_UYVY422:

            *yuv2packed1 = yuv2uyvy422_1_c;

            *yuv2packed2 = yuv2uyvy422_2_c;

            *yuv2packedX = yuv2uyvy422_X_c;

            break;

        case PIX_FMT_RGB48LE:

            //*yuv2packed1 = yuv2rgb48le_1_c;

            //*yuv2packed2 = yuv2rgb48le_2_c;

            //*yuv2packedX = yuv2rgb48le_X_c;

            //break;

        case PIX_FMT_RGB48BE:

            *yuv2packed1 = yuv2rgb48be_1_c;

            *yuv2packed2 = yuv2rgb48be_2_c;

            *yuv2packedX = yuv2rgb48be_X_c;

            break;

        case PIX_FMT_BGR48LE:

            //*yuv2packed1 = yuv2bgr48le_1_c;

            //*yuv2packed2 = yuv2bgr48le_2_c;

            //*yuv2packedX = yuv2bgr48le_X_c;

            //break;

        case PIX_FMT_BGR48BE:

            *yuv2packed1 = yuv2bgr48be_1_c;

            *yuv2packed2 = yuv2bgr48be_2_c;

            *yuv2packedX = yuv2bgr48be_X_c;

            break;

        case PIX_FMT_RGB32:

        case PIX_FMT_BGR32:

#if CONFIG_SMALL

            *yuv2packed1 = yuv2rgb32_1_c;

            *yuv2packed2 = yuv2rgb32_2_c;

            *yuv2packedX = yuv2rgb32_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packed1 = yuv2rgba32_1_c;

                    *yuv2packed2 = yuv2rgba32_2_c;

                    *yuv2packedX = yuv2rgba32_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packed1 = yuv2rgbx32_1_c;

                    *yuv2packed2 = yuv2rgbx32_2_c;

                    *yuv2packedX = yuv2rgbx32_X_c;

                }

#endif /* !CONFIG_SMALL */

            break;

        case PIX_FMT_RGB32_1:

        case PIX_FMT_BGR32_1:

#if CONFIG_SMALL

                *yuv2packed1 = yuv2rgb32_1_1_c;

                *yuv2packed2 = yuv2rgb32_1_2_c;

                *yuv2packedX = yuv2rgb32_1_X_c;

#else

#if CONFIG_SWSCALE_ALPHA

                if (c->alpPixBuf) {

                    *yuv2packed1 = yuv2rgba32_1_1_c;

                    *yuv2packed2 = yuv2rgba32_1_2_c;

                    *yuv2packedX = yuv2rgba32_1_X_c;

                } else

#endif /* CONFIG_SWSCALE_ALPHA */

                {

                    *yuv2packed1 = yuv2rgbx32_1_1_c;

                    *yuv2packed2 = yuv2rgbx32_1_2_c;

                    *yuv2packedX = yuv2rgbx32_1_X_c;

                }

#endif /* !CONFIG_SMALL */

                break;

        case PIX_FMT_RGB24:

            *yuv2packed1 = yuv2rgb24_1_c;

            *yuv2packed2 = yuv2rgb24_2_c;

            *yuv2packedX = yuv2rgb24_X_c;

            break;

        case PIX_FMT_BGR24:

            *yuv2packed1 = yuv2bgr24_1_c;

            *yuv2packed2 = yuv2bgr24_2_c;

            *yuv2packedX = yuv2bgr24_X_c;

            break;

        case PIX_FMT_RGB565:

        case PIX_FMT_BGR565:

            *yuv2packed1 = yuv2rgb16_1_c;

            *yuv2packed2 = yuv2rgb16_2_c;

            *yuv2packedX = yuv2rgb16_X_c;

            break;

        case PIX_FMT_RGB555:

        case PIX_FMT_BGR555:

            *yuv2packed1 = yuv2rgb15_1_c;

            *yuv2packed2 = yuv2rgb15_2_c;

            *yuv2packedX = yuv2rgb15_X_c;

            break;

        case PIX_FMT_RGB444:

        case PIX_FMT_BGR444:

            *yuv2packed1 = yuv2rgb12_1_c;

            *yuv2packed2 = yuv2rgb12_2_c;

            *yuv2packedX = yuv2rgb12_X_c;

            break;

        case PIX_FMT_RGB8:

        case PIX_FMT_BGR8:

            *yuv2packed1 = yuv2rgb8_1_c;

            *yuv2packed2 = yuv2rgb8_2_c;

            *yuv2packedX = yuv2rgb8_X_c;

            break;

        case PIX_FMT_RGB4:

        case PIX_FMT_BGR4:

            *yuv2packed1 = yuv2rgb4_1_c;

            *yuv2packed2 = yuv2rgb4_2_c;

            *yuv2packedX = yuv2rgb4_X_c;

            break;

        case PIX_FMT_RGB4_BYTE:

        case PIX_FMT_BGR4_BYTE:

            *yuv2packed1 = yuv2rgb4b_1_c;

            *yuv2packed2 = yuv2rgb4b_2_c;

            *yuv2packedX = yuv2rgb4b_X_c;

            break;

        }

    }

}
 and probability:0.4342105263157895
code:static av_always_inline void h264_filter_mb_fast_internal(H264Context *h,

                                                          int mb_x, int mb_y,

                                                          uint8_t *img_y,

                                                          uint8_t *img_cb,

                                                          uint8_t *img_cr,

                                                          unsigned int linesize,

                                                          unsigned int uvlinesize,

                                                          int pixel_shift)

{

    int chroma = !(CONFIG_GRAY && (h->flags&CODEC_FLAG_GRAY));

    int chroma444 = CHROMA444(h);

    int chroma422 = CHROMA422(h);



    int mb_xy = h->mb_xy;

    int left_type= h->left_type[LTOP];

    int top_type= h->top_type;



    int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    int a = h->slice_alpha_c0_offset - qp_bd_offset;

    int b = h->slice_beta_offset - qp_bd_offset;



    int mb_type = h->cur_pic.mb_type[mb_xy];

    int qp      = h->cur_pic.qscale_table[mb_xy];

    int qp0     = h->cur_pic.qscale_table[mb_xy - 1];

    int qp1     = h->cur_pic.qscale_table[h->top_mb_xy];

    int qpc = get_chroma_qp( h, 0, qp );

    int qpc0 = get_chroma_qp( h, 0, qp0 );

    int qpc1 = get_chroma_qp( h, 0, qp1 );

    qp0 = (qp + qp0 + 1) >> 1;

    qp1 = (qp + qp1 + 1) >> 1;

    qpc0 = (qpc + qpc0 + 1) >> 1;

    qpc1 = (qpc + qpc1 + 1) >> 1;



    if( IS_INTRA(mb_type) ) {

        static const int16_t bS4[4] = {4,4,4,4};

        static const int16_t bS3[4] = {3,3,3,3};

        const int16_t *bSH = FIELD_PICTURE(h) ? bS3 : bS4;

        if(left_type)

            filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1);

        if( IS_8x8DCT(mb_type) ) {

            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);

            if(top_type){

                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);

            }

            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);

        } else {

            filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0);

            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);

            filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0);

            if(top_type){

                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);

            }

            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0);

            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);

            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0);

        }

        if(chroma){

            if(chroma444){

                if(left_type){

                    filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);

                    filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);

                }

                if( IS_8x8DCT(mb_type) ) {

                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    if(top_type){

                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );

                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );

                    }

                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);

                } else {

                    filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);

                    if(top_type){

                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);

                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);

                    }

                    filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);

                    filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);

                }

            }else if(chroma422){

                if(left_type){

                    filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);

                    filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);

                }

                filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);

                if(top_type){

                    filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);

                    filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);

                }

                filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

            }else{

                if(left_type){

                    filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);

                    filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);

                }

                filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);

                if(top_type){

                    filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);

                    filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);

                }

                filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

                filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);

            }

        }

        return;

    } else {

        LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]);

        int edges;

        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) {

            edges = 4;

            AV_WN64A(bS[0][0], 0x0002000200020002ULL);

            AV_WN64A(bS[0][2], 0x0002000200020002ULL);

            AV_WN64A(bS[1][0], 0x0002000200020002ULL);

            AV_WN64A(bS[1][2], 0x0002000200020002ULL);

        } else {

            int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); //(mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0;

            int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); // (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (h->left_type[LTOP] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0;

            int step =  1+(mb_type>>24); //IS_8x8DCT(mb_type) ? 2 : 1;

            edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); //(mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;

            h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,

                                              h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE(h));

        }

        if( IS_INTRA(left_type) )

            AV_WN64A(bS[0][0], 0x0004000400040004ULL);

        if( IS_INTRA(top_type) )

            AV_WN64A(bS[1][0], FIELD_PICTURE(h) ? 0x0003000300030003ULL : 0x0004000400040004ULL);



#define FILTER(hv,dir,edge,intra)\

        if(AV_RN64A(bS[dir][edge])) {                                   \

            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\

            if(chroma){\

                if(chroma444){\

                    filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\

                    filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\

                } else if(!(edge&1)) {\

                    filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\

                    filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\

                }\

            }\

        }

        if(left_type)

            FILTER(v,0,0,1);

        if( edges == 1 ) {

            if(top_type)

                FILTER(h,1,0,1);

        } else if( IS_8x8DCT(mb_type) ) {

            FILTER(v,0,2,0);

            if(top_type)

                FILTER(h,1,0,1);

            FILTER(h,1,2,0);

        } else {

            FILTER(v,0,1,0);

            FILTER(v,0,2,0);

            FILTER(v,0,3,0);

            if(top_type)

                FILTER(h,1,0,1);

            FILTER(h,1,1,0);

            FILTER(h,1,2,0);

            FILTER(h,1,3,0);

        }

#undef FILTER

    }

}
 and probability:0.4685714285714286
code:static int h263_decode_init(AVCodecContext *avctx)

{

    MpegEncContext *s = avctx->priv_data;

    int i;



    s->avctx = avctx;

    s->out_format = FMT_H263;



    s->width = avctx->width;

    s->height = avctx->height;



    /* select sub codec */

    switch(avctx->codec->id) {

    case CODEC_ID_H263:

        s->gob_number = 0;

        s->first_gob_line = 0;

        break;

    case CODEC_ID_MPEG4:

        s->time_increment_bits = 4; /* default value for broken headers */

        s->h263_pred = 1;

        s->has_b_frames = 1; //default, might be overriden in the vol header during header parsing

        break;

    case CODEC_ID_MSMPEG4V1:

        s->h263_msmpeg4 = 1;

        s->h263_pred = 1;

        s->msmpeg4_version=1;

        break;

    case CODEC_ID_MSMPEG4V2:

        s->h263_msmpeg4 = 1;

        s->h263_pred = 1;

        s->msmpeg4_version=2;

        break;

    case CODEC_ID_MSMPEG4V3:

        s->h263_msmpeg4 = 1;

        s->h263_pred = 1;

        s->msmpeg4_version=3;

        break;

    case CODEC_ID_WMV1:

        s->h263_msmpeg4 = 1;

        s->h263_pred = 1;

        s->msmpeg4_version=4;

        break;

    case CODEC_ID_H263I:

        s->h263_intel = 1;

        break;

    default:

        return -1;

    }



    /* for h263, we allocate the images after having read the header */

    if (avctx->codec->id != CODEC_ID_H263 && avctx->codec->id != CODEC_ID_MPEG4)

        if (MPV_common_init(s) < 0)

            return -1;



    /* XXX: suppress this matrix init, only needed because using mpeg1

       dequantize in mmx case */

    for(i=0;i<64;i++)

        s->non_intra_matrix[i] = default_non_intra_matrix[i];



    if (s->h263_msmpeg4)

        msmpeg4_decode_init_vlc(s);

    else

        h263_decode_init_vlc(s);

    

    return 0;

}
 and probability:0.4745762711864407
code:static int spdif_write_packet(struct AVFormatContext *s, AVPacket *pkt)

{

    IEC958Context *ctx = s->priv_data;

    int ret, padding;




    ctx->out_bytes = pkt->size;

    ctx->length_code = FFALIGN(pkt->size, 2) << 3;



    ret = ctx->header_info(s, pkt);

    if (ret < 0)

        return -1;

    if (!ctx->pkt_offset)

        return 0;



    padding = (ctx->pkt_offset - BURST_HEADER_SIZE - ctx->out_bytes) >> 1;

    if (padding < 0) {

        av_log(s, AV_LOG_ERROR, "bitrate is too high\n");

        return -1;

    }



    put_le16(s->pb, SYNCWORD1);      //Pa

    put_le16(s->pb, SYNCWORD2);      //Pb

    put_le16(s->pb, ctx->data_type); //Pc

    put_le16(s->pb, ctx->length_code);//Pd



#if HAVE_BIGENDIAN

    put_buffer(s->pb, ctx->out_buf, ctx->out_bytes & ~1);

#else

    av_fast_malloc(&ctx->buffer, &ctx->buffer_size, ctx->out_bytes + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!ctx->buffer)

        return AVERROR(ENOMEM);

    ff_spdif_bswap_buf16((uint16_t *)ctx->buffer, (uint16_t *)ctx->out_buf, ctx->out_bytes >> 1);

    put_buffer(s->pb, ctx->buffer, ctx->out_bytes & ~1);

#endif



    if (ctx->out_bytes & 1)

        put_be16(s->pb, ctx->out_buf[ctx->out_bytes - 1]);



    for (; padding > 0; padding--)

        put_be16(s->pb, 0);



    av_log(s, AV_LOG_DEBUG, "type=%x len=%i pkt_offset=%i\n",

           ctx->data_type, ctx->out_bytes, ctx->pkt_offset);



    put_flush_packet(s->pb);

    return 0;

} and probability:0.5526315789473685
code:static void blkverify_refresh_filename(BlockDriverState *bs, QDict *options)

{

    BDRVBlkverifyState *s = bs->opaque;



    /* bs->file->bs has already been refreshed */

    bdrv_refresh_filename(s->test_file->bs);



    if (bs->file->bs->full_open_options

        && s->test_file->bs->full_open_options)

    {

        QDict *opts = qdict_new();

        qdict_put_str(opts, "driver", "blkverify");



        QINCREF(bs->file->bs->full_open_options);

        qdict_put(opts, "raw", bs->file->bs->full_open_options);

        QINCREF(s->test_file->bs->full_open_options);

        qdict_put(opts, "test", s->test_file->bs->full_open_options);



        bs->full_open_options = opts;

    }



    if (bs->file->bs->exact_filename[0]

        && s->test_file->bs->exact_filename[0])

    {

        snprintf(bs->exact_filename, sizeof(bs->exact_filename),

                 "blkverify:%s:%s",

                 bs->file->bs->exact_filename,

                 s->test_file->bs->exact_filename);

    }

}
 and probability:0.56
code:static int ffmmal_read_frame(AVCodecContext *avctx, AVFrame *frame, int *got_frame)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    MMAL_BUFFER_HEADER_T *buffer = NULL;

    MMAL_STATUS_T status = 0;

    int ret = 0;



    if (ctx->eos_received)

        goto done;



    while (1) {

        // To ensure decoding in lockstep with a constant delay between fed packets

        // and output frames, we always wait until an output buffer is available.

        // Except during start we don't know after how many input packets the decoder

        // is going to return the first buffer, and we can't distinguish decoder

        // being busy from decoder waiting for input. So just poll at the start and

        // keep feeding new data to the buffer.

        // We are pretty sure the decoder will produce output if we sent more input

        // frames than what a h264 decoder could logically delay. This avoids too

        // excessive buffering.

        // We also wait if we sent eos, but didn't receive it yet (think of decoding

        // stream with a very low number of frames).

        if (ctx->frames_output || ctx->packets_sent > MAX_DELAYED_FRAMES || ctx->eos_sent) {

            buffer = mmal_queue_wait(ctx->queue_decoded_frames);

        } else {

            buffer = mmal_queue_get(ctx->queue_decoded_frames);

        }

        if (!buffer)

            goto done;



        ctx->eos_received |= !!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_EOS);

        if (ctx->eos_received)

            goto done;



        if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED) {

            MMAL_COMPONENT_T *decoder = ctx->decoder;

            MMAL_EVENT_FORMAT_CHANGED_T *ev = mmal_event_format_changed_get(buffer);

            MMAL_BUFFER_HEADER_T *stale_buffer;



            av_log(avctx, AV_LOG_INFO, "Changing output format.\n");



            if ((status = mmal_port_disable(decoder->output[0])))

                goto done;



            while ((stale_buffer = mmal_queue_get(ctx->queue_decoded_frames)))

                mmal_buffer_header_release(stale_buffer);



            mmal_format_copy(decoder->output[0]->format, ev->format);



            if ((ret = ffmal_update_format(avctx)) < 0)

                goto done;



            if ((status = mmal_port_enable(decoder->output[0], output_callback)))

                goto done;



            if ((ret = ffmmal_fill_output_port(avctx)) < 0)

                goto done;



            if ((ret = ffmmal_fill_input_port(avctx)) < 0)

                goto done;



            mmal_buffer_header_release(buffer);

            continue;

        } else if (buffer->cmd) {

            char s[20];

            av_get_codec_tag_string(s, sizeof(s), buffer->cmd);

            av_log(avctx, AV_LOG_WARNING, "Unknown MMAL event %s on output port\n", s);

            goto done;

        } else if (buffer->length == 0) {

            // Unused output buffer that got drained after format change.

            mmal_buffer_header_release(buffer);

            continue;

        }



        ctx->frames_output++;



        if ((ret = ffmal_copy_frame(avctx, frame, buffer)) < 0)

            goto done;



        *got_frame = 1;

        break;

    }



done:

    if (buffer)

        mmal_buffer_header_release(buffer);

    if (status && ret >= 0)

        ret = AVERROR_UNKNOWN;

    return ret;

}
 and probability:0.2465753424657534
code:void ff_sbrdsp_init_x86(SBRDSPContext *s)

{

    if (HAVE_YASM) {

        int mm_flags = av_get_cpu_flags();



        if (mm_flags & AV_CPU_FLAG_SSE) {

            s->sum_square = ff_sbr_sum_square_sse;

            s->hf_g_filt = ff_sbr_hf_g_filt_sse;

        }

    }

}
 and probability:0.2
code:static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)

{

    struct usbdevfs_urb *urb;

    AsyncURB *aurb;

    int ret, value, index;



    /* 

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */

    value = le16_to_cpu(s->ctrl.req.wValue);

    index = le16_to_cpu(s->ctrl.req.wIndex);



    dprintf("husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\n",

        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, 

        s->ctrl.len);



    if (s->ctrl.req.bRequestType == 0) {

        switch (s->ctrl.req.bRequest) {

        case USB_REQ_SET_ADDRESS:

            return usb_host_set_address(s, value);



        case USB_REQ_SET_CONFIGURATION:

            return usb_host_set_config(s, value & 0xff);

        }

    }



    if (s->ctrl.req.bRequestType == 1 &&

                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)

        return usb_host_set_interface(s, index, value);



    /* The rest are asynchronous */



    aurb = async_alloc();

    aurb->hdev   = s;

    aurb->packet = p;



    /* 

     * Setup ctrl transfer.

     *

     * s->ctrl is layed out such that data buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */ 

    urb = &aurb->urb;



    urb->type     = USBDEVFS_URB_TYPE_CONTROL;

    urb->endpoint = p->devep;



    urb->buffer        = &s->ctrl.req;

    urb->buffer_length = 8 + s->ctrl.len;



    urb->usercontext = s;



    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);



    dprintf("husb: submit ctrl. len %u aurb %p\n", urb->buffer_length, aurb);



    if (ret < 0) {

        dprintf("husb: submit failed. errno %d\n", errno);

        async_free(aurb);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    usb_defer_packet(p, async_cancel, aurb);

    return USB_RET_ASYNC;

}
 and probability:0.3157894736842105
code:static void pc_init1(MachineState *machine)

{

    PCMachineState *pc_machine = PC_MACHINE(machine);

    MemoryRegion *system_memory = get_system_memory();

    MemoryRegion *system_io = get_system_io();

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    ISABus *isa_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *gsi;

    qemu_irq *i8259;

    qemu_irq *smi_irq;

    GSIState *gsi_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;

    ISADevice *floppy;

    MemoryRegion *ram_memory;

    MemoryRegion *pci_memory;

    MemoryRegion *rom_memory;

    DeviceState *icc_bridge;

    FWCfgState *fw_cfg = NULL;

    PcGuestInfo *guest_info;

    ram_addr_t lowmem;



    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).

     * If it doesn't, we need to split it in chunks below and above 4G.

     * In any case, try to make sure that guest addresses aligned at

     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.

     * For old machine types, use whatever split we used historically to avoid

     * breaking migration.

     */

    if (machine->ram_size >= 0xe0000000) {

        lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;

    } else {

        lowmem = 0xe0000000;

    }



    /* Handle the machine opt max-ram-below-4g.  It is basically doing

     * min(qemu limit, user limit).

     */

    if (lowmem > pc_machine->max_ram_below_4g) {

        lowmem = pc_machine->max_ram_below_4g;

        if (machine->ram_size - lowmem > lowmem &&

            lowmem & ((1ULL << 30) - 1)) {

            error_report("Warning: Large machine and max_ram_below_4g(%"PRIu64

                         ") not a multiple of 1G; possible bad performance.",

                         pc_machine->max_ram_below_4g);

        }

    }



    if (machine->ram_size >= lowmem) {

        above_4g_mem_size = machine->ram_size - lowmem;

        below_4g_mem_size = lowmem;

    } else {

        above_4g_mem_size = 0;

        below_4g_mem_size = machine->ram_size;

    }



    if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,

                                      &ram_memory) != 0) {

        fprintf(stderr, "xen hardware virtual machine initialisation failed\n");

        exit(1);

    }



    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);

    object_property_add_child(qdev_get_machine(), "icc-bridge",

                              OBJECT(icc_bridge), NULL);



    pc_cpus_init(machine->cpu_model, icc_bridge);



    if (kvm_enabled() && kvmclock_enabled) {

        kvmclock_create();

    }



    if (pci_enabled) {

        pci_memory = g_new(MemoryRegion, 1);

        memory_region_init(pci_memory, NULL, "pci", UINT64_MAX);

        rom_memory = pci_memory;

    } else {

        pci_memory = NULL;

        rom_memory = system_memory;

    }



    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);



    guest_info->has_acpi_build = has_acpi_build;

    guest_info->legacy_acpi_table_size = legacy_acpi_table_size;



    guest_info->isapc_ram_fw = !pci_enabled;

    guest_info->has_reserved_memory = has_reserved_memory;

    guest_info->rsdp_in_ram = rsdp_in_ram;



    if (smbios_defaults) {

        MachineClass *mc = MACHINE_GET_CLASS(machine);

        /* These values are guest ABI, do not change */

        smbios_set_defaults("QEMU", "Standard PC (i440FX + PIIX, 1996)",

                            mc->name, smbios_legacy_mode, smbios_uuid_encoded);

    }



    /* allocate ram and load rom/bios */

    if (!xen_enabled()) {

        fw_cfg = pc_memory_init(machine, system_memory,

                                below_4g_mem_size, above_4g_mem_size,

                                rom_memory, &ram_memory, guest_info);

    } else if (machine->kernel_filename != NULL) {

        /* For xen HVM direct kernel boot, load linux here */

        fw_cfg = xen_load_linux(machine->kernel_filename,

                                machine->kernel_cmdline,

                                machine->initrd_filename,

                                below_4g_mem_size,

                                guest_info);

    }



    gsi_state = g_malloc0(sizeof(*gsi_state));

    if (kvm_irqchip_in_kernel()) {

        kvm_pc_setup_irq_routing(pci_enabled);

        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,

                                 GSI_NUM_PINS);

    } else {

        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);

    }



    if (pci_enabled) {

        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,

                              system_memory, system_io, machine->ram_size,

                              below_4g_mem_size,

                              above_4g_mem_size,

                              pci_memory, ram_memory);

    } else {

        pci_bus = NULL;

        i440fx_state = NULL;

        isa_bus = isa_bus_new(NULL, get_system_memory(), system_io);

        no_hpet = 1;

    }

    isa_bus_irqs(isa_bus, gsi);



    if (kvm_irqchip_in_kernel()) {

        i8259 = kvm_i8259_init(isa_bus);

    } else if (xen_enabled()) {

        i8259 = xen_interrupt_controller_init();

    } else {

        cpu_irq = pc_allocate_cpu_irq();

        i8259 = i8259_init(isa_bus, cpu_irq[0]);

    }



    for (i = 0; i < ISA_NUM_IRQS; i++) {

        gsi_state->i8259_irq[i] = i8259[i];

    }

    if (pci_enabled) {

        ioapic_init_gsi(gsi_state, "i440fx");

    }

    qdev_init_nofail(icc_bridge);



    pc_register_ferr_irq(gsi[13]);



    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);



    assert(pc_machine->vmport != ON_OFF_AUTO_MAX);

    if (pc_machine->vmport == ON_OFF_AUTO_AUTO) {

        pc_machine->vmport = xen_enabled() ? ON_OFF_AUTO_OFF : ON_OFF_AUTO_ON;

    }



    /* init basic PC hardware */

    pc_basic_device_init(isa_bus, gsi, &rtc_state, true, &floppy,

                         (pc_machine->vmport != ON_OFF_AUTO_ON), 0x4);



    pc_nic_init(isa_bus, pci_bus);



    ide_drive_get(hd, ARRAY_SIZE(hd));

    if (pci_enabled) {

        PCIDevice *dev;

        if (xen_enabled()) {

            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);

        } else {

            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);

        }

        idebus[0] = qdev_get_child_bus(&dev->qdev, "ide.0");

        idebus[1] = qdev_get_child_bus(&dev->qdev, "ide.1");

    } else {

        for(i = 0; i < MAX_IDE_BUS; i++) {

            ISADevice *dev;

            char busname[] = "ide.0";

            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],

                               ide_irq[i],

                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);

            /*

             * The ide bus name is ide.0 for the first bus and ide.1 for the

             * second one.

             */

            busname[4] = '0' + i;

            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);

        }

    }



    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, machine->boot_order,

                 machine, floppy, idebus[0], idebus[1], rtc_state);



    if (pci_enabled && usb_enabled()) {

        pci_create_simple(pci_bus, piix3_devfn + 2, "piix3-usb-uhci");

    }



    if (pci_enabled && acpi_enabled) {

        DeviceState *piix4_pm;

        I2CBus *smbus;



        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);

        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,

                              gsi[9], *smi_irq,

                              kvm_enabled(), fw_cfg, &piix4_pm);

        smbus_eeprom_init(smbus, 8, NULL, 0);



        object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,

                                 TYPE_HOTPLUG_HANDLER,

                                 (Object **)&pc_machine->acpi_dev,

                                 object_property_allow_set_link,

                                 OBJ_PROP_LINK_UNREF_ON_RELEASE, &error_abort);

        object_property_set_link(OBJECT(machine), OBJECT(piix4_pm),

                                 PC_MACHINE_ACPI_DEVICE_PROP, &error_abort);

    }



    if (pci_enabled) {

        pc_pci_device_init(pci_bus);

    }

}
 and probability:0.235
code:static void parse_type_int64(Visitor *v, const char *name, int64_t *obj,

                             Error **errp)

{

    StringInputVisitor *siv = to_siv(v);



    if (!siv->string) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : "null",

                   "integer");

        return;

    }



    parse_str(siv, errp);



    if (!siv->ranges) {

        goto error;

    }



    if (!siv->cur_range) {

        Range *r;



        siv->cur_range = g_list_first(siv->ranges);

        if (!siv->cur_range) {

            goto error;

        }



        r = siv->cur_range->data;

        if (!r) {

            goto error;

        }



        siv->cur = r->begin;

    }



    *obj = siv->cur;

    siv->cur++;

    return;



error:

    error_setg(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : "null",

               "an int64 value or range");

}
 and probability:0.28125
code:void qemu_chr_be_write(CharDriverState *s, uint8_t *buf, int len)

{

    s->chr_read(s->handler_opaque, buf, len);

}
 and probability:0.25
code:static void virtio_set_status(struct subchannel_id schid,

                              unsigned long dev_addr)

{

    unsigned char status = dev_addr;

    if (run_ccw(schid, CCW_CMD_WRITE_STATUS, &status, sizeof(status))) {

        virtio_panic("Could not write status to host!\n");

    }

}
 and probability:0.0
code:uint32_t do_arm_semihosting(CPUState *env)

{

    target_ulong args;

    char * s;

    int nr;

    uint32_t ret;

    uint32_t len;

#ifdef CONFIG_USER_ONLY

    TaskState *ts = env->opaque;

#else

    CPUState *ts = env;

#endif



    nr = env->regs[0];

    args = env->regs[1];

    switch (nr) {

    case SYS_OPEN:

        if (!(s = lock_user_string(ARG(0))))

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        if (ARG(1) >= 12)

            return (uint32_t)-1;

        if (strcmp(s, ":tt") == 0) {

            if (ARG(1) < 4)

                return STDIN_FILENO;

            else

                return STDOUT_FILENO;

        }

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "open,%s,%x,1a4", ARG(0),

			   (int)ARG(2)+1, gdb_open_modeflags[ARG(1)]);

            return env->regs[0];

        } else {

            ret = set_swi_errno(ts, open(s, open_modeflags[ARG(1)], 0644));

        }

        unlock_user(s, ARG(0), 0);

        return ret;

    case SYS_CLOSE:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "close,%x", ARG(0));

            return env->regs[0];

        } else {

            return set_swi_errno(ts, close(ARG(0)));

        }

    case SYS_WRITEC:

        {

          char c;



          if (get_user_u8(c, args))

              /* FIXME - should this error code be -TARGET_EFAULT ? */

              return (uint32_t)-1;

          /* Write to debug console.  stderr is near enough.  */

          if (use_gdb_syscalls()) {

                gdb_do_syscall(arm_semi_cb, "write,2,%x,1", args);

                return env->regs[0];

          } else {

                return write(STDERR_FILENO, &c, 1);

          }

        }

    case SYS_WRITE0:

        if (!(s = lock_user_string(args)))

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        len = strlen(s);

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "write,2,%x,%x\n", args, len);

            ret = env->regs[0];

        } else {

            ret = write(STDERR_FILENO, s, len);

        }

        unlock_user(s, args, 0);

        return ret;

    case SYS_WRITE:

        len = ARG(2);

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            gdb_do_syscall(arm_semi_cb, "write,%x,%x,%x", ARG(0), ARG(1), len);

            return env->regs[0];

        } else {

            if (!(s = lock_user(VERIFY_READ, ARG(1), len, 1)))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            ret = set_swi_errno(ts, write(ARG(0), s, len));

            unlock_user(s, ARG(1), 0);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case SYS_READ:

        len = ARG(2);

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            gdb_do_syscall(arm_semi_cb, "read,%x,%x,%x", ARG(0), ARG(1), len);

            return env->regs[0];

        } else {

            if (!(s = lock_user(VERIFY_WRITE, ARG(1), len, 0)))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            do

              ret = set_swi_errno(ts, read(ARG(0), s, len));

            while (ret == -1 && errno == EINTR);

            unlock_user(s, ARG(1), len);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case SYS_READC:

       /* XXX: Read from debug cosole. Not implemented.  */

        return 0;

    case SYS_ISTTY:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "isatty,%x", ARG(0));

            return env->regs[0];

        } else {

            return isatty(ARG(0));

        }

    case SYS_SEEK:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "lseek,%x,%x,0", ARG(0), ARG(1));

            return env->regs[0];

        } else {

            ret = set_swi_errno(ts, lseek(ARG(0), ARG(1), SEEK_SET));

            if (ret == (uint32_t)-1)

              return -1;

            return 0;

        }

    case SYS_FLEN:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_flen_cb, "fstat,%x,%x",

			   ARG(0), env->regs[13]-64);

            return env->regs[0];

        } else {

            struct stat buf;

            ret = set_swi_errno(ts, fstat(ARG(0), &buf));

            if (ret == (uint32_t)-1)

                return -1;

            return buf.st_size;

        }

    case SYS_TMPNAM:

        /* XXX: Not implemented.  */

        return -1;

    case SYS_REMOVE:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "unlink,%s", ARG(0), (int)ARG(1)+1);

            ret = env->regs[0];

        } else {

            if (!(s = lock_user_string(ARG(0))))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            ret =  set_swi_errno(ts, remove(s));

            unlock_user(s, ARG(0), 0);

        }

        return ret;

    case SYS_RENAME:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "rename,%s,%s",

                           ARG(0), (int)ARG(1)+1, ARG(2), (int)ARG(3)+1);

            return env->regs[0];

        } else {

            char *s2;

            s = lock_user_string(ARG(0));

            s2 = lock_user_string(ARG(2));

            if (!s || !s2)

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                ret = (uint32_t)-1;

            else

                ret = set_swi_errno(ts, rename(s, s2));

            if (s2)

                unlock_user(s2, ARG(2), 0);

            if (s)

                unlock_user(s, ARG(0), 0);

            return ret;

        }

    case SYS_CLOCK:

        return clock() / (CLOCKS_PER_SEC / 100);

    case SYS_TIME:

        return set_swi_errno(ts, time(NULL));

    case SYS_SYSTEM:

        if (use_gdb_syscalls()) {

            gdb_do_syscall(arm_semi_cb, "system,%s", ARG(0), (int)ARG(1)+1);

            return env->regs[0];

        } else {

            if (!(s = lock_user_string(ARG(0))))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            ret = set_swi_errno(ts, system(s));

            unlock_user(s, ARG(0), 0);

            return ret;

        }

    case SYS_ERRNO:

#ifdef CONFIG_USER_ONLY

        return ts->swi_errno;

#else

        return syscall_err;

#endif

    case SYS_GET_CMDLINE:

#ifdef CONFIG_USER_ONLY

        /* Build a commandline from the original argv.  */

        {

            char *arm_cmdline_buffer;

            const char *host_cmdline_buffer;



            unsigned int i;

            unsigned int arm_cmdline_len = ARG(1);

            unsigned int host_cmdline_len =

                ts->info->arg_end-ts->info->arg_start;



            if (!arm_cmdline_len || host_cmdline_len > arm_cmdline_len) {

                return -1; /* not enough space to store command line */

            }



            if (!host_cmdline_len) {

                /* We special-case the "empty command line" case (argc==0).

                   Just provide the terminating 0. */

                arm_cmdline_buffer = lock_user(VERIFY_WRITE, ARG(0), 1, 0);

                arm_cmdline_buffer[0] = 0;

                unlock_user(arm_cmdline_buffer, ARG(0), 1);



                /* Adjust the commandline length argument. */

                SET_ARG(1, 0);

                return 0;

            }



            /* lock the buffers on the ARM side */

            arm_cmdline_buffer =

                lock_user(VERIFY_WRITE, ARG(0), host_cmdline_len, 0);

            host_cmdline_buffer =

                lock_user(VERIFY_READ, ts->info->arg_start,

                                       host_cmdline_len, 1);



            if (arm_cmdline_buffer && host_cmdline_buffer)

            {

                /* the last argument is zero-terminated;

                   no need for additional termination */

                memcpy(arm_cmdline_buffer, host_cmdline_buffer,

                       host_cmdline_len);



                /* separate arguments by white spaces */

                for (i = 0; i < host_cmdline_len-1; i++) {

                    if (arm_cmdline_buffer[i] == 0) {

                        arm_cmdline_buffer[i] = ' ';

                    }

                }



                /* Adjust the commandline length argument. */

                SET_ARG(1, host_cmdline_len-1);

            }



            /* Unlock the buffers on the ARM side.  */

            unlock_user(arm_cmdline_buffer, ARG(0), host_cmdline_len);

            unlock_user((void*)host_cmdline_buffer, ts->info->arg_start, 0);



            /* Return success if we could return a commandline.  */

            return (arm_cmdline_buffer && host_cmdline_buffer) ? 0 : -1;

        }

#else

        return -1;

#endif

    case SYS_HEAPINFO:

        {

            uint32_t *ptr;

            uint32_t limit;



#ifdef CONFIG_USER_ONLY

            /* Some C libraries assume the heap immediately follows .bss, so

               allocate it using sbrk.  */

            if (!ts->heap_limit) {

                long ret;



                ts->heap_base = do_brk(0);

                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;

                /* Try a big heap, and reduce the size if that fails.  */

                for (;;) {

                    ret = do_brk(limit);

                    if (ret != -1)

                        break;

                    limit = (ts->heap_base >> 1) + (limit >> 1);

                }

                ts->heap_limit = limit;

            }



            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            ptr[0] = tswap32(ts->heap_base);

            ptr[1] = tswap32(ts->heap_limit);

            ptr[2] = tswap32(ts->stack_base);

            ptr[3] = tswap32(0); /* Stack limit.  */

            unlock_user(ptr, ARG(0), 16);

#else

            limit = ram_size;

            if (!(ptr = lock_user(VERIFY_WRITE, ARG(0), 16, 0)))

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            /* TODO: Make this use the limit of the loaded application.  */

            ptr[0] = tswap32(limit / 2);

            ptr[1] = tswap32(limit);

            ptr[2] = tswap32(limit); /* Stack base */

            ptr[3] = tswap32(0); /* Stack limit.  */

            unlock_user(ptr, ARG(0), 16);

#endif

            return 0;

        }

    case SYS_EXIT:

        gdb_exit(env, 0);

        exit(0);

    default:

        fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);

        cpu_dump_state(env, stderr, fprintf, 0);

        abort();

    }

}
 and probability:0.15824915824915825
code:int inet_connect(const char *str, Error **errp)

{

    QemuOpts *opts;

    int sock = -1;



    opts = qemu_opts_create(&dummy_opts, NULL, 0, NULL);

    if (inet_parse(opts, str) == 0) {

        sock = inet_connect_opts(opts, true, NULL, errp);

    } else {

        error_set(errp, QERR_SOCKET_CREATE_FAILED);

    }

    qemu_opts_del(opts);

    return sock;

}
 and probability:0.0
code:static void do_interrupt_user(CPUX86State *env, int intno, int is_int,

                              int error_code, target_ulong next_eip)

{

    SegmentCache *dt;

    target_ulong ptr;

    int dpl, cpl, shift;

    uint32_t e2;



    dt = &env->idt;

    if (env->hflags & HF_LMA_MASK) {

        shift = 4;

    } else {

        shift = 3;

    }

    ptr = dt->base + (intno << shift);

    e2 = cpu_ldl_kernel(env, ptr + 4);



    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, (intno << shift) + 2);

    }



    /* Since we emulate only user space, we cannot do more than

       exiting the emulation with the suitable exception and error

       code. So update EIP for INT 0x80 and EXCP_SYSCALL. */

    if (is_int || intno == EXCP_SYSCALL) {

        env->eip = next_eip;

    }

}
 and probability:0.25
code:static int64_t load_kernel(void)

{

    int64_t entry, kernel_high;

    long kernel_size, initrd_size, params_size;

    ram_addr_t initrd_offset;

    uint32_t *params_buf;

    int big_endian;



#ifdef TARGET_WORDS_BIGENDIAN

    big_endian = 1;

#else

    big_endian = 0;

#endif

    kernel_size = load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys,

                           NULL, (uint64_t *)&entry, NULL,

                           (uint64_t *)&kernel_high, big_endian,

                           ELF_MACHINE, 1);

    if (kernel_size >= 0) {

        if ((entry & ~0x7fffffffULL) == 0x80000000)

            entry = (int32_t)entry;

    } else {

        fprintf(stderr, "qemu: could not load kernel '%s'\n",

                loaderparams.kernel_filename);

        exit(1);

    }



    /* load initrd */

    initrd_size = 0;

    initrd_offset = 0;

    if (loaderparams.initrd_filename) {

        initrd_size = get_image_size (loaderparams.initrd_filename);

        if (initrd_size > 0) {

            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;

            if (initrd_offset + initrd_size > ram_size) {

                fprintf(stderr,

                        "qemu: memory too small for initial ram disk '%s'\n",

                        loaderparams.initrd_filename);

                exit(1);

            }

            initrd_size = load_image_targphys(loaderparams.initrd_filename,

                                              initrd_offset,

                                              ram_size - initrd_offset);

        }

        if (initrd_size == (target_ulong) -1) {

            fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",

                    loaderparams.initrd_filename);

            exit(1);

        }

    }



    /* Store command line.  */

    params_size = 264;

    params_buf = g_malloc(params_size);



    params_buf[0] = tswap32(ram_size);

    params_buf[1] = tswap32(0x12345678);



    if (initrd_size > 0) {

        snprintf((char *)params_buf + 8, 256, "rd_start=0x%" PRIx64 " rd_size=%li %s",

                 cpu_mips_phys_to_kseg0(NULL, initrd_offset),

                 initrd_size, loaderparams.kernel_cmdline);

    } else {

        snprintf((char *)params_buf + 8, 256, "%s", loaderparams.kernel_cmdline);

    }



    rom_add_blob_fixed("params", params_buf, params_size,

                       (16 << 20) - 264);




    return entry;

} and probability:0.14285714285714285
code:static int cin_read_frame_header(CinDemuxContext *cin, AVIOContext *pb) {

    CinFrameHeader *hdr = &cin->frame_header;



    hdr->video_frame_type = avio_r8(pb);

    hdr->audio_frame_type = avio_r8(pb);

    hdr->pal_colors_count = avio_rl16(pb);

    hdr->video_frame_size = avio_rl32(pb);

    hdr->audio_frame_size = avio_rl32(pb);



    if (pb->eof_reached || pb->error)

        return AVERROR(EIO);



    if (avio_rl32(pb) != 0xAA55AA55)






    return 0;

} and probability:0.5833333333333334
code:static void test_endianness_combine(gconstpointer data)

{

    const TestCase *test = data;

    char *args;



    args = g_strdup_printf("-display none -M %s%s%s -device pc-testdev",

                           test->machine,

                           test->superio ? " -device " : "",

                           test->superio ?: "");

    qtest_start(args);

    isa_outl(test, 0xe0, 0x87654321);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654321);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);



    isa_outw(test, 0xe2, 0x8866);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x88664321);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8866);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);



    isa_outw(test, 0xe0, 0x4422);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x88664422);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8866);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4422);



    isa_outb(test, 0xe3, 0x87);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87664422);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8766);



    isa_outb(test, 0xe2, 0x65);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654422);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4422);



    isa_outb(test, 0xe1, 0x43);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654322);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4322);



    isa_outb(test, 0xe0, 0x21);

    g_assert_cmphex(isa_inl(test, 0xe8), ==, 0x87654321);

    g_assert_cmphex(isa_inw(test, 0xea), ==, 0x8765);

    g_assert_cmphex(isa_inw(test, 0xe8), ==, 0x4321);

    qtest_quit(global_qtest);

    g_free(args);

}
 and probability:0.07692307692307693
code:int avpicture_deinterlace(AVPicture *dst, const AVPicture *src,

                          enum AVPixelFormat pix_fmt, int width, int height)

{

    int i;



    if (pix_fmt != AV_PIX_FMT_YUV420P &&

        pix_fmt != AV_PIX_FMT_YUVJ420P &&

        pix_fmt != AV_PIX_FMT_YUV422P &&

        pix_fmt != AV_PIX_FMT_YUVJ422P &&

        pix_fmt != AV_PIX_FMT_YUV444P &&

        pix_fmt != AV_PIX_FMT_YUV411P &&

        pix_fmt != AV_PIX_FMT_GRAY8)

        return -1;

    if ((width & 3) != 0 || (height & 3) != 0)

        return -1;



    for(i=0;i<3;i++) {

        if (i == 1) {

            switch(pix_fmt) {

            case AV_PIX_FMT_YUVJ420P:

            case AV_PIX_FMT_YUV420P:

                width >>= 1;

                height >>= 1;

                break;

            case AV_PIX_FMT_YUV422P:

            case AV_PIX_FMT_YUVJ422P:

                width >>= 1;

                break;

            case AV_PIX_FMT_YUV411P:

                width >>= 2;

                break;

            default:

                break;

            }

            if (pix_fmt == AV_PIX_FMT_GRAY8) {

                break;

            }

        }

        if (src == dst) {

            deinterlace_bottom_field_inplace(dst->data[i], dst->linesize[i],

                                 width, height);

        } else {

            deinterlace_bottom_field(dst->data[i],dst->linesize[i],

                                        src->data[i], src->linesize[i],

                                        width, height);

        }

    }

    emms_c();

    return 0;

}
 and probability:0.08333333333333333
code:static void chroma_mc(HEVCContext *s, int16_t *dst1, int16_t *dst2,

                      ptrdiff_t dststride, AVFrame *ref, const Mv *mv,

                      int x_off, int y_off, int block_w, int block_h)

{

    HEVCLocalContext *lc = &s->HEVClc;

    uint8_t *src1        = ref->data[1];

    uint8_t *src2        = ref->data[2];

    ptrdiff_t src1stride = ref->linesize[1];

    ptrdiff_t src2stride = ref->linesize[2];

    int pic_width        = s->ps.sps->width >> 1;

    int pic_height       = s->ps.sps->height >> 1;



    int mx = mv->x & 7;

    int my = mv->y & 7;



    x_off += mv->x >> 3;

    y_off += mv->y >> 3;

    src1  += y_off * src1stride + (x_off << s->ps.sps->pixel_shift);

    src2  += y_off * src2stride + (x_off << s->ps.sps->pixel_shift);



    if (x_off < EPEL_EXTRA_BEFORE || y_off < EPEL_EXTRA_AFTER ||

        x_off >= pic_width - block_w - EPEL_EXTRA_AFTER ||

        y_off >= pic_height - block_h - EPEL_EXTRA_AFTER) {

        const int edge_emu_stride = EDGE_EMU_BUFFER_STRIDE << s->ps.sps->pixel_shift;

        int offset1 = EPEL_EXTRA_BEFORE * (src1stride + (1 << s->ps.sps->pixel_shift));

        int buf_offset1 = EPEL_EXTRA_BEFORE *

                          (edge_emu_stride + (1 << s->ps.sps->pixel_shift));

        int offset2 = EPEL_EXTRA_BEFORE * (src2stride + (1 << s->ps.sps->pixel_shift));

        int buf_offset2 = EPEL_EXTRA_BEFORE *

                          (edge_emu_stride + (1 << s->ps.sps->pixel_shift));



        s->vdsp.emulated_edge_mc(lc->edge_emu_buffer, src1 - offset1,

                                 edge_emu_stride, src1stride,

                                 block_w + EPEL_EXTRA, block_h + EPEL_EXTRA,

                                 x_off - EPEL_EXTRA_BEFORE,

                                 y_off - EPEL_EXTRA_BEFORE,

                                 pic_width, pic_height);



        src1 = lc->edge_emu_buffer + buf_offset1;

        src1stride = edge_emu_stride;

        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst1, dststride, src1, src1stride,

                                             block_w, block_h, mx, my, lc->mc_buffer);



        s->vdsp.emulated_edge_mc(lc->edge_emu_buffer, src2 - offset2,

                                 edge_emu_stride, src2stride,

                                 block_w + EPEL_EXTRA, block_h + EPEL_EXTRA,

                                 x_off - EPEL_EXTRA_BEFORE,

                                 y_off - EPEL_EXTRA_BEFORE,

                                 pic_width, pic_height);

        src2 = lc->edge_emu_buffer + buf_offset2;

        src2stride = edge_emu_stride;



        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst2, dststride, src2, src2stride,

                                             block_w, block_h, mx, my,

                                             lc->mc_buffer);

    } else {

        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst1, dststride, src1, src1stride,

                                             block_w, block_h, mx, my,

                                             lc->mc_buffer);

        s->hevcdsp.put_hevc_epel[!!my][!!mx](dst2, dststride, src2, src2stride,

                                             block_w, block_h, mx, my,

                                             lc->mc_buffer);

    }

}
 and probability:0.7017543859649122
code:static void mpegts_push_data(void *opaque,

                             const uint8_t *buf, int buf_size, int is_start)

{

    PESContext *pes = opaque;

    MpegTSContext *ts = pes->stream->priv_data;

    AVStream *st;

    const uint8_t *p;

    int len, code, codec_type, codec_id;

    

    if (is_start) {

        pes->state = MPEGTS_HEADER;

        pes->data_index = 0;

    }

    p = buf;

    while (buf_size > 0) {

        switch(pes->state) {

        case MPEGTS_HEADER:

            len = PES_START_SIZE - pes->data_index;

            if (len > buf_size)

                len = buf_size;

            memcpy(pes->header + pes->data_index, p, len);

            pes->data_index += len;

            p += len;

            buf_size -= len;

            if (pes->data_index == PES_START_SIZE) {

                /* we got all the PES or section header. We can now

                   decide */

#if 0

                av_hex_dump(pes->header, pes->data_index);

#endif

                if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&

                    pes->header[2] == 0x01) {

                    /* it must be an mpeg2 PES stream */

                    /* XXX: add AC3 support */

                    code = pes->header[3] | 0x100;

                    if (!((code >= 0x1c0 && code <= 0x1df) ||

                          (code >= 0x1e0 && code <= 0x1ef)))

                        goto skip;

                    if (!pes->st) {

                        /* allocate stream */

                        if (code >= 0x1c0 && code <= 0x1df) {

                            codec_type = CODEC_TYPE_AUDIO;

                            codec_id = CODEC_ID_MP2;

                        } else {

                            codec_type = CODEC_TYPE_VIDEO;

                            codec_id = CODEC_ID_MPEG1VIDEO;

                        }

                        st = av_new_stream(pes->stream, pes->pid);

                        if (st) {

                            st->priv_data = pes;

                            st->codec.codec_type = codec_type;

                            st->codec.codec_id = codec_id;

                            pes->st = st;

                        }

                    }

                    pes->state = MPEGTS_PESHEADER_FILL;

                    pes->total_size = (pes->header[4] << 8) | pes->header[5];

                    /* NOTE: a zero total size means the PES size is

                       unbounded */

                    if (pes->total_size)

                        pes->total_size += 6;

                    pes->pes_header_size = pes->header[8] + 9;

                } else {

                    /* otherwise, it should be a table */

                    /* skip packet */

                skip:

                    pes->state = MPEGTS_SKIP;

                    continue;

                }

            }

            break;

            /**********************************************/

            /* PES packing parsing */

        case MPEGTS_PESHEADER_FILL:

            len = pes->pes_header_size - pes->data_index;

            if (len > buf_size)

                len = buf_size;

            memcpy(pes->header + pes->data_index, p, len);

            pes->data_index += len;

            p += len;

            buf_size -= len;

            if (pes->data_index == pes->pes_header_size) {

                const uint8_t *r;

                unsigned int flags;



                flags = pes->header[7];

                r = pes->header + 9;

                pes->pts = AV_NOPTS_VALUE;

                pes->dts = AV_NOPTS_VALUE;

                if ((flags & 0xc0) == 0x80) {

                    pes->pts = get_pts(r);

                    r += 5;

                } else if ((flags & 0xc0) == 0xc0) {

                    pes->pts = get_pts(r);

                    r += 5;

                    pes->dts = get_pts(r);

                    r += 5;

                }

                /* we got the full header. We parse it and get the payload */

                pes->state = MPEGTS_PAYLOAD;

            }

            break;

        case MPEGTS_PAYLOAD:

            if (pes->total_size) {

                len = pes->total_size - pes->data_index;

                if (len > buf_size)

                    len = buf_size;

            } else {

                len = buf_size;

            }

            if (len > 0) {

                AVPacket *pkt = ts->pkt;

                if (pes->st && av_new_packet(pkt, len) == 0) {

                    memcpy(pkt->data, p, len);

                    pkt->stream_index = pes->st->index;

                    pkt->pts = pes->pts;

                    /* reset pts values */

                    pes->pts = AV_NOPTS_VALUE;

                    pes->dts = AV_NOPTS_VALUE;

                    ts->stop_parse = 1;

                    return;

                }

            }

            buf_size = 0;

            break;

        case MPEGTS_SKIP:

            buf_size = 0;

            break;

        }

    }

}
 and probability:0.4108527131782946
code:static bool gscb_needed(void *opaque)

{

    return kvm_s390_get_gs();

}
 and probability:0.0
code:void do_fctiw (void)

{

    union {

        double d;

        uint64_t i;

    } p;



    /* XXX: higher bits are not supposed to be significant.

     *     to make tests easier, return the same as a real PowerPC 750 (aka G3)

     */

    p.i = float64_to_int32(FT0, &env->fp_status);

    p.i |= 0xFFF80000ULL << 32;

    FT0 = p.d;

}
 and probability:0.07692307692307693
code:static struct omap_mpu_timer_s *omap_mpu_timer_init(MemoryRegion *system_memory,

                hwaddr base,

                qemu_irq irq, omap_clk clk)

{

    struct omap_mpu_timer_s *s = (struct omap_mpu_timer_s *)

            g_malloc0(sizeof(struct omap_mpu_timer_s));



    s->irq = irq;

    s->clk = clk;

    s->timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, omap_timer_tick, s);

    s->tick = qemu_bh_new(omap_timer_fire, s);

    omap_mpu_timer_reset(s);

    omap_timer_clk_setup(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mpu_timer_ops, s,

                          "omap-mpu-timer", 0x100);



    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
 and probability:0.35294117647058826
code:static int libopenjpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                                    const AVFrame *frame, int *got_packet)

{

    LibOpenJPEGContext *ctx = avctx->priv_data;

    opj_cinfo_t *compress = ctx->compress;

    opj_image_t *image    = ctx->image;

    opj_cio_t *stream     = ctx->stream;

    int cpyresult = 0;

    int ret, len;

    AVFrame *gbrframe;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_RGB24:

    case AV_PIX_FMT_RGBA:

    case AV_PIX_FMT_GRAY8A:

        cpyresult = libopenjpeg_copy_packed8(avctx, frame, image);

        break;

    case AV_PIX_FMT_XYZ12:

        cpyresult = libopenjpeg_copy_packed12(avctx, frame, image);

        break;

    case AV_PIX_FMT_RGB48:

    case AV_PIX_FMT_RGBA64:

        cpyresult = libopenjpeg_copy_packed16(avctx, frame, image);

        break;

    case AV_PIX_FMT_GBR24P:

    case AV_PIX_FMT_GBRP9:

    case AV_PIX_FMT_GBRP10:

    case AV_PIX_FMT_GBRP12:

    case AV_PIX_FMT_GBRP14:

    case AV_PIX_FMT_GBRP16:

        gbrframe = av_frame_alloc();



        av_frame_ref(gbrframe, frame);

        gbrframe->data[0] = frame->data[2]; // swap to be rgb

        gbrframe->data[1] = frame->data[0];

        gbrframe->data[2] = frame->data[1];

        gbrframe->linesize[0] = frame->linesize[2];

        gbrframe->linesize[1] = frame->linesize[0];

        gbrframe->linesize[2] = frame->linesize[1];

        if (avctx->pix_fmt == AV_PIX_FMT_GBR24P) {

            cpyresult = libopenjpeg_copy_unpacked8(avctx, gbrframe, image);

        } else {

            cpyresult = libopenjpeg_copy_unpacked16(avctx, gbrframe, image);

        }

        av_frame_free(&gbrframe);

        break;

    case AV_PIX_FMT_GRAY8:

    case AV_PIX_FMT_YUV410P:

    case AV_PIX_FMT_YUV411P:

    case AV_PIX_FMT_YUV420P:

    case AV_PIX_FMT_YUV422P:

    case AV_PIX_FMT_YUV440P:

    case AV_PIX_FMT_YUV444P:

    case AV_PIX_FMT_YUVA420P:

    case AV_PIX_FMT_YUVA422P:

    case AV_PIX_FMT_YUVA444P:

        cpyresult = libopenjpeg_copy_unpacked8(avctx, frame, image);

        break;

    case AV_PIX_FMT_GRAY16:

    case AV_PIX_FMT_YUV420P9:

    case AV_PIX_FMT_YUV422P9:

    case AV_PIX_FMT_YUV444P9:

    case AV_PIX_FMT_YUVA420P9:

    case AV_PIX_FMT_YUVA422P9:

    case AV_PIX_FMT_YUVA444P9:

    case AV_PIX_FMT_YUV444P10:

    case AV_PIX_FMT_YUV422P10:

    case AV_PIX_FMT_YUV420P10:

    case AV_PIX_FMT_YUVA444P10:

    case AV_PIX_FMT_YUVA422P10:

    case AV_PIX_FMT_YUVA420P10:

    case AV_PIX_FMT_YUV420P12:

    case AV_PIX_FMT_YUV422P12:

    case AV_PIX_FMT_YUV444P12:

    case AV_PIX_FMT_YUV420P14:

    case AV_PIX_FMT_YUV422P14:

    case AV_PIX_FMT_YUV444P14:

    case AV_PIX_FMT_YUV444P16:

    case AV_PIX_FMT_YUV422P16:

    case AV_PIX_FMT_YUV420P16:

    case AV_PIX_FMT_YUVA444P16:

    case AV_PIX_FMT_YUVA422P16:

    case AV_PIX_FMT_YUVA420P16:

        cpyresult = libopenjpeg_copy_unpacked16(avctx, frame, image);

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               "The frame's pixel format '%s' is not supported\n",

               av_get_pix_fmt_name(avctx->pix_fmt));

        return AVERROR(EINVAL);

        break;

    }



    if (!cpyresult) {

        av_log(avctx, AV_LOG_ERROR,

               "Could not copy the frame data to the internal image buffer\n");

        return -1;

    }



    cio_seek(stream, 0);

    if (!opj_encode(compress, stream, image, NULL)) {

        av_log(avctx, AV_LOG_ERROR, "Error during the opj encode\n");

        return -1;

    }



    len = cio_tell(stream);

    if ((ret = ff_alloc_packet2(avctx, pkt, len)) < 0) {

        return ret;

    }



    memcpy(pkt->data, stream->buffer, len);

    pkt->flags |= AV_PKT_FLAG_KEY;

    *got_packet = 1;

    return 0;

} and probability:0.14678899082568808
code:static void termsig_handler(int signum)

{

    state = TERMINATE;

    qemu_notify_event();

}
 and probability:0.0
code:static int qxl_post_load(void *opaque, int version)

{

    PCIQXLDevice* d = opaque;

    uint8_t *ram_start = d->vga.vram_ptr;

    QXLCommandExt *cmds;

    int in, out, newmode;



    assert(d->last_release_offset < d->vga.vram_size);

    if (d->last_release_offset == 0) {

        d->last_release = NULL;

    } else {

        d->last_release = (QXLReleaseInfo *)(ram_start + d->last_release_offset);

    }



    d->modes = (QXLModes*)((uint8_t*)d->rom + d->rom->modes_offset);



    trace_qxl_post_load(d->id, qxl_mode_to_string(d->mode));

    newmode = d->mode;

    d->mode = QXL_MODE_UNDEFINED;



    switch (newmode) {

    case QXL_MODE_UNDEFINED:

        qxl_create_memslots(d);

        break;

    case QXL_MODE_VGA:

        qxl_create_memslots(d);

        qxl_enter_vga_mode(d);

        break;

    case QXL_MODE_NATIVE:

        qxl_create_memslots(d);

        qxl_create_guest_primary(d, 1, QXL_SYNC);



        /* replay surface-create and cursor-set commands */

        cmds = g_malloc0(sizeof(QXLCommandExt) * (d->ssd.num_surfaces + 1));

        for (in = 0, out = 0; in < d->ssd.num_surfaces; in++) {

            if (d->guest_surfaces.cmds[in] == 0) {

                continue;

            }

            cmds[out].cmd.data = d->guest_surfaces.cmds[in];

            cmds[out].cmd.type = QXL_CMD_SURFACE;

            cmds[out].group_id = MEMSLOT_GROUP_GUEST;

            out++;

        }

        if (d->guest_cursor) {

            cmds[out].cmd.data = d->guest_cursor;

            cmds[out].cmd.type = QXL_CMD_CURSOR;

            cmds[out].group_id = MEMSLOT_GROUP_GUEST;

            out++;

        }

        qxl_spice_loadvm_commands(d, cmds, out);

        g_free(cmds);

        if (d->guest_monitors_config) {

            qxl_spice_monitors_config_async(d, 1);

        }

        break;

    case QXL_MODE_COMPAT:

        /* note: no need to call qxl_create_memslots, qxl_set_mode

         * creates the mem slot. */

        qxl_set_mode(d, d->shadow_rom.mode, 1);

        break;

    }

    return 0;

}
 and probability:0.39655172413793105
code:static int rtp_parse_one_packet(RTPDemuxContext *s, AVPacket *pkt,

                                uint8_t **bufptr, int len)

{

    uint8_t *buf = bufptr ? *bufptr : NULL;

    int flags = 0;

    uint32_t timestamp;

    int rv = 0;



    if (!buf) {

        /* If parsing of the previous packet actually returned 0 or an error,

         * there's nothing more to be parsed from that packet, but we may have

         * indicated that we can return the next enqueued packet. */

        if (s->prev_ret <= 0)

            return rtp_parse_queued_packet(s, pkt);

        /* return the next packets, if any */

        if (s->handler && s->handler->parse_packet) {

            /* timestamp should be overwritten by parse_packet, if not,

             * the packet is left with pts == AV_NOPTS_VALUE */

            timestamp = RTP_NOTS_VALUE;

            rv        = s->handler->parse_packet(s->ic, s->dynamic_protocol_context,

                                                 s->st, pkt, &timestamp, NULL, 0, 0,

                                                 flags);

            finalize_packet(s, pkt, timestamp);

            return rv;

        }

    }



    if (len < 12)

        return -1;



    if ((buf[0] & 0xc0) != (RTP_VERSION << 6))

        return -1;

    if (RTP_PT_IS_RTCP(buf[1])) {

        return rtcp_parse_packet(s, buf, len);

    }



    if (s->st) {

        int64_t received = av_gettime_relative();

        uint32_t arrival_ts = av_rescale_q(received, AV_TIME_BASE_Q,

                                           s->st->time_base);

        timestamp = AV_RB32(buf + 4);

        // Calculate the jitter immediately, before queueing the packet

        // into the reordering queue.

        rtcp_update_jitter(&s->statistics, timestamp, arrival_ts);

    }



    if ((s->seq == 0 && !s->queue) || s->queue_size <= 1) {

        /* First packet, or no reordering */

        return rtp_parse_packet_internal(s, pkt, buf, len);

    } else {

        uint16_t seq = AV_RB16(buf + 2);

        int16_t diff = seq - s->seq;

        if (diff < 0) {

            /* Packet older than the previously emitted one, drop */

            av_log(s->st ? s->st->codec : NULL, AV_LOG_WARNING,

                   "RTP: dropping old packet received too late\n");

            return -1;

        } else if (diff <= 1) {

            /* Correct packet */

            rv = rtp_parse_packet_internal(s, pkt, buf, len);

            return rv;

        } else {

            /* Still missing some packet, enqueue this one. */

            enqueue_packet(s, buf, len);

            *bufptr = NULL;

            /* Return the first enqueued packet if the queue is full,

             * even if we're missing something */

            if (s->queue_len >= s->queue_size) {

                av_log(s->st ? s->st->codec : NULL, AV_LOG_WARNING,

                       "jitter buffer full\n");

                return rtp_parse_queued_packet(s, pkt);

            }

            return -1;

        }

    }

}
 and probability:0.2535211267605634
code:static inline void RENAME(rgb16to15)(const uint8_t *src,uint8_t *dst,long src_size)

{

  register const uint8_t* s=src;

  register uint8_t* d=dst;

  register const uint8_t *end;

  const uint8_t *mm_end;

  end = s + src_size;

#ifdef HAVE_MMX

  __asm __volatile(PREFETCH"	%0"::"m"(*s));

  __asm __volatile("movq	%0, %%mm7"::"m"(mask15rg));

  __asm __volatile("movq	%0, %%mm6"::"m"(mask15b));

  mm_end = end - 15;

  while(s<mm_end)

  {

	__asm __volatile(

		PREFETCH"	32%1\n\t"

		"movq	%1, %%mm0\n\t"

		"movq	8%1, %%mm2\n\t"

		"movq	%%mm0, %%mm1\n\t"

		"movq	%%mm2, %%mm3\n\t"

		"psrlq	$1, %%mm0\n\t"

		"psrlq	$1, %%mm2\n\t"

		"pand	%%mm7, %%mm0\n\t"

		"pand	%%mm7, %%mm2\n\t"

		"pand	%%mm6, %%mm1\n\t"

		"pand	%%mm6, %%mm3\n\t"

		"por	%%mm1, %%mm0\n\t"

		"por	%%mm3, %%mm2\n\t"

		MOVNTQ"	%%mm0, %0\n\t"

		MOVNTQ"	%%mm2, 8%0"

		:"=m"(*d)

		:"m"(*s)

		);

	d+=16;

	s+=16;

  }

  __asm __volatile(SFENCE:::"memory");

  __asm __volatile(EMMS:::"memory");

#endif

    mm_end = end - 3;

    while(s < mm_end)

    {

	register uint32_t x= *((uint32_t *)s);

	*((uint32_t *)d) = ((x>>1)&0x7FE07FE0) | (x&0x001F001F);

	s+=4;

	d+=4;

    }

    if(s < end)

    {

	register uint16_t x= *((uint16_t *)s);

	*((uint16_t *)d) = ((x>>1)&0x7FE0) | (x&0x001F);

	s+=2;

	d+=2;

    }

}
 and probability:0.23636363636363636
code:static void xics_class_init(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);



    dc->realize = xics_realize;

    dc->props = xics_properties;

    dc->reset = xics_reset;

}
 and probability:0.42857142857142855
code:void acpi_memory_hotplug_init(MemoryRegion *as, Object *owner,

                              MemHotplugState *state)

{

    MachineState *machine = MACHINE(qdev_get_machine());



    state->dev_count = machine->ram_slots;

    if (!state->dev_count) {

        return;

    }



    state->devs = g_malloc0(sizeof(*state->devs) * state->dev_count);

    memory_region_init_io(&state->io, owner, &acpi_memory_hotplug_ops, state,

                          "acpi-mem-hotplug", ACPI_MEMORY_HOTPLUG_IO_LEN);

    memory_region_add_subregion(as, ACPI_MEMORY_HOTPLUG_BASE, &state->io);

}
 and probability:0.38461538461538464
code:static void test_qemu_strtoul_correct(void)

{

    const char *str = "12345 foo";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 12345);

    g_assert(endptr == str + 5);

}
 and probability:0.08333333333333333
code:Aml *aml_shiftleft(Aml *arg1, Aml *count)

{

    Aml *var = aml_opcode(0x79 /* ShiftLeftOp */);

    aml_append(var, arg1);

    aml_append(var, count);

    build_append_byte(var->buf, 0x00); /* NullNameOp */

    return var;

}
 and probability:0.125
code:static void nfs_process_write(void *arg)

{

    NFSClient *client = arg;



    aio_context_acquire(client->aio_context);

    nfs_service(client->context, POLLOUT);

    nfs_set_events(client);

    aio_context_release(client->aio_context);

}
 and probability:0.375
code:static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,

                                    TranslationBlock **last_tb, int *tb_exit)

{

    uintptr_t ret;

    int32_t insns_left;



    if (unlikely(atomic_read(&cpu->exit_request))) {

        return;

    }



    trace_exec_tb(tb, tb->pc);

    ret = cpu_tb_exec(cpu, tb);

    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);

    *tb_exit = ret & TB_EXIT_MASK;

    if (*tb_exit != TB_EXIT_REQUESTED) {

        *last_tb = tb;

        return;

    }



    *last_tb = NULL;

    insns_left = atomic_read(&cpu->icount_decr.u32);

    atomic_set(&cpu->icount_decr.u16.high, 0);

    if (insns_left < 0) {

        /* Something asked us to stop executing

         * chained TBs; just continue round the main

         * loop. Whatever requested the exit will also

         * have set something else (eg exit_request or

         * interrupt_request) which we will handle

         * next time around the loop.  But we need to

         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)

         * comes before the next read of cpu->exit_request

         * or cpu->interrupt_request.

         */

        smp_mb();

        return;

    }



    /* Instruction counter expired.  */

    assert(use_icount);

#ifndef CONFIG_USER_ONLY

    if (cpu->icount_extra) {

        /* Refill decrementer and continue execution.  */

        cpu->icount_extra += insns_left;

        insns_left = MIN(0xffff, cpu->icount_extra);

        cpu->icount_extra -= insns_left;

        cpu->icount_decr.u16.low = insns_left;

    } else {

        /* Execute any remaining instructions, then let the main loop

         * handle the next event.

         */

        if (insns_left > 0) {

            cpu_exec_nocache(cpu, insns_left, tb, false);

        }

    }

#endif

}
 and probability:0.25
code:static int xen_pt_byte_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,

                                uint8_t *value, uint8_t valid_mask)

{

    XenPTRegInfo *reg = cfg_entry->reg;

    uint8_t valid_emu_mask = 0;



    /* emulate byte register */

    valid_emu_mask = reg->emu_mask & valid_mask;

    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);



    return 0;

}
 and probability:0.3
code:static int vfio_setup_pcie_cap(VFIOPCIDevice *vdev, int pos, uint8_t size)

{

    uint16_t flags;

    uint8_t type;



    flags = pci_get_word(vdev->pdev.config + pos + PCI_CAP_FLAGS);

    type = (flags & PCI_EXP_FLAGS_TYPE) >> 4;



    if (type != PCI_EXP_TYPE_ENDPOINT &&

        type != PCI_EXP_TYPE_LEG_END &&

        type != PCI_EXP_TYPE_RC_END) {



        error_report("vfio: Assignment of PCIe type 0x%x "

                     "devices is not currently supported", type);

        return -EINVAL;

    }



    if (!pci_bus_is_express(vdev->pdev.bus)) {

        /*

         * Use express capability as-is on PCI bus.  It doesn't make much

         * sense to even expose, but some drivers (ex. tg3) depend on it

         * and guests don't seem to be particular about it.  We'll need

         * to revist this or force express devices to express buses if we

         * ever expose an IOMMU to the guest.

         */

    } else if (pci_bus_is_root(vdev->pdev.bus)) {

        /*

         * On a Root Complex bus Endpoints become Root Complex Integrated

         * Endpoints, which changes the type and clears the LNK & LNK2 fields.

         */

        if (type == PCI_EXP_TYPE_ENDPOINT) {

            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,

                                   PCI_EXP_TYPE_RC_END << 4,

                                   PCI_EXP_FLAGS_TYPE);



            /* Link Capabilities, Status, and Control goes away */

            if (size > PCI_EXP_LNKCTL) {

                vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP, 0, ~0);

                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);

                vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA, 0, ~0);



#ifndef PCI_EXP_LNKCAP2

#define PCI_EXP_LNKCAP2 44

#endif

#ifndef PCI_EXP_LNKSTA2

#define PCI_EXP_LNKSTA2 50

#endif

                /* Link 2 Capabilities, Status, and Control goes away */

                if (size > PCI_EXP_LNKCAP2) {

                    vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP2, 0, ~0);

                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL2, 0, ~0);

                    vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA2, 0, ~0);

                }

            }



        } else if (type == PCI_EXP_TYPE_LEG_END) {

            /*

             * Legacy endpoints don't belong on the root complex.  Windows

             * seems to be happier with devices if we skip the capability.

             */

            return 0;

        }



    } else {

        /*

         * Convert Root Complex Integrated Endpoints to regular endpoints.

         * These devices don't support LNK/LNK2 capabilities, so make them up.

         */

        if (type == PCI_EXP_TYPE_RC_END) {

            vfio_add_emulated_word(vdev, pos + PCI_CAP_FLAGS,

                                   PCI_EXP_TYPE_ENDPOINT << 4,

                                   PCI_EXP_FLAGS_TYPE);

            vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP,

                                   PCI_EXP_LNK_MLW_1 | PCI_EXP_LNK_LS_25, ~0);

            vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKCTL, 0, ~0);

        }



        /* Mark the Link Status bits as emulated to allow virtual negotiation */

        vfio_add_emulated_word(vdev, pos + PCI_EXP_LNKSTA,

                               pci_get_word(vdev->pdev.config + pos +

                                            PCI_EXP_LNKSTA),

                               PCI_EXP_LNKCAP_MLW | PCI_EXP_LNKCAP_SLS);

    }



    pos = pci_add_capability(&vdev->pdev, PCI_CAP_ID_EXP, pos, size);

    if (pos >= 0) {

        vdev->pdev.exp.exp_cap = pos;

    }



    return pos;

}
 and probability:0.2125
code:static UserDefNested *nested_struct_create(void)

{

    UserDefNested *udnp = g_malloc0(sizeof(*udnp));

    udnp->string0 = strdup("test_string0");

    udnp->dict1.string1 = strdup("test_string1");

    udnp->dict1.dict2.userdef1 = g_malloc0(sizeof(UserDefOne));

    udnp->dict1.dict2.userdef1->base = g_new0(UserDefZero, 1);

    udnp->dict1.dict2.userdef1->base->integer = 42;

    udnp->dict1.dict2.userdef1->string = strdup("test_string");

    udnp->dict1.dict2.string2 = strdup("test_string2");

    udnp->dict1.has_dict3 = true;

    udnp->dict1.dict3.userdef2 = g_malloc0(sizeof(UserDefOne));

    udnp->dict1.dict3.userdef2->base = g_new0(UserDefZero, 1);

    udnp->dict1.dict3.userdef2->base->integer = 43;

    udnp->dict1.dict3.userdef2->string = strdup("test_string");

    udnp->dict1.dict3.string3 = strdup("test_string3");

    return udnp;

}
 and probability:0.7777777777777778
code:static int qcow2_create(const char *filename, QEMUOptionParameter *options)

{

    const char *backing_file = NULL;

    const char *backing_fmt = NULL;

    uint64_t sectors = 0;

    int flags = 0;

    size_t cluster_size = DEFAULT_CLUSTER_SIZE;

    int prealloc = 0;



    /* Read out options */

    while (options && options->name) {

        if (!strcmp(options->name, BLOCK_OPT_SIZE)) {

            sectors = options->value.n / 512;

        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {

            backing_file = options->value.s;

        } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FMT)) {

            backing_fmt = options->value.s;

        } else if (!strcmp(options->name, BLOCK_OPT_ENCRYPT)) {

            flags |= options->value.n ? BLOCK_FLAG_ENCRYPT : 0;

        } else if (!strcmp(options->name, BLOCK_OPT_CLUSTER_SIZE)) {

            if (options->value.n) {

                cluster_size = options->value.n;

            }

        } else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {

            if (!options->value.s || !strcmp(options->value.s, "off")) {

                prealloc = 0;

            } else if (!strcmp(options->value.s, "metadata")) {

                prealloc = 1;

            } else {

                fprintf(stderr, "Invalid preallocation mode: '%s'\n",

                    options->value.s);

                return -EINVAL;

            }

        }

        options++;

    }



    if (backing_file && prealloc) {

        fprintf(stderr, "Backing file and preallocation cannot be used at "

            "the same time\n");

        return -EINVAL;

    }



    return qcow2_create2(filename, sectors, backing_file, backing_fmt, flags,

                         cluster_size, prealloc, options);

}
 and probability:0.3953488372093023
code:static int rpza_decode_init(AVCodecContext *avctx)

{

    RpzaContext *s = avctx->priv_data;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_RGB555;

    dsputil_init(&s->dsp, avctx);



    s->frame.data[0] = NULL;



    return 0;

}
 and probability:0.5555555555555556
code:static void qmp_output_type_str(Visitor *v, const char *name, char **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    if (*obj) {

        qmp_output_add(qov, name, qstring_from_str(*obj));

    } else {

        qmp_output_add(qov, name, qstring_from_str(""));

    }

}
 and probability:0.2
code:static void v9fs_open_post_lstat(V9fsState *s, V9fsOpenState *vs, int err)

{

    int flags;



    if (err) {

        err = -errno;

        goto out;

    }



    stat_to_qid(&vs->stbuf, &vs->qid);



    if (S_ISDIR(vs->stbuf.st_mode)) {

        vs->fidp->fs.dir = v9fs_do_opendir(s, &vs->fidp->path);

        v9fs_open_post_opendir(s, vs, err);

    } else {

        if (s->proto_version == V9FS_PROTO_2000L) {

            if (!valid_flags(vs->mode)) {

                err = -EINVAL;

                goto out;

            }

            flags = vs->mode;

        } else {

            flags = omode_to_uflags(vs->mode);

        }

        vs->fidp->fs.fd = v9fs_do_open(s, &vs->fidp->path, flags);

        v9fs_open_post_open(s, vs, err);

    }

    return;

out:

    complete_pdu(s, vs->pdu, err);

    qemu_free(vs);

}
 and probability:0.3103448275862069
code:static void spapr_cpu_core_unrealizefn(DeviceState *dev, Error **errp)

{

    sPAPRCPUCore *sc = SPAPR_CPU_CORE(OBJECT(dev));

    sPAPRCPUCoreClass *scc = SPAPR_CPU_CORE_GET_CLASS(OBJECT(dev));

    size_t size = object_type_get_instance_size(scc->cpu_type);

    CPUCore *cc = CPU_CORE(dev);

    int i;



    for (i = 0; i < cc->nr_threads; i++) {

        void *obj = sc->threads + i * size;

        DeviceState *dev = DEVICE(obj);

        CPUState *cs = CPU(dev);

        PowerPCCPU *cpu = POWERPC_CPU(cs);



        spapr_cpu_destroy(cpu);

        object_unparent(cpu->intc);

        cpu_remove_sync(cs);

        object_unparent(obj);

    }

    g_free(sc->threads);

}
 and probability:0.2631578947368421
code:static uint32_t taihu_cpld_readw (void *opaque, hwaddr addr)

{

    uint32_t ret;



    ret = taihu_cpld_readb(opaque, addr) << 8;

    ret |= taihu_cpld_readb(opaque, addr + 1);



    return ret;

}
 and probability:0.14285714285714285
code:int vfio_container_ioctl(AddressSpace *as, int32_t groupid,

                         int req, void *param)

{

    /* We allow only certain ioctls to the container */

    switch (req) {

    case VFIO_CHECK_EXTENSION:

    case VFIO_IOMMU_SPAPR_TCE_GET_INFO:

    case VFIO_EEH_PE_OP:

        break;

    default:

        /* Return an error on unknown requests */

        error_report("vfio: unsupported ioctl %X", req);

        return -1;

    }



    return vfio_container_do_ioctl(as, groupid, req, param);

}
 and probability:0.0
code:static void vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,

                                   uint8_t devfn, hwaddr addr, bool is_write,

                                   IOMMUTLBEntry *entry)

{

    IntelIOMMUState *s = vtd_as->iommu_state;

    VTDContextEntry ce;

    uint8_t bus_num = pci_bus_num(bus);

    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;

    uint64_t slpte;

    uint32_t level;

    uint16_t source_id = vtd_make_source_id(bus_num, devfn);

    int ret_fr;

    bool is_fpd_set = false;

    bool reads = true;

    bool writes = true;

    VTDIOTLBEntry *iotlb_entry;



    /* Check if the request is in interrupt address range */

    if (vtd_is_interrupt_addr(addr)) {

        if (is_write) {

            /* FIXME: since we don't know the length of the access here, we

             * treat Non-DWORD length write requests without PASID as

             * interrupt requests, too. Withoud interrupt remapping support,

             * we just use 1:1 mapping.

             */

            VTD_DPRINTF(MMU, "write request to interrupt address "

                        "gpa 0x%"PRIx64, addr);

            entry->iova = addr & VTD_PAGE_MASK_4K;

            entry->translated_addr = addr & VTD_PAGE_MASK_4K;

            entry->addr_mask = ~VTD_PAGE_MASK_4K;

            entry->perm = IOMMU_WO;

            return;

        } else {

            VTD_DPRINTF(GENERAL, "error: read request from interrupt address "

                        "gpa 0x%"PRIx64, addr);

            vtd_report_dmar_fault(s, source_id, addr, VTD_FR_READ, is_write);

            return;

        }

    }

    /* Try to fetch slpte form IOTLB */

    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);

    if (iotlb_entry) {

        VTD_DPRINTF(CACHE, "hit iotlb sid 0x%"PRIx16 " gpa 0x%"PRIx64

                    " slpte 0x%"PRIx64 " did 0x%"PRIx16, source_id, addr,

                    iotlb_entry->slpte, iotlb_entry->domain_id);

        slpte = iotlb_entry->slpte;

        reads = iotlb_entry->read_flags;

        writes = iotlb_entry->write_flags;

        goto out;

    }

    /* Try to fetch context-entry from cache first */

    if (cc_entry->context_cache_gen == s->context_cache_gen) {

        VTD_DPRINTF(CACHE, "hit context-cache bus %d devfn %d "

                    "(hi %"PRIx64 " lo %"PRIx64 " gen %"PRIu32 ")",

                    bus_num, devfn, cc_entry->context_entry.hi,

                    cc_entry->context_entry.lo, cc_entry->context_cache_gen);

        ce = cc_entry->context_entry;

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

    } else {

        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

        if (ret_fr) {

            ret_fr = -ret_fr;

            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

                VTD_DPRINTF(FLOG, "fault processing is disabled for DMA "

                            "requests through this context-entry "

                            "(with FPD Set)");

            } else {

                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

            }

            return;

        }

        /* Update context-cache */

        VTD_DPRINTF(CACHE, "update context-cache bus %d devfn %d "

                    "(hi %"PRIx64 " lo %"PRIx64 " gen %"PRIu32 "->%"PRIu32 ")",

                    bus_num, devfn, ce.hi, ce.lo,

                    cc_entry->context_cache_gen, s->context_cache_gen);

        cc_entry->context_entry = ce;

        cc_entry->context_cache_gen = s->context_cache_gen;

    }



    ret_fr = vtd_gpa_to_slpte(&ce, addr, is_write, &slpte, &level,

                              &reads, &writes);

    if (ret_fr) {

        ret_fr = -ret_fr;

        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

            VTD_DPRINTF(FLOG, "fault processing is disabled for DMA requests "

                        "through this context-entry (with FPD Set)");

        } else {

            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

        }

        return;

    }



    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,

                     reads, writes);

out:

    entry->iova = addr & VTD_PAGE_MASK_4K;

    entry->translated_addr = vtd_get_slpte_addr(slpte) & VTD_PAGE_MASK_4K;

    entry->addr_mask = ~VTD_PAGE_MASK_4K;

    entry->perm = (writes ? 2 : 0) + (reads ? 1 : 0);

}
 and probability:0.21212121212121213
code:void call_pal (CPUState *env, int palcode)

{

    target_ulong ret;



    if (logfile != NULL)

        fprintf(logfile, "%s: palcode %02x\n", __func__, palcode);

    switch (palcode) {

    case 0x83:

        /* CALLSYS */

        if (logfile != NULL)

            fprintf(logfile, "CALLSYS n " TARGET_FMT_ld "\n", env->ir[0]);

        ret = do_syscall(env, env->ir[IR_V0], env->ir[IR_A0], env->ir[IR_A1],

                         env->ir[IR_A2], env->ir[IR_A3], env->ir[IR_A4],

                         env->ir[IR_A5]);

        if (ret >= 0) {

            env->ir[IR_A3] = 0;

            env->ir[IR_V0] = ret;

        } else {

            env->ir[IR_A3] = 1;

            env->ir[IR_V0] = -ret;

        }

        break;

    case 0x9E:

        /* RDUNIQUE */

        env->ir[IR_V0] = env->unique;

        if (logfile != NULL)

            fprintf(logfile, "RDUNIQUE: " TARGET_FMT_lx "\n", env->unique);

        break;

    case 0x9F:

        /* WRUNIQUE */

        env->unique = env->ir[IR_A0];

        if (logfile != NULL)

            fprintf(logfile, "WRUNIQUE: " TARGET_FMT_lx "\n", env->unique);

        break;

    default:

        if (logfile != NULL)

            fprintf(logfile, "%s: unhandled palcode %02x\n",

                    __func__, palcode);

        exit(1);

    }

}
 and probability:0.3
code:static void RENAME(yuv2yuyv422_1)(SwsContext *c, const uint16_t *buf0,

                                  const uint16_t *ubuf0, const uint16_t *ubuf1,

                                  const uint16_t *vbuf0, const uint16_t *vbuf1,

                                  const uint16_t *abuf0, uint8_t *dest,

                                  int dstW, int uvalpha, enum PixelFormat dstFormat,

                                  int flags, int y)

{

    const uint16_t *buf1= buf0; //FIXME needed for RGB1/BGR1



    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster

        __asm__ volatile(

            "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"

            "mov        %4, %%"REG_b"               \n\t"

            "push %%"REG_BP"                        \n\t"

            YSCALEYUV2PACKED1(%%REGBP, %5)

            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)

            "pop %%"REG_BP"                         \n\t"

            "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"

            :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),

               "a" (&c->redDither)

        );

    } else {

        __asm__ volatile(

            "mov %%"REG_b", "ESP_OFFSET"(%5)        \n\t"

            "mov        %4, %%"REG_b"               \n\t"

            "push %%"REG_BP"                        \n\t"

            YSCALEYUV2PACKED1b(%%REGBP, %5)

            WRITEYUY2(%%REGb, 8280(%5), %%REGBP)

            "pop %%"REG_BP"                         \n\t"

            "mov "ESP_OFFSET"(%5), %%"REG_b"        \n\t"

            :: "c" (buf0), "d" (buf1), "S" (ubuf0), "D" (ubuf1), "m" (dest),

               "a" (&c->redDither)

        );

    }

}
 and probability:0.058823529411764705
code:yuv2gray16_1_c_template(SwsContext *c, const uint16_t *buf0,

                        const uint16_t *ubuf0, const uint16_t *ubuf1,

                        const uint16_t *vbuf0, const uint16_t *vbuf1,

                        const uint16_t *abuf0, uint8_t *dest, int dstW,

                        int uvalpha, enum PixelFormat dstFormat,

                        int flags, int y, enum PixelFormat target)

{

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        const int i2 = 2 * i;

        int Y1 = buf0[i2  ] << 1;

        int Y2 = buf0[i2+1] << 1;



        output_pixel(&dest[2 * i2 + 0], Y1);

        output_pixel(&dest[2 * i2 + 2], Y2);

    }

}
 and probability:0.625
code:uint32_t helper_efdctuiz (uint64_t val)

{

    CPU_DoubleU u;



    u.ll = val;

    /* NaN are not treated the same way IEEE 754 does */

    if (unlikely(float64_is_nan(u.d)))

        return 0;



    return float64_to_uint32_round_to_zero(u.d, &env->vec_status);

}
 and probability:0.1111111111111111
code:int qcow2_zero_clusters(BlockDriverState *bs, uint64_t offset, int nb_sectors)

{

    BDRVQcow2State *s = bs->opaque;

    unsigned int nb_clusters;

    int ret;



    /* The zero flag is only supported by version 3 and newer */

    if (s->qcow_version < 3) {

        return -ENOTSUP;

    }



    /* Each L2 table is handled by its own loop iteration */

    nb_clusters = size_to_clusters(s, nb_sectors << BDRV_SECTOR_BITS);



    s->cache_discards = true;



    while (nb_clusters > 0) {

        ret = zero_single_l2(bs, offset, nb_clusters);

        if (ret < 0) {

            goto fail;

        }



        nb_clusters -= ret;

        offset += (ret * s->cluster_size);

    }



    ret = 0;

fail:

    s->cache_discards = false;

    qcow2_process_discards(bs, ret);



    return ret;

}
 and probability:0.23076923076923078
code:void async_context_push(void)

{

    struct AsyncContext *new = qemu_mallocz(sizeof(*new));

    new->parent = async_context;

    new->id = async_context->id + 1;

    async_context = new;

}
 and probability:0.42857142857142855
code:static int h264_extradata_to_annexb(AVCodecContext *avctx, const int padding)

{

    uint16_t unit_size;

    uint64_t total_size                 = 0;

    uint8_t *out                        = NULL, unit_nb, sps_done = 0,

             sps_seen                   = 0, pps_seen = 0;

    const uint8_t *extradata            = avctx->extradata + 4;

    static const uint8_t nalu_header[4] = { 0, 0, 0, 1 };

    int length_size = (*extradata++ & 0x3) + 1; // retrieve length coded size



    /* retrieve sps and pps unit(s) */

    unit_nb = *extradata++ & 0x1f; /* number of sps unit(s) */

    if (!unit_nb) {

        goto pps;

    } else {

        sps_seen = 1;

    }



    while (unit_nb--) {

        void *tmp;



        unit_size   = AV_RB16(extradata);

        total_size += unit_size + 4;

        if (total_size > INT_MAX - padding ||

            extradata + 2 + unit_size > avctx->extradata +

            avctx->extradata_size) {

            av_free(out);

            return AVERROR(EINVAL);

        }

        tmp = av_realloc(out, total_size + padding);

        if (!tmp) {

            av_free(out);

            return AVERROR(ENOMEM);

        }

        out = tmp;

        memcpy(out + total_size - unit_size - 4, nalu_header, 4);

        memcpy(out + total_size - unit_size, extradata + 2, unit_size);

        extradata += 2 + unit_size;

pps:

        if (!unit_nb && !sps_done++) {

            unit_nb = *extradata++; /* number of pps unit(s) */

            if (unit_nb)

                pps_seen = 1;

        }

    }



    if (out)

        memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);



    if (!sps_seen)

        av_log(avctx, AV_LOG_WARNING,

               "Warning: SPS NALU missing or invalid. "

               "The resulting stream may not play.\n");



    if (!pps_seen)

        av_log(avctx, AV_LOG_WARNING,

               "Warning: PPS NALU missing or invalid. "

               "The resulting stream may not play.\n");



    av_free(avctx->extradata);

    avctx->extradata      = out;

    avctx->extradata_size = total_size;



    return length_size;

}
 and probability:0.3157894736842105
code:static inline void stl_phys_internal(hwaddr addr, uint32_t val,

                                     enum device_endian endian)

{

    uint8_t *ptr;

    MemoryRegionSection *section;

    hwaddr l = 4;

    hwaddr addr1;



    section = address_space_translate(&address_space_memory, addr, &addr1, &l,

                                      true);

    if (l < 4 || !memory_region_is_ram(section->mr) || section->readonly) {

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

#if defined(TARGET_WORDS_BIGENDIAN)

        if (endian == DEVICE_LITTLE_ENDIAN) {

            val = bswap32(val);

        }

#else

        if (endian == DEVICE_BIG_ENDIAN) {

            val = bswap32(val);

        }

#endif

        io_mem_write(section->mr, addr1, val, 4);

    } else {

        /* RAM case */

        addr1 += memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK;

        ptr = qemu_get_ram_ptr(addr1);

        switch (endian) {

        case DEVICE_LITTLE_ENDIAN:

            stl_le_p(ptr, val);

            break;

        case DEVICE_BIG_ENDIAN:

            stl_be_p(ptr, val);

            break;

        default:

            stl_p(ptr, val);

            break;

        }

        invalidate_and_set_dirty(addr1, 4);

    }

}
 and probability:0.12195121951219512
code:static int vmdk_write(BlockDriverState *bs, int64_t sector_num,

                     const uint8_t *buf, int nb_sectors)

{

    BDRVVmdkState *s = bs->opaque;

    VmdkExtent *extent = NULL;

    int n;

    int64_t index_in_cluster;

    uint64_t cluster_offset;

    VmdkMetaData m_data;



    if (sector_num > bs->total_sectors) {

        fprintf(stderr,

                "(VMDK) Wrong offset: sector_num=0x%" PRIx64

                " total_sectors=0x%" PRIx64 "\n",

                sector_num, bs->total_sectors);

        return -1;

    }



    while (nb_sectors > 0) {

        extent = find_extent(s, sector_num, extent);

        if (!extent) {

            return -EIO;

        }

        cluster_offset = get_cluster_offset(

                                bs,

                                extent,

                                &m_data,

                                sector_num << 9, 1);

        if (!cluster_offset) {

            return -1;

        }

        index_in_cluster = sector_num % extent->cluster_sectors;

        n = extent->cluster_sectors - index_in_cluster;

        if (n > nb_sectors) {

            n = nb_sectors;

        }



        if (bdrv_pwrite(bs->file,

                        cluster_offset + index_in_cluster * 512,

                        buf, n * 512)

                != n * 512) {

            return -1;

        }

        if (m_data.valid) {

            /* update L2 tables */

            if (vmdk_L2update(extent, &m_data) == -1) {

                return -1;

            }

        }

        nb_sectors -= n;

        sector_num += n;

        buf += n * 512;



        // update CID on the first write every time the virtual disk is opened

        if (!s->cid_updated) {

            vmdk_write_cid(bs, time(NULL));

            s->cid_updated = true;

        }

    }

    return 0;

}
 and probability:0.24561403508771928
code:static inline void gen_evfsabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], ~0x8000000080000000LL);

#else

    tcg_gen_andi_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], ~0x80000000);

    tcg_gen_andi_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], ~0x80000000);

#endif

}
 and probability:0.3076923076923077
code:void usb_ep_reset(USBDevice *dev)

{

    int ep;



    dev->ep_ctl.nr = 0;

    dev->ep_ctl.type = USB_ENDPOINT_XFER_CONTROL;

    dev->ep_ctl.ifnum = 0;

    dev->ep_ctl.dev = dev;

    dev->ep_ctl.pipeline = false;

    for (ep = 0; ep < USB_MAX_ENDPOINTS; ep++) {

        dev->ep_in[ep].nr = ep + 1;

        dev->ep_out[ep].nr = ep + 1;

        dev->ep_in[ep].pid = USB_TOKEN_IN;

        dev->ep_out[ep].pid = USB_TOKEN_OUT;

        dev->ep_in[ep].type = USB_ENDPOINT_XFER_INVALID;

        dev->ep_out[ep].type = USB_ENDPOINT_XFER_INVALID;

        dev->ep_in[ep].ifnum = 0;

        dev->ep_out[ep].ifnum = 0;

        dev->ep_in[ep].dev = dev;

        dev->ep_out[ep].dev = dev;

        dev->ep_in[ep].pipeline = false;

        dev->ep_out[ep].pipeline = false;

    }

}
 and probability:0.782608695652174
code:int qemu_v9fs_synth_mkdir(V9fsSynthNode *parent, int mode,

                          const char *name, V9fsSynthNode **result)

{

    int ret;

    V9fsSynthNode *node, *tmp;



    if (!v9fs_synth_fs) {

        return EAGAIN;

    }

    if (!name || (strlen(name) >= NAME_MAX)) {

        return EINVAL;

    }

    if (!parent) {

        parent = &v9fs_synth_root;

    }

    qemu_mutex_lock(&v9fs_synth_mutex);

    QLIST_FOREACH(tmp, &parent->child, sibling) {

        if (!strcmp(tmp->name, name)) {

            ret = EEXIST;

            goto err_out;

        }

    }

    /* Add the name */

    node = v9fs_add_dir_node(parent, mode, name, NULL, v9fs_synth_node_count++);

    v9fs_add_dir_node(node, parent->attr->mode, "..",

                      parent->attr, parent->attr->inode);

    v9fs_add_dir_node(node, node->attr->mode, ".",

                      node->attr, node->attr->inode);

    *result = node;

    ret = 0;

err_out:

    qemu_mutex_unlock(&v9fs_synth_mutex);

    return ret;

}
 and probability:0.2727272727272727
code:static void megasas_handle_frame(MegasasState *s, uint64_t frame_addr,

                                 uint32_t frame_count)

{

    uint8_t frame_status = MFI_STAT_INVALID_CMD;

    uint64_t frame_context;

    MegasasCmd *cmd;



    /*

     * Always read 64bit context, top bits will be

     * masked out if required in megasas_enqueue_frame()

     */

    frame_context = megasas_frame_get_context(s, frame_addr);



    cmd = megasas_enqueue_frame(s, frame_addr, frame_context, frame_count);

    if (!cmd) {

        /* reply queue full */

        trace_megasas_frame_busy(frame_addr);

        megasas_frame_set_scsi_status(s, frame_addr, BUSY);

        megasas_frame_set_cmd_status(s, frame_addr, MFI_STAT_SCSI_DONE_WITH_ERROR);

        megasas_complete_frame(s, frame_context);

        s->event_count++;

        return;

    }

    switch (cmd->frame->header.frame_cmd) {

    case MFI_CMD_INIT:

        frame_status = megasas_init_firmware(s, cmd);

        break;

    case MFI_CMD_DCMD:

        frame_status = megasas_handle_dcmd(s, cmd);

        break;

    case MFI_CMD_ABORT:

        frame_status = megasas_handle_abort(s, cmd);

        break;

    case MFI_CMD_PD_SCSI_IO:

        frame_status = megasas_handle_scsi(s, cmd, 0);

        break;

    case MFI_CMD_LD_SCSI_IO:

        frame_status = megasas_handle_scsi(s, cmd, 1);

        break;

    case MFI_CMD_LD_READ:

    case MFI_CMD_LD_WRITE:

        frame_status = megasas_handle_io(s, cmd);

        break;

    default:

        trace_megasas_unhandled_frame_cmd(cmd->index,

                                          cmd->frame->header.frame_cmd);

        s->event_count++;

        break;

    }

    if (frame_status != MFI_STAT_INVALID_STATUS) {

        if (cmd->frame) {

            cmd->frame->header.cmd_status = frame_status;

        } else {

            megasas_frame_set_cmd_status(s, frame_addr, frame_status);

        }

        megasas_unmap_frame(s, cmd);

        megasas_complete_frame(s, cmd->context);

    }

}
 and probability:0.14035087719298245
code:static void intel_hda_mmio_writew(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffff);

}
 and probability:0.0
code:void pcnet_common_cleanup(PCNetState *d)

{

    d->nic = NULL;

}
 and probability:0.25
code:static void lan9118_16bit_mode_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t val, unsigned size)

{

    switch (size) {

    case 2:

        lan9118_writew(opaque, offset, (uint32_t)val);

        return;

    case 4:

        lan9118_writel(opaque, offset, val, size);

        return;

    }



    hw_error("lan9118_write: Bad size 0x%x\n", size);

}
 and probability:0.0
code:av_cold int ff_h264_decode_init(AVCodecContext *avctx)

{

    H264Context *h = avctx->priv_data;

    int ret;



    ret = h264_init_context(avctx, h);

    if (ret < 0)

        return ret;



    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));

    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));



    /* set defaults */

    // s->decode_mb = ff_h263_decode_mb;

    if (!avctx->has_b_frames)

        h->low_delay = 1;



    ff_h264_decode_init_vlc();



    ff_init_cabac_states();



    if (avctx->codec_id == AV_CODEC_ID_H264) {

        if (avctx->ticks_per_frame == 1)

            h->avctx->framerate.num *= 2;

        avctx->ticks_per_frame = 2;

    }



    if (avctx->extradata_size > 0 && avctx->extradata) {

       ret = ff_h264_decode_extradata(h);

       if (ret < 0) {

           ff_h264_free_context(h);

           return ret;

       }

    }



    if (h->sps.bitstream_restriction_flag &&

        h->avctx->has_b_frames < h->sps.num_reorder_frames) {

        h->avctx->has_b_frames = h->sps.num_reorder_frames;

        h->low_delay           = 0;

    }



    avctx->internal->allocate_progress = 1;



    if (h->enable_er) {

        av_log(avctx, AV_LOG_WARNING,

               "Error resilience is enabled. It is unsafe and unsupported and may crash. "

               "Use it at your own risk\n");

    }



    return 0;

}
 and probability:0.4
code:static void stream_desc_load(struct Stream *s, hwaddr addr)

{

    struct SDesc *d = &s->desc;

    int i;



    cpu_physical_memory_read(addr, (void *) d, sizeof *d);



    /* Convert from LE into host endianness.  */

    d->buffer_address = le64_to_cpu(d->buffer_address);

    d->nxtdesc = le64_to_cpu(d->nxtdesc);

    d->control = le32_to_cpu(d->control);

    d->status = le32_to_cpu(d->status);

    for (i = 0; i < ARRAY_SIZE(d->app); i++) {

        d->app[i] = le32_to_cpu(d->app[i]);

    }

}
 and probability:0.5714285714285714
code:static CharDriverState *qemu_chr_open_win_file(HANDLE fd_out)

{

    CharDriverState *chr;

    WinCharState *s;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(WinCharState));

    s->hcom = fd_out;

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    return chr;

}
 and probability:0.2727272727272727
code:void gdb_exit(CPUState *env, int code)

{

  GDBState *s;

  char buf[4];



  s = &gdbserver_state;

  if (gdbserver_fd < 0 || s->fd < 0)

    return;



  snprintf(buf, sizeof(buf), "W%02x", code);

  put_packet(s, buf);

}
 and probability:0.1
code:static int usb_uhci_piix4_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_2);

    return usb_uhci_common_initfn(s);

}
 and probability:0.125
code:static void pxa2xx_gpio_write(void *opaque, hwaddr offset,

                              uint64_t value, unsigned size)

{

    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;

    int bank;

    if (offset >= 0x200)

        return;



    bank = pxa2xx_gpio_regs[offset].bank;

    switch (pxa2xx_gpio_regs[offset].reg) {

    case GPDR:		/* GPIO Pin-Direction registers */

        s->dir[bank] = value;

        pxa2xx_gpio_handler_update(s);

        break;



    case GPSR:		/* GPIO Pin-Output Set registers */

        s->olevel[bank] |= value;

        pxa2xx_gpio_handler_update(s);

        break;



    case GPCR:		/* GPIO Pin-Output Clear registers */

        s->olevel[bank] &= ~value;

        pxa2xx_gpio_handler_update(s);

        break;



    case GRER:		/* GPIO Rising-Edge Detect Enable registers */

        s->rising[bank] = value;

        break;



    case GFER:		/* GPIO Falling-Edge Detect Enable registers */

        s->falling[bank] = value;

        break;



    case GAFR_L:	/* GPIO Alternate Function registers */

        s->gafr[bank * 2] = value;

        break;



    case GAFR_U:	/* GPIO Alternate Function registers */

        s->gafr[bank * 2 + 1] = value;

        break;



    case GEDR:		/* GPIO Edge Detect Status registers */

        s->status[bank] &= ~value;

        pxa2xx_gpio_irq_update(s);

        break;



    default:

        hw_error("%s: Bad offset " REG_FMT "\n", __FUNCTION__, offset);

    }

}
 and probability:0.24390243902439024
code:int cpu_signal_handler(int host_signum, void *pinfo, void *puc)

{

    siginfo_t *info = pinfo;

    ucontext_t *uc = puc;

    unsigned long ip;

    int is_write = 0;



    ip = uc->uc_mcontext.sc_ip;

    switch (host_signum) {

    case SIGILL:

    case SIGFPE:

    case SIGSEGV:

    case SIGBUS:

    case SIGTRAP:

        if (info->si_code && (info->si_segvflags & __ISR_VALID)) {

            /* ISR.W (write-access) is bit 33:  */

            is_write = (info->si_isr >> 33) & 1;

        }

        break;



    default:

        break;

    }

    return handle_cpu_signal(ip, (unsigned long)info->si_addr,

                             is_write,

                             (sigset_t *)&uc->uc_sigmask);

}
 and probability:0.2
code:void virtio_blk_data_plane_start(VirtIOBlockDataPlane *s)

{

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s->vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    VirtIOBlock *vblk = VIRTIO_BLK(s->vdev);

    VirtQueue *vq;

    int r;



    if (s->started || s->disabled) {

        return;

    }



    if (s->starting) {

        return;

    }



    s->starting = true;



    vq = virtio_get_queue(s->vdev, 0);

    if (!vring_setup(&s->vring, s->vdev, 0)) {

        goto fail_vring;

    }



    /* Set up guest notifier (irq) */

    r = k->set_guest_notifiers(qbus->parent, 1, true);

    if (r != 0) {

        fprintf(stderr, "virtio-blk failed to set guest notifier (%d), "

                "ensure -enable-kvm is set\n", r);

        goto fail_guest_notifiers;

    }

    s->guest_notifier = virtio_queue_get_guest_notifier(vq);



    /* Set up virtqueue notify */

    r = k->set_host_notifier(qbus->parent, 0, true);

    if (r != 0) {

        fprintf(stderr, "virtio-blk failed to set host notifier (%d)\n", r);

        goto fail_host_notifier;

    }

    s->host_notifier = *virtio_queue_get_host_notifier(vq);



    s->saved_complete_request = vblk->complete_request;

    vblk->complete_request = complete_request_vring;



    s->starting = false;

    s->started = true;

    trace_virtio_blk_data_plane_start(s);



    blk_set_aio_context(s->conf->conf.blk, s->ctx);



    /* Kick right away to begin processing requests already in vring */

    event_notifier_set(virtio_queue_get_host_notifier(vq));



    /* Get this show started by hooking up our callbacks */

    aio_context_acquire(s->ctx);

    aio_set_event_notifier(s->ctx, &s->host_notifier, true,

                           handle_notify);

    aio_context_release(s->ctx);

    return;



  fail_host_notifier:

    k->set_guest_notifiers(qbus->parent, 1, false);

  fail_guest_notifiers:

    vring_teardown(&s->vring, s->vdev, 0);

    s->disabled = true;

  fail_vring:

    s->starting = false;

}
 and probability:0.41818181818181815
code:static void qdm2_decode_fft_packets (QDM2Context *q)

{

    int i, j, min, max, value, type, unknown_flag;

    GetBitContext gb;



    if (q->sub_packet_list_B[0].packet == NULL)

        return;



    /* reset minimum indices for FFT coefficients */

    q->fft_coefs_index = 0;

    for (i=0; i < 5; i++)

        q->fft_coefs_min_index[i] = -1;



    /* process subpackets ordered by type, largest type first */

    for (i = 0, max = 256; i < q->sub_packets_B; i++) {

        QDM2SubPacket *packet;



        /* find subpacket with largest type less than max */

        for (j = 0, min = 0, packet = NULL; j < q->sub_packets_B; j++) {

            value = q->sub_packet_list_B[j].packet->type;

            if (value > min && value < max) {

                min = value;

                packet = q->sub_packet_list_B[j].packet;

            }

        }



        max = min;



        /* check for errors (?) */

        if (i == 0 && (packet->type < 16 || packet->type >= 48 || fft_subpackets[packet->type - 16]))

            return;



        /* decode FFT tones */

        init_get_bits (&gb, packet->data, packet->size*8);



        if (packet->type >= 32 && packet->type < 48 && !fft_subpackets[packet->type - 16])

            unknown_flag = 1;

        else

            unknown_flag = 0;



        type = packet->type;



        if ((type >= 17 && type < 24) || (type >= 33 && type < 40)) {

            int duration = q->sub_sampling + 5 - (type & 15);



            if (duration >= 0 && duration < 4)

                qdm2_fft_decode_tones(q, duration, &gb, unknown_flag);

        } else if (type == 31) {

            for (i=0; i < 4; i++)

                qdm2_fft_decode_tones(q, i, &gb, unknown_flag);

        } else if (type == 46) {

            for (i=0; i < 6; i++)

                q->fft_level_exp[i] = get_bits(&gb, 6);

            for (i=0; i < 4; i++)

            qdm2_fft_decode_tones(q, i, &gb, unknown_flag);

        }

    } // Loop on B packets



    /* calculate maximum indices for FFT coefficients */

    for (i = 0, j = -1; i < 5; i++)

        if (q->fft_coefs_min_index[i] >= 0) {

            if (j >= 0)

                q->fft_coefs_max_index[j] = q->fft_coefs_min_index[i];

            j = i;

        }

    if (j >= 0)

        q->fft_coefs_max_index[j] = q->fft_coefs_index;

}
 and probability:0.375
code:void avcodec_get_channel_layout_string(char *buf, int buf_size, int nb_channels, int64_t channel_layout)

{

    int i;



    if (channel_layout==0)

        channel_layout = avcodec_guess_channel_layout(nb_channels, CODEC_ID_NONE, NULL);



    for (i=0; channel_layout_map[i].name; i++)

        if (nb_channels    == channel_layout_map[i].nb_channels &&

            channel_layout == channel_layout_map[i].layout) {

            snprintf(buf, buf_size, channel_layout_map[i].name);

            return;

        }



    snprintf(buf, buf_size, "%d channels", nb_channels);

    if (channel_layout) {

        int i,ch;

        av_strlcat(buf, " (", buf_size);

        for(i=0,ch=0; i<64; i++) {

            if ((channel_layout & (1L<<i))) {

                const char *name = get_channel_name(i);

                if (name) {

                    if (ch>0) av_strlcat(buf, "|", buf_size);

                    av_strlcat(buf, name, buf_size);

                }

                ch++;

            }

        }

        av_strlcat(buf, ")", buf_size);

    }

}
 and probability:0.21428571428571427
code:int ff_h264_decode_ref_pic_list_reordering(H264Context *h, H264SliceContext *sl)

{

    int list, index, pic_structure;



    print_short_term(h);

    print_long_term(h);



    for (list = 0; list < sl->list_count; list++) {

        memcpy(sl->ref_list[list], h->default_ref_list[list], sl->ref_count[list] * sizeof(sl->ref_list[0][0]));



        if (get_bits1(&sl->gb)) {    // ref_pic_list_modification_flag_l[01]

            int pred = h->curr_pic_num;



            for (index = 0; ; index++) {

                unsigned int modification_of_pic_nums_idc = get_ue_golomb_31(&sl->gb);

                unsigned int pic_id;

                int i;

                H264Picture *ref = NULL;



                if (modification_of_pic_nums_idc == 3)

                    break;



                if (index >= sl->ref_count[list]) {

                    av_log(h->avctx, AV_LOG_ERROR, "reference count overflow\n");

                    return -1;

                }



                switch (modification_of_pic_nums_idc) {

                case 0:

                case 1: {

                    const unsigned int abs_diff_pic_num = get_ue_golomb(&sl->gb) + 1;

                    int frame_num;



                    if (abs_diff_pic_num > h->max_pic_num) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               "abs_diff_pic_num overflow\n");

                        return AVERROR_INVALIDDATA;

                    }



                    if (modification_of_pic_nums_idc == 0)

                        pred -= abs_diff_pic_num;

                    else

                        pred += abs_diff_pic_num;

                    pred &= h->max_pic_num - 1;



                    frame_num = pic_num_extract(h, pred, &pic_structure);



                    for (i = h->short_ref_count - 1; i >= 0; i--) {

                        ref = h->short_ref[i];

                        assert(ref->reference);

                        assert(!ref->long_ref);

                        if (ref->frame_num == frame_num &&

                            (ref->reference & pic_structure))

                            break;

                    }

                    if (i >= 0)

                        ref->pic_id = pred;

                    break;

                }

                case 2: {

                    int long_idx;

                    pic_id = get_ue_golomb(&sl->gb); // long_term_pic_idx



                    long_idx = pic_num_extract(h, pic_id, &pic_structure);



                    if (long_idx > 31) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               "long_term_pic_idx overflow\n");

                        return AVERROR_INVALIDDATA;

                    }

                    ref = h->long_ref[long_idx];

                    assert(!(ref && !ref->reference));

                    if (ref && (ref->reference & pic_structure)) {

                        ref->pic_id = pic_id;

                        assert(ref->long_ref);

                        i = 0;

                    } else {

                        i = -1;

                    }

                    break;

                }

                default:

                    av_log(h->avctx, AV_LOG_ERROR,

                           "illegal modification_of_pic_nums_idc %u\n",

                           modification_of_pic_nums_idc);

                    return AVERROR_INVALIDDATA;

                }



                if (i < 0) {

                    av_log(h->avctx, AV_LOG_ERROR,

                           "reference picture missing during reorder\n");

                    memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME

                } else {

                    for (i = index; i + 1 < sl->ref_count[list]; i++) {

                        if (sl->ref_list[list][i].parent &&

                            ref->long_ref == sl->ref_list[list][i].parent->long_ref &&

                            ref->pic_id   == sl->ref_list[list][i].pic_id)

                            break;

                    }

                    for (; i > index; i--) {

                        sl->ref_list[list][i] = sl->ref_list[list][i - 1];

                    }

                    ref_from_h264pic(&sl->ref_list[list][index], ref);

                    if (FIELD_PICTURE(h)) {

                        pic_as_field(&sl->ref_list[list][index], pic_structure);

                    }

                }

            }

        }

    }

    for (list = 0; list < sl->list_count; list++) {

        for (index = 0; index < sl->ref_count[list]; index++) {

            if (   !sl->ref_list[list][index].parent

                || (!FIELD_PICTURE(h) && (sl->ref_list[list][index].reference&3) != 3)) {

                int i;

                av_log(h->avctx, AV_LOG_ERROR, "Missing reference picture, default is %d\n", h->default_ref_list[list][0].poc);

                for (i = 0; i < FF_ARRAY_ELEMS(h->last_pocs); i++)

                    h->last_pocs[i] = INT_MIN;

                if (h->default_ref_list[list][0].parent

                    && !(!FIELD_PICTURE(h) && (h->default_ref_list[list][0].reference&3) != 3))

                    sl->ref_list[list][index] = h->default_ref_list[list][0];

                else

                    return -1;

            }

            av_assert0(av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0);

        }

    }



    return 0;

}
 and probability:0.43478260869565216
code:void FUNCC(ff_h264_chroma422_dc_dequant_idct)(int16_t *_block, int qmul){

    const int stride= 16*2;

    const int xStride= 16;

    int i;

    int temp[8];

    static const uint8_t x_offset[2]={0, 16};

    dctcoef *block = (dctcoef*)_block;



    for(i=0; i<4; i++){

        temp[2*i+0] = block[stride*i + xStride*0] + block[stride*i + xStride*1];

        temp[2*i+1] = block[stride*i + xStride*0] - block[stride*i + xStride*1];

    }



    for(i=0; i<2; i++){

        const int offset= x_offset[i];

        const int z0= temp[2*0+i] + temp[2*2+i];

        const int z1= temp[2*0+i] - temp[2*2+i];

        const int z2= temp[2*1+i] - temp[2*3+i];

        const int z3= temp[2*1+i] + temp[2*3+i];



        block[stride*0+offset]= ((z0 + z3)*qmul + 128) >> 8;

        block[stride*1+offset]= ((z1 + z2)*qmul + 128) >> 8;

        block[stride*2+offset]= ((z1 - z2)*qmul + 128) >> 8;

        block[stride*3+offset]= ((z0 - z3)*qmul + 128) >> 8;

    }

}
 and probability:0.6086956521739131
code:static int curl_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVCURLState *s = bs->opaque;

    CURLState *state = NULL;

    double d;



    #define RA_OPTSTR ":readahead="

    char *file;

    char *ra;

    const char *ra_val;

    int parse_state = 0;



    static int inited = 0;



    file = strdup(filename);

    s->readahead_size = READ_AHEAD_SIZE;



    /* Parse a trailing ":readahead=#:" param, if present. */

    ra = file + strlen(file) - 1;

    while (ra >= file) {

        if (parse_state == 0) {

            if (*ra == ':')

                parse_state++;

            else

                break;

        } else if (parse_state == 1) {

            if (*ra > '9' || *ra < '0') {

                char *opt_start = ra - strlen(RA_OPTSTR) + 1;

                if (opt_start > file &&

                    strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {

                    ra_val = ra + 1;

                    ra -= strlen(RA_OPTSTR) - 1;

                    *ra = '\0';

                    s->readahead_size = atoi(ra_val);

                    break;

                } else {

                    break;

                }

            }

        }

        ra--;

    }



    if ((s->readahead_size & 0x1ff) != 0) {

        fprintf(stderr, "HTTP_READAHEAD_SIZE %zd is not a multiple of 512\n",

                s->readahead_size);

        goto out_noclean;

    }



    if (!inited) {

        curl_global_init(CURL_GLOBAL_ALL);

        inited = 1;

    }



    DPRINTF("CURL: Opening %s\n", file);

    s->url = file;

    state = curl_init_state(s);

    if (!state)

        goto out_noclean;



    // Get file size



    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);

    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_size_cb);

    if (curl_easy_perform(state->curl))

        goto out;

    curl_easy_getinfo(state->curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d);

    curl_easy_setopt(state->curl, CURLOPT_WRITEFUNCTION, (void *)curl_read_cb);

    curl_easy_setopt(state->curl, CURLOPT_NOBODY, 0);

    if (d)

        s->len = (size_t)d;

    else if(!s->len)

        goto out;

    DPRINTF("CURL: Size = %lld\n", (long long)s->len);



    curl_clean_state(state);

    curl_easy_cleanup(state->curl);

    state->curl = NULL;



    // Now we know the file exists and its size, so let's

    // initialize the multi interface!



    s->multi = curl_multi_init();

    curl_multi_setopt( s->multi, CURLMOPT_SOCKETDATA, s); 

    curl_multi_setopt( s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb ); 

    curl_multi_do(s);



    return 0;



out:

    fprintf(stderr, "CURL: Error opening file: %s\n", state->errmsg);

    curl_easy_cleanup(state->curl);

    state->curl = NULL;

out_noclean:

    qemu_free(file);

    return -EINVAL;

}
 and probability:0.39759036144578314
code:static void cin_decode_rle(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)

{

    int len, code;

    unsigned char *dst_end = dst + dst_size;

    const unsigned char *src_end = src + src_size;



    while (src < src_end && dst < dst_end) {

        code = *src++;

        if (code & 0x80) {

            len = code - 0x7F;

            memset(dst, *src++, FFMIN(len, dst_end - dst));

        } else {

            len = code + 1;

            memcpy(dst, src, FFMIN(len, dst_end - dst));

            src += len;

        }

        dst += len;

    }

}
 and probability:0.5
code:static int64_t coroutine_fn iscsi_co_get_block_status(BlockDriverState *bs,

                                                  int64_t sector_num,

                                                  int nb_sectors, int *pnum,

                                                  BlockDriverState **file)

{

    IscsiLun *iscsilun = bs->opaque;

    struct scsi_get_lba_status *lbas = NULL;

    struct scsi_lba_status_descriptor *lbasd = NULL;

    struct IscsiTask iTask;

    uint64_t lba;

    int64_t ret;



    if (!is_sector_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {

        ret = -EINVAL;

        goto out;

    }



    /* default to all sectors allocated */

    ret = BDRV_BLOCK_DATA;

    ret |= (sector_num << BDRV_SECTOR_BITS) | BDRV_BLOCK_OFFSET_VALID;

    *pnum = nb_sectors;



    /* LUN does not support logical block provisioning */

    if (!iscsilun->lbpme) {

        goto out;

    }



    lba = sector_qemu2lun(sector_num, iscsilun);



    iscsi_co_init_iscsitask(iscsilun, &iTask);

    qemu_mutex_lock(&iscsilun->mutex);

retry:

    if (iscsi_get_lba_status_task(iscsilun->iscsi, iscsilun->lun,

                                  lba, 8 + 16, iscsi_co_generic_cb,

                                  &iTask) == NULL) {

        ret = -ENOMEM;

        goto out_unlock;

    }



    while (!iTask.complete) {

        iscsi_set_events(iscsilun);

        qemu_mutex_unlock(&iscsilun->mutex);

        qemu_coroutine_yield();

        qemu_mutex_lock(&iscsilun->mutex);

    }



    if (iTask.do_retry) {

        if (iTask.task != NULL) {

            scsi_free_scsi_task(iTask.task);

            iTask.task = NULL;

        }

        iTask.complete = 0;

        goto retry;

    }



    if (iTask.status != SCSI_STATUS_GOOD) {

        /* in case the get_lba_status_callout fails (i.e.

         * because the device is busy or the cmd is not

         * supported) we pretend all blocks are allocated

         * for backwards compatibility */

        error_report("iSCSI GET_LBA_STATUS failed at lba %" PRIu64 ": %s",

                     lba, iTask.err_str);

        goto out_unlock;

    }



    lbas = scsi_datain_unmarshall(iTask.task);

    if (lbas == NULL) {

        ret = -EIO;

        goto out_unlock;

    }



    lbasd = &lbas->descriptors[0];



    if (sector_qemu2lun(sector_num, iscsilun) != lbasd->lba) {

        ret = -EIO;

        goto out_unlock;

    }



    *pnum = sector_lun2qemu(lbasd->num_blocks, iscsilun);



    if (lbasd->provisioning == SCSI_PROVISIONING_TYPE_DEALLOCATED ||

        lbasd->provisioning == SCSI_PROVISIONING_TYPE_ANCHORED) {

        ret &= ~BDRV_BLOCK_DATA;

        if (iscsilun->lbprz) {

            ret |= BDRV_BLOCK_ZERO;

        }

    }



    if (ret & BDRV_BLOCK_ZERO) {

        iscsi_allocmap_set_unallocated(iscsilun, sector_num, *pnum);

    } else {

        iscsi_allocmap_set_allocated(iscsilun, sector_num, *pnum);

    }



    if (*pnum > nb_sectors) {

        *pnum = nb_sectors;

    }

out_unlock:

    qemu_mutex_unlock(&iscsilun->mutex);

    g_free(iTask.err_str);

out:

    if (iTask.task != NULL) {

        scsi_free_scsi_task(iTask.task);

    }

    if (ret > 0 && ret & BDRV_BLOCK_OFFSET_VALID) {

        *file = bs;

    }

    return ret;

}
 and probability:0.2127659574468085
code:static int dvvideo_decode_frame(AVCodecContext *avctx, void *data,

                                int *got_frame, AVPacket *avpkt)

{

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DVVideoContext *s = avctx->priv_data;

    const uint8_t *vsc_pack;

    int apt, is16_9, ret;

    const AVDVProfile *sys;



    sys = av_dv_frame_profile(s->sys, buf, buf_size);

    if (!sys || buf_size < sys->frame_size) {

        av_log(avctx, AV_LOG_ERROR, "could not find dv frame profile\n");

        return -1; /* NOTE: we only accept several full frames */

    }



    if (sys != s->sys) {

        ret = ff_dv_init_dynamic_tables(s, sys);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, "Error initializing the work tables.\n");

            return ret;

        }

        s->sys = sys;

    }



    s->frame            = data;

    s->frame->key_frame = 1;

    s->frame->pict_type = AV_PICTURE_TYPE_I;

    avctx->pix_fmt      = s->sys->pix_fmt;

    avctx->framerate    = av_inv_q(s->sys->time_base);



    ret = ff_set_dimensions(avctx, s->sys->width, s->sys->height);

    if (ret < 0)

        return ret;



    /* Determine the codec's sample_aspect ratio from the packet */

    vsc_pack = buf + 80 * 5 + 48 + 5;

    if (*vsc_pack == dv_video_control) {

        apt    = buf[4] & 0x07;

        is16_9 = (vsc_pack && ((vsc_pack[2] & 0x07) == 0x02 ||

                               (!apt && (vsc_pack[2] & 0x07) == 0x07)));

        ff_set_sar(avctx, s->sys->sar[is16_9]);

    }



    if (ff_get_buffer(avctx, s->frame, 0) < 0) {

        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");

        return -1;

    }

    s->frame->interlaced_frame = 1;

    s->frame->top_field_first  = 0;



    s->buf = buf;

    avctx->execute(avctx, dv_decode_video_segment, s->work_chunks, NULL,

                   dv_work_pool_size(s->sys), sizeof(DVwork_chunk));



    emms_c();



    /* return image */

    *got_frame = 1;



    return s->sys->frame_size;

}
 and probability:0.5192307692307693
code:static int inc_refcounts(BlockDriverState *bs,

                          uint16_t *refcount_table,

                          int refcount_table_size,

                          int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    int64_t start, last, cluster_offset;

    int k;

    int errors = 0;



    if (size <= 0)

        return 0;



    start = offset & ~(s->cluster_size - 1);

    last = (offset + size - 1) & ~(s->cluster_size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k < 0 || k >= refcount_table_size) {

            fprintf(stderr, "ERROR: invalid cluster offset=0x%" PRIx64 "\n",

                cluster_offset);

            errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, "ERROR: overflow cluster offset=0x%" PRIx64

                    "\n", cluster_offset);

                errors++;

            }

        }

    }



    return errors;

}
 and probability:0.26666666666666666
code:static void arm_tr_tb_stop(DisasContextBase *dcbase, CPUState *cpu)

{

    DisasContext *dc = container_of(dcbase, DisasContext, base);



    if (dc->base.tb->cflags & CF_LAST_IO && dc->condjmp) {

        /* FIXME: This can theoretically happen with self-modifying code. */

        cpu_abort(cpu, "IO on conditional branch instruction");

    }



    /* At this stage dc->condjmp will only be set when the skipped

       instruction was a conditional branch or trap, and the PC has

       already been written.  */

    gen_set_condexec(dc);

    if (dc->base.is_jmp == DISAS_BX_EXCRET) {

        /* Exception return branches need some special case code at the

         * end of the TB, which is complex enough that it has to

         * handle the single-step vs not and the condition-failed

         * insn codepath itself.

         */

        gen_bx_excret_final_code(dc);

    } else if (unlikely(is_singlestepping(dc))) {

        /* Unconditional and "condition passed" instruction codepath. */

        switch (dc->base.is_jmp) {

        case DISAS_SWI:

            gen_ss_advance(dc);

            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),

                          default_exception_el(dc));

            break;

        case DISAS_HVC:

            gen_ss_advance(dc);

            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);

            break;

        case DISAS_SMC:

            gen_ss_advance(dc);

            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);

            break;

        case DISAS_NEXT:

        case DISAS_TOO_MANY:

        case DISAS_UPDATE:

            gen_set_pc_im(dc, dc->pc);

            /* fall through */

        default:

            /* FIXME: Single stepping a WFI insn will not halt the CPU. */

            gen_singlestep_exception(dc);

            break;

        case DISAS_NORETURN:

            break;

        }

    } else {

        /* While branches must always occur at the end of an IT block,

           there are a few other things that can cause us to terminate

           the TB in the middle of an IT block:

            - Exception generating instructions (bkpt, swi, undefined).

            - Page boundaries.

            - Hardware watchpoints.

           Hardware breakpoints have already been handled and skip this code.

         */

        switch(dc->base.is_jmp) {

        case DISAS_NEXT:

        case DISAS_TOO_MANY:

            gen_goto_tb(dc, 1, dc->pc);

            break;

        case DISAS_JUMP:

            gen_goto_ptr();

            break;

        case DISAS_UPDATE:

            gen_set_pc_im(dc, dc->pc);

            /* fall through */

        default:

            /* indicate that the hash table must be used to find the next TB */

            tcg_gen_exit_tb(0);

            break;

        case DISAS_NORETURN:

            /* nothing more to generate */

            break;

        case DISAS_WFI:

            gen_helper_wfi(cpu_env);

            /* The helper doesn't necessarily throw an exception, but we

             * must go back to the main loop to check for interrupts anyway.

             */

            tcg_gen_exit_tb(0);

            break;

        case DISAS_WFE:

            gen_helper_wfe(cpu_env);

            break;

        case DISAS_YIELD:

            gen_helper_yield(cpu_env);

            break;

        case DISAS_SWI:

            gen_exception(EXCP_SWI, syn_aa32_svc(dc->svc_imm, dc->thumb),

                          default_exception_el(dc));

            break;

        case DISAS_HVC:

            gen_exception(EXCP_HVC, syn_aa32_hvc(dc->svc_imm), 2);

            break;

        case DISAS_SMC:

            gen_exception(EXCP_SMC, syn_aa32_smc(), 3);

            break;

        }

    }



    if (dc->condjmp) {

        /* "Condition failed" instruction codepath for the branch/trap insn */

        gen_set_label(dc->condlabel);

        gen_set_condexec(dc);

        if (unlikely(is_singlestepping(dc))) {

            gen_set_pc_im(dc, dc->pc);

            gen_singlestep_exception(dc);

        } else {

            gen_goto_tb(dc, 1, dc->pc);

        }

    }



    /* Functions above can change dc->pc, so re-align db->pc_next */

    dc->base.pc_next = dc->pc;

}
 and probability:0.14285714285714285
code:void pcmcia_info(Monitor *mon, const QDict *qdict)

{

    struct pcmcia_socket_entry_s *iter;



    if (!pcmcia_sockets)

        monitor_printf(mon, "No PCMCIA sockets\n");



    for (iter = pcmcia_sockets; iter; iter = iter->next)

        monitor_printf(mon, "%s: %s\n", iter->socket->slot_string,

                       iter->socket->attached ? iter->socket->card_string :

                       "Empty");

}
 and probability:0.3
code:static void ahci_reg_init(AHCIState *s)

{

    int i;



    s->control_regs.cap = (s->ports - 1) |

                          (AHCI_NUM_COMMAND_SLOTS << 8) |

                          (AHCI_SUPPORTED_SPEED_GEN1 << AHCI_SUPPORTED_SPEED) |

                          HOST_CAP_NCQ | HOST_CAP_AHCI;



    s->control_regs.impl = (1 << s->ports) - 1;



    s->control_regs.version = AHCI_VERSION_1_0;



    for (i = 0; i < s->ports; i++) {

        s->dev[i].port_state = STATE_RUN;

    }

}
 and probability:0.38461538461538464
code:static void virtio_crypto_get_config(VirtIODevice *vdev, uint8_t *config)

{

    VirtIOCrypto *c = VIRTIO_CRYPTO(vdev);

    struct virtio_crypto_config crypto_cfg;



    /*

     * Virtio-crypto device conforms to VIRTIO 1.0 which is always LE,

     * so we can use LE accessors directly.

     */

    stl_le_p(&crypto_cfg.status, c->status);

    stl_le_p(&crypto_cfg.max_dataqueues, c->max_queues);

    stl_le_p(&crypto_cfg.crypto_services, c->conf.crypto_services);

    stl_le_p(&crypto_cfg.cipher_algo_l, c->conf.cipher_algo_l);

    stl_le_p(&crypto_cfg.cipher_algo_h, c->conf.cipher_algo_h);

    stl_le_p(&crypto_cfg.hash_algo, c->conf.hash_algo);

    stl_le_p(&crypto_cfg.mac_algo_l, c->conf.mac_algo_l);

    stl_le_p(&crypto_cfg.mac_algo_h, c->conf.mac_algo_h);

    stl_le_p(&crypto_cfg.aead_algo, c->conf.aead_algo);

    stl_le_p(&crypto_cfg.max_cipher_key_len, c->conf.max_cipher_key_len);

    stl_le_p(&crypto_cfg.max_auth_key_len, c->conf.max_auth_key_len);

    stq_le_p(&crypto_cfg.max_size, c->conf.max_size);



    memcpy(config, &crypto_cfg, c->config_size);

}
 and probability:0.5909090909090909
code:static int flac_probe(AVProbeData *p)

{

    uint8_t *bufptr = p->buf;

    uint8_t *end    = p->buf + p->buf_size;



    if(bufptr > end-4 || memcmp(bufptr, "fLaC", 4)) return 0;

    else                                            return AVPROBE_SCORE_MAX/2;

}
 and probability:0.5714285714285714
code:static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,
                   uint8_t *properties)
{
    Jpeg2000QuantStyle tmp;
    int compno, ret;
    if ((ret = get_qcx(s, n, &tmp)) < 0)
        return ret;
    for (compno = 0; compno < s->ncomponents; compno++)
        if (!(properties[compno] & HAD_QCC))
            memcpy(q + compno, &tmp, sizeof(tmp));
    return 0;
} and probability:0.25
code:void slirp_init(int restricted, struct in_addr vnetwork,

                struct in_addr vnetmask, struct in_addr vhost,

                const char *vhostname, const char *tftp_path,

                const char *bootfile, struct in_addr vdhcp_start,

                struct in_addr vnameserver)

{

#ifdef _WIN32

    WSADATA Data;



    WSAStartup(MAKEWORD(2,0), &Data);

    atexit(slirp_cleanup);

#endif



    link_up = 1;

    slirp_restrict = restricted;



    if_init();

    ip_init();



    /* Initialise mbufs *after* setting the MTU */

    m_init();



    /* set default addresses */

    inet_aton("127.0.0.1", &loopback_addr);



    if (get_dns_addr(&dns_addr) < 0) {

        dns_addr = loopback_addr;

        fprintf (stderr, "Warning: No DNS servers found\n");

    }



    vnetwork_addr = vnetwork;

    vnetwork_mask = vnetmask;

    vhost_addr = vhost;

    if (vhostname) {

        pstrcpy(slirp_hostname, sizeof(slirp_hostname), vhostname);

    }

    qemu_free(tftp_prefix);

    tftp_prefix = NULL;

    if (tftp_path) {

        tftp_prefix = qemu_strdup(tftp_path);

    }

    qemu_free(bootp_filename);

    bootp_filename = NULL;

    if (bootfile) {

        bootp_filename = qemu_strdup(bootfile);

    }

    vdhcp_startaddr = vdhcp_start;

    vnameserver_addr = vnameserver;



    getouraddr();

    register_savevm("slirp", 0, 1, slirp_state_save, slirp_state_load, NULL);

}
 and probability:0.0
code:void virtio_net_set_config_size(VirtIONet *n, uint32_t host_features)

{

    int i, config_size = 0;


    for (i = 0; feature_sizes[i].flags != 0; i++) {

        if (host_features & feature_sizes[i].flags) {

            config_size = MAX(feature_sizes[i].end, config_size);

        }

    }

    n->config_size = config_size;

} and probability:0.4
code:qemu_irq *openpic_init (PCIBus *bus, int *pmem_index, int nb_cpus,

                        qemu_irq **irqs, qemu_irq irq_out)

{

    openpic_t *opp;

    uint8_t *pci_conf;

    int i, m;



    /* XXX: for now, only one CPU is supported */

    if (nb_cpus != 1)

        return NULL;

    if (bus) {

        opp = (openpic_t *)pci_register_device(bus, "OpenPIC", sizeof(openpic_t),

                                               -1, NULL, NULL);

        if (opp == NULL)

            return NULL;

        pci_conf = opp->pci_dev.config;

        pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_IBM);

        pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_IBM_OPENPIC2);

        pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER); // FIXME?

        pci_conf[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type

        pci_conf[0x3d] = 0x00; // no interrupt pin



        /* Register I/O spaces */

        pci_register_bar((PCIDevice *)opp, 0, 0x40000,

                               PCI_BASE_ADDRESS_SPACE_MEMORY, &openpic_map);

    } else {

        opp = qemu_mallocz(sizeof(openpic_t));

    }

    opp->mem_index = cpu_register_io_memory(openpic_read,

                                            openpic_write, opp);



    //    isu_base &= 0xFFFC0000;

    opp->nb_cpus = nb_cpus;

    opp->max_irq = OPENPIC_MAX_IRQ;

    opp->irq_ipi0 = OPENPIC_IRQ_IPI0;

    opp->irq_tim0 = OPENPIC_IRQ_TIM0;

    /* Set IRQ types */

    for (i = 0; i < OPENPIC_EXT_IRQ; i++) {

        opp->src[i].type = IRQ_EXTERNAL;

    }

    for (; i < OPENPIC_IRQ_TIM0; i++) {

        opp->src[i].type = IRQ_SPECIAL;

    }

#if MAX_IPI > 0

    m = OPENPIC_IRQ_IPI0;

#else

    m = OPENPIC_IRQ_DBL0;

#endif

    for (; i < m; i++) {

        opp->src[i].type = IRQ_TIMER;

    }

    for (; i < OPENPIC_MAX_IRQ; i++) {

        opp->src[i].type = IRQ_INTERNAL;

    }

    for (i = 0; i < nb_cpus; i++)

        opp->dst[i].irqs = irqs[i];

    opp->irq_out = irq_out;

    opp->need_swap = 1;



    register_savevm("openpic", 0, 2, openpic_save, openpic_load, opp);

    qemu_register_reset(openpic_reset, opp);



    opp->irq_raise = openpic_irq_raise;

    opp->reset = openpic_reset;



    if (pmem_index)

        *pmem_index = opp->mem_index;



    return qemu_allocate_irqs(openpic_set_irq, opp, opp->max_irq);

}
 and probability:0.38095238095238093
code:static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    uint32_t sequence_number;



    if (length != 26)

        return AVERROR_INVALIDDATA;



    if (!(s->state & PNG_IHDR)) {

        av_log(avctx, AV_LOG_ERROR, "fctl before IHDR\n");

        return AVERROR_INVALIDDATA;

    }



    s->last_w = s->cur_w;

    s->last_h = s->cur_h;

    s->last_x_offset = s->x_offset;

    s->last_y_offset = s->y_offset;

    s->last_dispose_op = s->dispose_op;



    sequence_number = bytestream2_get_be32(&s->gb);

    s->cur_w        = bytestream2_get_be32(&s->gb);

    s->cur_h        = bytestream2_get_be32(&s->gb);

    s->x_offset     = bytestream2_get_be32(&s->gb);

    s->y_offset     = bytestream2_get_be32(&s->gb);

    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */

    s->dispose_op   = bytestream2_get_byte(&s->gb);

    s->blend_op     = bytestream2_get_byte(&s->gb);

    bytestream2_skip(&s->gb, 4); /* crc */



    if (sequence_number == 0 &&

        (s->cur_w != s->width ||

         s->cur_h != s->height ||

         s->x_offset != 0 ||

         s->y_offset != 0) ||

        s->cur_w <= 0 || s->cur_h <= 0 ||

        s->x_offset < 0 || s->y_offset < 0 ||

        s->cur_w > s->width - s->x_offset|| s->cur_h > s->height - s->y_offset)

            return AVERROR_INVALIDDATA;



    if (sequence_number == 0 && s->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {

        // No previous frame to revert to for the first frame

        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND

        s->dispose_op = APNG_DISPOSE_OP_BACKGROUND;

    }



    if (s->dispose_op == APNG_BLEND_OP_OVER && !s->has_trns && (

            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||

            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||

            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||

            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||

            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||

            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK

        )) {

        // APNG_DISPOSE_OP_OVER is the same as APNG_DISPOSE_OP_SOURCE when there is no alpha channel

        s->dispose_op = APNG_BLEND_OP_SOURCE;

    }



    return 0;

}
 and probability:0.6274509803921569
code:int ff_h264_build_ref_list(H264Context *h, H264SliceContext *sl)

{

    int list, index, pic_structure;



    print_short_term(h);

    print_long_term(h);



    h264_initialise_ref_list(h, sl);



    for (list = 0; list < sl->list_count; list++) {

        int pred = sl->curr_pic_num;



        for (index = 0; index < sl->nb_ref_modifications[list]; index++) {

            unsigned int modification_of_pic_nums_idc = sl->ref_modifications[list][index].op;

            unsigned int                          val = sl->ref_modifications[list][index].val;

            unsigned int pic_id;

            int i;

            H264Picture *ref = NULL;



            switch (modification_of_pic_nums_idc) {

            case 0:

            case 1: {

                const unsigned int abs_diff_pic_num = val + 1;

                int frame_num;



                if (abs_diff_pic_num > sl->max_pic_num) {

                    av_log(h->avctx, AV_LOG_ERROR,

                           "abs_diff_pic_num overflow\n");

                    return AVERROR_INVALIDDATA;

                }



                if (modification_of_pic_nums_idc == 0)

                    pred -= abs_diff_pic_num;

                else

                    pred += abs_diff_pic_num;

                pred &= sl->max_pic_num - 1;



                frame_num = pic_num_extract(h, pred, &pic_structure);



                for (i = h->short_ref_count - 1; i >= 0; i--) {

                    ref = h->short_ref[i];

                    assert(ref->reference);

                    assert(!ref->long_ref);

                    if (ref->frame_num == frame_num &&

                        (ref->reference & pic_structure))

                        break;

                }

                if (i >= 0)

                    ref->pic_id = pred;

                break;

            }

            case 2: {

                int long_idx;

                pic_id = val; // long_term_pic_idx



                long_idx = pic_num_extract(h, pic_id, &pic_structure);



                if (long_idx > 31U) {

                    av_log(h->avctx, AV_LOG_ERROR,

                           "long_term_pic_idx overflow\n");

                    return AVERROR_INVALIDDATA;

                }

                ref = h->long_ref[long_idx];

                assert(!(ref && !ref->reference));

                if (ref && (ref->reference & pic_structure)) {

                    ref->pic_id = pic_id;

                    assert(ref->long_ref);

                    i = 0;

                } else {

                    i = -1;

                }

                break;

            }

            default:

                av_assert1(0);

            }



            if (i < 0) {

                av_log(h->avctx, AV_LOG_ERROR,

                       "reference picture missing during reorder\n");

                memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME

            } else {

                for (i = index; i + 1 < sl->ref_count[list]; i++) {

                    if (sl->ref_list[list][i].parent &&

                        ref->long_ref == sl->ref_list[list][i].parent->long_ref &&

                        ref->pic_id   == sl->ref_list[list][i].pic_id)

                        break;

                }

                for (; i > index; i--) {

                    sl->ref_list[list][i] = sl->ref_list[list][i - 1];

                }

                ref_from_h264pic(&sl->ref_list[list][index], ref);

                if (FIELD_PICTURE(h)) {

                    pic_as_field(&sl->ref_list[list][index], pic_structure);

                }

            }

        }

    }

    for (list = 0; list < sl->list_count; list++) {

        for (index = 0; index < sl->ref_count[list]; index++) {

            if (   !sl->ref_list[list][index].parent

                || (!FIELD_PICTURE(h) && (sl->ref_list[list][index].reference&3) != 3)) {

                int i;

                av_log(h->avctx, AV_LOG_ERROR, "Missing reference picture, default is %d\n", h->default_ref[list].poc);

                for (i = 0; i < FF_ARRAY_ELEMS(h->last_pocs); i++)

                    h->last_pocs[i] = INT_MIN;

                if (h->default_ref[list].parent

                    && !(!FIELD_PICTURE(h) && (h->default_ref[list].reference&3) != 3))

                    sl->ref_list[list][index] = h->default_ref[list];

                else

                    return -1;

            }

            av_assert0(av_buffer_get_ref_count(sl->ref_list[list][index].parent->f->buf[0]) > 0);

        }

    }



    if (FRAME_MBAFF(h))

        h264_fill_mbaff_ref_list(sl);



    return 0;

}
 and probability:0.4205607476635514
code:int check_hw_breakpoints(CPUX86State *env, int force_dr6_update)

{

    target_ulong dr6;

    int reg, type;

    int hit_enabled = 0;



    dr6 = env->dr[6] & ~0xf;

    for (reg = 0; reg < DR7_MAX_BP; reg++) {

        type = hw_breakpoint_type(env->dr[7], reg);

        if ((type == 0 && env->dr[reg] == env->eip) ||

            ((type & 1) && env->cpu_watchpoint[reg] &&

             (env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT))) {

            dr6 |= 1 << reg;

            if (hw_breakpoint_enabled(env->dr[7], reg)) {

                hit_enabled = 1;

            }

        }

    }

    if (hit_enabled || force_dr6_update)

        env->dr[6] = dr6;

    return hit_enabled;

}
 and probability:0.38095238095238093
code:void ff_dv_offset_reset(DVDemuxContext *c, int64_t frame_offset)

{

    c->frames= frame_offset;

    if (c->ach)

        c->abytes= av_rescale_q(c->frames, c->sys->time_base,

                                (AVRational){8, c->ast[0]->codec->bit_rate});

    c->audio_pkt[0].size = c->audio_pkt[1].size = 0;

    c->audio_pkt[2].size = c->audio_pkt[3].size = 0;

}
 and probability:0.6666666666666666
code:static int process_ipmovie_chunk(IPMVEContext *s, ByteIOContext *pb,

    AVPacket *pkt)

{

    unsigned char chunk_preamble[CHUNK_PREAMBLE_SIZE];

    int chunk_type;

    int chunk_size;

    unsigned char opcode_preamble[OPCODE_PREAMBLE_SIZE];

    unsigned char opcode_type;

    unsigned char opcode_version;

    int opcode_size;

    unsigned char scratch[1024];

    int i, j;

    int first_color, last_color;

    int audio_flags;

    unsigned char r, g, b;



    /* see if there are any pending packets */

    chunk_type = load_ipmovie_packet(s, pb, pkt);

    if ((chunk_type == CHUNK_VIDEO) && (chunk_type != CHUNK_DONE))

        return chunk_type;



    /* read the next chunk, wherever the file happens to be pointing */

    if (url_feof(pb))

        return CHUNK_EOF;

    if (get_buffer(pb, chunk_preamble, CHUNK_PREAMBLE_SIZE) !=

        CHUNK_PREAMBLE_SIZE)

        return CHUNK_BAD;

    chunk_size = AV_RL16(&chunk_preamble[0]);

    chunk_type = AV_RL16(&chunk_preamble[2]);



    debug_ipmovie("chunk type 0x%04X, 0x%04X bytes: ", chunk_type, chunk_size);



    switch (chunk_type) {



    case CHUNK_INIT_AUDIO:

        debug_ipmovie("initialize audio\n");

        break;



    case CHUNK_AUDIO_ONLY:

        debug_ipmovie("audio only\n");

        break;



    case CHUNK_INIT_VIDEO:

        debug_ipmovie("initialize video\n");

        break;



    case CHUNK_VIDEO:

        debug_ipmovie("video (and audio)\n");

        break;



    case CHUNK_SHUTDOWN:

        debug_ipmovie("shutdown\n");

        break;



    case CHUNK_END:

        debug_ipmovie("end\n");

        break;



    default:

        debug_ipmovie("invalid chunk\n");

        chunk_type = CHUNK_BAD;

        break;



    }



    while ((chunk_size > 0) && (chunk_type != CHUNK_BAD)) {



        /* read the next chunk, wherever the file happens to be pointing */

       if (url_feof(pb)) {

            chunk_type = CHUNK_EOF;

            break;

        }

        if (get_buffer(pb, opcode_preamble, CHUNK_PREAMBLE_SIZE) !=

            CHUNK_PREAMBLE_SIZE) {

            chunk_type = CHUNK_BAD;

            break;

        }



        opcode_size = AV_RL16(&opcode_preamble[0]);

        opcode_type = opcode_preamble[2];

        opcode_version = opcode_preamble[3];



        chunk_size -= OPCODE_PREAMBLE_SIZE;

        chunk_size -= opcode_size;

        if (chunk_size < 0) {

            debug_ipmovie("chunk_size countdown just went negative\n");

            chunk_type = CHUNK_BAD;

            break;

        }



        debug_ipmovie("  opcode type %02X, version %d, 0x%04X bytes: ",

            opcode_type, opcode_version, opcode_size);

        switch (opcode_type) {



        case OPCODE_END_OF_STREAM:

            debug_ipmovie("end of stream\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_END_OF_CHUNK:

            debug_ipmovie("end of chunk\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_CREATE_TIMER:

            debug_ipmovie("create timer\n");

            if ((opcode_version > 0) || (opcode_size > 6)) {

                debug_ipmovie("bad create_timer opcode\n");

                chunk_type = CHUNK_BAD;

                break;

            }

            if (get_buffer(pb, scratch, opcode_size) !=

                opcode_size) {

                chunk_type = CHUNK_BAD;

                break;

            }

            s->fps = 1000000.0 / (AV_RL32(&scratch[0]) * AV_RL16(&scratch[4]));

            s->frame_pts_inc = 90000 / s->fps;

            debug_ipmovie("  %.2f frames/second (timer div = %d, subdiv = %d)\n",

                s->fps, AV_RL32(&scratch[0]), AV_RL16(&scratch[4]));

            break;



        case OPCODE_INIT_AUDIO_BUFFERS:

            debug_ipmovie("initialize audio buffers\n");

            if ((opcode_version > 1) || (opcode_size > 10)) {

                debug_ipmovie("bad init_audio_buffers opcode\n");

                chunk_type = CHUNK_BAD;

                break;

            }

            if (get_buffer(pb, scratch, opcode_size) !=

                opcode_size) {

                chunk_type = CHUNK_BAD;

                break;

            }

            s->audio_sample_rate = AV_RL16(&scratch[4]);

            audio_flags = AV_RL16(&scratch[2]);

            /* bit 0 of the flags: 0 = mono, 1 = stereo */

            s->audio_channels = (audio_flags & 1) + 1;

            /* bit 1 of the flags: 0 = 8 bit, 1 = 16 bit */

            s->audio_bits = (((audio_flags >> 1) & 1) + 1) * 8;

            /* bit 2 indicates compressed audio in version 1 opcode */

            if ((opcode_version == 1) && (audio_flags & 0x4))

                s->audio_type = CODEC_ID_INTERPLAY_DPCM;

            else if (s->audio_bits == 16)

                s->audio_type = CODEC_ID_PCM_S16LE;

            else

                s->audio_type = CODEC_ID_PCM_U8;

            debug_ipmovie("audio: %d bits, %d Hz, %s, %s format\n",

                s->audio_bits,

                s->audio_sample_rate,

                (s->audio_channels == 2) ? "stereo" : "mono",

                (s->audio_type == CODEC_ID_INTERPLAY_DPCM) ?

                "Interplay audio" : "PCM");

            break;



        case OPCODE_START_STOP_AUDIO:

            debug_ipmovie("start/stop audio\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_INIT_VIDEO_BUFFERS:

            debug_ipmovie("initialize video buffers\n");

            if ((opcode_version > 2) || (opcode_size > 8)) {

                debug_ipmovie("bad init_video_buffers opcode\n");

                chunk_type = CHUNK_BAD;

                break;

            }

            if (get_buffer(pb, scratch, opcode_size) !=

                opcode_size) {

                chunk_type = CHUNK_BAD;

                break;

            }

            s->video_width = AV_RL16(&scratch[0]) * 8;

            s->video_height = AV_RL16(&scratch[2]) * 8;

            debug_ipmovie("video resolution: %d x %d\n",

                s->video_width, s->video_height);

            break;



        case OPCODE_UNKNOWN_06:

        case OPCODE_UNKNOWN_0E:

        case OPCODE_UNKNOWN_10:

        case OPCODE_UNKNOWN_12:

        case OPCODE_UNKNOWN_13:

        case OPCODE_UNKNOWN_14:

        case OPCODE_UNKNOWN_15:

            debug_ipmovie("unknown (but documented) opcode %02X\n", opcode_type);

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_SEND_BUFFER:

            debug_ipmovie("send buffer\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_AUDIO_FRAME:

            debug_ipmovie("audio frame\n");



            /* log position and move on for now */

            s->audio_chunk_offset = url_ftell(pb);

            s->audio_chunk_size = opcode_size;

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_SILENCE_FRAME:

            debug_ipmovie("silence frame\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_INIT_VIDEO_MODE:

            debug_ipmovie("initialize video mode\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_CREATE_GRADIENT:

            debug_ipmovie("create gradient\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_SET_PALETTE:

            debug_ipmovie("set palette\n");

            /* check for the logical maximum palette size

             * (3 * 256 + 4 bytes) */

            if (opcode_size > 0x304) {

                debug_ipmovie("demux_ipmovie: set_palette opcode too large\n");

                chunk_type = CHUNK_BAD;

                break;

            }

            if (get_buffer(pb, scratch, opcode_size) != opcode_size) {

                chunk_type = CHUNK_BAD;

                break;

            }



            /* load the palette into internal data structure */

            first_color = AV_RL16(&scratch[0]);

            last_color = first_color + AV_RL16(&scratch[2]) - 1;

            /* sanity check (since they are 16 bit values) */

            if ((first_color > 0xFF) || (last_color > 0xFF)) {

                debug_ipmovie("demux_ipmovie: set_palette indices out of range (%d -> %d)\n",

                    first_color, last_color);

                chunk_type = CHUNK_BAD;

                break;

            }

            j = 4;  /* offset of first palette data */

            for (i = first_color; i <= last_color; i++) {

                /* the palette is stored as a 6-bit VGA palette, thus each

                 * component is shifted up to a 8-bit range */

                r = scratch[j++] * 4;

                g = scratch[j++] * 4;

                b = scratch[j++] * 4;

                s->palette_control.palette[i] = (r << 16) | (g << 8) | (b);

            }

            /* indicate a palette change */

            s->palette_control.palette_changed = 1;

            break;



        case OPCODE_SET_PALETTE_COMPRESSED:

            debug_ipmovie("set palette compressed\n");

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_SET_DECODING_MAP:

            debug_ipmovie("set decoding map\n");



            /* log position and move on for now */

            s->decode_map_chunk_offset = url_ftell(pb);

            s->decode_map_chunk_size = opcode_size;

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        case OPCODE_VIDEO_DATA:

            debug_ipmovie("set video data\n");



            /* log position and move on for now */

            s->video_chunk_offset = url_ftell(pb);

            s->video_chunk_size = opcode_size;

            url_fseek(pb, opcode_size, SEEK_CUR);

            break;



        default:

            debug_ipmovie("*** unknown opcode type\n");

            chunk_type = CHUNK_BAD;

            break;



        }

    }



    /* make a note of where the stream is sitting */

    s->next_chunk_offset = url_ftell(pb);



    /* dispatch the first of any pending packets */

    if ((chunk_type == CHUNK_VIDEO) || (chunk_type == CHUNK_AUDIO_ONLY))

        chunk_type = load_ipmovie_packet(s, pb, pkt);



    return chunk_type;

}
 and probability:0.15810276679841898
code:static int save_xbzrle_page(RAMState *rs, uint8_t **current_data,

                            ram_addr_t current_addr, RAMBlock *block,

                            ram_addr_t offset, bool last_stage)

{

    int encoded_len = 0, bytes_xbzrle;

    uint8_t *prev_cached_page;



    if (!cache_is_cached(XBZRLE.cache, current_addr, rs->bitmap_sync_count)) {

        rs->xbzrle_cache_miss++;

        if (!last_stage) {

            if (cache_insert(XBZRLE.cache, current_addr, *current_data,

                             rs->bitmap_sync_count) == -1) {

                return -1;

            } else {

                /* update *current_data when the page has been

                   inserted into cache */

                *current_data = get_cached_data(XBZRLE.cache, current_addr);

            }

        }

        return -1;

    }



    prev_cached_page = get_cached_data(XBZRLE.cache, current_addr);



    /* save current buffer into memory */

    memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);



    /* XBZRLE encoding (if there is no overflow) */

    encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,

                                       TARGET_PAGE_SIZE, XBZRLE.encoded_buf,

                                       TARGET_PAGE_SIZE);

    if (encoded_len == 0) {

        trace_save_xbzrle_page_skipping();

        return 0;

    } else if (encoded_len == -1) {

        trace_save_xbzrle_page_overflow();

        rs->xbzrle_overflows++;

        /* update data in the cache */

        if (!last_stage) {

            memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);

            *current_data = prev_cached_page;

        }

        return -1;

    }



    /* we need to update the data in the cache, in order to get the same data */

    if (!last_stage) {

        memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);

    }



    /* Send XBZRLE based compressed page */

    bytes_xbzrle = save_page_header(rs, block,

                                    offset | RAM_SAVE_FLAG_XBZRLE);

    qemu_put_byte(rs->f, ENCODING_FLAG_XBZRLE);

    qemu_put_be16(rs->f, encoded_len);

    qemu_put_buffer(rs->f, XBZRLE.encoded_buf, encoded_len);

    bytes_xbzrle += encoded_len + 1 + 2;

    rs->xbzrle_pages++;

    rs->xbzrle_bytes += bytes_xbzrle;

    rs->bytes_transferred += bytes_xbzrle;



    return 1;

}
 and probability:0.2857142857142857
code:static void dump_qobject(fprintf_function func_fprintf, void *f,

                         int comp_indent, QObject *obj)

{

    switch (qobject_type(obj)) {

        case QTYPE_QINT: {

            QInt *value = qobject_to_qint(obj);

            func_fprintf(f, "%" PRId64, qint_get_int(value));

            break;

        }

        case QTYPE_QSTRING: {

            QString *value = qobject_to_qstring(obj);

            func_fprintf(f, "%s", qstring_get_str(value));

            break;

        }

        case QTYPE_QDICT: {

            QDict *value = qobject_to_qdict(obj);

            dump_qdict(func_fprintf, f, comp_indent, value);

            break;

        }

        case QTYPE_QLIST: {

            QList *value = qobject_to_qlist(obj);

            dump_qlist(func_fprintf, f, comp_indent, value);

            break;

        }

        case QTYPE_QFLOAT: {

            QFloat *value = qobject_to_qfloat(obj);

            func_fprintf(f, "%g", qfloat_get_double(value));

            break;

        }

        case QTYPE_QBOOL: {

            QBool *value = qobject_to_qbool(obj);

            func_fprintf(f, "%s", qbool_get_int(value) ? "true" : "false");

            break;

        }

        case QTYPE_QERROR: {

            QString *value = qerror_human((QError *)obj);

            func_fprintf(f, "%s", qstring_get_str(value));


            break;

        }

        case QTYPE_NONE:

            break;

        case QTYPE_MAX:

        default:

            abort();

    }

} and probability:0.0
code:int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)

{

    if (isYUV(c->dstFormat) || isGray(c->dstFormat)) return -1;



    *inv_table = c->srcColorspaceTable;

    *table     = c->dstColorspaceTable;

    *srcRange  = c->srcRange;

    *dstRange  = c->dstRange;

    *brightness= c->brightness;

    *contrast  = c->contrast;

    *saturation= c->saturation;



    return 0;

}
 and probability:0.6666666666666666
code:static int mjpeg_decode_frame(AVCodecContext *avctx, 

                              void *data, int *data_size,

                              UINT8 *buf, int buf_size)

{

    MJpegDecodeContext *s = avctx->priv_data;

    UINT8 *buf_end, *buf_ptr;

    int i, start_code;

    AVPicture *picture = data;



    *data_size = 0;



    /* no supplementary picture */

    if (buf_size == 0)

        return 0;



    buf_ptr = buf;

    buf_end = buf + buf_size;

    while (buf_ptr < buf_end) {

        /* find start next marker */

        start_code = find_marker(&buf_ptr, buf_end);

	{

	    /* EOF */

            if (start_code < 0) {

		goto the_end;

            } else {

                dprintf("marker=%x avail_size_in_buf=%d\n", start_code, buf_end - buf_ptr);

		

		if ((buf_end - buf_ptr) > s->buffer_size)

		{

		    av_free(s->buffer);

		    s->buffer_size = buf_end-buf_ptr;

		    s->buffer = av_malloc(s->buffer_size);

		    dprintf("buffer too small, expanding to %d bytes\n",

			s->buffer_size);

		}

		

		/* unescape buffer of SOS */

		if (start_code == SOS)

		{

		    UINT8 *src = buf_ptr;

		    UINT8 *dst = s->buffer;



		    while (src<buf_end)

		    {

			UINT8 x = *(src++);



			*(dst++) = x;

			if (x == 0xff)

			{

			    while(*src == 0xff) src++;



			    x = *(src++);

			    if (x >= 0xd0 && x <= 0xd7)

				*(dst++) = x;

			    else if (x)

				break;

			}

		    }

		    init_get_bits(&s->gb, s->buffer, dst - s->buffer);

		    

		    dprintf("escaping removed %d bytes\n",

			(buf_end - buf_ptr) - (dst - s->buffer));

		}

		else

		    init_get_bits(&s->gb, buf_ptr, buf_end - buf_ptr);

		

		s->start_code = start_code;



		/* process markers */

		if (start_code >= 0xd0 && start_code <= 0xd7) {

		    dprintf("restart marker: %d\n", start_code&0x0f);

		} else if (s->first_picture) {

		    /* APP fields */

		    if (start_code >= 0xe0 && start_code <= 0xef)

			mjpeg_decode_app(s);

		    /* Comment */

		    else if (start_code == COM)

			mjpeg_decode_com(s);

		}



                switch(start_code) {

                case SOI:

		    s->restart_interval = 0;

                    /* nothing to do on SOI */

                    break;

                case DQT:

                    mjpeg_decode_dqt(s);

                    break;

                case DHT:

                    mjpeg_decode_dht(s);

                    break;

                case SOF0:

                    if (mjpeg_decode_sof0(s) < 0)

			return -1;

                    break;

		case EOI:

eoi_parser:

		    {

                        if (s->interlaced) {

                            s->bottom_field ^= 1;

                            /* if not bottom field, do not output image yet */

                            if (s->bottom_field)

                                goto not_the_end;

                        }

                        for(i=0;i<3;i++) {

                            picture->data[i] = s->current_picture[i];

			    picture->linesize[i] = (s->interlaced) ?

				s->linesize[i] >> 1 : s->linesize[i];

                        }

                        *data_size = sizeof(AVPicture);

                        avctx->height = s->height;

                        if (s->interlaced)

                            avctx->height *= 2;

                        avctx->width = s->width;

                        /* XXX: not complete test ! */

                        switch((s->h_count[0] << 4) | s->v_count[0]) {

                        case 0x11:

                            avctx->pix_fmt = PIX_FMT_YUV444P;

                            break;

                        case 0x21:

                            avctx->pix_fmt = PIX_FMT_YUV422P;

                            break;

                        default:

                        case 0x22:

                            avctx->pix_fmt = PIX_FMT_YUV420P;

                            break;

                        }

                        /* dummy quality */

                        /* XXX: infer it with matrix */

//                    	avctx->quality = 3; 

                        goto the_end;

                    }

		    break;

                case SOS:

                    mjpeg_decode_sos(s);

		    /* buggy avid puts EOI every 10-20th frame */

		    /* if restart period is over process EOI */

		    if ((s->buggy_avid && !s->interlaced) || s->restart_interval)

			goto eoi_parser;

                    break;

		case DRI:

		    mjpeg_decode_dri(s);

		    break;

		case SOF1:

		case SOF2:

		case SOF3:

		case SOF5:

		case SOF6:

		case SOF7:

		case SOF9:

		case SOF10:

		case SOF11:

		case SOF13:

		case SOF14:

		case SOF15:

		case JPG:

		    printf("mjpeg: unsupported coding type (%x)\n", start_code);

		    break;

//		default:

//		    printf("mjpeg: unsupported marker (%x)\n", start_code);

//		    break;

                }



not_the_end:

		/* eof process start code */

		buf_ptr += (get_bits_count(&s->gb)+7)/8;

		dprintf("marker parser used %d bytes (%d bits)\n",

		    (get_bits_count(&s->gb)+7)/8, get_bits_count(&s->gb));

            }

        }

    }

the_end:

    dprintf("mjpeg decode frame unused %d bytes\n", buf_end - buf_ptr);

//    return buf_end - buf_ptr;

    return buf_ptr - buf;

}
 and probability:0.25766871165644173
code:static int draw_text(AVFilterContext *ctx, AVFrame *frame,

                     int width, int height)

{

    DrawTextContext *s = ctx->priv;

    AVFilterLink *inlink = ctx->inputs[0];



    uint32_t code = 0, prev_code = 0;

    int x = 0, y = 0, i = 0, ret;

    int max_text_line_w = 0, len;

    int box_w, box_h;

    char *text;

    uint8_t *p;

    int y_min = 32000, y_max = -32000;

    int x_min = 32000, x_max = -32000;

    FT_Vector delta;

    Glyph *glyph = NULL, *prev_glyph = NULL;

    Glyph dummy = { 0 };



    time_t now = time(0);

    struct tm ltime;

    AVBPrint *bp = &s->expanded_text;



    FFDrawColor fontcolor;

    FFDrawColor shadowcolor;

    FFDrawColor bordercolor;

    FFDrawColor boxcolor;



    av_bprint_clear(bp);



    if(s->basetime != AV_NOPTS_VALUE)

        now= frame->pts*av_q2d(ctx->inputs[0]->time_base) + s->basetime/1000000;



    switch (s->exp_mode) {

    case EXP_NONE:

        av_bprintf(bp, "%s", s->text);

        break;

    case EXP_NORMAL:

        if ((ret = expand_text(ctx, s->text, &s->expanded_text)) < 0)

            return ret;

        break;

    case EXP_STRFTIME:

        localtime_r(&now, &ltime);

        av_bprint_strftime(bp, s->text, &ltime);

        break;

    }



    if (s->tc_opt_string) {

        char tcbuf[AV_TIMECODE_STR_SIZE];

        av_timecode_make_string(&s->tc, tcbuf, inlink->frame_count);

        av_bprint_clear(bp);

        av_bprintf(bp, "%s%s", s->text, tcbuf);

    }



    if (!av_bprint_is_complete(bp))

        return AVERROR(ENOMEM);

    text = s->expanded_text.str;

    if ((len = s->expanded_text.len) > s->nb_positions) {

        if (!(s->positions =

              av_realloc(s->positions, len*sizeof(*s->positions))))

            return AVERROR(ENOMEM);

        s->nb_positions = len;

    }



    if (s->fontcolor_expr[0]) {

        /* If expression is set, evaluate and replace the static value */

        av_bprint_clear(&s->expanded_fontcolor);

        if ((ret = expand_text(ctx, s->fontcolor_expr, &s->expanded_fontcolor)) < 0)

            return ret;

        if (!av_bprint_is_complete(&s->expanded_fontcolor))

            return AVERROR(ENOMEM);

        av_log(s, AV_LOG_DEBUG, "Evaluated fontcolor is '%s'\n", s->expanded_fontcolor.str);

        ret = av_parse_color(s->fontcolor.rgba, s->expanded_fontcolor.str, -1, s);

        if (ret)

            return ret;

        ff_draw_color(&s->dc, &s->fontcolor, s->fontcolor.rgba);

    }



    x = 0;

    y = 0;



    /* load and cache glyphs */

    for (i = 0, p = text; *p; i++) {

        GET_UTF8(code, *p++, continue;);



        /* get glyph */

        dummy.code = code;

        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);

        if (!glyph) {

            load_glyph(ctx, &glyph, code);

        }



        y_min = FFMIN(glyph->bbox.yMin, y_min);

        y_max = FFMAX(glyph->bbox.yMax, y_max);

        x_min = FFMIN(glyph->bbox.xMin, x_min);

        x_max = FFMAX(glyph->bbox.xMax, x_max);

    }

    s->max_glyph_h = y_max - y_min;

    s->max_glyph_w = x_max - x_min;



    /* compute and save position for each glyph */

    glyph = NULL;

    for (i = 0, p = text; *p; i++) {

        GET_UTF8(code, *p++, continue;);



        /* skip the \n in the sequence \r\n */

        if (prev_code == '\r' && code == '\n')

            continue;



        prev_code = code;

        if (is_newline(code)) {



            max_text_line_w = FFMAX(max_text_line_w, x);

            y += s->max_glyph_h;

            x = 0;

            continue;

        }



        /* get glyph */

        prev_glyph = glyph;

        dummy.code = code;

        glyph = av_tree_find(s->glyphs, &dummy, glyph_cmp, NULL);



        /* kerning */

        if (s->use_kerning && prev_glyph && glyph->code) {

            FT_Get_Kerning(s->face, prev_glyph->code, glyph->code,

                           ft_kerning_default, &delta);

            x += delta.x >> 6;

        }



        /* save position */

        s->positions[i].x = x + glyph->bitmap_left;

        s->positions[i].y = y - glyph->bitmap_top + y_max;

        if (code == '\t') x  = (x / s->tabsize + 1)*s->tabsize;

        else              x += glyph->advance;

    }



    max_text_line_w = FFMAX(x, max_text_line_w);



    s->var_values[VAR_TW] = s->var_values[VAR_TEXT_W] = max_text_line_w;

    s->var_values[VAR_TH] = s->var_values[VAR_TEXT_H] = y + s->max_glyph_h;



    s->var_values[VAR_MAX_GLYPH_W] = s->max_glyph_w;

    s->var_values[VAR_MAX_GLYPH_H] = s->max_glyph_h;

    s->var_values[VAR_MAX_GLYPH_A] = s->var_values[VAR_ASCENT ] = y_max;

    s->var_values[VAR_MAX_GLYPH_D] = s->var_values[VAR_DESCENT] = y_min;



    s->var_values[VAR_LINE_H] = s->var_values[VAR_LH] = s->max_glyph_h;



    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);

    s->y = s->var_values[VAR_Y] = av_expr_eval(s->y_pexpr, s->var_values, &s->prng);

    s->x = s->var_values[VAR_X] = av_expr_eval(s->x_pexpr, s->var_values, &s->prng);



    update_alpha(s);

    update_color_with_alpha(s, &fontcolor  , s->fontcolor  );

    update_color_with_alpha(s, &shadowcolor, s->shadowcolor);

    update_color_with_alpha(s, &bordercolor, s->bordercolor);

    update_color_with_alpha(s, &boxcolor   , s->boxcolor   );



    box_w = FFMIN(width - 1 , max_text_line_w);

    box_h = FFMIN(height - 1, y + s->max_glyph_h);



    /* draw box */

    if (s->draw_box)

        ff_blend_rectangle(&s->dc, &boxcolor,

                           frame->data, frame->linesize, width, height,

                           s->x - s->boxborderw, s->y - s->boxborderw,

                           box_w + s->boxborderw * 2, box_h + s->boxborderw * 2);



    if (s->shadowx || s->shadowy) {

        if ((ret = draw_glyphs(s, frame, width, height,

                               &shadowcolor, s->shadowx, s->shadowy, 0)) < 0)

            return ret;

    }



    if (s->borderw) {

        if ((ret = draw_glyphs(s, frame, width, height,

                               &bordercolor, 0, 0, s->borderw)) < 0)

            return ret;

    }

    if ((ret = draw_glyphs(s, frame, width, height,

                           &fontcolor, 0, 0, 0)) < 0)

        return ret;



    return 0;

}
 and probability:0.44805194805194803
code:static int planarCopyWrapper(SwsContext *c, const uint8_t *src[],

                             int srcStride[], int srcSliceY, int srcSliceH,

                             uint8_t *dst[], int dstStride[])

{

    const AVPixFmtDescriptor *desc_src = av_pix_fmt_desc_get(c->srcFormat);

    const AVPixFmtDescriptor *desc_dst = av_pix_fmt_desc_get(c->dstFormat);

    int plane, i, j;

    for (plane = 0; plane < 4; plane++) {

        int length = (plane == 0 || plane == 3) ? c->srcW  : -((-c->srcW  ) >> c->chrDstHSubSample);

        int y =      (plane == 0 || plane == 3) ? srcSliceY: -((-srcSliceY) >> c->chrDstVSubSample);

        int height = (plane == 0 || plane == 3) ? srcSliceH: -((-srcSliceH) >> c->chrDstVSubSample);

        const uint8_t *srcPtr = src[plane];

        uint8_t *dstPtr = dst[plane] + dstStride[plane] * y;



        if (!dst[plane])

            continue;

        // ignore palette for GRAY8

        if (plane == 1 && !dst[2]) continue;

        if (!src[plane] || (plane == 1 && !src[2])) {

            int val = (plane == 3) ? 255 : 128;

            if (is16BPS(c->dstFormat))

                length *= 2;

            if (is9_OR_10BPS(c->dstFormat)) {

                fill_plane9or10(dst[plane], dstStride[plane],

                                length, height, y, val,

                                desc_dst->comp[plane].depth_minus1 + 1,

                                isBE(c->dstFormat));

            } else

                fillPlane(dst[plane], dstStride[plane], length, height, y,

                          val);

        } else {

            if (is9_OR_10BPS(c->srcFormat)) {

                const int src_depth = desc_src->comp[plane].depth_minus1 + 1;

                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;

                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;



                if (is16BPS(c->dstFormat)) {

                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;

#define COPY9_OR_10TO16(rfunc, wfunc) \

                    for (i = 0; i < height; i++) { \

                        for (j = 0; j < length; j++) { \

                            int srcpx = rfunc(&srcPtr2[j]); \

                            wfunc(&dstPtr2[j], (srcpx << (16 - src_depth)) | (srcpx >> (2 * src_depth - 16))); \

                        } \

                        dstPtr2 += dstStride[plane] / 2; \

                        srcPtr2 += srcStride[plane] / 2; \

                    }

                    if (isBE(c->dstFormat)) {

                        if (isBE(c->srcFormat)) {

                            COPY9_OR_10TO16(AV_RB16, AV_WB16);

                        } else {

                            COPY9_OR_10TO16(AV_RL16, AV_WB16);

                        }

                    } else {

                        if (isBE(c->srcFormat)) {

                            COPY9_OR_10TO16(AV_RB16, AV_WL16);

                        } else {

                            COPY9_OR_10TO16(AV_RL16, AV_WL16);

                        }

                    }

                } else if (is9_OR_10BPS(c->dstFormat)) {

                    uint16_t *dstPtr2 = (uint16_t *) dstPtr;

#define COPY9_OR_10TO9_OR_10(loop) \

                    for (i = 0; i < height; i++) { \

                        for (j = 0; j < length; j++) { \

                            loop; \

                        } \

                        dstPtr2 += dstStride[plane] / 2; \

                        srcPtr2 += srcStride[plane] / 2; \

                    }

#define COPY9_OR_10TO9_OR_10_2(rfunc, wfunc) \

                    if (dst_depth > src_depth) { \

                        COPY9_OR_10TO9_OR_10(int srcpx = rfunc(&srcPtr2[j]); \

                            wfunc(&dstPtr2[j], (srcpx << 1) | (srcpx >> 9))); \

                    } else if (dst_depth < src_depth) { \

                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \

                                    srcPtr2, srcStride[plane] / 2, rfunc, \

                                    dither_8x8_1, 1, clip9); \

                    } else { \

                        COPY9_OR_10TO9_OR_10(wfunc(&dstPtr2[j], rfunc(&srcPtr2[j]))); \

                    }

                    if (isBE(c->dstFormat)) {

                        if (isBE(c->srcFormat)) {

                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WB16);

                        } else {

                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WB16);

                        }

                    } else {

                        if (isBE(c->srcFormat)) {

                            COPY9_OR_10TO9_OR_10_2(AV_RB16, AV_WL16);

                        } else {

                            COPY9_OR_10TO9_OR_10_2(AV_RL16, AV_WL16);

                        }

                    }

                } else {

#define W8(a, b) { *(a) = (b); }

#define COPY9_OR_10TO8(rfunc) \

                    if (src_depth == 9) { \

                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \

                                    srcPtr2, srcStride[plane] / 2, rfunc, \

                                    dither_8x8_1, 1, av_clip_uint8); \

                    } else { \

                        DITHER_COPY(dstPtr,  dstStride[plane],   W8, \

                                    srcPtr2, srcStride[plane] / 2, rfunc, \

                                    dither_8x8_3, 2, av_clip_uint8); \

                    }

                    if (isBE(c->srcFormat)) {

                        COPY9_OR_10TO8(AV_RB16);

                    } else {

                        COPY9_OR_10TO8(AV_RL16);

                    }

                }

            } else if (is9_OR_10BPS(c->dstFormat)) {

                const int dst_depth = desc_dst->comp[plane].depth_minus1 + 1;

                uint16_t *dstPtr2 = (uint16_t *) dstPtr;



                if (is16BPS(c->srcFormat)) {

                    const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;

#define COPY16TO9_OR_10(rfunc, wfunc) \

                    if (dst_depth == 9) { \

                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \

                                    srcPtr2, srcStride[plane] / 2, rfunc, \

                                    ff_dither_8x8_128, 7, clip9); \

                    } else { \

                        DITHER_COPY(dstPtr2, dstStride[plane] / 2, wfunc, \

                                    srcPtr2, srcStride[plane] / 2, rfunc, \

                                    dither_8x8_64, 6, clip10); \

                    }

                    if (isBE(c->dstFormat)) {

                        if (isBE(c->srcFormat)) {

                            COPY16TO9_OR_10(AV_RB16, AV_WB16);

                        } else {

                            COPY16TO9_OR_10(AV_RL16, AV_WB16);

                        }

                    } else {

                        if (isBE(c->srcFormat)) {

                            COPY16TO9_OR_10(AV_RB16, AV_WL16);

                        } else {

                            COPY16TO9_OR_10(AV_RL16, AV_WL16);

                        }

                    }

                } else /* 8bit */ {

#define COPY8TO9_OR_10(wfunc) \

                    for (i = 0; i < height; i++) { \

                        for (j = 0; j < length; j++) { \

                            const int srcpx = srcPtr[j]; \

                            wfunc(&dstPtr2[j], (srcpx << (dst_depth - 8)) | (srcpx >> (16 - dst_depth))); \

                        } \

                        dstPtr2 += dstStride[plane] / 2; \

                        srcPtr  += srcStride[plane]; \

                    }

                    if (isBE(c->dstFormat)) {

                        COPY8TO9_OR_10(AV_WB16);

                    } else {

                        COPY8TO9_OR_10(AV_WL16);

                    }

                }

            } else if (is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) {

                const uint16_t *srcPtr2 = (const uint16_t *) srcPtr;

#define COPY16TO8(rfunc) \

                    DITHER_COPY(dstPtr,  dstStride[plane],   W8, \

                                srcPtr2, srcStride[plane] / 2, rfunc, \

                                dither_8x8_256, 8, av_clip_uint8);

                if (isBE(c->srcFormat)) {

                    COPY16TO8(AV_RB16);

                } else {

                    COPY16TO8(AV_RL16);

                }

            } else if (!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) {

                for (i = 0; i < height; i++) {

                    for (j = 0; j < length; j++) {

                        dstPtr[ j << 1     ] = srcPtr[j];

                        dstPtr[(j << 1) + 1] = srcPtr[j];

                    }

                    srcPtr += srcStride[plane];

                    dstPtr += dstStride[plane];

                }

            } else if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat) &&

                      isBE(c->srcFormat) != isBE(c->dstFormat)) {



                for (i = 0; i < height; i++) {

                    for (j = 0; j < length; j++)

                        ((uint16_t *) dstPtr)[j] = av_bswap16(((const uint16_t *) srcPtr)[j]);

                    srcPtr += srcStride[plane];

                    dstPtr += dstStride[plane];

                }

            } else if (dstStride[plane] == srcStride[plane] &&

                       srcStride[plane] > 0 && srcStride[plane] == length) {

                memcpy(dst[plane] + dstStride[plane] * y, src[plane],

                       height * dstStride[plane]);

            } else {

                if (is16BPS(c->srcFormat) && is16BPS(c->dstFormat))

                    length *= 2;

                else if (!desc_src->comp[0].depth_minus1)

                    length >>= 3; // monowhite/black

                for (i = 0; i < height; i++) {

                    memcpy(dstPtr, srcPtr, length);

                    srcPtr += srcStride[plane];

                    dstPtr += dstStride[plane];

                }

            }

        }

    }

    return srcSliceH;

}
 and probability:0.43781094527363185
code:static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)

{

    AcpiPciHpState *s = opaque;

    uint32_t val = 0;

    int bsel = s->hotplug_select;



    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {

        return 0;

    }



    switch (addr) {

    case PCI_UP_BASE:

        val = s->acpi_pcihp_pci_status[bsel].up;

        if (!s->legacy_piix) {

            s->acpi_pcihp_pci_status[bsel].up = 0;

        }

        ACPI_PCIHP_DPRINTF("pci_up_read %" PRIu32 "\n", val);

        break;

    case PCI_DOWN_BASE:

        val = s->acpi_pcihp_pci_status[bsel].down;

        ACPI_PCIHP_DPRINTF("pci_down_read %" PRIu32 "\n", val);

        break;

    case PCI_EJ_BASE:

        /* No feature defined yet */

        ACPI_PCIHP_DPRINTF("pci_features_read %" PRIu32 "\n", val);

        break;

    case PCI_RMV_BASE:

        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;

        ACPI_PCIHP_DPRINTF("pci_rmv_read %" PRIu32 "\n", val);

        break;

    case PCI_SEL_BASE:

        val = s->hotplug_select;

        ACPI_PCIHP_DPRINTF("pci_sel_read %" PRIu32 "\n", val);

    default:

        break;

    }



    return val;

}
 and probability:0.19444444444444445
code:static void free_field_queue(PullupField *head, PullupField **last)

{

    PullupField *f = head;

    while (f) {

        av_free(f->diffs);

        av_free(f->combs);

        av_free(f->vars);

        if (f == *last) {

            av_freep(last);

            break;

        }

        f = f->next;

        av_freep(&f->prev);

    };

}
 and probability:0.4
code:static void notify_guest_bh(void *opaque)

{

    VirtIOBlockDataPlane *s = opaque;

    unsigned nvqs = s->conf->num_queues;

    unsigned long bitmap[BITS_TO_LONGS(nvqs)];

    unsigned j;



    memcpy(bitmap, s->batch_notify_vqs, sizeof(bitmap));

    memset(s->batch_notify_vqs, 0, sizeof(bitmap));



    for (j = 0; j < nvqs; j += BITS_PER_LONG) {

        unsigned long bits = bitmap[j];



        while (bits != 0) {

            unsigned i = j + ctzl(bits);

            VirtQueue *vq = virtio_get_queue(s->vdev, i);



            if (virtio_should_notify(s->vdev, vq)) {

                event_notifier_set(virtio_queue_get_guest_notifier(vq));

            }



            bits &= bits - 1; /* clear right-most bit */

        }

    }

}
 and probability:0.45
code:static char *doubles2str(double *dp, int count, const char *sep)

{

    int i;

    char *ap, *ap0;

    int component_len = 15 + strlen(sep);

    if (!sep) sep = ", ";

    ap = av_malloc(component_len * count);

    if (!ap)

        return NULL;

    ap0   = ap;

    ap[0] = '\0';

    for (i = 0; i < count; i++) {

        unsigned l = snprintf(ap, component_len, "%f%s", dp[i], sep);

        if(l >= component_len)

            return NULL;

        ap += l;

    }

    ap0[strlen(ap0) - strlen(sep)] = '\0';

    return ap0;

}
 and probability:0.35
code:static uint32_t arm_v7m_load_vector(ARMCPU *cpu)



{

    CPUState *cs = CPU(cpu);

    CPUARMState *env = &cpu->env;

    MemTxResult result;

    hwaddr vec = env->v7m.vecbase + env->v7m.exception * 4;

    uint32_t addr;



    addr = address_space_ldl(cs->as, vec,

                             MEMTXATTRS_UNSPECIFIED, &result);

    if (result != MEMTX_OK) {

        /* Architecturally this should cause a HardFault setting HSFR.VECTTBL,

         * which would then be immediately followed by our failing to load

         * the entry vector for that HardFault, which is a Lockup case.

         * Since we don't model Lockup, we just report this guest error

         * via cpu_abort().

         */

        cpu_abort(cs, "Failed to read from exception vector table "

                  "entry %08x\n", (unsigned)vec);

    }

    return addr;

}
 and probability:0.14285714285714285
code:static void htab_save_first_pass(QEMUFile *f, sPAPREnvironment *spapr,

                                 int64_t max_ns)

{

    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;

    int index = spapr->htab_save_index;

    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);



    assert(spapr->htab_first_pass);



    do {

        int chunkstart;



        /* Consume invalid HPTEs */

        while ((index < htabslots)

               && !HPTE_VALID(HPTE(spapr->htab, index))) {

            index++;

            CLEAN_HPTE(HPTE(spapr->htab, index));

        }



        /* Consume valid HPTEs */

        chunkstart = index;

        while ((index < htabslots)

               && HPTE_VALID(HPTE(spapr->htab, index))) {

            index++;

            CLEAN_HPTE(HPTE(spapr->htab, index));

        }



        if (index > chunkstart) {

            int n_valid = index - chunkstart;



            qemu_put_be32(f, chunkstart);

            qemu_put_be16(f, n_valid);

            qemu_put_be16(f, 0);

            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),

                            HASH_PTE_SIZE_64 * n_valid);



            if ((qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {

                break;

            }

        }

    } while ((index < htabslots) && !qemu_file_rate_limit(f));



    if (index >= htabslots) {

        assert(index == htabslots);

        index = 0;

        spapr->htab_first_pass = false;

    }

    spapr->htab_save_index = index;

}
 and probability:0.36585365853658536
code:build_dsdt(GArray *table_data, BIOSLinker *linker,

           AcpiPmInfo *pm, AcpiMiscInfo *misc,

           Range *pci_hole, Range *pci_hole64, MachineState *machine)

{

    CrsRangeEntry *entry;

    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;

    CrsRangeSet crs_range_set;

    PCMachineState *pcms = PC_MACHINE(machine);

    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(machine);

    uint32_t nr_mem = machine->ram_slots;

    int root_bus_limit = 0xFF;

    PCIBus *bus = NULL;

    int i;



    dsdt = init_aml_allocator();



    /* Reserve space for header */

    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));



    build_dbg_aml(dsdt);

    if (misc->is_piix4) {

        sb_scope = aml_scope("_SB");

        dev = aml_device("PCI0");

        aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));

        aml_append(dev, aml_name_decl("_ADR", aml_int(0)));

        aml_append(dev, aml_name_decl("_UID", aml_int(1)));

        aml_append(sb_scope, dev);

        aml_append(dsdt, sb_scope);



        build_hpet_aml(dsdt);

        build_piix4_pm(dsdt);

        build_piix4_isa_bridge(dsdt);

        build_isa_devices_aml(dsdt);

        build_piix4_pci_hotplug(dsdt);

        build_piix4_pci0_int(dsdt);

    } else {

        sb_scope = aml_scope("_SB");

        dev = aml_device("PCI0");

        aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A08")));

        aml_append(dev, aml_name_decl("_CID", aml_eisaid("PNP0A03")));

        aml_append(dev, aml_name_decl("_ADR", aml_int(0)));

        aml_append(dev, aml_name_decl("_UID", aml_int(1)));

        aml_append(dev, build_q35_osc_method());

        aml_append(sb_scope, dev);

        aml_append(dsdt, sb_scope);



        build_hpet_aml(dsdt);

        build_q35_isa_bridge(dsdt);

        build_isa_devices_aml(dsdt);

        build_q35_pci0_int(dsdt);

    }



    if (pcmc->legacy_cpu_hotplug) {

        build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);

    } else {

        CPUHotplugFeatures opts = {

            .apci_1_compatible = true, .has_legacy_cphp = true

        };

        build_cpus_aml(dsdt, machine, opts, pm->cpu_hp_io_base,

                       "\\_SB.PCI0", "\\_GPE._E02");

    }

    build_memory_hotplug_aml(dsdt, nr_mem, "\\_SB.PCI0", "\\_GPE._E03");



    scope =  aml_scope("_GPE");

    {

        aml_append(scope, aml_name_decl("_HID", aml_string("ACPI0006")));



        if (misc->is_piix4) {

            method = aml_method("_E01", 0, AML_NOTSERIALIZED);

            aml_append(method,

                aml_acquire(aml_name("\\_SB.PCI0.BLCK"), 0xFFFF));

            aml_append(method, aml_call0("\\_SB.PCI0.PCNT"));

            aml_append(method, aml_release(aml_name("\\_SB.PCI0.BLCK")));

            aml_append(scope, method);

        }



        if (pcms->acpi_nvdimm_state.is_enabled) {

            method = aml_method("_E04", 0, AML_NOTSERIALIZED);

            aml_append(method, aml_notify(aml_name("\\_SB.NVDR"),

                                          aml_int(0x80)));

            aml_append(scope, method);

        }

    }

    aml_append(dsdt, scope);



    crs_range_set_init(&crs_range_set);

    bus = PC_MACHINE(machine)->bus;

    if (bus) {

        QLIST_FOREACH(bus, &bus->child, sibling) {

            uint8_t bus_num = pci_bus_num(bus);

            uint8_t numa_node = pci_bus_numa_node(bus);



            /* look only for expander root buses */

            if (!pci_bus_is_root(bus)) {

                continue;

            }



            if (bus_num < root_bus_limit) {

                root_bus_limit = bus_num - 1;

            }



            scope = aml_scope("\\_SB");

            dev = aml_device("PC%.02X", bus_num);

            aml_append(dev, aml_name_decl("_UID", aml_int(bus_num)));

            aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));

            aml_append(dev, aml_name_decl("_BBN", aml_int(bus_num)));

            if (pci_bus_is_express(bus)) {

                aml_append(dev, build_q35_osc_method());

            }



            if (numa_node != NUMA_NODE_UNASSIGNED) {

                aml_append(dev, aml_name_decl("_PXM", aml_int(numa_node)));

            }



            aml_append(dev, build_prt(false));

            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent), &crs_range_set);

            aml_append(dev, aml_name_decl("_CRS", crs));

            aml_append(scope, dev);

            aml_append(dsdt, scope);

        }

    }



    scope = aml_scope("\\_SB.PCI0");

    /* build PCI0._CRS */

    crs = aml_resource_template();

    aml_append(crs,

        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,

                            0x0000, 0x0, root_bus_limit,

                            0x0000, root_bus_limit + 1));

    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));



    aml_append(crs,

        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                    AML_POS_DECODE, AML_ENTIRE_RANGE,

                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));



    crs_replace_with_free_ranges(crs_range_set.io_ranges, 0x0D00, 0xFFFF);

    for (i = 0; i < crs_range_set.io_ranges->len; i++) {

        entry = g_ptr_array_index(crs_range_set.io_ranges, i);

        aml_append(crs,

            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                        AML_POS_DECODE, AML_ENTIRE_RANGE,

                        0x0000, entry->base, entry->limit,

                        0x0000, entry->limit - entry->base + 1));

    }



    aml_append(crs,

        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                         AML_CACHEABLE, AML_READ_WRITE,

                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));



    crs_replace_with_free_ranges(crs_range_set.mem_ranges,

                                 range_lob(pci_hole),

                                 range_upb(pci_hole));

    for (i = 0; i < crs_range_set.mem_ranges->len; i++) {

        entry = g_ptr_array_index(crs_range_set.mem_ranges, i);

        aml_append(crs,

            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                             AML_NON_CACHEABLE, AML_READ_WRITE,

                             0, entry->base, entry->limit,

                             0, entry->limit - entry->base + 1));

    }



    if (!range_is_empty(pci_hole64)) {

        crs_replace_with_free_ranges(crs_range_set.mem_64bit_ranges,

                                     range_lob(pci_hole64),

                                     range_upb(pci_hole64));

        for (i = 0; i < crs_range_set.mem_64bit_ranges->len; i++) {

            entry = g_ptr_array_index(crs_range_set.mem_64bit_ranges, i);

            aml_append(crs,

                       aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED,

                                        AML_MAX_FIXED,

                                        AML_CACHEABLE, AML_READ_WRITE,

                                        0, entry->base, entry->limit,

                                        0, entry->limit - entry->base + 1));

        }

    }



    if (misc->tpm_version != TPM_VERSION_UNSPEC) {

        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,

                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));

    }

    aml_append(scope, aml_name_decl("_CRS", crs));



    /* reserve GPE0 block resources */

    dev = aml_device("GPE0");

    aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A06")));

    aml_append(dev, aml_name_decl("_UID", aml_string("GPE0 resources")));

    /* device present, functioning, decoding, not shown in UI */

    aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));

    crs = aml_resource_template();

    aml_append(crs,

        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)

    );

    aml_append(dev, aml_name_decl("_CRS", crs));

    aml_append(scope, dev);



    crs_range_set_free(&crs_range_set);



    /* reserve PCIHP resources */

    if (pm->pcihp_io_len) {

        dev = aml_device("PHPR");

        aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A06")));

        aml_append(dev,

            aml_name_decl("_UID", aml_string("PCI Hotplug resources")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));

        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,

                   pm->pcihp_io_len)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));

        aml_append(scope, dev);

    }

    aml_append(dsdt, scope);



    /*  create S3_ / S4_ / S5_ packages if necessary */

    scope = aml_scope("\\");

    if (!pm->s3_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */

        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl("_S3", pkg));

    }



    if (!pm->s4_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */

        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(pm->s4_val));

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl("_S4", pkg));

    }



    pkg = aml_package(4);

    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */

    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(scope, aml_name_decl("_S5", pkg));

    aml_append(dsdt, scope);



    /* create fw_cfg node, unconditionally */

    {

        /* when using port i/o, the 8-bit data register *always* overlaps

         * with half of the 16-bit control register. Hence, the total size

         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the

         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */

        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),

                                                   "dma_enabled", NULL) ?

                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :

                          FW_CFG_CTL_SIZE;



        scope = aml_scope("\\_SB.PCI0");

        dev = aml_device("FWCF");



        aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0002")));



        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    if (misc->applesmc_io_base) {

        scope = aml_scope("\\_SB.PCI0.ISA");

        dev = aml_device("SMC");



        aml_append(dev, aml_name_decl("_HID", aml_eisaid("APP0001")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,

                   0x01, APPLESMC_MAX_DATA_LENGTH)

        );

        aml_append(crs, aml_irq_no_flags(6));

        aml_append(dev, aml_name_decl("_CRS", crs));



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    if (misc->pvpanic_port) {

        scope = aml_scope("\\_SB.PCI0.ISA");



        dev = aml_device("PEVT");

        aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));



        aml_append(dev, aml_operation_region("PEOR", AML_SYSTEM_IO,

                                              aml_int(misc->pvpanic_port), 1));

        field = aml_field("PEOR", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);

        aml_append(field, aml_named_field("PEPT", 8));

        aml_append(dev, field);



        /* device present, functioning, decoding, shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xF)));



        method = aml_method("RDPT", 0, AML_NOTSERIALIZED);

        aml_append(method, aml_store(aml_name("PEPT"), aml_local(0)));

        aml_append(method, aml_return(aml_local(0)));

        aml_append(dev, method);



        method = aml_method("WRPT", 1, AML_NOTSERIALIZED);

        aml_append(method, aml_store(aml_arg(0), aml_name("PEPT")));

        aml_append(dev, method);



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    sb_scope = aml_scope("\\_SB");

    {

        Object *pci_host;

        PCIBus *bus = NULL;



        pci_host = acpi_get_i386_pci_host();

        if (pci_host) {

            bus = PCI_HOST_BRIDGE(pci_host)->bus;

        }



        if (bus) {

            Aml *scope = aml_scope("PCI0");

            /* Scan all PCI buses. Generate tables to support hotplug. */

            build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);



            if (misc->tpm_version != TPM_VERSION_UNSPEC) {

                dev = aml_device("ISA.TPM");

                aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0C31")));

                aml_append(dev, aml_name_decl("_STA", aml_int(0xF)));

                crs = aml_resource_template();

                aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,

                           TPM_TIS_ADDR_SIZE, AML_READ_WRITE));

                /*

                    FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,

                    Rewrite to take IRQ from TPM device model and

                    fix default IRQ value there to use some unused IRQ

                 */

                /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */

                aml_append(dev, aml_name_decl("_CRS", crs));

                aml_append(scope, dev);

            }



            aml_append(sb_scope, scope);

        }

    }

    aml_append(dsdt, sb_scope);



    /* copy AML table into ACPI tables blob and patch header there */

    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);

    build_header(linker, table_data,

        (void *)(table_data->data + table_data->len - dsdt->buf->len),

        "DSDT", dsdt->buf->len, 1, NULL, NULL);

    free_aml_allocator();

}
 and probability:0.14641744548286603
code:int64_t cpu_get_clock(void)

{

    int64_t ti;

    if (!timers_state.cpu_ticks_enabled) {

        return timers_state.cpu_clock_offset;

    } else {

        ti = get_clock();

        return ti + timers_state.cpu_clock_offset;

    }

}
 and probability:0.1
code:static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s, int16_t *block, int n)

{

    int level, dc, diff, j, run;

    int component;

    RLTable *rl;

    uint8_t * scantable = s->intra_scantable.permutated;

    const uint16_t *quant_matrix;

    const int qscale = s->qscale;



    /* DC coefficient */

    if (n < 4) {

        quant_matrix = s->intra_matrix;

        component = 0;

    } else {

        quant_matrix = s->chroma_intra_matrix;

        component = (n & 1) + 1;

    }

    diff = decode_dc(&s->gb, component);

    if (diff >= 0xffff)

        return -1;

    dc = s->last_dc[component];

    dc += diff;

    s->last_dc[component] = dc;

    block[0] = dc << (3 - s->intra_dc_precision);

    if (s->intra_vlc_format)

        rl = &ff_rl_mpeg2;

    else

        rl = &ff_rl_mpeg1;



    {

        OPEN_READER(re, &s->gb);

        /* now quantify & encode AC coefficients */

        for (;;) {

            UPDATE_CACHE(re, &s->gb);

            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



            if (level == 127) {

                break;

            } else if (level != 0) {

                scantable += run;

                j = *scantable;

                level = (level * qscale * quant_matrix[j]) >> 4;

                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

                LAST_SKIP_BITS(re, &s->gb, 1);

            } else {

                /* escape */

                run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

                UPDATE_CACHE(re, &s->gb);

                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);

                scantable += run;

                j = *scantable;

                if (level < 0) {

                    level = (-level * qscale * quant_matrix[j]) >> 4;

                    level = -level;

                } else {

                    level = (level * qscale * quant_matrix[j]) >> 4;

                }

            }



            block[j] = level;

        }

        CLOSE_READER(re, &s->gb);

    }



    s->block_last_index[n] = scantable - s->intra_scantable.permutated;

    return 0;

}
 and probability:0.46774193548387094
code:abi_long do_syscall(void *cpu_env, int num, abi_long arg1,

                    abi_long arg2, abi_long arg3, abi_long arg4,

                    abi_long arg5, abi_long arg6, abi_long arg7,

                    abi_long arg8)

{

    CPUState *cpu = ENV_GET_CPU(cpu_env);

    abi_long ret;

    struct stat st;

    struct statfs stfs;

    void *p;



#ifdef DEBUG

    gemu_log("syscall %d", num);

#endif

    if(do_strace)

        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);



    switch(num) {

    case TARGET_NR_exit:

        /* In old applications this may be used to implement _exit(2).

           However in threaded applictions it is used for thread termination,

           and _exit_group is used for application termination.

           Do thread termination if we have more then one thread.  */

        /* FIXME: This probably breaks if a signal arrives.  We should probably

           be disabling signals.  */

        if (CPU_NEXT(first_cpu)) {

            TaskState *ts;



            cpu_list_lock();

            /* Remove the CPU from the list.  */

            QTAILQ_REMOVE(&cpus, cpu, node);

            cpu_list_unlock();

            ts = cpu->opaque;

            if (ts->child_tidptr) {

                put_user_u32(0, ts->child_tidptr);

                sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,

                          NULL, NULL, 0);

            }

            thread_cpu = NULL;

            object_unref(OBJECT(cpu));

            g_free(ts);

            pthread_exit(NULL);

        }

#ifdef TARGET_GPROF

        _mcleanup();

#endif

        gdb_exit(cpu_env, arg1);

        _exit(arg1);

        ret = 0; /* avoid warning */

        break;

    case TARGET_NR_read:

        if (arg3 == 0)


        else {

            if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))

                goto efault;

            ret = get_errno(read(arg1, p, arg3));

            unlock_user(p, arg2, ret);

        }

        break;

    case TARGET_NR_write:

        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))

            goto efault;

        ret = get_errno(write(arg1, p, arg3));

        unlock_user(p, arg2, 0);

        break;

    case TARGET_NR_open:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(do_open(cpu_env, p,

                                target_to_host_bitmask(arg2, fcntl_flags_tbl),

                                arg3));

        unlock_user(p, arg1, 0);

        break;

#if defined(TARGET_NR_openat) && defined(__NR_openat)

    case TARGET_NR_openat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(sys_openat(arg1,

                                   path(p),

                                   target_to_host_bitmask(arg3, fcntl_flags_tbl),

                                   arg4));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_close:

        ret = get_errno(close(arg1));

        break;

    case TARGET_NR_brk:

        ret = do_brk(arg1);

        break;

    case TARGET_NR_fork:

        ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));

        break;

#ifdef TARGET_NR_waitpid

    case TARGET_NR_waitpid:

        {

            int status;

            ret = get_errno(waitpid(arg1, &status, arg3));

            if (!is_error(ret) && arg2 && ret

                && put_user_s32(host_to_target_waitstatus(status), arg2))

                goto efault;

        }

        break;

#endif

#ifdef TARGET_NR_waitid

    case TARGET_NR_waitid:

        {

            siginfo_t info;

            info.si_pid = 0;

            ret = get_errno(waitid(arg1, arg2, &info, arg4));

            if (!is_error(ret) && arg3 && info.si_pid != 0) {

                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))

                    goto efault;

                host_to_target_siginfo(p, &info);

                unlock_user(p, arg3, sizeof(target_siginfo_t));

            }

        }

        break;

#endif

#ifdef TARGET_NR_creat /* not on alpha */

    case TARGET_NR_creat:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(creat(p, arg2));

        unlock_user(p, arg1, 0);

        break;

#endif

    case TARGET_NR_link:

        {

            void * p2;

            p = lock_user_string(arg1);

            p2 = lock_user_string(arg2);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(link(p, p2));

            unlock_user(p2, arg2, 0);

            unlock_user(p, arg1, 0);

        }

        break;

#if defined(TARGET_NR_linkat)

    case TARGET_NR_linkat:

        {

            void * p2 = NULL;

            if (!arg2 || !arg4)

                goto efault;

            p  = lock_user_string(arg2);

            p2 = lock_user_string(arg4);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(linkat(arg1, p, arg3, p2, arg5));

            unlock_user(p, arg2, 0);

            unlock_user(p2, arg4, 0);

        }

        break;

#endif

    case TARGET_NR_unlink:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(unlink(p));

        unlock_user(p, arg1, 0);

        break;

#if defined(TARGET_NR_unlinkat)

    case TARGET_NR_unlinkat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(unlinkat(arg1, p, arg3));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_execve:

        {

            char **argp, **envp;

            int argc, envc;

            abi_ulong gp;

            abi_ulong guest_argp;

            abi_ulong guest_envp;

            abi_ulong addr;

            char **q;

            int total_size = 0;



            argc = 0;

            guest_argp = arg2;

            for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {

                if (get_user_ual(addr, gp))

                    goto efault;

                if (!addr)

                    break;

                argc++;

            }

            envc = 0;

            guest_envp = arg3;

            for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {

                if (get_user_ual(addr, gp))

                    goto efault;

                if (!addr)

                    break;

                envc++;

            }



            argp = alloca((argc + 1) * sizeof(void *));

            envp = alloca((envc + 1) * sizeof(void *));



            for (gp = guest_argp, q = argp; gp;

                  gp += sizeof(abi_ulong), q++) {

                if (get_user_ual(addr, gp))

                    goto execve_efault;

                if (!addr)

                    break;

                if (!(*q = lock_user_string(addr)))

                    goto execve_efault;

                total_size += strlen(*q) + 1;

            }

            *q = NULL;



            for (gp = guest_envp, q = envp; gp;

                  gp += sizeof(abi_ulong), q++) {

                if (get_user_ual(addr, gp))

                    goto execve_efault;

                if (!addr)

                    break;

                if (!(*q = lock_user_string(addr)))

                    goto execve_efault;

                total_size += strlen(*q) + 1;

            }

            *q = NULL;



            /* This case will not be caught by the host's execve() if its

               page size is bigger than the target's. */

            if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {

                ret = -TARGET_E2BIG;

                goto execve_end;

            }

            if (!(p = lock_user_string(arg1)))

                goto execve_efault;

            ret = get_errno(execve(p, argp, envp));

            unlock_user(p, arg1, 0);



            goto execve_end;



        execve_efault:

            ret = -TARGET_EFAULT;



        execve_end:

            for (gp = guest_argp, q = argp; *q;

                  gp += sizeof(abi_ulong), q++) {

                if (get_user_ual(addr, gp)

                    || !addr)

                    break;

                unlock_user(*q, addr, 0);

            }

            for (gp = guest_envp, q = envp; *q;

                  gp += sizeof(abi_ulong), q++) {

                if (get_user_ual(addr, gp)

                    || !addr)

                    break;

                unlock_user(*q, addr, 0);

            }

        }

        break;

    case TARGET_NR_chdir:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(chdir(p));

        unlock_user(p, arg1, 0);

        break;

#ifdef TARGET_NR_time

    case TARGET_NR_time:

        {

            time_t host_time;

            ret = get_errno(time(&host_time));

            if (!is_error(ret)

                && arg1

                && put_user_sal(host_time, arg1))

                goto efault;

        }

        break;

#endif

    case TARGET_NR_mknod:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(mknod(p, arg2, arg3));

        unlock_user(p, arg1, 0);

        break;

#if defined(TARGET_NR_mknodat)

    case TARGET_NR_mknodat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(mknodat(arg1, p, arg3, arg4));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_chmod:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(chmod(p, arg2));

        unlock_user(p, arg1, 0);

        break;

#ifdef TARGET_NR_break

    case TARGET_NR_break:

        goto unimplemented;

#endif

#ifdef TARGET_NR_oldstat

    case TARGET_NR_oldstat:

        goto unimplemented;

#endif

    case TARGET_NR_lseek:

        ret = get_errno(lseek(arg1, arg2, arg3));

        break;

#if defined(TARGET_NR_getxpid) && defined(TARGET_ALPHA)

    /* Alpha specific */

    case TARGET_NR_getxpid:

        ((CPUAlphaState *)cpu_env)->ir[IR_A4] = getppid();

        ret = get_errno(getpid());

        break;

#endif

#ifdef TARGET_NR_getpid

    case TARGET_NR_getpid:

        ret = get_errno(getpid());

        break;

#endif

    case TARGET_NR_mount:

		{

			/* need to look at the data field */

			void *p2, *p3;

			p = lock_user_string(arg1);

			p2 = lock_user_string(arg2);

			p3 = lock_user_string(arg3);

                        if (!p || !p2 || !p3)

                            ret = -TARGET_EFAULT;

                        else {

                            /* FIXME - arg5 should be locked, but it isn't clear how to

                             * do that since it's not guaranteed to be a NULL-terminated

                             * string.

                             */

                            if ( ! arg5 )

                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));

                            else

                                ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));

                        }

                        unlock_user(p, arg1, 0);

                        unlock_user(p2, arg2, 0);

                        unlock_user(p3, arg3, 0);

			break;

		}

#ifdef TARGET_NR_umount

    case TARGET_NR_umount:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(umount(p));

        unlock_user(p, arg1, 0);

        break;

#endif

#ifdef TARGET_NR_stime /* not on alpha */

    case TARGET_NR_stime:

        {

            time_t host_time;

            if (get_user_sal(host_time, arg1))

                goto efault;

            ret = get_errno(stime(&host_time));

        }

        break;

#endif

    case TARGET_NR_ptrace:

        goto unimplemented;

#ifdef TARGET_NR_alarm /* not on alpha */

    case TARGET_NR_alarm:

        ret = alarm(arg1);

        break;

#endif

#ifdef TARGET_NR_oldfstat

    case TARGET_NR_oldfstat:

        goto unimplemented;

#endif

#ifdef TARGET_NR_pause /* not on alpha */

    case TARGET_NR_pause:

        ret = get_errno(pause());

        break;

#endif

#ifdef TARGET_NR_utime

    case TARGET_NR_utime:

        {

            struct utimbuf tbuf, *host_tbuf;

            struct target_utimbuf *target_tbuf;

            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))

                    goto efault;

                tbuf.actime = tswapal(target_tbuf->actime);

                tbuf.modtime = tswapal(target_tbuf->modtime);

                unlock_user_struct(target_tbuf, arg2, 0);

                host_tbuf = &tbuf;

            } else {

                host_tbuf = NULL;

            }

            if (!(p = lock_user_string(arg1)))

                goto efault;

            ret = get_errno(utime(p, host_tbuf));

            unlock_user(p, arg1, 0);

        }

        break;

#endif

    case TARGET_NR_utimes:

        {

            struct timeval *tvp, tv[2];

            if (arg2) {

                if (copy_from_user_timeval(&tv[0], arg2)

                    || copy_from_user_timeval(&tv[1],

                                              arg2 + sizeof(struct target_timeval)))

                    goto efault;

                tvp = tv;

            } else {

                tvp = NULL;

            }

            if (!(p = lock_user_string(arg1)))

                goto efault;

            ret = get_errno(utimes(p, tvp));

            unlock_user(p, arg1, 0);

        }

        break;

#if defined(TARGET_NR_futimesat)

    case TARGET_NR_futimesat:

        {

            struct timeval *tvp, tv[2];

            if (arg3) {

                if (copy_from_user_timeval(&tv[0], arg3)

                    || copy_from_user_timeval(&tv[1],

                                              arg3 + sizeof(struct target_timeval)))

                    goto efault;

                tvp = tv;

            } else {

                tvp = NULL;

            }

            if (!(p = lock_user_string(arg2)))

                goto efault;

            ret = get_errno(futimesat(arg1, path(p), tvp));

            unlock_user(p, arg2, 0);

        }

        break;

#endif

#ifdef TARGET_NR_stty

    case TARGET_NR_stty:

        goto unimplemented;

#endif

#ifdef TARGET_NR_gtty

    case TARGET_NR_gtty:

        goto unimplemented;

#endif

    case TARGET_NR_access:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(access(path(p), arg2));

        unlock_user(p, arg1, 0);

        break;

#if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)

    case TARGET_NR_faccessat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(faccessat(arg1, p, arg3, 0));

        unlock_user(p, arg2, 0);

        break;

#endif

#ifdef TARGET_NR_nice /* not on alpha */

    case TARGET_NR_nice:

        ret = get_errno(nice(arg1));

        break;

#endif

#ifdef TARGET_NR_ftime

    case TARGET_NR_ftime:

        goto unimplemented;

#endif

    case TARGET_NR_sync:

        sync();


        break;

    case TARGET_NR_kill:

        ret = get_errno(kill(arg1, target_to_host_signal(arg2)));

        break;

    case TARGET_NR_rename:

        {

            void *p2;

            p = lock_user_string(arg1);

            p2 = lock_user_string(arg2);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(rename(p, p2));

            unlock_user(p2, arg2, 0);

            unlock_user(p, arg1, 0);

        }

        break;

#if defined(TARGET_NR_renameat)

    case TARGET_NR_renameat:

        {

            void *p2;

            p  = lock_user_string(arg2);

            p2 = lock_user_string(arg4);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(renameat(arg1, p, arg3, p2));

            unlock_user(p2, arg4, 0);

            unlock_user(p, arg2, 0);

        }

        break;

#endif

    case TARGET_NR_mkdir:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(mkdir(p, arg2));

        unlock_user(p, arg1, 0);

        break;

#if defined(TARGET_NR_mkdirat)

    case TARGET_NR_mkdirat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(mkdirat(arg1, p, arg3));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_rmdir:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(rmdir(p));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_dup:

        ret = get_errno(dup(arg1));

        break;

    case TARGET_NR_pipe:

        ret = do_pipe(cpu_env, arg1, 0, 0);

        break;

#ifdef TARGET_NR_pipe2

    case TARGET_NR_pipe2:

        ret = do_pipe(cpu_env, arg1,

                      target_to_host_bitmask(arg2, fcntl_flags_tbl), 1);

        break;

#endif

    case TARGET_NR_times:

        {

            struct target_tms *tmsp;

            struct tms tms;

            ret = get_errno(times(&tms));

            if (arg1) {

                tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);

                if (!tmsp)

                    goto efault;

                tmsp->tms_utime = tswapal(host_to_target_clock_t(tms.tms_utime));

                tmsp->tms_stime = tswapal(host_to_target_clock_t(tms.tms_stime));

                tmsp->tms_cutime = tswapal(host_to_target_clock_t(tms.tms_cutime));

                tmsp->tms_cstime = tswapal(host_to_target_clock_t(tms.tms_cstime));

            }

            if (!is_error(ret))

                ret = host_to_target_clock_t(ret);

        }

        break;

#ifdef TARGET_NR_prof

    case TARGET_NR_prof:

        goto unimplemented;

#endif

#ifdef TARGET_NR_signal

    case TARGET_NR_signal:

        goto unimplemented;

#endif

    case TARGET_NR_acct:

        if (arg1 == 0) {

            ret = get_errno(acct(NULL));

        } else {

            if (!(p = lock_user_string(arg1)))

                goto efault;

            ret = get_errno(acct(path(p)));

            unlock_user(p, arg1, 0);

        }

        break;

#ifdef TARGET_NR_umount2

    case TARGET_NR_umount2:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(umount2(p, arg2));

        unlock_user(p, arg1, 0);

        break;

#endif

#ifdef TARGET_NR_lock

    case TARGET_NR_lock:

        goto unimplemented;

#endif

    case TARGET_NR_ioctl:

        ret = do_ioctl(arg1, arg2, arg3);

        break;

    case TARGET_NR_fcntl:

        ret = do_fcntl(arg1, arg2, arg3);

        break;

#ifdef TARGET_NR_mpx

    case TARGET_NR_mpx:

        goto unimplemented;

#endif

    case TARGET_NR_setpgid:

        ret = get_errno(setpgid(arg1, arg2));

        break;

#ifdef TARGET_NR_ulimit

    case TARGET_NR_ulimit:

        goto unimplemented;

#endif

#ifdef TARGET_NR_oldolduname

    case TARGET_NR_oldolduname:

        goto unimplemented;

#endif

    case TARGET_NR_umask:

        ret = get_errno(umask(arg1));

        break;

    case TARGET_NR_chroot:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(chroot(p));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_ustat:

        goto unimplemented;

    case TARGET_NR_dup2:

        ret = get_errno(dup2(arg1, arg2));

        break;

#if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)

    case TARGET_NR_dup3:

        ret = get_errno(dup3(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_getppid /* not on alpha */

    case TARGET_NR_getppid:

        ret = get_errno(getppid());

        break;

#endif

    case TARGET_NR_getpgrp:

        ret = get_errno(getpgrp());

        break;

    case TARGET_NR_setsid:

        ret = get_errno(setsid());

        break;

#ifdef TARGET_NR_sigaction

    case TARGET_NR_sigaction:

        {

#if defined(TARGET_ALPHA)

            struct target_sigaction act, oact, *pact = 0;

            struct target_old_sigaction *old_act;

            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))

                    goto efault;

                act._sa_handler = old_act->_sa_handler;

                target_siginitset(&act.sa_mask, old_act->sa_mask);

                act.sa_flags = old_act->sa_flags;

                act.sa_restorer = 0;

                unlock_user_struct(old_act, arg2, 0);

                pact = &act;

            }

            ret = get_errno(do_sigaction(arg1, pact, &oact));

            if (!is_error(ret) && arg3) {

                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))

                    goto efault;

                old_act->_sa_handler = oact._sa_handler;

                old_act->sa_mask = oact.sa_mask.sig[0];

                old_act->sa_flags = oact.sa_flags;

                unlock_user_struct(old_act, arg3, 1);

            }

#elif defined(TARGET_MIPS)

	    struct target_sigaction act, oact, *pact, *old_act;



	    if (arg2) {

                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))

                    goto efault;

		act._sa_handler = old_act->_sa_handler;

		target_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);

		act.sa_flags = old_act->sa_flags;

		unlock_user_struct(old_act, arg2, 0);

		pact = &act;

	    } else {

		pact = NULL;

	    }



	    ret = get_errno(do_sigaction(arg1, pact, &oact));



	    if (!is_error(ret) && arg3) {

                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))

                    goto efault;

		old_act->_sa_handler = oact._sa_handler;

		old_act->sa_flags = oact.sa_flags;

		old_act->sa_mask.sig[0] = oact.sa_mask.sig[0];

		old_act->sa_mask.sig[1] = 0;

		old_act->sa_mask.sig[2] = 0;

		old_act->sa_mask.sig[3] = 0;

		unlock_user_struct(old_act, arg3, 1);

	    }

#else

            struct target_old_sigaction *old_act;

            struct target_sigaction act, oact, *pact;

            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))

                    goto efault;

                act._sa_handler = old_act->_sa_handler;

                target_siginitset(&act.sa_mask, old_act->sa_mask);

                act.sa_flags = old_act->sa_flags;

                act.sa_restorer = old_act->sa_restorer;

                unlock_user_struct(old_act, arg2, 0);

                pact = &act;

            } else {

                pact = NULL;

            }

            ret = get_errno(do_sigaction(arg1, pact, &oact));

            if (!is_error(ret) && arg3) {

                if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))

                    goto efault;

                old_act->_sa_handler = oact._sa_handler;

                old_act->sa_mask = oact.sa_mask.sig[0];

                old_act->sa_flags = oact.sa_flags;

                old_act->sa_restorer = oact.sa_restorer;

                unlock_user_struct(old_act, arg3, 1);

            }

#endif

        }

        break;

#endif

    case TARGET_NR_rt_sigaction:

        {

#if defined(TARGET_ALPHA)

            struct target_sigaction act, oact, *pact = 0;

            struct target_rt_sigaction *rt_act;

            /* ??? arg4 == sizeof(sigset_t).  */

            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, rt_act, arg2, 1))

                    goto efault;

                act._sa_handler = rt_act->_sa_handler;

                act.sa_mask = rt_act->sa_mask;

                act.sa_flags = rt_act->sa_flags;

                act.sa_restorer = arg5;

                unlock_user_struct(rt_act, arg2, 0);

                pact = &act;

            }

            ret = get_errno(do_sigaction(arg1, pact, &oact));

            if (!is_error(ret) && arg3) {

                if (!lock_user_struct(VERIFY_WRITE, rt_act, arg3, 0))

                    goto efault;

                rt_act->_sa_handler = oact._sa_handler;

                rt_act->sa_mask = oact.sa_mask;

                rt_act->sa_flags = oact.sa_flags;

                unlock_user_struct(rt_act, arg3, 1);

            }

#else

            struct target_sigaction *act;

            struct target_sigaction *oact;



            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, act, arg2, 1))

                    goto efault;

            } else

                act = NULL;

            if (arg3) {

                if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {

                    ret = -TARGET_EFAULT;

                    goto rt_sigaction_fail;

                }

            } else

                oact = NULL;

            ret = get_errno(do_sigaction(arg1, act, oact));

	rt_sigaction_fail:

            if (act)

                unlock_user_struct(act, arg2, 0);

            if (oact)

                unlock_user_struct(oact, arg3, 1);

#endif

        }

        break;

#ifdef TARGET_NR_sgetmask /* not on alpha */

    case TARGET_NR_sgetmask:

        {

            sigset_t cur_set;

            abi_ulong target_set;

            sigprocmask(0, NULL, &cur_set);

            host_to_target_old_sigset(&target_set, &cur_set);

            ret = target_set;

        }

        break;

#endif

#ifdef TARGET_NR_ssetmask /* not on alpha */

    case TARGET_NR_ssetmask:

        {

            sigset_t set, oset, cur_set;

            abi_ulong target_set = arg1;

            sigprocmask(0, NULL, &cur_set);

            target_to_host_old_sigset(&set, &target_set);

            sigorset(&set, &set, &cur_set);

            sigprocmask(SIG_SETMASK, &set, &oset);

            host_to_target_old_sigset(&target_set, &oset);

            ret = target_set;

        }

        break;

#endif

#ifdef TARGET_NR_sigprocmask

    case TARGET_NR_sigprocmask:

        {

#if defined(TARGET_ALPHA)

            sigset_t set, oldset;

            abi_ulong mask;

            int how;



            switch (arg1) {

            case TARGET_SIG_BLOCK:

                how = SIG_BLOCK;

                break;

            case TARGET_SIG_UNBLOCK:

                how = SIG_UNBLOCK;

                break;

            case TARGET_SIG_SETMASK:

                how = SIG_SETMASK;

                break;

            default:

                ret = -TARGET_EINVAL;

                goto fail;

            }

            mask = arg2;

            target_to_host_old_sigset(&set, &mask);



            ret = get_errno(sigprocmask(how, &set, &oldset));

            if (!is_error(ret)) {

                host_to_target_old_sigset(&mask, &oldset);

                ret = mask;

                ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0; /* force no error */

            }

#else

            sigset_t set, oldset, *set_ptr;

            int how;



            if (arg2) {

                switch (arg1) {

                case TARGET_SIG_BLOCK:

                    how = SIG_BLOCK;

                    break;

                case TARGET_SIG_UNBLOCK:

                    how = SIG_UNBLOCK;

                    break;

                case TARGET_SIG_SETMASK:

                    how = SIG_SETMASK;

                    break;

                default:

                    ret = -TARGET_EINVAL;

                    goto fail;

                }

                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))

                    goto efault;

                target_to_host_old_sigset(&set, p);

                unlock_user(p, arg2, 0);

                set_ptr = &set;

            } else {

                how = 0;

                set_ptr = NULL;

            }

            ret = get_errno(sigprocmask(how, set_ptr, &oldset));

            if (!is_error(ret) && arg3) {

                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))

                    goto efault;

                host_to_target_old_sigset(p, &oldset);

                unlock_user(p, arg3, sizeof(target_sigset_t));

            }

#endif

        }

        break;

#endif

    case TARGET_NR_rt_sigprocmask:

        {

            int how = arg1;

            sigset_t set, oldset, *set_ptr;



            if (arg2) {

                switch(how) {

                case TARGET_SIG_BLOCK:

                    how = SIG_BLOCK;

                    break;

                case TARGET_SIG_UNBLOCK:

                    how = SIG_UNBLOCK;

                    break;

                case TARGET_SIG_SETMASK:

                    how = SIG_SETMASK;

                    break;

                default:

                    ret = -TARGET_EINVAL;

                    goto fail;

                }

                if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))

                    goto efault;

                target_to_host_sigset(&set, p);

                unlock_user(p, arg2, 0);

                set_ptr = &set;

            } else {

                how = 0;

                set_ptr = NULL;

            }

            ret = get_errno(sigprocmask(how, set_ptr, &oldset));

            if (!is_error(ret) && arg3) {

                if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))

                    goto efault;

                host_to_target_sigset(p, &oldset);

                unlock_user(p, arg3, sizeof(target_sigset_t));

            }

        }

        break;

#ifdef TARGET_NR_sigpending

    case TARGET_NR_sigpending:

        {

            sigset_t set;

            ret = get_errno(sigpending(&set));

            if (!is_error(ret)) {

                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))

                    goto efault;

                host_to_target_old_sigset(p, &set);

                unlock_user(p, arg1, sizeof(target_sigset_t));

            }

        }

        break;

#endif

    case TARGET_NR_rt_sigpending:

        {

            sigset_t set;

            ret = get_errno(sigpending(&set));

            if (!is_error(ret)) {

                if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))

                    goto efault;

                host_to_target_sigset(p, &set);

                unlock_user(p, arg1, sizeof(target_sigset_t));

            }

        }

        break;

#ifdef TARGET_NR_sigsuspend

    case TARGET_NR_sigsuspend:

        {

            sigset_t set;

#if defined(TARGET_ALPHA)

            abi_ulong mask = arg1;

            target_to_host_old_sigset(&set, &mask);

#else

            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))

                goto efault;

            target_to_host_old_sigset(&set, p);

            unlock_user(p, arg1, 0);

#endif

            ret = get_errno(sigsuspend(&set));

        }

        break;

#endif

    case TARGET_NR_rt_sigsuspend:

        {

            sigset_t set;

            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))

                goto efault;

            target_to_host_sigset(&set, p);

            unlock_user(p, arg1, 0);

            ret = get_errno(sigsuspend(&set));

        }

        break;

    case TARGET_NR_rt_sigtimedwait:

        {

            sigset_t set;

            struct timespec uts, *puts;

            siginfo_t uinfo;



            if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))

                goto efault;

            target_to_host_sigset(&set, p);

            unlock_user(p, arg1, 0);

            if (arg3) {

                puts = &uts;

                target_to_host_timespec(puts, arg3);

            } else {

                puts = NULL;

            }

            ret = get_errno(sigtimedwait(&set, &uinfo, puts));

            if (!is_error(ret)) {

                if (arg2) {

                    p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t),

                                  0);

                    if (!p) {

                        goto efault;

                    }

                    host_to_target_siginfo(p, &uinfo);

                    unlock_user(p, arg2, sizeof(target_siginfo_t));

                }

                ret = host_to_target_signal(ret);

            }

        }

        break;

    case TARGET_NR_rt_sigqueueinfo:

        {

            siginfo_t uinfo;

            if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))

                goto efault;

            target_to_host_siginfo(&uinfo, p);

            unlock_user(p, arg1, 0);

            ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));

        }

        break;

#ifdef TARGET_NR_sigreturn

    case TARGET_NR_sigreturn:

        /* NOTE: ret is eax, so not transcoding must be done */

        ret = do_sigreturn(cpu_env);

        break;

#endif

    case TARGET_NR_rt_sigreturn:

        /* NOTE: ret is eax, so not transcoding must be done */

        ret = do_rt_sigreturn(cpu_env);

        break;

    case TARGET_NR_sethostname:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(sethostname(p, arg2));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_setrlimit:

        {

            int resource = target_to_host_resource(arg1);

            struct target_rlimit *target_rlim;

            struct rlimit rlim;

            if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))

                goto efault;

            rlim.rlim_cur = target_to_host_rlim(target_rlim->rlim_cur);

            rlim.rlim_max = target_to_host_rlim(target_rlim->rlim_max);

            unlock_user_struct(target_rlim, arg2, 0);

            ret = get_errno(setrlimit(resource, &rlim));

        }

        break;

    case TARGET_NR_getrlimit:

        {

            int resource = target_to_host_resource(arg1);

            struct target_rlimit *target_rlim;

            struct rlimit rlim;



            ret = get_errno(getrlimit(resource, &rlim));

            if (!is_error(ret)) {

                if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))

                    goto efault;

                target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);

                target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);

                unlock_user_struct(target_rlim, arg2, 1);

            }

        }

        break;

    case TARGET_NR_getrusage:

        {

            struct rusage rusage;

            ret = get_errno(getrusage(arg1, &rusage));

            if (!is_error(ret)) {

                host_to_target_rusage(arg2, &rusage);

            }

        }

        break;

    case TARGET_NR_gettimeofday:

        {

            struct timeval tv;

            ret = get_errno(gettimeofday(&tv, NULL));

            if (!is_error(ret)) {

                if (copy_to_user_timeval(arg1, &tv))

                    goto efault;

            }

        }

        break;

    case TARGET_NR_settimeofday:

        {

            struct timeval tv;

            if (copy_from_user_timeval(&tv, arg1))

                goto efault;

            ret = get_errno(settimeofday(&tv, NULL));

        }

        break;

#if defined(TARGET_NR_select)

    case TARGET_NR_select:

#if defined(TARGET_S390X) || defined(TARGET_ALPHA)

        ret = do_select(arg1, arg2, arg3, arg4, arg5);

#else

        {

            struct target_sel_arg_struct *sel;

            abi_ulong inp, outp, exp, tvp;

            long nsel;



            if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))

                goto efault;

            nsel = tswapal(sel->n);

            inp = tswapal(sel->inp);

            outp = tswapal(sel->outp);

            exp = tswapal(sel->exp);

            tvp = tswapal(sel->tvp);

            unlock_user_struct(sel, arg1, 0);

            ret = do_select(nsel, inp, outp, exp, tvp);

        }

#endif

        break;

#endif

#ifdef TARGET_NR_pselect6

    case TARGET_NR_pselect6:

        {

            abi_long rfd_addr, wfd_addr, efd_addr, n, ts_addr;

            fd_set rfds, wfds, efds;

            fd_set *rfds_ptr, *wfds_ptr, *efds_ptr;

            struct timespec ts, *ts_ptr;



            /*

             * The 6th arg is actually two args smashed together,

             * so we cannot use the C library.

             */

            sigset_t set;

            struct {

                sigset_t *set;

                size_t size;

            } sig, *sig_ptr;



            abi_ulong arg_sigset, arg_sigsize, *arg7;

            target_sigset_t *target_sigset;



            n = arg1;

            rfd_addr = arg2;

            wfd_addr = arg3;

            efd_addr = arg4;

            ts_addr = arg5;



            ret = copy_from_user_fdset_ptr(&rfds, &rfds_ptr, rfd_addr, n);

            if (ret) {

                goto fail;

            }

            ret = copy_from_user_fdset_ptr(&wfds, &wfds_ptr, wfd_addr, n);

            if (ret) {

                goto fail;

            }

            ret = copy_from_user_fdset_ptr(&efds, &efds_ptr, efd_addr, n);

            if (ret) {

                goto fail;

            }



            /*

             * This takes a timespec, and not a timeval, so we cannot

             * use the do_select() helper ...

             */

            if (ts_addr) {

                if (target_to_host_timespec(&ts, ts_addr)) {

                    goto efault;

                }

                ts_ptr = &ts;

            } else {

                ts_ptr = NULL;

            }



            /* Extract the two packed args for the sigset */

            if (arg6) {

                sig_ptr = &sig;

                sig.size = _NSIG / 8;



                arg7 = lock_user(VERIFY_READ, arg6, sizeof(*arg7) * 2, 1);

                if (!arg7) {

                    goto efault;

                }

                arg_sigset = tswapal(arg7[0]);

                arg_sigsize = tswapal(arg7[1]);

                unlock_user(arg7, arg6, 0);



                if (arg_sigset) {

                    sig.set = &set;

                    if (arg_sigsize != sizeof(*target_sigset)) {

                        /* Like the kernel, we enforce correct size sigsets */

                        ret = -TARGET_EINVAL;

                        goto fail;

                    }

                    target_sigset = lock_user(VERIFY_READ, arg_sigset,

                                              sizeof(*target_sigset), 1);

                    if (!target_sigset) {

                        goto efault;

                    }

                    target_to_host_sigset(&set, target_sigset);

                    unlock_user(target_sigset, arg_sigset, 0);

                } else {

                    sig.set = NULL;

                }

            } else {

                sig_ptr = NULL;

            }



            ret = get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,

                                         ts_ptr, sig_ptr));



            if (!is_error(ret)) {

                if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))

                    goto efault;

                if (wfd_addr && copy_to_user_fdset(wfd_addr, &wfds, n))

                    goto efault;

                if (efd_addr && copy_to_user_fdset(efd_addr, &efds, n))

                    goto efault;



                if (ts_addr && host_to_target_timespec(ts_addr, &ts))

                    goto efault;

            }

        }

        break;

#endif

    case TARGET_NR_symlink:

        {

            void *p2;

            p = lock_user_string(arg1);

            p2 = lock_user_string(arg2);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(symlink(p, p2));

            unlock_user(p2, arg2, 0);

            unlock_user(p, arg1, 0);

        }

        break;

#if defined(TARGET_NR_symlinkat)

    case TARGET_NR_symlinkat:

        {

            void *p2;

            p  = lock_user_string(arg1);

            p2 = lock_user_string(arg3);

            if (!p || !p2)

                ret = -TARGET_EFAULT;

            else

                ret = get_errno(symlinkat(p, arg2, p2));

            unlock_user(p2, arg3, 0);

            unlock_user(p, arg1, 0);

        }

        break;

#endif

#ifdef TARGET_NR_oldlstat

    case TARGET_NR_oldlstat:

        goto unimplemented;

#endif

    case TARGET_NR_readlink:

        {

            void *p2;

            p = lock_user_string(arg1);

            p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);

            if (!p || !p2) {

                ret = -TARGET_EFAULT;

            } else if (is_proc_myself((const char *)p, "exe")) {

                char real[PATH_MAX], *temp;

                temp = realpath(exec_path, real);

                ret = temp == NULL ? get_errno(-1) : strlen(real) ;

                snprintf((char *)p2, arg3, "%s", real);

            } else {

                ret = get_errno(readlink(path(p), p2, arg3));

            }

            unlock_user(p2, arg2, ret);

            unlock_user(p, arg1, 0);

        }

        break;

#if defined(TARGET_NR_readlinkat)

    case TARGET_NR_readlinkat:

        {

            void *p2;

            p  = lock_user_string(arg2);

            p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);

            if (!p || !p2) {

                ret = -TARGET_EFAULT;

            } else if (is_proc_myself((const char *)p, "exe")) {

                char real[PATH_MAX], *temp;

                temp = realpath(exec_path, real);

                ret = temp == NULL ? get_errno(-1) : strlen(real) ;

                snprintf((char *)p2, arg4, "%s", real);

            } else {

                ret = get_errno(readlinkat(arg1, path(p), p2, arg4));

            }

            unlock_user(p2, arg3, ret);

            unlock_user(p, arg2, 0);

        }

        break;

#endif

#ifdef TARGET_NR_uselib

    case TARGET_NR_uselib:

        goto unimplemented;

#endif

#ifdef TARGET_NR_swapon

    case TARGET_NR_swapon:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(swapon(p, arg2));

        unlock_user(p, arg1, 0);

        break;

#endif

    case TARGET_NR_reboot:

        if (arg3 == LINUX_REBOOT_CMD_RESTART2) {

           /* arg4 must be ignored in all other cases */

           p = lock_user_string(arg4);

           if (!p) {

              goto efault;

           }

           ret = get_errno(reboot(arg1, arg2, arg3, p));

           unlock_user(p, arg4, 0);

        } else {

           ret = get_errno(reboot(arg1, arg2, arg3, NULL));

        }

        break;

#ifdef TARGET_NR_readdir

    case TARGET_NR_readdir:

        goto unimplemented;

#endif

#ifdef TARGET_NR_mmap

    case TARGET_NR_mmap:

#if (defined(TARGET_I386) && defined(TARGET_ABI32)) || \

    (defined(TARGET_ARM) && defined(TARGET_ABI32)) || \

    defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE) \

    || defined(TARGET_S390X)

        {

            abi_ulong *v;

            abi_ulong v1, v2, v3, v4, v5, v6;

            if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))

                goto efault;

            v1 = tswapal(v[0]);

            v2 = tswapal(v[1]);

            v3 = tswapal(v[2]);

            v4 = tswapal(v[3]);

            v5 = tswapal(v[4]);

            v6 = tswapal(v[5]);

            unlock_user(v, arg1, 0);

            ret = get_errno(target_mmap(v1, v2, v3,

                                        target_to_host_bitmask(v4, mmap_flags_tbl),

                                        v5, v6));

        }

#else

        ret = get_errno(target_mmap(arg1, arg2, arg3,

                                    target_to_host_bitmask(arg4, mmap_flags_tbl),

                                    arg5,

                                    arg6));

#endif

        break;

#endif

#ifdef TARGET_NR_mmap2

    case TARGET_NR_mmap2:

#ifndef MMAP_SHIFT

#define MMAP_SHIFT 12

#endif

        ret = get_errno(target_mmap(arg1, arg2, arg3,

                                    target_to_host_bitmask(arg4, mmap_flags_tbl),

                                    arg5,

                                    arg6 << MMAP_SHIFT));

        break;

#endif

    case TARGET_NR_munmap:

        ret = get_errno(target_munmap(arg1, arg2));

        break;

    case TARGET_NR_mprotect:

        {

            TaskState *ts = cpu->opaque;

            /* Special hack to detect libc making the stack executable.  */

            if ((arg3 & PROT_GROWSDOWN)

                && arg1 >= ts->info->stack_limit

                && arg1 <= ts->info->start_stack) {

                arg3 &= ~PROT_GROWSDOWN;

                arg2 = arg2 + arg1 - ts->info->stack_limit;

                arg1 = ts->info->stack_limit;

            }

        }

        ret = get_errno(target_mprotect(arg1, arg2, arg3));

        break;

#ifdef TARGET_NR_mremap

    case TARGET_NR_mremap:

        ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));

        break;

#endif

        /* ??? msync/mlock/munlock are broken for softmmu.  */

#ifdef TARGET_NR_msync

    case TARGET_NR_msync:

        ret = get_errno(msync(g2h(arg1), arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_mlock

    case TARGET_NR_mlock:

        ret = get_errno(mlock(g2h(arg1), arg2));

        break;

#endif

#ifdef TARGET_NR_munlock

    case TARGET_NR_munlock:

        ret = get_errno(munlock(g2h(arg1), arg2));

        break;

#endif

#ifdef TARGET_NR_mlockall

    case TARGET_NR_mlockall:

        ret = get_errno(mlockall(arg1));

        break;

#endif

#ifdef TARGET_NR_munlockall

    case TARGET_NR_munlockall:

        ret = get_errno(munlockall());

        break;

#endif

    case TARGET_NR_truncate:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(truncate(p, arg2));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_ftruncate:

        ret = get_errno(ftruncate(arg1, arg2));

        break;

    case TARGET_NR_fchmod:

        ret = get_errno(fchmod(arg1, arg2));

        break;

#if defined(TARGET_NR_fchmodat)

    case TARGET_NR_fchmodat:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(fchmodat(arg1, p, arg3, 0));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_getpriority:

        /* Note that negative values are valid for getpriority, so we must

           differentiate based on errno settings.  */

        errno = 0;

        ret = getpriority(arg1, arg2);

        if (ret == -1 && errno != 0) {

            ret = -host_to_target_errno(errno);

            break;

        }

#ifdef TARGET_ALPHA

        /* Return value is the unbiased priority.  Signal no error.  */

        ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0;

#else

        /* Return value is a biased priority to avoid negative numbers.  */

        ret = 20 - ret;

#endif

        break;

    case TARGET_NR_setpriority:

        ret = get_errno(setpriority(arg1, arg2, arg3));

        break;

#ifdef TARGET_NR_profil

    case TARGET_NR_profil:

        goto unimplemented;

#endif

    case TARGET_NR_statfs:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(statfs(path(p), &stfs));

        unlock_user(p, arg1, 0);

    convert_statfs:

        if (!is_error(ret)) {

            struct target_statfs *target_stfs;



            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))

                goto efault;

            __put_user(stfs.f_type, &target_stfs->f_type);

            __put_user(stfs.f_bsize, &target_stfs->f_bsize);

            __put_user(stfs.f_blocks, &target_stfs->f_blocks);

            __put_user(stfs.f_bfree, &target_stfs->f_bfree);

            __put_user(stfs.f_bavail, &target_stfs->f_bavail);

            __put_user(stfs.f_files, &target_stfs->f_files);

            __put_user(stfs.f_ffree, &target_stfs->f_ffree);

            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);

            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);

            __put_user(stfs.f_namelen, &target_stfs->f_namelen);

            __put_user(stfs.f_frsize, &target_stfs->f_frsize);

            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));

            unlock_user_struct(target_stfs, arg2, 1);

        }

        break;

    case TARGET_NR_fstatfs:

        ret = get_errno(fstatfs(arg1, &stfs));

        goto convert_statfs;

#ifdef TARGET_NR_statfs64

    case TARGET_NR_statfs64:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(statfs(path(p), &stfs));

        unlock_user(p, arg1, 0);

    convert_statfs64:

        if (!is_error(ret)) {

            struct target_statfs64 *target_stfs;



            if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))

                goto efault;

            __put_user(stfs.f_type, &target_stfs->f_type);

            __put_user(stfs.f_bsize, &target_stfs->f_bsize);

            __put_user(stfs.f_blocks, &target_stfs->f_blocks);

            __put_user(stfs.f_bfree, &target_stfs->f_bfree);

            __put_user(stfs.f_bavail, &target_stfs->f_bavail);

            __put_user(stfs.f_files, &target_stfs->f_files);

            __put_user(stfs.f_ffree, &target_stfs->f_ffree);

            __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);

            __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);

            __put_user(stfs.f_namelen, &target_stfs->f_namelen);

            __put_user(stfs.f_frsize, &target_stfs->f_frsize);

            memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));

            unlock_user_struct(target_stfs, arg3, 1);

        }

        break;

    case TARGET_NR_fstatfs64:

        ret = get_errno(fstatfs(arg1, &stfs));

        goto convert_statfs64;

#endif

#ifdef TARGET_NR_ioperm

    case TARGET_NR_ioperm:

        goto unimplemented;

#endif

#ifdef TARGET_NR_socketcall

    case TARGET_NR_socketcall:

        ret = do_socketcall(arg1, arg2);

        break;

#endif

#ifdef TARGET_NR_accept

    case TARGET_NR_accept:

        ret = do_accept4(arg1, arg2, arg3, 0);

        break;

#endif

#ifdef TARGET_NR_accept4

    case TARGET_NR_accept4:

#ifdef CONFIG_ACCEPT4

        ret = do_accept4(arg1, arg2, arg3, arg4);

#else

        goto unimplemented;

#endif

        break;

#endif

#ifdef TARGET_NR_bind

    case TARGET_NR_bind:

        ret = do_bind(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_connect

    case TARGET_NR_connect:

        ret = do_connect(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_getpeername

    case TARGET_NR_getpeername:

        ret = do_getpeername(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_getsockname

    case TARGET_NR_getsockname:

        ret = do_getsockname(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_getsockopt

    case TARGET_NR_getsockopt:

        ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);

        break;

#endif

#ifdef TARGET_NR_listen

    case TARGET_NR_listen:

        ret = get_errno(listen(arg1, arg2));

        break;

#endif

#ifdef TARGET_NR_recv

    case TARGET_NR_recv:

        ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);

        break;

#endif

#ifdef TARGET_NR_recvfrom

    case TARGET_NR_recvfrom:

        ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);

        break;

#endif

#ifdef TARGET_NR_recvmsg

    case TARGET_NR_recvmsg:

        ret = do_sendrecvmsg(arg1, arg2, arg3, 0);

        break;

#endif

#ifdef TARGET_NR_send

    case TARGET_NR_send:

        ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);

        break;

#endif

#ifdef TARGET_NR_sendmsg

    case TARGET_NR_sendmsg:

        ret = do_sendrecvmsg(arg1, arg2, arg3, 1);

        break;

#endif

#ifdef TARGET_NR_sendmmsg

    case TARGET_NR_sendmmsg:

        ret = do_sendrecvmmsg(arg1, arg2, arg3, arg4, 1);

        break;

    case TARGET_NR_recvmmsg:

        ret = do_sendrecvmmsg(arg1, arg2, arg3, arg4, 0);

        break;

#endif

#ifdef TARGET_NR_sendto

    case TARGET_NR_sendto:

        ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);

        break;

#endif

#ifdef TARGET_NR_shutdown

    case TARGET_NR_shutdown:

        ret = get_errno(shutdown(arg1, arg2));

        break;

#endif

#ifdef TARGET_NR_socket

    case TARGET_NR_socket:

        ret = do_socket(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_socketpair

    case TARGET_NR_socketpair:

        ret = do_socketpair(arg1, arg2, arg3, arg4);

        break;

#endif

#ifdef TARGET_NR_setsockopt

    case TARGET_NR_setsockopt:

        ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);

        break;

#endif



    case TARGET_NR_syslog:

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));

        unlock_user(p, arg2, 0);

        break;



    case TARGET_NR_setitimer:

        {

            struct itimerval value, ovalue, *pvalue;



            if (arg2) {

                pvalue = &value;

                if (copy_from_user_timeval(&pvalue->it_interval, arg2)

                    || copy_from_user_timeval(&pvalue->it_value,

                                              arg2 + sizeof(struct target_timeval)))

                    goto efault;

            } else {

                pvalue = NULL;

            }

            ret = get_errno(setitimer(arg1, pvalue, &ovalue));

            if (!is_error(ret) && arg3) {

                if (copy_to_user_timeval(arg3,

                                         &ovalue.it_interval)

                    || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),

                                            &ovalue.it_value))

                    goto efault;

            }

        }

        break;

    case TARGET_NR_getitimer:

        {

            struct itimerval value;



            ret = get_errno(getitimer(arg1, &value));

            if (!is_error(ret) && arg2) {

                if (copy_to_user_timeval(arg2,

                                         &value.it_interval)

                    || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),

                                            &value.it_value))

                    goto efault;

            }

        }

        break;

    case TARGET_NR_stat:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(stat(path(p), &st));

        unlock_user(p, arg1, 0);

        goto do_stat;

    case TARGET_NR_lstat:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(lstat(path(p), &st));

        unlock_user(p, arg1, 0);

        goto do_stat;

    case TARGET_NR_fstat:

        {

            ret = get_errno(fstat(arg1, &st));

        do_stat:

            if (!is_error(ret)) {

                struct target_stat *target_st;



                if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))

                    goto efault;

                memset(target_st, 0, sizeof(*target_st));

                __put_user(st.st_dev, &target_st->st_dev);

                __put_user(st.st_ino, &target_st->st_ino);

                __put_user(st.st_mode, &target_st->st_mode);

                __put_user(st.st_uid, &target_st->st_uid);

                __put_user(st.st_gid, &target_st->st_gid);

                __put_user(st.st_nlink, &target_st->st_nlink);

                __put_user(st.st_rdev, &target_st->st_rdev);

                __put_user(st.st_size, &target_st->st_size);

                __put_user(st.st_blksize, &target_st->st_blksize);

                __put_user(st.st_blocks, &target_st->st_blocks);

                __put_user(st.st_atime, &target_st->target_st_atime);

                __put_user(st.st_mtime, &target_st->target_st_mtime);

                __put_user(st.st_ctime, &target_st->target_st_ctime);

                unlock_user_struct(target_st, arg2, 1);

            }

        }

        break;

#ifdef TARGET_NR_olduname

    case TARGET_NR_olduname:

        goto unimplemented;

#endif

#ifdef TARGET_NR_iopl

    case TARGET_NR_iopl:

        goto unimplemented;

#endif

    case TARGET_NR_vhangup:

        ret = get_errno(vhangup());

        break;

#ifdef TARGET_NR_idle

    case TARGET_NR_idle:

        goto unimplemented;

#endif

#ifdef TARGET_NR_syscall

    case TARGET_NR_syscall:

        ret = do_syscall(cpu_env, arg1 & 0xffff, arg2, arg3, arg4, arg5,

                         arg6, arg7, arg8, 0);

        break;

#endif

    case TARGET_NR_wait4:

        {

            int status;

            abi_long status_ptr = arg2;

            struct rusage rusage, *rusage_ptr;

            abi_ulong target_rusage = arg4;

            if (target_rusage)

                rusage_ptr = &rusage;

            else

                rusage_ptr = NULL;

            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));

            if (!is_error(ret)) {

                if (status_ptr && ret) {

                    status = host_to_target_waitstatus(status);

                    if (put_user_s32(status, status_ptr))

                        goto efault;

                }

                if (target_rusage)

                    host_to_target_rusage(target_rusage, &rusage);

            }

        }

        break;

#ifdef TARGET_NR_swapoff

    case TARGET_NR_swapoff:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(swapoff(p));

        unlock_user(p, arg1, 0);

        break;

#endif

    case TARGET_NR_sysinfo:

        {

            struct target_sysinfo *target_value;

            struct sysinfo value;

            ret = get_errno(sysinfo(&value));

            if (!is_error(ret) && arg1)

            {

                if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))

                    goto efault;

                __put_user(value.uptime, &target_value->uptime);

                __put_user(value.loads[0], &target_value->loads[0]);

                __put_user(value.loads[1], &target_value->loads[1]);

                __put_user(value.loads[2], &target_value->loads[2]);

                __put_user(value.totalram, &target_value->totalram);

                __put_user(value.freeram, &target_value->freeram);

                __put_user(value.sharedram, &target_value->sharedram);

                __put_user(value.bufferram, &target_value->bufferram);

                __put_user(value.totalswap, &target_value->totalswap);

                __put_user(value.freeswap, &target_value->freeswap);

                __put_user(value.procs, &target_value->procs);

                __put_user(value.totalhigh, &target_value->totalhigh);

                __put_user(value.freehigh, &target_value->freehigh);

                __put_user(value.mem_unit, &target_value->mem_unit);

                unlock_user_struct(target_value, arg1, 1);

            }

        }

        break;

#ifdef TARGET_NR_ipc

    case TARGET_NR_ipc:

	ret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);

	break;

#endif

#ifdef TARGET_NR_semget

    case TARGET_NR_semget:

        ret = get_errno(semget(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_semop

    case TARGET_NR_semop:

        ret = do_semop(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_semctl

    case TARGET_NR_semctl:

        ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);

        break;

#endif

#ifdef TARGET_NR_msgctl

    case TARGET_NR_msgctl:

        ret = do_msgctl(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_msgget

    case TARGET_NR_msgget:

        ret = get_errno(msgget(arg1, arg2));

        break;

#endif

#ifdef TARGET_NR_msgrcv

    case TARGET_NR_msgrcv:

        ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);

        break;

#endif

#ifdef TARGET_NR_msgsnd

    case TARGET_NR_msgsnd:

        ret = do_msgsnd(arg1, arg2, arg3, arg4);

        break;

#endif

#ifdef TARGET_NR_shmget

    case TARGET_NR_shmget:

        ret = get_errno(shmget(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_shmctl

    case TARGET_NR_shmctl:

        ret = do_shmctl(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_shmat

    case TARGET_NR_shmat:

        ret = do_shmat(arg1, arg2, arg3);

        break;

#endif

#ifdef TARGET_NR_shmdt

    case TARGET_NR_shmdt:

        ret = do_shmdt(arg1);

        break;

#endif

    case TARGET_NR_fsync:

        ret = get_errno(fsync(arg1));

        break;

    case TARGET_NR_clone:

        /* Linux manages to have three different orderings for its

         * arguments to clone(); the BACKWARDS and BACKWARDS2 defines

         * match the kernel's CONFIG_CLONE_* settings.

         * Microblaze is further special in that it uses a sixth

         * implicit argument to clone for the TLS pointer.

         */

#if defined(TARGET_MICROBLAZE)

        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg4, arg6, arg5));

#elif defined(TARGET_CLONE_BACKWARDS)

        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));

#elif defined(TARGET_CLONE_BACKWARDS2)

        ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg5, arg4));

#else

        ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));

#endif

        break;

#ifdef __NR_exit_group

        /* new thread calls */

    case TARGET_NR_exit_group:

#ifdef TARGET_GPROF

        _mcleanup();

#endif

        gdb_exit(cpu_env, arg1);

        ret = get_errno(exit_group(arg1));

        break;

#endif

    case TARGET_NR_setdomainname:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(setdomainname(p, arg2));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_uname:

        /* no need to transcode because we use the linux syscall */

        {

            struct new_utsname * buf;



            if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))

                goto efault;

            ret = get_errno(sys_uname(buf));

            if (!is_error(ret)) {

                /* Overrite the native machine name with whatever is being

                   emulated. */

                strcpy (buf->machine, cpu_to_uname_machine(cpu_env));

                /* Allow the user to override the reported release.  */

                if (qemu_uname_release && *qemu_uname_release)

                  strcpy (buf->release, qemu_uname_release);

            }

            unlock_user_struct(buf, arg1, 1);

        }

        break;

#ifdef TARGET_I386

    case TARGET_NR_modify_ldt:

        ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);

        break;

#if !defined(TARGET_X86_64)

    case TARGET_NR_vm86old:

        goto unimplemented;

    case TARGET_NR_vm86:

        ret = do_vm86(cpu_env, arg1, arg2);

        break;

#endif

#endif

    case TARGET_NR_adjtimex:

        goto unimplemented;

#ifdef TARGET_NR_create_module

    case TARGET_NR_create_module:

#endif

    case TARGET_NR_init_module:

    case TARGET_NR_delete_module:

#ifdef TARGET_NR_get_kernel_syms

    case TARGET_NR_get_kernel_syms:

#endif

        goto unimplemented;

    case TARGET_NR_quotactl:

        goto unimplemented;

    case TARGET_NR_getpgid:

        ret = get_errno(getpgid(arg1));

        break;

    case TARGET_NR_fchdir:

        ret = get_errno(fchdir(arg1));

        break;

#ifdef TARGET_NR_bdflush /* not on x86_64 */

    case TARGET_NR_bdflush:

        goto unimplemented;

#endif

#ifdef TARGET_NR_sysfs

    case TARGET_NR_sysfs:

        goto unimplemented;

#endif

    case TARGET_NR_personality:

        ret = get_errno(personality(arg1));

        break;

#ifdef TARGET_NR_afs_syscall

    case TARGET_NR_afs_syscall:

        goto unimplemented;

#endif

#ifdef TARGET_NR__llseek /* Not on alpha */

    case TARGET_NR__llseek:

        {

            int64_t res;

#if !defined(__NR_llseek)

            res = lseek(arg1, ((uint64_t)arg2 << 32) | arg3, arg5);

            if (res == -1) {

                ret = get_errno(res);

            } else {


            }

#else

            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));

#endif

            if ((ret == 0) && put_user_s64(res, arg4)) {

                goto efault;

            }

        }

        break;

#endif

    case TARGET_NR_getdents:

#ifdef __NR_getdents

#if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64

        {

            struct target_dirent *target_dirp;

            struct linux_dirent *dirp;

            abi_long count = arg3;



	    dirp = malloc(count);

	    if (!dirp) {

                ret = -TARGET_ENOMEM;

                goto fail;

            }



            ret = get_errno(sys_getdents(arg1, dirp, count));

            if (!is_error(ret)) {

                struct linux_dirent *de;

		struct target_dirent *tde;

                int len = ret;

                int reclen, treclen;

		int count1, tnamelen;



		count1 = 0;

                de = dirp;

                if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))

                    goto efault;

		tde = target_dirp;

                while (len > 0) {

                    reclen = de->d_reclen;

                    tnamelen = reclen - offsetof(struct linux_dirent, d_name);

                    assert(tnamelen >= 0);

                    treclen = tnamelen + offsetof(struct target_dirent, d_name);

                    assert(count1 + treclen <= count);

                    tde->d_reclen = tswap16(treclen);

                    tde->d_ino = tswapal(de->d_ino);

                    tde->d_off = tswapal(de->d_off);

                    memcpy(tde->d_name, de->d_name, tnamelen);

                    de = (struct linux_dirent *)((char *)de + reclen);

                    len -= reclen;

                    tde = (struct target_dirent *)((char *)tde + treclen);

		    count1 += treclen;

                }

		ret = count1;

                unlock_user(target_dirp, arg2, ret);

            }

	    free(dirp);

        }

#else

        {

            struct linux_dirent *dirp;

            abi_long count = arg3;



            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))

                goto efault;

            ret = get_errno(sys_getdents(arg1, dirp, count));

            if (!is_error(ret)) {

                struct linux_dirent *de;

                int len = ret;

                int reclen;

                de = dirp;

                while (len > 0) {

                    reclen = de->d_reclen;

                    if (reclen > len)

                        break;

                    de->d_reclen = tswap16(reclen);

                    tswapls(&de->d_ino);

                    tswapls(&de->d_off);

                    de = (struct linux_dirent *)((char *)de + reclen);

                    len -= reclen;

                }

            }

            unlock_user(dirp, arg2, ret);

        }

#endif

#else

        /* Implement getdents in terms of getdents64 */

        {

            struct linux_dirent64 *dirp;

            abi_long count = arg3;



            dirp = lock_user(VERIFY_WRITE, arg2, count, 0);

            if (!dirp) {

                goto efault;

            }

            ret = get_errno(sys_getdents64(arg1, dirp, count));

            if (!is_error(ret)) {

                /* Convert the dirent64 structs to target dirent.  We do this

                 * in-place, since we can guarantee that a target_dirent is no

                 * larger than a dirent64; however this means we have to be

                 * careful to read everything before writing in the new format.

                 */

                struct linux_dirent64 *de;

                struct target_dirent *tde;

                int len = ret;

                int tlen = 0;



                de = dirp;

                tde = (struct target_dirent *)dirp;

                while (len > 0) {

                    int namelen, treclen;

                    int reclen = de->d_reclen;

                    uint64_t ino = de->d_ino;

                    int64_t off = de->d_off;

                    uint8_t type = de->d_type;



                    namelen = strlen(de->d_name);

                    treclen = offsetof(struct target_dirent, d_name)

                        + namelen + 2;

                    treclen = QEMU_ALIGN_UP(treclen, sizeof(abi_long));



                    memmove(tde->d_name, de->d_name, namelen + 1);

                    tde->d_ino = tswapal(ino);

                    tde->d_off = tswapal(off);

                    tde->d_reclen = tswap16(treclen);

                    /* The target_dirent type is in what was formerly a padding

                     * byte at the end of the structure:

                     */

                    *(((char *)tde) + treclen - 1) = type;



                    de = (struct linux_dirent64 *)((char *)de + reclen);

                    tde = (struct target_dirent *)((char *)tde + treclen);

                    len -= reclen;

                    tlen += treclen;

                }

                ret = tlen;

            }

            unlock_user(dirp, arg2, ret);

        }

#endif

        break;

#if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)

    case TARGET_NR_getdents64:

        {

            struct linux_dirent64 *dirp;

            abi_long count = arg3;

            if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))

                goto efault;

            ret = get_errno(sys_getdents64(arg1, dirp, count));

            if (!is_error(ret)) {

                struct linux_dirent64 *de;

                int len = ret;

                int reclen;

                de = dirp;

                while (len > 0) {

                    reclen = de->d_reclen;

                    if (reclen > len)

                        break;

                    de->d_reclen = tswap16(reclen);

                    tswap64s((uint64_t *)&de->d_ino);

                    tswap64s((uint64_t *)&de->d_off);

                    de = (struct linux_dirent64 *)((char *)de + reclen);

                    len -= reclen;

                }

            }

            unlock_user(dirp, arg2, ret);

        }

        break;

#endif /* TARGET_NR_getdents64 */

#if defined(TARGET_NR__newselect)

    case TARGET_NR__newselect:

        ret = do_select(arg1, arg2, arg3, arg4, arg5);

        break;

#endif

#if defined(TARGET_NR_poll) || defined(TARGET_NR_ppoll)

# ifdef TARGET_NR_poll

    case TARGET_NR_poll:

# endif

# ifdef TARGET_NR_ppoll

    case TARGET_NR_ppoll:

# endif

        {

            struct target_pollfd *target_pfd;

            unsigned int nfds = arg2;

            int timeout = arg3;

            struct pollfd *pfd;

            unsigned int i;



            target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);

            if (!target_pfd)

                goto efault;



            pfd = alloca(sizeof(struct pollfd) * nfds);

            for(i = 0; i < nfds; i++) {

                pfd[i].fd = tswap32(target_pfd[i].fd);

                pfd[i].events = tswap16(target_pfd[i].events);

            }



# ifdef TARGET_NR_ppoll

            if (num == TARGET_NR_ppoll) {

                struct timespec _timeout_ts, *timeout_ts = &_timeout_ts;

                target_sigset_t *target_set;

                sigset_t _set, *set = &_set;



                if (arg3) {

                    if (target_to_host_timespec(timeout_ts, arg3)) {

                        unlock_user(target_pfd, arg1, 0);

                        goto efault;

                    }

                } else {

                    timeout_ts = NULL;

                }



                if (arg4) {

                    target_set = lock_user(VERIFY_READ, arg4, sizeof(target_sigset_t), 1);

                    if (!target_set) {

                        unlock_user(target_pfd, arg1, 0);

                        goto efault;

                    }

                    target_to_host_sigset(set, target_set);

                } else {

                    set = NULL;

                }



                ret = get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8));



                if (!is_error(ret) && arg3) {

                    host_to_target_timespec(arg3, timeout_ts);

                }

                if (arg4) {

                    unlock_user(target_set, arg4, 0);

                }

            } else

# endif

                ret = get_errno(poll(pfd, nfds, timeout));



            if (!is_error(ret)) {

                for(i = 0; i < nfds; i++) {

                    target_pfd[i].revents = tswap16(pfd[i].revents);

                }

            }

            unlock_user(target_pfd, arg1, sizeof(struct target_pollfd) * nfds);

        }

        break;

#endif

    case TARGET_NR_flock:

        /* NOTE: the flock constant seems to be the same for every

           Linux platform */

        ret = get_errno(flock(arg1, arg2));

        break;

    case TARGET_NR_readv:

        {

            struct iovec *vec = lock_iovec(VERIFY_WRITE, arg2, arg3, 0);

            if (vec != NULL) {

                ret = get_errno(readv(arg1, vec, arg3));

                unlock_iovec(vec, arg2, arg3, 1);

            } else {

                ret = -host_to_target_errno(errno);

            }

        }

        break;

    case TARGET_NR_writev:

        {

            struct iovec *vec = lock_iovec(VERIFY_READ, arg2, arg3, 1);

            if (vec != NULL) {

                ret = get_errno(writev(arg1, vec, arg3));

                unlock_iovec(vec, arg2, arg3, 0);

            } else {

                ret = -host_to_target_errno(errno);

            }

        }

        break;

    case TARGET_NR_getsid:

        ret = get_errno(getsid(arg1));

        break;

#if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */

    case TARGET_NR_fdatasync:

        ret = get_errno(fdatasync(arg1));

        break;

#endif

    case TARGET_NR__sysctl:

        /* We don't implement this, but ENOTDIR is always a safe

           return value. */

        ret = -TARGET_ENOTDIR;

        break;

    case TARGET_NR_sched_getaffinity:

        {

            unsigned int mask_size;

            unsigned long *mask;



            /*

             * sched_getaffinity needs multiples of ulong, so need to take

             * care of mismatches between target ulong and host ulong sizes.

             */

            if (arg2 & (sizeof(abi_ulong) - 1)) {

                ret = -TARGET_EINVAL;

                break;

            }

            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);



            mask = alloca(mask_size);

            ret = get_errno(sys_sched_getaffinity(arg1, mask_size, mask));



            if (!is_error(ret)) {

                if (copy_to_user(arg3, mask, ret)) {

                    goto efault;

                }

            }

        }

        break;

    case TARGET_NR_sched_setaffinity:

        {

            unsigned int mask_size;

            unsigned long *mask;



            /*

             * sched_setaffinity needs multiples of ulong, so need to take

             * care of mismatches between target ulong and host ulong sizes.

             */

            if (arg2 & (sizeof(abi_ulong) - 1)) {

                ret = -TARGET_EINVAL;

                break;

            }

            mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);



            mask = alloca(mask_size);

            if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {

                goto efault;

            }

            memcpy(mask, p, arg2);

            unlock_user_struct(p, arg2, 0);



            ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));

        }

        break;

    case TARGET_NR_sched_setparam:

        {

            struct sched_param *target_schp;

            struct sched_param schp;



            if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))

                goto efault;

            schp.sched_priority = tswap32(target_schp->sched_priority);

            unlock_user_struct(target_schp, arg2, 0);

            ret = get_errno(sched_setparam(arg1, &schp));

        }

        break;

    case TARGET_NR_sched_getparam:

        {

            struct sched_param *target_schp;

            struct sched_param schp;

            ret = get_errno(sched_getparam(arg1, &schp));

            if (!is_error(ret)) {

                if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))

                    goto efault;

                target_schp->sched_priority = tswap32(schp.sched_priority);

                unlock_user_struct(target_schp, arg2, 1);

            }

        }

        break;

    case TARGET_NR_sched_setscheduler:

        {

            struct sched_param *target_schp;

            struct sched_param schp;

            if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))

                goto efault;

            schp.sched_priority = tswap32(target_schp->sched_priority);

            unlock_user_struct(target_schp, arg3, 0);

            ret = get_errno(sched_setscheduler(arg1, arg2, &schp));

        }

        break;

    case TARGET_NR_sched_getscheduler:

        ret = get_errno(sched_getscheduler(arg1));

        break;

    case TARGET_NR_sched_yield:

        ret = get_errno(sched_yield());

        break;

    case TARGET_NR_sched_get_priority_max:

        ret = get_errno(sched_get_priority_max(arg1));

        break;

    case TARGET_NR_sched_get_priority_min:

        ret = get_errno(sched_get_priority_min(arg1));

        break;

    case TARGET_NR_sched_rr_get_interval:

        {

            struct timespec ts;

            ret = get_errno(sched_rr_get_interval(arg1, &ts));

            if (!is_error(ret)) {

                host_to_target_timespec(arg2, &ts);

            }

        }

        break;

    case TARGET_NR_nanosleep:

        {

            struct timespec req, rem;

            target_to_host_timespec(&req, arg1);

            ret = get_errno(nanosleep(&req, &rem));

            if (is_error(ret) && arg2) {

                host_to_target_timespec(arg2, &rem);

            }

        }

        break;

#ifdef TARGET_NR_query_module

    case TARGET_NR_query_module:

        goto unimplemented;

#endif

#ifdef TARGET_NR_nfsservctl

    case TARGET_NR_nfsservctl:

        goto unimplemented;

#endif

    case TARGET_NR_prctl:

        switch (arg1) {

        case PR_GET_PDEATHSIG:

        {

            int deathsig;

            ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));

            if (!is_error(ret) && arg2

                && put_user_ual(deathsig, arg2)) {

                goto efault;

            }

            break;

        }

#ifdef PR_GET_NAME

        case PR_GET_NAME:

        {

            void *name = lock_user(VERIFY_WRITE, arg2, 16, 1);

            if (!name) {

                goto efault;

            }

            ret = get_errno(prctl(arg1, (unsigned long)name,

                                  arg3, arg4, arg5));

            unlock_user(name, arg2, 16);

            break;

        }

        case PR_SET_NAME:

        {

            void *name = lock_user(VERIFY_READ, arg2, 16, 1);

            if (!name) {

                goto efault;

            }

            ret = get_errno(prctl(arg1, (unsigned long)name,

                                  arg3, arg4, arg5));

            unlock_user(name, arg2, 0);

            break;

        }

#endif

        default:

            /* Most prctl options have no pointer arguments */

            ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));

            break;

        }

        break;

#ifdef TARGET_NR_arch_prctl

    case TARGET_NR_arch_prctl:

#if defined(TARGET_I386) && !defined(TARGET_ABI32)

        ret = do_arch_prctl(cpu_env, arg1, arg2);

        break;

#else

        goto unimplemented;

#endif

#endif

#ifdef TARGET_NR_pread64

    case TARGET_NR_pread64:

        if (regpairs_aligned(cpu_env)) {

            arg4 = arg5;

            arg5 = arg6;

        }

        if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))

            goto efault;

        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));

        unlock_user(p, arg2, ret);

        break;

    case TARGET_NR_pwrite64:

        if (regpairs_aligned(cpu_env)) {

            arg4 = arg5;

            arg5 = arg6;

        }

        if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))

            goto efault;

        ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));

        unlock_user(p, arg2, 0);

        break;

#endif

    case TARGET_NR_getcwd:

        if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))

            goto efault;

        ret = get_errno(sys_getcwd1(p, arg2));

        unlock_user(p, arg1, ret);

        break;

    case TARGET_NR_capget:

        goto unimplemented;

    case TARGET_NR_capset:

        goto unimplemented;

    case TARGET_NR_sigaltstack:

#if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \

    defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \

    defined(TARGET_M68K) || defined(TARGET_S390X) || defined(TARGET_OPENRISC)

        ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUArchState *)cpu_env));

        break;

#else

        goto unimplemented;

#endif



#ifdef CONFIG_SENDFILE

    case TARGET_NR_sendfile:

    {

        off_t *offp = NULL;

        off_t off;

        if (arg3) {

            ret = get_user_sal(off, arg3);

            if (is_error(ret)) {

                break;

            }

            offp = &off;

        }

        ret = get_errno(sendfile(arg1, arg2, offp, arg4));

        if (!is_error(ret) && arg3) {

            abi_long ret2 = put_user_sal(off, arg3);

            if (is_error(ret2)) {

                ret = ret2;

            }

        }

        break;

    }

#ifdef TARGET_NR_sendfile64

    case TARGET_NR_sendfile64:

    {

        off_t *offp = NULL;

        off_t off;

        if (arg3) {

            ret = get_user_s64(off, arg3);

            if (is_error(ret)) {

                break;

            }

            offp = &off;

        }

        ret = get_errno(sendfile(arg1, arg2, offp, arg4));

        if (!is_error(ret) && arg3) {

            abi_long ret2 = put_user_s64(off, arg3);

            if (is_error(ret2)) {

                ret = ret2;

            }

        }

        break;

    }

#endif

#else

    case TARGET_NR_sendfile:

#ifdef TARGET_NR_sendfile64

    case TARGET_NR_sendfile64:

#endif

        goto unimplemented;

#endif



#ifdef TARGET_NR_getpmsg

    case TARGET_NR_getpmsg:

        goto unimplemented;

#endif

#ifdef TARGET_NR_putpmsg

    case TARGET_NR_putpmsg:

        goto unimplemented;

#endif

#ifdef TARGET_NR_vfork

    case TARGET_NR_vfork:

        ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,

                        0, 0, 0, 0));

        break;

#endif

#ifdef TARGET_NR_ugetrlimit

    case TARGET_NR_ugetrlimit:

    {

	struct rlimit rlim;

	int resource = target_to_host_resource(arg1);

	ret = get_errno(getrlimit(resource, &rlim));

	if (!is_error(ret)) {

	    struct target_rlimit *target_rlim;

            if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))

                goto efault;

	    target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);

	    target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);

            unlock_user_struct(target_rlim, arg2, 1);

	}

	break;

    }

#endif

#ifdef TARGET_NR_truncate64

    case TARGET_NR_truncate64:

        if (!(p = lock_user_string(arg1)))

            goto efault;

	ret = target_truncate64(cpu_env, p, arg2, arg3, arg4);

        unlock_user(p, arg1, 0);

	break;

#endif

#ifdef TARGET_NR_ftruncate64

    case TARGET_NR_ftruncate64:

	ret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);

	break;

#endif

#ifdef TARGET_NR_stat64

    case TARGET_NR_stat64:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(stat(path(p), &st));

        unlock_user(p, arg1, 0);

        if (!is_error(ret))

            ret = host_to_target_stat64(cpu_env, arg2, &st);

        break;

#endif

#ifdef TARGET_NR_lstat64

    case TARGET_NR_lstat64:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(lstat(path(p), &st));

        unlock_user(p, arg1, 0);

        if (!is_error(ret))

            ret = host_to_target_stat64(cpu_env, arg2, &st);

        break;

#endif

#ifdef TARGET_NR_fstat64

    case TARGET_NR_fstat64:

        ret = get_errno(fstat(arg1, &st));

        if (!is_error(ret))

            ret = host_to_target_stat64(cpu_env, arg2, &st);

        break;

#endif

#if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat))

#ifdef TARGET_NR_fstatat64

    case TARGET_NR_fstatat64:

#endif

#ifdef TARGET_NR_newfstatat

    case TARGET_NR_newfstatat:

#endif

        if (!(p = lock_user_string(arg2)))

            goto efault;

        ret = get_errno(fstatat(arg1, path(p), &st, arg4));

        if (!is_error(ret))

            ret = host_to_target_stat64(cpu_env, arg3, &st);

        break;

#endif

    case TARGET_NR_lchown:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));

        unlock_user(p, arg1, 0);

        break;

#ifdef TARGET_NR_getuid

    case TARGET_NR_getuid:

        ret = get_errno(high2lowuid(getuid()));

        break;

#endif

#ifdef TARGET_NR_getgid

    case TARGET_NR_getgid:

        ret = get_errno(high2lowgid(getgid()));

        break;

#endif

#ifdef TARGET_NR_geteuid

    case TARGET_NR_geteuid:

        ret = get_errno(high2lowuid(geteuid()));

        break;

#endif

#ifdef TARGET_NR_getegid

    case TARGET_NR_getegid:

        ret = get_errno(high2lowgid(getegid()));

        break;

#endif

    case TARGET_NR_setreuid:

        ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));

        break;

    case TARGET_NR_setregid:

        ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));

        break;

    case TARGET_NR_getgroups:

        {

            int gidsetsize = arg1;

            target_id *target_grouplist;

            gid_t *grouplist;

            int i;



            grouplist = alloca(gidsetsize * sizeof(gid_t));

            ret = get_errno(getgroups(gidsetsize, grouplist));

            if (gidsetsize == 0)

                break;

            if (!is_error(ret)) {

                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * sizeof(target_id), 0);

                if (!target_grouplist)

                    goto efault;

                for(i = 0;i < ret; i++)

                    target_grouplist[i] = tswapid(high2lowgid(grouplist[i]));

                unlock_user(target_grouplist, arg2, gidsetsize * sizeof(target_id));

            }

        }

        break;

    case TARGET_NR_setgroups:

        {

            int gidsetsize = arg1;

            target_id *target_grouplist;

            gid_t *grouplist = NULL;

            int i;

            if (gidsetsize) {

                grouplist = alloca(gidsetsize * sizeof(gid_t));

                target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * sizeof(target_id), 1);

                if (!target_grouplist) {

                    ret = -TARGET_EFAULT;

                    goto fail;

                }

                for (i = 0; i < gidsetsize; i++) {

                    grouplist[i] = low2highgid(tswapid(target_grouplist[i]));

                }

                unlock_user(target_grouplist, arg2, 0);

            }

            ret = get_errno(setgroups(gidsetsize, grouplist));

        }

        break;

    case TARGET_NR_fchown:

        ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));

        break;

#if defined(TARGET_NR_fchownat)

    case TARGET_NR_fchownat:

        if (!(p = lock_user_string(arg2))) 

            goto efault;

        ret = get_errno(fchownat(arg1, p, low2highuid(arg3),

                                 low2highgid(arg4), arg5));

        unlock_user(p, arg2, 0);

        break;

#endif

#ifdef TARGET_NR_setresuid

    case TARGET_NR_setresuid:

        ret = get_errno(setresuid(low2highuid(arg1),

                                  low2highuid(arg2),

                                  low2highuid(arg3)));

        break;

#endif

#ifdef TARGET_NR_getresuid

    case TARGET_NR_getresuid:

        {

            uid_t ruid, euid, suid;

            ret = get_errno(getresuid(&ruid, &euid, &suid));

            if (!is_error(ret)) {

                if (put_user_id(high2lowuid(ruid), arg1)

                    || put_user_id(high2lowuid(euid), arg2)

                    || put_user_id(high2lowuid(suid), arg3))

                    goto efault;

            }

        }

        break;

#endif

#ifdef TARGET_NR_getresgid

    case TARGET_NR_setresgid:

        ret = get_errno(setresgid(low2highgid(arg1),

                                  low2highgid(arg2),

                                  low2highgid(arg3)));

        break;

#endif

#ifdef TARGET_NR_getresgid

    case TARGET_NR_getresgid:

        {

            gid_t rgid, egid, sgid;

            ret = get_errno(getresgid(&rgid, &egid, &sgid));

            if (!is_error(ret)) {

                if (put_user_id(high2lowgid(rgid), arg1)

                    || put_user_id(high2lowgid(egid), arg2)

                    || put_user_id(high2lowgid(sgid), arg3))

                    goto efault;

            }

        }

        break;

#endif

    case TARGET_NR_chown:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));

        unlock_user(p, arg1, 0);

        break;

    case TARGET_NR_setuid:

        ret = get_errno(setuid(low2highuid(arg1)));

        break;

    case TARGET_NR_setgid:

        ret = get_errno(setgid(low2highgid(arg1)));

        break;

    case TARGET_NR_setfsuid:

        ret = get_errno(setfsuid(arg1));

        break;

    case TARGET_NR_setfsgid:

        ret = get_errno(setfsgid(arg1));

        break;



#ifdef TARGET_NR_lchown32

    case TARGET_NR_lchown32:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(lchown(p, arg2, arg3));

        unlock_user(p, arg1, 0);

        break;

#endif

#ifdef TARGET_NR_getuid32

    case TARGET_NR_getuid32:

        ret = get_errno(getuid());

        break;

#endif



#if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)

   /* Alpha specific */

    case TARGET_NR_getxuid:

         {

            uid_t euid;

            euid=geteuid();

            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;

         }

        ret = get_errno(getuid());

        break;

#endif

#if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)

   /* Alpha specific */

    case TARGET_NR_getxgid:

         {

            uid_t egid;

            egid=getegid();

            ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;

         }

        ret = get_errno(getgid());

        break;

#endif

#if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)

    /* Alpha specific */

    case TARGET_NR_osf_getsysinfo:

        ret = -TARGET_EOPNOTSUPP;

        switch (arg1) {

          case TARGET_GSI_IEEE_FP_CONTROL:

            {

                uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);



                /* Copied from linux ieee_fpcr_to_swcr.  */

                swcr = (fpcr >> 35) & SWCR_STATUS_MASK;

                swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;

                swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV

                                        | SWCR_TRAP_ENABLE_DZE

                                        | SWCR_TRAP_ENABLE_OVF);

                swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF

                                        | SWCR_TRAP_ENABLE_INE);

                swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;

                swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;



                if (put_user_u64 (swcr, arg2))

                        goto efault;


            }

            break;



          /* case GSI_IEEE_STATE_AT_SIGNAL:

             -- Not implemented in linux kernel.

             case GSI_UACPROC:

             -- Retrieves current unaligned access state; not much used.

             case GSI_PROC_TYPE:

             -- Retrieves implver information; surely not used.

             case GSI_GET_HWRPB:

             -- Grabs a copy of the HWRPB; surely not used.

          */

        }

        break;

#endif

#if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)

    /* Alpha specific */

    case TARGET_NR_osf_setsysinfo:

        ret = -TARGET_EOPNOTSUPP;

        switch (arg1) {

          case TARGET_SSI_IEEE_FP_CONTROL:

            {

                uint64_t swcr, fpcr, orig_fpcr;



                if (get_user_u64 (swcr, arg2)) {

                    goto efault;

                }

                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);

                fpcr = orig_fpcr & FPCR_DYN_MASK;



                /* Copied from linux ieee_swcr_to_fpcr.  */

                fpcr |= (swcr & SWCR_STATUS_MASK) << 35;

                fpcr |= (swcr & SWCR_MAP_DMZ) << 36;

                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV

                                  | SWCR_TRAP_ENABLE_DZE

                                  | SWCR_TRAP_ENABLE_OVF)) << 48;

                fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF

                                  | SWCR_TRAP_ENABLE_INE)) << 57;

                fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);

                fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;



                cpu_alpha_store_fpcr(cpu_env, fpcr);


            }

            break;



          case TARGET_SSI_IEEE_RAISE_EXCEPTION:

            {

                uint64_t exc, fpcr, orig_fpcr;

                int si_code;



                if (get_user_u64(exc, arg2)) {

                    goto efault;

                }



                orig_fpcr = cpu_alpha_load_fpcr(cpu_env);



                /* We only add to the exception status here.  */

                fpcr = orig_fpcr | ((exc & SWCR_STATUS_MASK) << 35);



                cpu_alpha_store_fpcr(cpu_env, fpcr);




                /* Old exceptions are not signaled.  */

                fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);



                /* If any exceptions set by this call,

                   and are unmasked, send a signal.  */

                si_code = 0;

                if ((fpcr & (FPCR_INE | FPCR_INED)) == FPCR_INE) {

                    si_code = TARGET_FPE_FLTRES;

                }

                if ((fpcr & (FPCR_UNF | FPCR_UNFD)) == FPCR_UNF) {

                    si_code = TARGET_FPE_FLTUND;

                }

                if ((fpcr & (FPCR_OVF | FPCR_OVFD)) == FPCR_OVF) {

                    si_code = TARGET_FPE_FLTOVF;

                }

                if ((fpcr & (FPCR_DZE | FPCR_DZED)) == FPCR_DZE) {

                    si_code = TARGET_FPE_FLTDIV;

                }

                if ((fpcr & (FPCR_INV | FPCR_INVD)) == FPCR_INV) {

                    si_code = TARGET_FPE_FLTINV;

                }

                if (si_code != 0) {

                    target_siginfo_t info;

                    info.si_signo = SIGFPE;

                    info.si_errno = 0;

                    info.si_code = si_code;

                    info._sifields._sigfault._addr

                        = ((CPUArchState *)cpu_env)->pc;

                    queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);

                }

            }

            break;



          /* case SSI_NVPAIRS:

             -- Used with SSIN_UACPROC to enable unaligned accesses.

             case SSI_IEEE_STATE_AT_SIGNAL:

             case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:

             -- Not implemented in linux kernel

          */

        }

        break;

#endif

#ifdef TARGET_NR_osf_sigprocmask

    /* Alpha specific.  */

    case TARGET_NR_osf_sigprocmask:

        {

            abi_ulong mask;

            int how;

            sigset_t set, oldset;



            switch(arg1) {

            case TARGET_SIG_BLOCK:

                how = SIG_BLOCK;

                break;

            case TARGET_SIG_UNBLOCK:

                how = SIG_UNBLOCK;

                break;

            case TARGET_SIG_SETMASK:

                how = SIG_SETMASK;

                break;

            default:

                ret = -TARGET_EINVAL;

                goto fail;

            }

            mask = arg2;

            target_to_host_old_sigset(&set, &mask);

            sigprocmask(how, &set, &oldset);

            host_to_target_old_sigset(&mask, &oldset);

            ret = mask;

        }

        break;

#endif



#ifdef TARGET_NR_getgid32

    case TARGET_NR_getgid32:

        ret = get_errno(getgid());

        break;

#endif

#ifdef TARGET_NR_geteuid32

    case TARGET_NR_geteuid32:

        ret = get_errno(geteuid());

        break;

#endif

#ifdef TARGET_NR_getegid32

    case TARGET_NR_getegid32:

        ret = get_errno(getegid());

        break;

#endif

#ifdef TARGET_NR_setreuid32

    case TARGET_NR_setreuid32:

        ret = get_errno(setreuid(arg1, arg2));

        break;

#endif

#ifdef TARGET_NR_setregid32

    case TARGET_NR_setregid32:

        ret = get_errno(setregid(arg1, arg2));

        break;

#endif

#ifdef TARGET_NR_getgroups32

    case TARGET_NR_getgroups32:

        {

            int gidsetsize = arg1;

            uint32_t *target_grouplist;

            gid_t *grouplist;

            int i;



            grouplist = alloca(gidsetsize * sizeof(gid_t));

            ret = get_errno(getgroups(gidsetsize, grouplist));

            if (gidsetsize == 0)

                break;

            if (!is_error(ret)) {

                target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);

                if (!target_grouplist) {

                    ret = -TARGET_EFAULT;

                    goto fail;

                }

                for(i = 0;i < ret; i++)

                    target_grouplist[i] = tswap32(grouplist[i]);

                unlock_user(target_grouplist, arg2, gidsetsize * 4);

            }

        }

        break;

#endif

#ifdef TARGET_NR_setgroups32

    case TARGET_NR_setgroups32:

        {

            int gidsetsize = arg1;

            uint32_t *target_grouplist;

            gid_t *grouplist;

            int i;



            grouplist = alloca(gidsetsize * sizeof(gid_t));

            target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);

            if (!target_grouplist) {

                ret = -TARGET_EFAULT;

                goto fail;

            }

            for(i = 0;i < gidsetsize; i++)

                grouplist[i] = tswap32(target_grouplist[i]);

            unlock_user(target_grouplist, arg2, 0);

            ret = get_errno(setgroups(gidsetsize, grouplist));

        }

        break;

#endif

#ifdef TARGET_NR_fchown32

    case TARGET_NR_fchown32:

        ret = get_errno(fchown(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_setresuid32

    case TARGET_NR_setresuid32:

        ret = get_errno(setresuid(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_getresuid32

    case TARGET_NR_getresuid32:

        {

            uid_t ruid, euid, suid;

            ret = get_errno(getresuid(&ruid, &euid, &suid));

            if (!is_error(ret)) {

                if (put_user_u32(ruid, arg1)

                    || put_user_u32(euid, arg2)

                    || put_user_u32(suid, arg3))

                    goto efault;

            }

        }

        break;

#endif

#ifdef TARGET_NR_setresgid32

    case TARGET_NR_setresgid32:

        ret = get_errno(setresgid(arg1, arg2, arg3));

        break;

#endif

#ifdef TARGET_NR_getresgid32

    case TARGET_NR_getresgid32:

        {

            gid_t rgid, egid, sgid;

            ret = get_errno(getresgid(&rgid, &egid, &sgid));

            if (!is_error(ret)) {

                if (put_user_u32(rgid, arg1)

                    || put_user_u32(egid, arg2)

                    || put_user_u32(sgid, arg3))

                    goto efault;

            }

        }

        break;

#endif

#ifdef TARGET_NR_chown32

    case TARGET_NR_chown32:

        if (!(p = lock_user_string(arg1)))

            goto efault;

        ret = get_errno(chown(p, arg2, arg3));

        unlock_user(p, arg1, 0);

        break;

#endif

#ifdef TARGET_NR_setuid32

    case TARGET_NR_setuid32:

        ret = get_errno(setuid(arg1));

        break;

#endif

#ifdef TARGET_NR_setgid32

    case TARGET_NR_setgid32:

        ret = get_errno(setgid(arg1));

        break;

#endif

#ifdef TARGET_NR_setfsuid32

    case TARGET_NR_setfsuid32:

        ret = get_errno(setfsuid(arg1));

        break;

#endif

#ifdef TARGET_NR_setfsgid32

    case TARGET_NR_setfsgid32:

        ret = get_errno(setfsgid(arg1));

        break;

#endif



    case TARGET_NR_pivot_root:

        goto unimplemented;

#ifdef TARGET_NR_mincore

    case TARGET_NR_mincore:

        {

            void *a;

            ret = -TARGET_EFAULT;

            if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))

                goto efault;

            if (!(p = lock_user_string(arg3)))

                goto mincore_fail;

            ret = get_errno(mincore(a, arg2, p));

            unlock_user(p, arg3, ret);

            mincore_fail:

            unlock_user(a, arg1, 0);

        }

        break;

#endif

#ifdef TARGET_NR_arm_fadvise64_64

    case TARGET_NR_arm_fadvise64_64:

	{

		/*

		 * arm_fadvise64_64 looks like fadvise64_64 but

		 * with different argument order

		 */

		abi_long temp;

		temp = arg3;

		arg3 = arg4;

		arg4 = temp;

	}

#endif

#if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)

#ifdef TARGET_NR_fadvise64_64

    case TARGET_NR_fadvise64_64:

#endif

#ifdef TARGET_NR_fadvise64

    case TARGET_NR_fadvise64:

#endif

#ifdef TARGET_S390X

        switch (arg4) {

        case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */

        case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */

        case 6: arg4 = POSIX_FADV_DONTNEED; break;

        case 7: arg4 = POSIX_FADV_NOREUSE; break;

        default: break;

        }

#endif

        ret = -posix_fadvise(arg1, arg2, arg3, arg4);

	break;

#endif

#ifdef TARGET_NR_madvise

    case TARGET_NR_madvise:

        /* A straight passthrough may not be safe because qemu sometimes

           turns private file-backed mappings into anonymous mappings.

           This will break MADV_DONTNEED.

           This is a hint, so ignoring and returning success is ok.  */

        ret = get_errno(0);

        break;

#endif

#if TARGET_ABI_BITS == 32

    case TARGET_NR_fcntl64:

    {

	int cmd;

	struct flock64 fl;

	struct target_flock64 *target_fl;

#ifdef TARGET_ARM

	struct target_eabi_flock64 *target_efl;

#endif



	cmd = target_to_host_fcntl_cmd(arg2);

        if (cmd == -TARGET_EINVAL) {

            ret = cmd;

            break;

        }



        switch(arg2) {

        case TARGET_F_GETLK64:

#ifdef TARGET_ARM

            if (((CPUARMState *)cpu_env)->eabi) {

                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) 

                    goto efault;

                fl.l_type = tswap16(target_efl->l_type);

                fl.l_whence = tswap16(target_efl->l_whence);

                fl.l_start = tswap64(target_efl->l_start);

                fl.l_len = tswap64(target_efl->l_len);

                fl.l_pid = tswap32(target_efl->l_pid);

                unlock_user_struct(target_efl, arg3, 0);

            } else

#endif

            {

                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) 

                    goto efault;

                fl.l_type = tswap16(target_fl->l_type);

                fl.l_whence = tswap16(target_fl->l_whence);

                fl.l_start = tswap64(target_fl->l_start);

                fl.l_len = tswap64(target_fl->l_len);

                fl.l_pid = tswap32(target_fl->l_pid);

                unlock_user_struct(target_fl, arg3, 0);

            }

            ret = get_errno(fcntl(arg1, cmd, &fl));

	    if (ret == 0) {

#ifdef TARGET_ARM

                if (((CPUARMState *)cpu_env)->eabi) {

                    if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0)) 

                        goto efault;

                    target_efl->l_type = tswap16(fl.l_type);

                    target_efl->l_whence = tswap16(fl.l_whence);

                    target_efl->l_start = tswap64(fl.l_start);

                    target_efl->l_len = tswap64(fl.l_len);

                    target_efl->l_pid = tswap32(fl.l_pid);

                    unlock_user_struct(target_efl, arg3, 1);

                } else

#endif

                {

                    if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0)) 

                        goto efault;

                    target_fl->l_type = tswap16(fl.l_type);

                    target_fl->l_whence = tswap16(fl.l_whence);

                    target_fl->l_start = tswap64(fl.l_start);

                    target_fl->l_len = tswap64(fl.l_len);

                    target_fl->l_pid = tswap32(fl.l_pid);

                    unlock_user_struct(target_fl, arg3, 1);

                }

	    }

	    break;



        case TARGET_F_SETLK64:

        case TARGET_F_SETLKW64:

#ifdef TARGET_ARM

            if (((CPUARMState *)cpu_env)->eabi) {

                if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1)) 

                    goto efault;

                fl.l_type = tswap16(target_efl->l_type);

                fl.l_whence = tswap16(target_efl->l_whence);

                fl.l_start = tswap64(target_efl->l_start);

                fl.l_len = tswap64(target_efl->l_len);

                fl.l_pid = tswap32(target_efl->l_pid);

                unlock_user_struct(target_efl, arg3, 0);

            } else

#endif

            {

                if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1)) 

                    goto efault;

                fl.l_type = tswap16(target_fl->l_type);

                fl.l_whence = tswap16(target_fl->l_whence);

                fl.l_start = tswap64(target_fl->l_start);

                fl.l_len = tswap64(target_fl->l_len);

                fl.l_pid = tswap32(target_fl->l_pid);

                unlock_user_struct(target_fl, arg3, 0);

            }

            ret = get_errno(fcntl(arg1, cmd, &fl));

	    break;

        default:

            ret = do_fcntl(arg1, arg2, arg3);

            break;

        }

	break;

    }

#endif

#ifdef TARGET_NR_cacheflush

    case TARGET_NR_cacheflush:

        /* self-modifying code is handled automatically, so nothing needed */


        break;

#endif

#ifdef TARGET_NR_security

    case TARGET_NR_security:

        goto unimplemented;

#endif

#ifdef TARGET_NR_getpagesize

    case TARGET_NR_getpagesize:

        ret = TARGET_PAGE_SIZE;

        break;

#endif

    case TARGET_NR_gettid:

        ret = get_errno(gettid());

        break;

#ifdef TARGET_NR_readahead

    case TARGET_NR_readahead:

#if TARGET_ABI_BITS == 32

        if (regpairs_aligned(cpu_env)) {

            arg2 = arg3;

            arg3 = arg4;

            arg4 = arg5;

        }

        ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));

#else

        ret = get_errno(readahead(arg1, arg2, arg3));

#endif

        break;

#endif

#ifdef CONFIG_ATTR

#ifdef TARGET_NR_setxattr

    case TARGET_NR_listxattr:

    case TARGET_NR_llistxattr:

    {

        void *p, *b = 0;

        if (arg2) {

            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);

            if (!b) {

                ret = -TARGET_EFAULT;

                break;

            }

        }

        p = lock_user_string(arg1);

        if (p) {

            if (num == TARGET_NR_listxattr) {

                ret = get_errno(listxattr(p, b, arg3));

            } else {

                ret = get_errno(llistxattr(p, b, arg3));

            }

        } else {

            ret = -TARGET_EFAULT;

        }

        unlock_user(p, arg1, 0);

        unlock_user(b, arg2, arg3);

        break;

    }

    case TARGET_NR_flistxattr:

    {

        void *b = 0;

        if (arg2) {

            b = lock_user(VERIFY_WRITE, arg2, arg3, 0);

            if (!b) {

                ret = -TARGET_EFAULT;

                break;

            }

        }

        ret = get_errno(flistxattr(arg1, b, arg3));

        unlock_user(b, arg2, arg3);

        break;

    }

    case TARGET_NR_setxattr:

    case TARGET_NR_lsetxattr:

        {

            void *p, *n, *v = 0;

            if (arg3) {

                v = lock_user(VERIFY_READ, arg3, arg4, 1);

                if (!v) {

                    ret = -TARGET_EFAULT;

                    break;

                }

            }

            p = lock_user_string(arg1);

            n = lock_user_string(arg2);

            if (p && n) {

                if (num == TARGET_NR_setxattr) {

                    ret = get_errno(setxattr(p, n, v, arg4, arg5));

                } else {

                    ret = get_errno(lsetxattr(p, n, v, arg4, arg5));

                }

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(p, arg1, 0);

            unlock_user(n, arg2, 0);

            unlock_user(v, arg3, 0);

        }

        break;

    case TARGET_NR_fsetxattr:

        {

            void *n, *v = 0;

            if (arg3) {

                v = lock_user(VERIFY_READ, arg3, arg4, 1);

                if (!v) {

                    ret = -TARGET_EFAULT;

                    break;

                }

            }

            n = lock_user_string(arg2);

            if (n) {

                ret = get_errno(fsetxattr(arg1, n, v, arg4, arg5));

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(n, arg2, 0);

            unlock_user(v, arg3, 0);

        }

        break;

    case TARGET_NR_getxattr:

    case TARGET_NR_lgetxattr:

        {

            void *p, *n, *v = 0;

            if (arg3) {

                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);

                if (!v) {

                    ret = -TARGET_EFAULT;

                    break;

                }

            }

            p = lock_user_string(arg1);

            n = lock_user_string(arg2);

            if (p && n) {

                if (num == TARGET_NR_getxattr) {

                    ret = get_errno(getxattr(p, n, v, arg4));

                } else {

                    ret = get_errno(lgetxattr(p, n, v, arg4));

                }

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(p, arg1, 0);

            unlock_user(n, arg2, 0);

            unlock_user(v, arg3, arg4);

        }

        break;

    case TARGET_NR_fgetxattr:

        {

            void *n, *v = 0;

            if (arg3) {

                v = lock_user(VERIFY_WRITE, arg3, arg4, 0);

                if (!v) {

                    ret = -TARGET_EFAULT;

                    break;

                }

            }

            n = lock_user_string(arg2);

            if (n) {

                ret = get_errno(fgetxattr(arg1, n, v, arg4));

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(n, arg2, 0);

            unlock_user(v, arg3, arg4);

        }

        break;

    case TARGET_NR_removexattr:

    case TARGET_NR_lremovexattr:

        {

            void *p, *n;

            p = lock_user_string(arg1);

            n = lock_user_string(arg2);

            if (p && n) {

                if (num == TARGET_NR_removexattr) {

                    ret = get_errno(removexattr(p, n));

                } else {

                    ret = get_errno(lremovexattr(p, n));

                }

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(p, arg1, 0);

            unlock_user(n, arg2, 0);

        }

        break;

    case TARGET_NR_fremovexattr:

        {

            void *n;

            n = lock_user_string(arg2);

            if (n) {

                ret = get_errno(fremovexattr(arg1, n));

            } else {

                ret = -TARGET_EFAULT;

            }

            unlock_user(n, arg2, 0);

        }

        break;

#endif

#endif /* CONFIG_ATTR */

#ifdef TARGET_NR_set_thread_area

    case TARGET_NR_set_thread_area:

#if defined(TARGET_MIPS)

      ((CPUMIPSState *) cpu_env)->tls_value = arg1;


      break;

#elif defined(TARGET_CRIS)

      if (arg1 & 0xff)

          ret = -TARGET_EINVAL;

      else {

          ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;


      }

      break;

#elif defined(TARGET_I386) && defined(TARGET_ABI32)

      ret = do_set_thread_area(cpu_env, arg1);

      break;

#elif defined(TARGET_M68K)

      {

          TaskState *ts = cpu->opaque;

          ts->tp_value = arg1;


          break;

      }

#else

      goto unimplemented_nowarn;

#endif

#endif

#ifdef TARGET_NR_get_thread_area

    case TARGET_NR_get_thread_area:

#if defined(TARGET_I386) && defined(TARGET_ABI32)

        ret = do_get_thread_area(cpu_env, arg1);

        break;

#elif defined(TARGET_M68K)

        {

            TaskState *ts = cpu->opaque;

            ret = ts->tp_value;

            break;

        }

#else

        goto unimplemented_nowarn;

#endif

#endif

#ifdef TARGET_NR_getdomainname

    case TARGET_NR_getdomainname:

        goto unimplemented_nowarn;

#endif



#ifdef TARGET_NR_clock_gettime

    case TARGET_NR_clock_gettime:

    {

        struct timespec ts;

        ret = get_errno(clock_gettime(arg1, &ts));

        if (!is_error(ret)) {

            host_to_target_timespec(arg2, &ts);

        }

        break;

    }

#endif

#ifdef TARGET_NR_clock_getres

    case TARGET_NR_clock_getres:

    {

        struct timespec ts;

        ret = get_errno(clock_getres(arg1, &ts));

        if (!is_error(ret)) {

            host_to_target_timespec(arg2, &ts);

        }

        break;

    }

#endif

#ifdef TARGET_NR_clock_nanosleep

    case TARGET_NR_clock_nanosleep:

    {

        struct timespec ts;

        target_to_host_timespec(&ts, arg3);

        ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));

        if (arg4)

            host_to_target_timespec(arg4, &ts);

        break;

    }

#endif



#if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)

    case TARGET_NR_set_tid_address:

        ret = get_errno(set_tid_address((int *)g2h(arg1)));

        break;

#endif



#if defined(TARGET_NR_tkill) && defined(__NR_tkill)

    case TARGET_NR_tkill:

        ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));

        break;

#endif



#if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)

    case TARGET_NR_tgkill:

	ret = get_errno(sys_tgkill((int)arg1, (int)arg2,

                        target_to_host_signal(arg3)));

	break;

#endif



#ifdef TARGET_NR_set_robust_list

    case TARGET_NR_set_robust_list:

    case TARGET_NR_get_robust_list:

        /* The ABI for supporting robust futexes has userspace pass

         * the kernel a pointer to a linked list which is updated by

         * userspace after the syscall; the list is walked by the kernel

         * when the thread exits. Since the linked list in QEMU guest

         * memory isn't a valid linked list for the host and we have

         * no way to reliably intercept the thread-death event, we can't

         * support these. Silently return ENOSYS so that guest userspace

         * falls back to a non-robust futex implementation (which should

         * be OK except in the corner case of the guest crashing while

         * holding a mutex that is shared with another process via

         * shared memory).

         */

        goto unimplemented_nowarn;

#endif



#if defined(TARGET_NR_utimensat)

    case TARGET_NR_utimensat:

        {

            struct timespec *tsp, ts[2];

            if (!arg3) {

                tsp = NULL;

            } else {

                target_to_host_timespec(ts, arg3);

                target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));

                tsp = ts;

            }

            if (!arg2)

                ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));

            else {

                if (!(p = lock_user_string(arg2))) {

                    ret = -TARGET_EFAULT;

                    goto fail;

                }

                ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));

                unlock_user(p, arg2, 0);

            }

        }

	break;

#endif

    case TARGET_NR_futex:

        ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);

        break;

#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

    case TARGET_NR_inotify_init:

        ret = get_errno(sys_inotify_init());

        break;

#endif

#ifdef CONFIG_INOTIFY1

#if defined(TARGET_NR_inotify_init1) && defined(__NR_inotify_init1)

    case TARGET_NR_inotify_init1:

        ret = get_errno(sys_inotify_init1(arg1));

        break;

#endif

#endif

#if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)

    case TARGET_NR_inotify_add_watch:

        p = lock_user_string(arg2);

        ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));

        unlock_user(p, arg2, 0);

        break;

#endif

#if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)

    case TARGET_NR_inotify_rm_watch:

        ret = get_errno(sys_inotify_rm_watch(arg1, arg2));

        break;

#endif



#if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)

    case TARGET_NR_mq_open:

        {

            struct mq_attr posix_mq_attr;



            p = lock_user_string(arg1 - 1);

            if (arg4 != 0)

                copy_from_user_mq_attr (&posix_mq_attr, arg4);

            ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));

            unlock_user (p, arg1, 0);

        }

        break;



    case TARGET_NR_mq_unlink:

        p = lock_user_string(arg1 - 1);

        ret = get_errno(mq_unlink(p));

        unlock_user (p, arg1, 0);

        break;



    case TARGET_NR_mq_timedsend:

        {

            struct timespec ts;



            p = lock_user (VERIFY_READ, arg2, arg3, 1);

            if (arg5 != 0) {

                target_to_host_timespec(&ts, arg5);

                ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));

                host_to_target_timespec(arg5, &ts);

            }

            else

                ret = get_errno(mq_send(arg1, p, arg3, arg4));

            unlock_user (p, arg2, arg3);

        }

        break;



    case TARGET_NR_mq_timedreceive:

        {

            struct timespec ts;

            unsigned int prio;



            p = lock_user (VERIFY_READ, arg2, arg3, 1);

            if (arg5 != 0) {

                target_to_host_timespec(&ts, arg5);

                ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));

                host_to_target_timespec(arg5, &ts);

            }

            else

                ret = get_errno(mq_receive(arg1, p, arg3, &prio));

            unlock_user (p, arg2, arg3);

            if (arg4 != 0)

                put_user_u32(prio, arg4);

        }

        break;



    /* Not implemented for now... */

/*     case TARGET_NR_mq_notify: */

/*         break; */



    case TARGET_NR_mq_getsetattr:

        {

            struct mq_attr posix_mq_attr_in, posix_mq_attr_out;


            if (arg3 != 0) {

                ret = mq_getattr(arg1, &posix_mq_attr_out);

                copy_to_user_mq_attr(arg3, &posix_mq_attr_out);

            }

            if (arg2 != 0) {

                copy_from_user_mq_attr(&posix_mq_attr_in, arg2);

                ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);

            }



        }

        break;

#endif



#ifdef CONFIG_SPLICE

#ifdef TARGET_NR_tee

    case TARGET_NR_tee:

        {

            ret = get_errno(tee(arg1,arg2,arg3,arg4));

        }

        break;

#endif

#ifdef TARGET_NR_splice

    case TARGET_NR_splice:

        {

            loff_t loff_in, loff_out;

            loff_t *ploff_in = NULL, *ploff_out = NULL;

            if(arg2) {

                get_user_u64(loff_in, arg2);

                ploff_in = &loff_in;

            }

            if(arg4) {

                get_user_u64(loff_out, arg2);

                ploff_out = &loff_out;

            }

            ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));

        }

        break;

#endif

#ifdef TARGET_NR_vmsplice

	case TARGET_NR_vmsplice:

        {

            struct iovec *vec = lock_iovec(VERIFY_READ, arg2, arg3, 1);

            if (vec != NULL) {

                ret = get_errno(vmsplice(arg1, vec, arg3, arg4));

                unlock_iovec(vec, arg2, arg3, 0);

            } else {

                ret = -host_to_target_errno(errno);

            }

        }

        break;

#endif

#endif /* CONFIG_SPLICE */

#ifdef CONFIG_EVENTFD

#if defined(TARGET_NR_eventfd)

    case TARGET_NR_eventfd:

        ret = get_errno(eventfd(arg1, 0));

        break;

#endif

#if defined(TARGET_NR_eventfd2)

    case TARGET_NR_eventfd2:

    {

        int host_flags = arg2 & (~(TARGET_O_NONBLOCK | TARGET_O_CLOEXEC));

        if (arg2 & TARGET_O_NONBLOCK) {

            host_flags |= O_NONBLOCK;

        }

        if (arg2 & TARGET_O_CLOEXEC) {

            host_flags |= O_CLOEXEC;

        }

        ret = get_errno(eventfd(arg1, host_flags));

        break;

    }

#endif

#endif /* CONFIG_EVENTFD  */

#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)

    case TARGET_NR_fallocate:

#if TARGET_ABI_BITS == 32

        ret = get_errno(fallocate(arg1, arg2, target_offset64(arg3, arg4),

                                  target_offset64(arg5, arg6)));

#else

        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));

#endif

        break;

#endif

#if defined(CONFIG_SYNC_FILE_RANGE)

#if defined(TARGET_NR_sync_file_range)

    case TARGET_NR_sync_file_range:

#if TARGET_ABI_BITS == 32

#if defined(TARGET_MIPS)

        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),

                                        target_offset64(arg5, arg6), arg7));

#else

        ret = get_errno(sync_file_range(arg1, target_offset64(arg2, arg3),

                                        target_offset64(arg4, arg5), arg6));

#endif /* !TARGET_MIPS */

#else

        ret = get_errno(sync_file_range(arg1, arg2, arg3, arg4));

#endif

        break;

#endif

#if defined(TARGET_NR_sync_file_range2)

    case TARGET_NR_sync_file_range2:

        /* This is like sync_file_range but the arguments are reordered */

#if TARGET_ABI_BITS == 32

        ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),

                                        target_offset64(arg5, arg6), arg2));

#else

        ret = get_errno(sync_file_range(arg1, arg3, arg4, arg2));

#endif

        break;

#endif

#endif

#if defined(CONFIG_EPOLL)

#if defined(TARGET_NR_epoll_create)

    case TARGET_NR_epoll_create:

        ret = get_errno(epoll_create(arg1));

        break;

#endif

#if defined(TARGET_NR_epoll_create1) && defined(CONFIG_EPOLL_CREATE1)

    case TARGET_NR_epoll_create1:

        ret = get_errno(epoll_create1(arg1));

        break;

#endif

#if defined(TARGET_NR_epoll_ctl)

    case TARGET_NR_epoll_ctl:

    {

        struct epoll_event ep;

        struct epoll_event *epp = 0;

        if (arg4) {

            struct target_epoll_event *target_ep;

            if (!lock_user_struct(VERIFY_READ, target_ep, arg4, 1)) {

                goto efault;

            }

            ep.events = tswap32(target_ep->events);

            /* The epoll_data_t union is just opaque data to the kernel,

             * so we transfer all 64 bits across and need not worry what

             * actual data type it is.

             */

            ep.data.u64 = tswap64(target_ep->data.u64);

            unlock_user_struct(target_ep, arg4, 0);

            epp = &ep;

        }

        ret = get_errno(epoll_ctl(arg1, arg2, arg3, epp));

        break;

    }

#endif



#if defined(TARGET_NR_epoll_pwait) && defined(CONFIG_EPOLL_PWAIT)

#define IMPLEMENT_EPOLL_PWAIT

#endif

#if defined(TARGET_NR_epoll_wait) || defined(IMPLEMENT_EPOLL_PWAIT)

#if defined(TARGET_NR_epoll_wait)

    case TARGET_NR_epoll_wait:

#endif

#if defined(IMPLEMENT_EPOLL_PWAIT)

    case TARGET_NR_epoll_pwait:

#endif

    {

        struct target_epoll_event *target_ep;

        struct epoll_event *ep;

        int epfd = arg1;

        int maxevents = arg3;

        int timeout = arg4;



        target_ep = lock_user(VERIFY_WRITE, arg2,

                              maxevents * sizeof(struct target_epoll_event), 1);

        if (!target_ep) {

            goto efault;

        }



        ep = alloca(maxevents * sizeof(struct epoll_event));



        switch (num) {

#if defined(IMPLEMENT_EPOLL_PWAIT)

        case TARGET_NR_epoll_pwait:

        {

            target_sigset_t *target_set;

            sigset_t _set, *set = &_set;



            if (arg5) {

                target_set = lock_user(VERIFY_READ, arg5,

                                       sizeof(target_sigset_t), 1);

                if (!target_set) {

                    unlock_user(target_ep, arg2, 0);

                    goto efault;

                }

                target_to_host_sigset(set, target_set);

                unlock_user(target_set, arg5, 0);

            } else {

                set = NULL;

            }



            ret = get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set));

            break;

        }

#endif

#if defined(TARGET_NR_epoll_wait)

        case TARGET_NR_epoll_wait:

            ret = get_errno(epoll_wait(epfd, ep, maxevents, timeout));

            break;

#endif

        default:

            ret = -TARGET_ENOSYS;

        }

        if (!is_error(ret)) {

            int i;

            for (i = 0; i < ret; i++) {

                target_ep[i].events = tswap32(ep[i].events);

                target_ep[i].data.u64 = tswap64(ep[i].data.u64);

            }

        }

        unlock_user(target_ep, arg2, ret * sizeof(struct target_epoll_event));

        break;

    }

#endif

#endif

#ifdef TARGET_NR_prlimit64

    case TARGET_NR_prlimit64:

    {

        /* args: pid, resource number, ptr to new rlimit, ptr to old rlimit */

        struct target_rlimit64 *target_rnew, *target_rold;

        struct host_rlimit64 rnew, rold, *rnewp = 0;

        if (arg3) {

            if (!lock_user_struct(VERIFY_READ, target_rnew, arg3, 1)) {

                goto efault;

            }

            rnew.rlim_cur = tswap64(target_rnew->rlim_cur);

            rnew.rlim_max = tswap64(target_rnew->rlim_max);

            unlock_user_struct(target_rnew, arg3, 0);

            rnewp = &rnew;

        }



        ret = get_errno(sys_prlimit64(arg1, arg2, rnewp, arg4 ? &rold : 0));

        if (!is_error(ret) && arg4) {

            if (!lock_user_struct(VERIFY_WRITE, target_rold, arg4, 1)) {

                goto efault;

            }

            target_rold->rlim_cur = tswap64(rold.rlim_cur);

            target_rold->rlim_max = tswap64(rold.rlim_max);

            unlock_user_struct(target_rold, arg4, 1);

        }

        break;

    }

#endif

#ifdef TARGET_NR_gethostname

    case TARGET_NR_gethostname:

    {

        char *name = lock_user(VERIFY_WRITE, arg1, arg2, 0);

        if (name) {

            ret = get_errno(gethostname(name, arg2));

            unlock_user(name, arg1, arg2);

        } else {

            ret = -TARGET_EFAULT;

        }

        break;

    }

#endif

#ifdef TARGET_NR_atomic_cmpxchg_32

    case TARGET_NR_atomic_cmpxchg_32:

    {

        /* should use start_exclusive from main.c */

        abi_ulong mem_value;

        if (get_user_u32(mem_value, arg6)) {

            target_siginfo_t info;

            info.si_signo = SIGSEGV;

            info.si_errno = 0;

            info.si_code = TARGET_SEGV_MAPERR;

            info._sifields._sigfault._addr = arg6;

            queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);

            ret = 0xdeadbeef;



        }

        if (mem_value == arg2)

            put_user_u32(arg1, arg6);

        ret = mem_value;

        break;

    }

#endif

#ifdef TARGET_NR_atomic_barrier

    case TARGET_NR_atomic_barrier:

    {

        /* Like the kernel implementation and the qemu arm barrier, no-op this? */


        break;

    }

#endif



#ifdef TARGET_NR_timer_create

    case TARGET_NR_timer_create:

    {

        /* args: clockid_t clockid, struct sigevent *sevp, timer_t *timerid */



        struct sigevent host_sevp = { {0}, }, *phost_sevp = NULL;

        struct target_sigevent *ptarget_sevp;

        struct target_timer_t *ptarget_timer;



        int clkid = arg1;

        int timer_index = next_free_host_timer();



        if (timer_index < 0) {

            ret = -TARGET_EAGAIN;

        } else {

            timer_t *phtimer = g_posix_timers  + timer_index;



            if (arg2) {

                if (!lock_user_struct(VERIFY_READ, ptarget_sevp, arg2, 1)) {

                    goto efault;

                }



                host_sevp.sigev_signo = tswap32(ptarget_sevp->sigev_signo);

                host_sevp.sigev_notify = tswap32(ptarget_sevp->sigev_notify);



                phost_sevp = &host_sevp;

            }



            ret = get_errno(timer_create(clkid, phost_sevp, phtimer));

            if (ret) {

                phtimer = NULL;

            } else {

                if (!lock_user_struct(VERIFY_WRITE, ptarget_timer, arg3, 1)) {

                    goto efault;

                }

                ptarget_timer->ptr = tswap32(0xcafe0000 | timer_index);

                unlock_user_struct(ptarget_timer, arg3, 1);

            }

        }

        break;

    }

#endif



#ifdef TARGET_NR_timer_settime

    case TARGET_NR_timer_settime:

    {

        /* args: timer_t timerid, int flags, const struct itimerspec *new_value,

         * struct itimerspec * old_value */

        arg1 &= 0xffff;

        if (arg3 == 0 || arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {

            ret = -TARGET_EINVAL;

        } else {

            timer_t htimer = g_posix_timers[arg1];

            struct itimerspec hspec_new = {{0},}, hspec_old = {{0},};



            target_to_host_itimerspec(&hspec_new, arg3);

            ret = get_errno(

                          timer_settime(htimer, arg2, &hspec_new, &hspec_old));

            host_to_target_itimerspec(arg2, &hspec_old);

        }

        break;

    }

#endif



#ifdef TARGET_NR_timer_gettime

    case TARGET_NR_timer_gettime:

    {

        /* args: timer_t timerid, struct itimerspec *curr_value */

        arg1 &= 0xffff;

        if (!arg2) {

            return -TARGET_EFAULT;

        } else if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {

            ret = -TARGET_EINVAL;

        } else {

            timer_t htimer = g_posix_timers[arg1];

            struct itimerspec hspec;

            ret = get_errno(timer_gettime(htimer, &hspec));



            if (host_to_target_itimerspec(arg2, &hspec)) {

                ret = -TARGET_EFAULT;

            }

        }

        break;

    }

#endif



#ifdef TARGET_NR_timer_getoverrun

    case TARGET_NR_timer_getoverrun:

    {

        /* args: timer_t timerid */

        arg1 &= 0xffff;

        if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {

            ret = -TARGET_EINVAL;

        } else {

            timer_t htimer = g_posix_timers[arg1];

            ret = get_errno(timer_getoverrun(htimer));

        }

        break;

    }

#endif



#ifdef TARGET_NR_timer_delete

    case TARGET_NR_timer_delete:

    {

        /* args: timer_t timerid */

        arg1 &= 0xffff;

        if (arg1 < 0 || arg1 >= ARRAY_SIZE(g_posix_timers)) {

            ret = -TARGET_EINVAL;

        } else {

            timer_t htimer = g_posix_timers[arg1];

            ret = get_errno(timer_delete(htimer));

            g_posix_timers[arg1] = 0;

        }

        break;

    }

#endif



    default:

    unimplemented:

        gemu_log("qemu: Unsupported syscall: %d\n", num);

#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)

    unimplemented_nowarn:

#endif

        ret = -TARGET_ENOSYS;

        break;

    }

fail:

#ifdef DEBUG

    gemu_log(" = " TARGET_ABI_FMT_ld "\n", ret);

#endif

    if(do_strace)

        print_syscall_ret(num, ret);

    return ret;

efault:

    ret = -TARGET_EFAULT;

    goto fail;

} and probability:0.07739307535641547
code:static int dxv_decompress_dxt1(AVCodecContext *avctx)

{

    DXVContext *ctx = avctx->priv_data;

    GetByteContext *gbc = &ctx->gbc;

    uint32_t value, prev, op;

    int idx = 0, state = 0;

    int pos = 2;



    /* Copy the first two elements */

    AV_WL32(ctx->tex_data, bytestream2_get_le32(gbc));

    AV_WL32(ctx->tex_data + 4, bytestream2_get_le32(gbc));



    /* Process input until the whole texture has been filled */

    while (pos < ctx->tex_size / 4) {

        CHECKPOINT(2);



        /* Copy two elements from a previous offset or from the input buffer */

        if (op) {

            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;



            prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

        } else {

            CHECKPOINT(2);



            if (op)

                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            else

                prev = bytestream2_get_le32(gbc);

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;



            CHECKPOINT(2);



            if (op)

                prev = AV_RL32(ctx->tex_data + 4 * (pos - idx));

            else

                prev = bytestream2_get_le32(gbc);

            AV_WL32(ctx->tex_data + 4 * pos, prev);

            pos++;

        }

    }



    return 0;

}
 and probability:0.425
code:static int decode_frame(AVCodecContext *avctx,

                        void *data, int *data_size,

                        AVPacket *avpkt)

{

    JvContext *s           = avctx->priv_data;

    const uint8_t *buf     = avpkt->data;

    const uint8_t *buf_end = buf + avpkt->size;

    int video_size, video_type, i, j;



    video_size = AV_RL32(buf);

    video_type = buf[4];

    buf += 5;



    if (video_size) {

        if (video_size < 0 || video_size > avpkt->size - 5) {

            av_log(avctx, AV_LOG_ERROR, "video size %d invalid\n", video_size);

            return AVERROR_INVALIDDATA;

        }

        if (avctx->reget_buffer(avctx, &s->frame) < 0) {

            av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");

            return -1;

        }



        if (video_type == 0 || video_type == 1) {

            GetBitContext gb;

            init_get_bits(&gb, buf, 8 * video_size);



            for (j = 0; j < avctx->height; j += 8)

                for (i = 0; i < avctx->width; i += 8)

                    decode8x8(&gb, s->frame.data[0] + j*s->frame.linesize[0] + i,

                              s->frame.linesize[0], &s->dsp);



            buf += video_size;

        } else if (video_type == 2) {

            if (buf + 1 <= buf_end) {

                int v = *buf++;

                for (j = 0; j < avctx->height; j++)

                    memset(s->frame.data[0] + j*s->frame.linesize[0], v, avctx->width);

            }

        } else {

            av_log(avctx, AV_LOG_WARNING, "unsupported frame type %i\n", video_type);

            return AVERROR_INVALIDDATA;

        }

    }



    if (buf_end - buf >= AVPALETTE_COUNT * 3) {

        for (i = 0; i < AVPALETTE_COUNT; i++) {

            uint32_t pal = AV_RB24(buf);

            s->palette[i] = 0xFF << 24 | pal << 2 | ((pal >> 4) & 0x30303);

            buf += 3;

        }

        s->palette_has_changed = 1;

    }



    if (video_size) {

        s->frame.key_frame           = 1;

        s->frame.pict_type           = AV_PICTURE_TYPE_I;

        s->frame.palette_has_changed = s->palette_has_changed;

        s->palette_has_changed       = 0;

        memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);



        *data_size      = sizeof(AVFrame);

        *(AVFrame*)data = s->frame;

    }



    return avpkt->size;

}
 and probability:0.5172413793103449
code:static av_cold int asv_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);



    return 0;

}
 and probability:0.2
code:static void megasas_reset_frames(MegasasState *s)

{

    PCIDevice *pcid = PCI_DEVICE(s);

    int i;

    MegasasCmd *cmd;



    for (i = 0; i < s->fw_cmds; i++) {

        cmd = &s->frames[i];

        if (cmd->pa) {

            pci_dma_unmap(pcid, cmd->frame, cmd->pa_size, 0, 0);

            cmd->frame = NULL;

            cmd->pa = 0;

        }

    }

}
 and probability:0.42857142857142855
code:void aio_set_fd_handler(AioContext *ctx,

                        int fd,

                        bool is_external,

                        IOHandler *io_read,

                        IOHandler *io_write,

                        void *opaque)

{

    AioHandler *node;

    bool is_new = false;



    node = find_aio_handler(ctx, fd);



    /* Are we deleting the fd handler? */

    if (!io_read && !io_write) {

        if (node) {

            g_source_remove_poll(&ctx->source, &node->pfd);



            /* If the lock is held, just mark the node as deleted */

            if (ctx->walking_handlers) {

                node->deleted = 1;

                node->pfd.revents = 0;

            } else {

                /* Otherwise, delete it for real.  We can't just mark it as

                 * deleted because deleted nodes are only cleaned up after

                 * releasing the walking_handlers lock.

                 */

                QLIST_REMOVE(node, node);

                g_free(node);

            }

        }

    } else {

        if (node == NULL) {

            /* Alloc and insert if it's not already there */

            node = g_new0(AioHandler, 1);

            node->pfd.fd = fd;

            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);



            g_source_add_poll(&ctx->source, &node->pfd);

            is_new = true;

        }

        /* Update handler with latest information */

        node->io_read = io_read;

        node->io_write = io_write;

        node->opaque = opaque;

        node->is_external = is_external;



        node->pfd.events = (io_read ? G_IO_IN | G_IO_HUP | G_IO_ERR : 0);

        node->pfd.events |= (io_write ? G_IO_OUT | G_IO_ERR : 0);

    }



    aio_epoll_update(ctx, node, is_new);

    aio_notify(ctx);

}
 and probability:0.2765957446808511
code:unsigned long hbitmap_iter_skip_words(HBitmapIter *hbi)

{

    size_t pos = hbi->pos;

    const HBitmap *hb = hbi->hb;

    unsigned i = HBITMAP_LEVELS - 1;



    unsigned long cur;

    do {

        cur = hbi->cur[--i];

        pos >>= BITS_PER_LEVEL;

    } while (cur == 0);



    /* Check for end of iteration.  We always use fewer than BITS_PER_LONG

     * bits in the level 0 bitmap; thus we can repurpose the most significant

     * bit as a sentinel.  The sentinel is set in hbitmap_alloc and ensures

     * that the above loop ends even without an explicit check on i.

     */



    if (i == 0 && cur == (1UL << (BITS_PER_LONG - 1))) {

        return 0;

    }

    for (; i < HBITMAP_LEVELS - 1; i++) {

        /* Shift back pos to the left, matching the right shifts above.

         * The index of this word's least significant set bit provides

         * the low-order bits.

         */

        pos = (pos << BITS_PER_LEVEL) + ffsl(cur) - 1;

        hbi->cur[i] = cur & (cur - 1);



        /* Set up next level for iteration.  */

        cur = hb->levels[i + 1][pos];

    }



    hbi->pos = pos;

    trace_hbitmap_iter_skip_words(hbi->hb, hbi, pos, cur);



    assert(cur);

    return cur;

}
 and probability:0.3333333333333333
code:static int intel_hda_exit(PCIDevice *pci)

{

    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);



    if (d->msi) {

        msi_uninit(&d->pci);

    }

    cpu_unregister_io_memory(d->mmio_addr);

    return 0;

}
 and probability:0.3333333333333333
code:static int compand_nodelay(AVFilterContext *ctx, AVFrame *frame)

{

    CompandContext *s = ctx->priv;

    AVFilterLink *inlink = ctx->inputs[0];

    const int channels = inlink->channels;

    const int nb_samples = frame->nb_samples;

    AVFrame *out_frame;

    int chan, i;



    if (av_frame_is_writable(frame)) {

        out_frame = frame;

    } else {

        out_frame = ff_get_audio_buffer(inlink, nb_samples);

        if (!out_frame)

            return AVERROR(ENOMEM);

        av_frame_copy_props(out_frame, frame);

    }



    for (chan = 0; chan < channels; chan++) {

        const double *src = (double *)frame->extended_data[chan];

        double *dst = (double *)out_frame->extended_data[chan];

        ChanParam *cp = &s->channels[chan];



        for (i = 0; i < nb_samples; i++) {

            update_volume(cp, fabs(src[i]));



            dst[i] = av_clipd(src[i] * get_volume(s, cp->volume), -1, 1);

        }

    }



    if (frame != out_frame)

        av_frame_free(&frame);



    return ff_filter_frame(ctx->outputs[0], out_frame);

}
 and probability:0.41379310344827586
code:static void pfpu_start(MilkymistPFPUState *s)

{

    int x, y;

    int i;



    for (y = 0; y <= s->regs[R_VMESHLAST]; y++) {

        for (x = 0; x <= s->regs[R_HMESHLAST]; x++) {

            D_EXEC(qemu_log("\nprocessing x=%d y=%d\n", x, y));



            /* set current position */

            s->gp_regs[GPR_X] = x;

            s->gp_regs[GPR_Y] = y;



            /* run microcode on this position */

            i = 0;

            while (pfpu_decode_insn(s)) {

                /* decode at most MICROCODE_WORDS instructions */

                if (i++ >= MICROCODE_WORDS) {

                    error_report("milkymist_pfpu: too many instructions "

                            "executed in microcode. No VECTOUT?");

                    break;

                }

            }



            /* reset pc for next run */

            s->regs[R_PC] = 0;

        }

    }



    s->regs[R_VERTICES] = x * y;



    trace_milkymist_pfpu_pulse_irq();

    qemu_irq_pulse(s->irq);

}
 and probability:0.2857142857142857
code:av_cold void ff_vp9dsp_init(VP9DSPContext *dsp, int bpp)

{

    if (bpp == 8) {

        ff_vp9dsp_init_8(dsp);

    } else if (bpp == 10) {

        ff_vp9dsp_init_10(dsp);

    } else {

        av_assert0(bpp == 12);

        ff_vp9dsp_init_12(dsp);

    }



    if (ARCH_X86) ff_vp9dsp_init_x86(dsp, bpp);

    if (ARCH_MIPS) ff_vp9dsp_init_mips(dsp, bpp);

}
 and probability:0.0
code:static int mov_read_mdhd(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];



    print_atom("mdhd", atom);



    get_byte(pb); /* version */



    get_byte(pb); get_byte(pb);

    get_byte(pb); /* flags */



    get_be32(pb); /* creation time */

    get_be32(pb); /* modification time */



    c->streams[c->total_streams]->time_scale = get_be32(pb);



#ifdef DEBUG

    printf("track[%i].time_scale = %i\n", c->fc->nb_streams-1, c->streams[c->total_streams]->time_scale); /* time scale */

#endif

    get_be32(pb); /* duration */



    get_be16(pb); /* language */

    get_be16(pb); /* quality */



    return 0;

}
 and probability:0.16666666666666666
code:static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,

    int width, int height, int src_stride, int stride)

{

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    const int lambda= (s->picture.quality*s->picture.quality) >> (2*FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width = (width + 15) / 16;

    block_height = (height + 15) / 16;



    if(s->picture.pict_type == FF_P_TYPE){

        s->m.avctx= s->avctx;

        s->m.current_picture_ptr= &s->m.current_picture;

        s->m.last_picture_ptr   = &s->m.last_picture;

        s->m.last_picture.data[0]= ref_plane;

        s->m.linesize=

        s->m.last_picture.linesize[0]=

        s->m.new_picture.linesize[0]=

        s->m.current_picture.linesize[0]= stride;

        s->m.width= width;

        s->m.height= height;

        s->m.mb_width= block_width;

        s->m.mb_height= block_height;

        s->m.mb_stride= s->m.mb_width+1;

        s->m.b8_stride= 2*s->m.mb_width+1;

        s->m.f_code=1;

        s->m.pict_type= s->picture.pict_type;

        s->m.me_method= s->avctx->me_method;

        s->m.me.scene_change_score=0;

        s->m.flags= s->avctx->flags;

//        s->m.out_format = FMT_H263;

//        s->m.unrestricted_mv= 1;



        s->m.lambda= s->picture.quality;

        s->m.qscale= (s->m.lambda*139 + FF_LAMBDA_SCALE*64) >> (FF_LAMBDA_SHIFT + 7);

        s->m.lambda2= (s->m.lambda*s->m.lambda + FF_LAMBDA_SCALE/2) >> FF_LAMBDA_SHIFT;



        if(!s->motion_val8[plane]){

            s->motion_val8 [plane]= av_mallocz((s->m.b8_stride*block_height*2 + 2)*2*sizeof(int16_t));

            s->motion_val16[plane]= av_mallocz((s->m.mb_stride*(block_height + 2) + 1)*2*sizeof(int16_t));

        }



        s->m.mb_type= s->mb_type;



        //dummies, to avoid segfaults

        s->m.current_picture.mb_mean=   (uint8_t *)s->dummy;

        s->m.current_picture.mb_var=    (uint16_t*)s->dummy;

        s->m.current_picture.mc_mb_var= (uint16_t*)s->dummy;

        s->m.current_picture.mb_type= s->dummy;



        s->m.current_picture.motion_val[0]= s->motion_val8[plane] + 2;

        s->m.p_mv_table= s->motion_val16[plane] + s->m.mb_stride + 1;

        s->m.dsp= s->dsp; //move

        ff_init_me(&s->m);



        s->m.me.dia_size= s->avctx->dia_size;

        s->m.first_slice_line=1;

        for (y = 0; y < block_height; y++) {

            uint8_t src[stride*16];



            s->m.new_picture.data[0]= src - y*16*stride; //ugly

            s->m.mb_y= y;



            for(i=0; i<16 && i + 16*y<height; i++){

                memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);

                for(x=width; x<16*block_width; x++)

                    src[i*stride+x]= src[i*stride+x-1];

            }

            for(; i<16 && i + 16*y<16*block_height; i++)

                memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x= x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line=0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code, CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line=1;

    for (y = 0; y < block_height; y++) {

        uint8_t src[stride*16];



        for(i=0; i<16 && i + 16*y<height; i++){

            memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);

            for(x=width; x<16*block_width; x++)

                src[i*stride+x]= src[i*stride+x-1];

        }

        for(; i<16 && i + 16*y<16*block_height; i++)

            memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);



        s->m.mb_y= y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7*32];

            int count[3][6];

            int offset = y * 16 * stride + x * 16;

            uint8_t *decoded= decoded_plane + offset;

            uint8_t *ref= ref_plane + offset;

            int score[4]={0,0,0,0}, best;

            uint8_t *temp = s->scratchbuf;



            if(s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb)>>3) < 3000){ //FIXME check size

                av_log(s->avctx, AV_LOG_ERROR, "encoded frame too large\n");

                return -1;

            }



            s->m.mb_x= x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if(s->picture.pict_type == FF_I_TYPE || (s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTRA)){

                for(i=0; i<6; i++){

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i], 7*32);

                }

                if(s->picture.pict_type == FF_P_TYPE){

                    const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0]= vlc[1]*lambda;

                }

                score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);

                for(i=0; i<6; i++){

                    count[0][i]= put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            }else

                score[0]= INT_MAX;



            best=0;



            if(s->picture.pict_type == FF_P_TYPE){

                const uint8_t *vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr= h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if(s->m.mb_type[x + y*s->m.mb_stride]&CANDIDATE_MB_TYPE_INTER){

                    for(i=0; i<6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i], 7*32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb= s->reorder_pb[5];

                    mx= motion_ptr[0];

                    my= motion_ptr[1];

                    assert(mx>=-32 && mx<=31);

                    assert(my>=-32 && my<=31);

                    assert(pred_x>=-32 && pred_x<=31);

                    assert(pred_y>=-32 && pred_y<=31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5]= s->m.pb;

                    score[1] += lambda*put_bits_count(&s->reorder_pb[5]);



                    dxy= (mx&1) + 2*(my&1);



                    s->dsp.put_pixels_tab[0][dxy](temp+16, ref + (mx>>1) + stride*(my>>1), stride, 16);



                    score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);

                    best= score[1] <= score[0];



                    vlc= ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);

                    score[2]+= vlc[1]*lambda;

                    if(score[2] < score[best] && mx==0 && my==0){

                        best=2;

                        s->dsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for(i=0; i<6; i++){

                            count[2][i]=0;

                        }

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if(best==1){

                    for(i=0; i<6; i++){

                        count[1][i]= put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                }else{

                    motion_ptr[0                 ] = motion_ptr[1                 ]=

                    motion_ptr[2                 ] = motion_ptr[3                 ]=

                    motion_ptr[0+2*s->m.b8_stride] = motion_ptr[1+2*s->m.b8_stride]=

                    motion_ptr[2+2*s->m.b8_stride] = motion_ptr[3+2*s->m.b8_stride]=0;

                }

            }



            s->rd_total += score[best];



            for(i=5; i>=0; i--){

                ff_copy_bits(&s->pb, reorder_buffer[best][i], count[best][i]);

            }

            if(best==0){

                s->dsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

            }

        }

        s->m.first_slice_line=0;

    }

    return 0;

}
 and probability:0.7292817679558011
code:static int commit_direntries(BDRVVVFATState* s,

	int dir_index, int parent_mapping_index)

{

    direntry_t* direntry = array_get(&(s->directory), dir_index);

    uint32_t first_cluster = dir_index == 0 ? 0 : begin_of_direntry(direntry);

    mapping_t* mapping = find_mapping_for_cluster(s, first_cluster);



    int factor = 0x10 * s->sectors_per_cluster;

    int old_cluster_count, new_cluster_count;

    int current_dir_index = mapping->info.dir.first_dir_index;

    int first_dir_index = current_dir_index;

    int ret, i;

    uint32_t c;



DLOG(fprintf(stderr, "commit_direntries for %s, parent_mapping_index %d\n", mapping->path, parent_mapping_index));



    assert(direntry);

    assert(mapping);

    assert(mapping->begin == first_cluster);

    assert(mapping->info.dir.first_dir_index < s->directory.next);

    assert(mapping->mode & MODE_DIRECTORY);

    assert(dir_index == 0 || is_directory(direntry));



    mapping->info.dir.parent_mapping_index = parent_mapping_index;



    if (first_cluster == 0) {

	old_cluster_count = new_cluster_count =

	    s->last_cluster_of_root_directory;

    } else {

	for (old_cluster_count = 0, c = first_cluster; !fat_eof(s, c);

		c = fat_get(s, c))

	    old_cluster_count++;



	for (new_cluster_count = 0, c = first_cluster; !fat_eof(s, c);

		c = modified_fat_get(s, c))

	    new_cluster_count++;

    }



    if (new_cluster_count > old_cluster_count) {

	if (insert_direntries(s,

		current_dir_index + factor * old_cluster_count,

		factor * (new_cluster_count - old_cluster_count)) == NULL)

	    return -1;

    } else if (new_cluster_count < old_cluster_count)

	remove_direntries(s,

		current_dir_index + factor * new_cluster_count,

		factor * (old_cluster_count - new_cluster_count));



    for (c = first_cluster; !fat_eof(s, c); c = modified_fat_get(s, c)) {

	void* direntry = array_get(&(s->directory), current_dir_index);

	int ret = vvfat_read(s->bs, cluster2sector(s, c), direntry,

		s->sectors_per_cluster);

	if (ret)

	    return ret;

	assert(!strncmp(s->directory.pointer, "QEMU", 4));

	current_dir_index += factor;

    }



    ret = commit_mappings(s, first_cluster, dir_index);

    if (ret)

	return ret;



    /* recurse */

    for (i = 0; i < factor * new_cluster_count; i++) {

	direntry = array_get(&(s->directory), first_dir_index + i);

	if (is_directory(direntry) && !is_dot(direntry)) {

	    mapping = find_mapping_for_cluster(s, first_cluster);

	    assert(mapping->mode & MODE_DIRECTORY);

	    ret = commit_direntries(s, first_dir_index + i,

		array_index(&(s->mapping), mapping));

	    if (ret)

		return ret;

	}

    }



    return 0;

}
 and probability:0.3787878787878788
code:void vfio_put_group(VFIOGroup *group)

{

    if (!QLIST_EMPTY(&group->device_list)) {

        return;

    }



    vfio_kvm_device_del_group(group);

    vfio_disconnect_container(group);

    QLIST_REMOVE(group, next);

    trace_vfio_put_group(group->fd);

    close(group->fd);

    g_free(group);



    if (QLIST_EMPTY(&vfio_group_list)) {

        qemu_unregister_reset(vfio_reset_handler, NULL);

    }

}
 and probability:0.2
code:void do_POWER_div (void)

{

    uint64_t tmp;



    if (((int32_t)T0 == INT32_MIN && (int32_t)T1 == -1) || (int32_t)T1 == 0) {

        T0 = (long)((-1) * (T0 >> 31));

        env->spr[SPR_MQ] = 0;

    } else {

        tmp = ((uint64_t)T0 << 32) | env->spr[SPR_MQ];

        env->spr[SPR_MQ] = tmp % T1;

        T0 = tmp / (int32_t)T1;

    }

}
 and probability:0.4166666666666667
code:void qemu_chr_info(Monitor *mon)

{

    CharDriverState *chr;



    TAILQ_FOREACH(chr, &chardevs, next) {

        monitor_printf(mon, "%s: filename=%s\n", chr->label, chr->filename);

    }

}
 and probability:0.14285714285714285
code:void lm32_debug_excp_handler(CPUState *cs)

{

    LM32CPU *cpu = LM32_CPU(cs);

    CPULM32State *env = &cpu->env;

    CPUBreakpoint *bp;



    if (cs->watchpoint_hit) {

        if (cs->watchpoint_hit->flags & BP_CPU) {

            cs->watchpoint_hit = NULL;

            if (check_watchpoints(env)) {

                raise_exception(env, EXCP_WATCHPOINT);

            } else {

                cpu_resume_from_signal(cs, NULL);

            }

        }

    } else {

        QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {

            if (bp->pc == env->pc) {

                if (bp->flags & BP_CPU) {

                    raise_exception(env, EXCP_BREAKPOINT);

                }

                break;

            }

        }

    }

}
 and probability:0.28
code:int qemu_get_byte(QEMUFile *f)

{

    if (f->is_write)

        abort();



    if (f->buf_index >= f->buf_size) {

        qemu_fill_buffer(f);

        if (f->buf_index >= f->buf_size)

            return 0;

    }

    return f->buf[f->buf_index++];

}
 and probability:0.36363636363636365
code:static void parse_error(JSONParserContext *ctxt, QObject *token, const char *msg, ...)

{

    fprintf(stderr, "parse error: %s\n", msg);

}
 and probability:0.0
code:void gtod_save(QEMUFile *f, void *opaque)

{

    uint64_t tod_low;

    uint8_t tod_high;

    int r;



    r = s390_get_clock(&tod_high, &tod_low);

    if (r) {

        fprintf(stderr, "WARNING: Unable to get guest clock for migration. "

                        "Error code %d. Guest clock will not be migrated "

                        "which could cause the guest to hang.\n", r);

        qemu_put_byte(f, S390_TOD_CLOCK_VALUE_MISSING);

        return;

    }



    qemu_put_byte(f, S390_TOD_CLOCK_VALUE_PRESENT);

    qemu_put_byte(f, tod_high);

    qemu_put_be64(f, tod_low);

}
 and probability:0.0
code:void kvm_arch_update_guest_debug(CPUState *env, struct kvm_guest_debug *dbg)

{

    const uint8_t type_code[] = {

        [GDB_BREAKPOINT_HW] = 0x0,

        [GDB_WATCHPOINT_WRITE] = 0x1,

        [GDB_WATCHPOINT_ACCESS] = 0x3

    };

    const uint8_t len_code[] = {

        [1] = 0x0, [2] = 0x1, [4] = 0x3, [8] = 0x2

    };

    int n;



    if (kvm_sw_breakpoints_active(env))

        dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP;



    if (nb_hw_breakpoint > 0) {

        dbg->control |= KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_HW_BP;

        dbg->arch.debugreg[7] = 0x0600;

        for (n = 0; n < nb_hw_breakpoint; n++) {

            dbg->arch.debugreg[n] = hw_breakpoint[n].addr;

            dbg->arch.debugreg[7] |= (2 << (n * 2)) |

                (type_code[hw_breakpoint[n].type] << (16 + n*4)) |

                ((uint32_t)len_code[hw_breakpoint[n].len] << (18 + n*4));

        }

    }

    /* Legal xcr0 for loading */

    env->xcr0 = 1;

}
 and probability:0.34615384615384615
code:SocketAddress *socket_local_address(int fd, Error **errp)

{

    struct sockaddr_storage ss;

    socklen_t sslen = sizeof(ss);



    if (getsockname(fd, (struct sockaddr *)&ss, &sslen) < 0) {

        error_setg_errno(errp, errno, "%s",

                         "Unable to query local socket address");

        return NULL;

    }



    return socket_sockaddr_to_address(&ss, sslen, errp);

}
 and probability:0.0
code:static void eeprom_generate(eeprom24c0x_t *eeprom, ram_addr_t ram_size)

{

    enum { SDR = 0x4, DDR2 = 0x8 } type;

    uint8_t *spd = eeprom->contents;

    uint8_t nbanks = 0;

    uint16_t density = 0;

    int i;



    /* work in terms of MB */

    ram_size >>= 20;



    while ((ram_size >= 4) && (nbanks <= 2)) {

        int sz_log2 = MIN(31 - clz32(ram_size), 14);

        nbanks++;

        density |= 1 << (sz_log2 - 2);

        ram_size -= 1 << sz_log2;

    }



    /* split to 2 banks if possible */

    if ((nbanks == 1) && (density > 1)) {

        nbanks++;

        density >>= 1;

    }



    if (density & 0xff00) {

        density = (density & 0xe0) | ((density >> 8) & 0x1f);

        type = DDR2;

    } else if (!(density & 0x1f)) {

        type = DDR2;

    } else {

        type = SDR;

    }



    if (ram_size) {

        fprintf(stderr, "Warning: SPD cannot represent final %dMB"

                " of SDRAM\n", (int)ram_size);

    }



    /* fill in SPD memory information */

    spd[2] = type;

    spd[5] = nbanks;

    spd[31] = density;



    /* checksum */

    spd[63] = 0;

    for (i = 0; i < 63; i++) {

        spd[63] += spd[i];

    }

}
 and probability:0.2857142857142857
code:static int virtio_blk_init_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);

    VirtIODevice *vdev;



    if (proxy->class_code != PCI_CLASS_STORAGE_SCSI &&

        proxy->class_code != PCI_CLASS_STORAGE_OTHER)

        proxy->class_code = PCI_CLASS_STORAGE_SCSI;



    if (!proxy->block.dinfo) {

        error_report("virtio-blk-pci: drive property not set");

        return -1;

    }

    vdev = virtio_blk_init(&pci_dev->qdev, &proxy->block);

    vdev->nvectors = proxy->nvectors;

    virtio_init_pci(proxy, vdev,

                    PCI_VENDOR_ID_REDHAT_QUMRANET,

                    PCI_DEVICE_ID_VIRTIO_BLOCK,

                    proxy->class_code, 0x00);

    /* make the actual value visible */

    proxy->nvectors = vdev->nvectors;

    return 0;

}
 and probability:0.38095238095238093
code:void s390_io_interrupt(S390CPU *cpu, uint16_t subchannel_id,

                       uint16_t subchannel_nr, uint32_t io_int_parm,

                       uint32_t io_int_word)

{

    if (kvm_enabled()) {

        kvm_s390_io_interrupt(cpu, subchannel_id, subchannel_nr, io_int_parm,

                              io_int_word);

    } else {

        cpu_inject_io(cpu, subchannel_id, subchannel_nr, io_int_parm,

                      io_int_word);

    }

}
 and probability:0.0
code:static void pci_bridge_region_del(PCIBridge *br, PCIBridgeWindows *w)

{

    PCIDevice *pd = PCI_DEVICE(br);

    PCIBus *parent = pd->bus;



    memory_region_del_subregion(parent->address_space_io, &w->alias_io);

    memory_region_del_subregion(parent->address_space_mem, &w->alias_mem);

    memory_region_del_subregion(parent->address_space_mem, &w->alias_pref_mem);

    pci_unregister_vga(pd);

}
 and probability:0.4444444444444444
code:void bt_l2cap_psm_register(struct bt_l2cap_device_s *dev, int psm, int min_mtu,

                int (*new_channel)(struct bt_l2cap_device_s *dev,

                        struct bt_l2cap_conn_params_s *params))

{

    struct bt_l2cap_psm_s *new_psm = l2cap_psm(dev, psm);



    if (new_psm) {

        fprintf(stderr, "%s: PSM %04x already registered for device `%s'.\n",

                        __FUNCTION__, psm, dev->device.lmp_name);

        exit(-1);

    }



    new_psm = g_malloc0(sizeof(*new_psm));

    new_psm->psm = psm;

    new_psm->min_mtu = min_mtu;

    new_psm->new_channel = new_channel;

    new_psm->next = dev->first_psm;

    dev->first_psm = new_psm;

}
 and probability:0.4117647058823529
code:static int check_pow_970 (CPUPPCState *env)

{

    if (env->spr[SPR_HID0] & 0x00600000)

        return 1;



    return 0;

}
 and probability:0.16666666666666666
code:void do_info_usernet(Monitor *mon)

{

    SlirpState *s;



    TAILQ_FOREACH(s, &slirp_stacks, entry) {

        monitor_printf(mon, "VLAN %d (%s):\n", s->vc->vlan->id, s->vc->name);

        slirp_connection_info(s->slirp, mon);

    }

}
 and probability:0.25
code:static inline void RENAME(rgb16to32)(const uint8_t *src, uint8_t *dst, long src_size)

{

    const uint16_t *end;

#if COMPILE_TEMPLATE_MMX

    const uint16_t *mm_end;

#endif

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(PREFETCH"    %0"::"m"(*s):"memory");

    __asm__ volatile("pxor    %%mm7,%%mm7    \n\t":::"memory");

    __asm__ volatile("pcmpeqd %%mm6,%%mm6    \n\t":::"memory");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH"    32%1           \n\t"

            "movq          %1, %%mm0    \n\t"

            "movq          %1, %%mm1    \n\t"

            "movq          %1, %%mm2    \n\t"

            "pand          %2, %%mm0    \n\t"

            "pand          %3, %%mm1    \n\t"

            "pand          %4, %%mm2    \n\t"

            "psllq         $3, %%mm0    \n\t"

            "psrlq         $3, %%mm1    \n\t"

            "psrlq         $8, %%mm2    \n\t"

            PACK_RGB32

            :"=m"(*d)

            :"m"(*s),"m"(mask16b),"m"(mask16g),"m"(mask16r)

            :"memory");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::"memory");

    __asm__ volatile(EMMS:::"memory");

#endif

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

#if HAVE_BIGENDIAN

        *d++ = 255;

        *d++ = (bgr&0xF800)>>8;

        *d++ = (bgr&0x7E0)>>3;

        *d++ = (bgr&0x1F)<<3;

#else

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x7E0)>>3;

        *d++ = (bgr&0xF800)>>8;

        *d++ = 255;

#endif

    }

}
 and probability:0.28846153846153844
code:int ff_xvmc_field_start(MpegEncContext*s, AVCodecContext *avctx)

{

    struct xvmc_pixfmt_render *last, *next, *render = (struct xvmc_pixfmt_render*)s->current_picture.data[2];

    const int mb_block_count = 4 + (1 << s->chroma_format);



    assert(avctx);

    if (!render || render->magic_id != AV_XVMC_RENDER_MAGIC ||

        !render->data_blocks || !render->mv_blocks){

        av_log(avctx, AV_LOG_ERROR,

               "Render token doesn't look as expected.\n");

        return -1; // make sure that this is a render packet

    }



    render->picture_structure = s->picture_structure;

    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;



    if (render->filled_mv_blocks_num) {

        av_log(avctx, AV_LOG_ERROR,

               "Rendering surface contains %i unprocessed blocks.\n",

               render->filled_mv_blocks_num);

        return -1;

    }

    if (render->total_number_of_mv_blocks   < 1 ||

        render->total_number_of_data_blocks < mb_block_count) {

        av_log(avctx, AV_LOG_ERROR,

               "Rendering surface doesn't provide enough block structures to work with.\n");

        return -1;

    }

    if (render->total_number_of_mv_blocks   < 1 ||

        render->total_number_of_data_blocks < mb_block_count) {

        av_log(avctx, AV_LOG_ERROR,

               "Rendering surface doesn't provide enough block structures to work with.\n");

        return -1;

    }



    render->p_future_surface = NULL;

    render->p_past_surface   = NULL;



    switch(s->pict_type) {

        case  FF_I_TYPE:

            return 0; // no prediction from other frames

        case  FF_B_TYPE:

            next = (struct xvmc_pixfmt_render*)s->next_picture.data[2];

            if (!next)

                return -1;

            if (next->magic_id != AV_XVMC_RENDER_MAGIC)

                return -1;

            render->p_future_surface = next->p_surface;

            // no return here, going to set forward prediction

        case  FF_P_TYPE:

            last = (struct xvmc_pixfmt_render*)s->last_picture.data[2];

            if (!last)

                last = render; // predict second field from the first

            if (last->magic_id != AV_XVMC_RENDER_MAGIC)

                return -1;

            render->p_past_surface = last->p_surface;

            return 0;

    }



return -1;

}
 and probability:0.38181818181818183
code:int64_t url_fseek(ByteIOContext *s, int64_t offset, int whence)

{

    int64_t offset1;

    int64_t pos;

    int force = whence & AVSEEK_FORCE;

    whence &= ~AVSEEK_FORCE;



    if(!s)

        return AVERROR(EINVAL);



    pos = s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));



    if (whence != SEEK_CUR && whence != SEEK_SET)

        return AVERROR(EINVAL);



    if (whence == SEEK_CUR) {

        offset1 = pos + (s->buf_ptr - s->buffer);

        if (offset == 0)

            return offset1;

        offset += offset1;

    }

    offset1 = offset - pos;

    if (!s->must_flush &&

        offset1 >= 0 && offset1 <= (s->buf_end - s->buffer)) {

        /* can do the seek inside the buffer */

        s->buf_ptr = s->buffer + offset1;

    } else if(s->is_streamed && !s->write_flag && offset1 >= 0 &&

              (whence != SEEK_END || force)) {

        while(s->pos < offset && !s->eof_reached)

            fill_buffer(s);

        if (s->eof_reached)

            return AVERROR_EOF;

        s->buf_ptr = s->buf_end + offset - s->pos;

    } else {

        int64_t res = AVERROR(EPIPE);



#if CONFIG_MUXERS || CONFIG_NETWORK

        if (s->write_flag) {

            flush_buffer(s);

            s->must_flush = 1;

        }

#endif /* CONFIG_MUXERS || CONFIG_NETWORK */

        if (!s->seek || (res = s->seek(s->opaque, offset, SEEK_SET)) < 0)

            return res;

        if (!s->write_flag)

            s->buf_end = s->buffer;

        s->buf_ptr = s->buffer;

        s->pos = offset;

    }

    s->eof_reached = 0;

    return offset;

}
 and probability:0.40425531914893614
code:int ff_listen_connect(int fd, const struct sockaddr *addr,

                      socklen_t addrlen, int timeout, URLContext *h)

{

    struct pollfd p = {fd, POLLOUT, 0};

    int ret;

    socklen_t optlen;



    ff_socket_nonblock(fd, 1);



    while ((ret = connect(fd, addr, addrlen))) {

        ret = ff_neterrno();

        switch (ret) {

        case AVERROR(EINTR):

            if (ff_check_interrupt(&h->interrupt_callback))

                return AVERROR_EXIT;

            continue;

        case AVERROR(EINPROGRESS):

        case AVERROR(EAGAIN):

            while (timeout--) {

                if (ff_check_interrupt(&h->interrupt_callback))

                    return AVERROR_EXIT;

                ret = poll(&p, 1, 100);

                if (ret > 0)

                    break;

            }

            if (ret <= 0)

                return AVERROR(ETIMEDOUT);

            optlen = sizeof(ret);

            if (getsockopt (fd, SOL_SOCKET, SO_ERROR, &ret, &optlen))

                ret = AVUNERROR(ff_neterrno());

            if (ret != 0) {

                char errbuf[100];

                ret = AVERROR(ret);

                av_strerror(ret, errbuf, sizeof(errbuf));

                av_log(h, AV_LOG_ERROR,

                       "Connection to %s failed: %s\n",

                       h->filename, errbuf);

            }

        default:

            return ret;

        }

    }

    return ret;

}
 and probability:0.09523809523809523
code:static int get_uint32_equal(QEMUFile *f, void *pv, size_t size)

{

    uint32_t *v = pv;

    uint32_t v2;

    qemu_get_be32s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
 and probability:0.1
code:int socket_dgram(SocketAddress *remote, SocketAddress *local, Error **errp)

{

    QemuOpts *opts;

    int fd;



    opts = qemu_opts_create_nofail(&socket_optslist);

    switch (remote->kind) {

    case SOCKET_ADDRESS_KIND_INET:

        qemu_opt_set(opts, "host", remote->inet->host);

        qemu_opt_set(opts, "port", remote->inet->port);

        if (local) {

            qemu_opt_set(opts, "localaddr", local->inet->host);

            qemu_opt_set(opts, "localport", local->inet->port);

        }

        fd = inet_dgram_opts(opts, errp);

        break;



    default:

        error_setg(errp, "socket type unsupported for datagram");

        return -1;

    }

    qemu_opts_del(opts);

    return fd;

}
 and probability:0.22727272727272727
code:static void cpu_common_initfn(Object *obj)

{

    CPUState *cpu = CPU(obj);

    CPUClass *cc = CPU_GET_CLASS(obj);



    cpu->cpu_index = UNASSIGNED_CPU_INDEX;

    cpu->gdb_num_regs = cpu->gdb_num_g_regs = cc->gdb_num_core_regs;

    /* *-user doesn't have configurable SMP topology */

    /* the default value is changed by qemu_init_vcpu() for softmmu */

    cpu->nr_cores = 1;

    cpu->nr_threads = 1;



    qemu_mutex_init(&cpu->work_mutex);

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);



    cpu->trace_dstate = bitmap_new(trace_get_vcpu_event_count());



    cpu_exec_initfn(cpu);

}
 and probability:0.5
code:static void read_sbr_single_channel_element(AACContext *ac,

                                            SpectralBandReplication *sbr,

                                            GetBitContext *gb)

{

    if (get_bits1(gb)) // bs_data_extra

        skip_bits(gb, 4); // bs_reserved



    read_sbr_grid(ac, sbr, gb, &sbr->data[0]);

    read_sbr_dtdf(sbr, gb, &sbr->data[0]);

    read_sbr_invf(sbr, gb, &sbr->data[0]);

    read_sbr_envelope(sbr, gb, &sbr->data[0], 0);

    read_sbr_noise(sbr, gb, &sbr->data[0], 0);



    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))

        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);

}
 and probability:0.5
code:static int GLZWDecode(GifState * s, uint8_t * buf, int len)

{

    int l, c, code, oc, fc;

    uint8_t *sp;



    if (s->end_code < 0)

        return 0;



    l = len;

    sp = s->sp;

    oc = s->oc;

    fc = s->fc;



    while (sp > s->stack) {

        *buf++ = *(--sp);

        if ((--l) == 0)

            goto the_end;

    }



    for (;;) {

        c = GetCode(s);

        if (c == s->end_code) {

            s->end_code = -1;

            break;

        } else if (c == s->clear_code) {

            s->cursize = s->codesize + 1;

            s->curmask = mask[s->cursize];

            s->slot = s->newcodes;

            s->top_slot = 1 << s->cursize;

            while ((c = GetCode(s)) == s->clear_code);

            if (c == s->end_code) {

                s->end_code = -1;

                break;

            }

            /* test error */

            if (c >= s->slot)

                c = 0;

            fc = oc = c;

            *buf++ = c;

            if ((--l) == 0)

                break;

        } else {

            code = c;

            if (code >= s->slot) {

                *sp++ = fc;

                code = oc;

            }

            while (code >= s->newcodes) {

                *sp++ = s->suffix[code];

                code = s->prefix[code];

            }

            *sp++ = code;

            if (s->slot < s->top_slot) {

                s->suffix[s->slot] = fc = code;

                s->prefix[s->slot++] = oc;

                oc = c;

            }

            if (s->slot >= s->top_slot) {

                if (s->cursize < MAXBITS) {

                    s->top_slot <<= 1;

                    s->curmask = mask[++s->cursize];

                }

            }

            while (sp > s->stack) {

                *buf++ = *(--sp);

                if ((--l) == 0)

                    goto the_end;

            }

        }

    }

  the_end:

    s->sp = sp;

    s->oc = oc;

    s->fc = fc;

    return len - l;

}
 and probability:0.5555555555555556
code:bool throttle_is_valid(ThrottleConfig *cfg, Error **errp)
{
    int i;
    bool bps_flag, ops_flag;
    bool bps_max_flag, ops_max_flag;
    bps_flag = cfg->buckets[THROTTLE_BPS_TOTAL].avg &&
               (cfg->buckets[THROTTLE_BPS_READ].avg ||
                cfg->buckets[THROTTLE_BPS_WRITE].avg);
    ops_flag = cfg->buckets[THROTTLE_OPS_TOTAL].avg &&
               (cfg->buckets[THROTTLE_OPS_READ].avg ||
                cfg->buckets[THROTTLE_OPS_WRITE].avg);
    bps_max_flag = cfg->buckets[THROTTLE_BPS_TOTAL].max &&
                  (cfg->buckets[THROTTLE_BPS_READ].max  ||
                   cfg->buckets[THROTTLE_BPS_WRITE].max);
    ops_max_flag = cfg->buckets[THROTTLE_OPS_TOTAL].max &&
                   (cfg->buckets[THROTTLE_OPS_READ].max ||
                   cfg->buckets[THROTTLE_OPS_WRITE].max);
    if (bps_flag || ops_flag || bps_max_flag || ops_max_flag) {
        error_setg(errp, "bps/iops/max total values and read/write values"
                   " cannot be used at the same time");
    if (cfg->op_size &&
        !cfg->buckets[THROTTLE_OPS_TOTAL].avg &&
        !cfg->buckets[THROTTLE_OPS_READ].avg &&
        !cfg->buckets[THROTTLE_OPS_WRITE].avg) {
        error_setg(errp, "iops size requires an iops value to be set");
    for (i = 0; i < BUCKETS_COUNT; i++) {
        LeakyBucket *bkt = &cfg->buckets[i];
        if (bkt->avg > THROTTLE_VALUE_MAX || bkt->max > THROTTLE_VALUE_MAX) {
            error_setg(errp, "bps/iops/max values must be within [0, %lld]",
                       THROTTLE_VALUE_MAX);
        if (!bkt->burst_length) {
            error_setg(errp, "the burst length cannot be 0");
        if (bkt->burst_length > 1 && !bkt->max) {
            error_setg(errp, "burst length set without burst rate");
        if (bkt->max && !bkt->avg) {
            error_setg(errp, "bps_max/iops_max require corresponding"
                       " bps/iops values");
        if (bkt->max && bkt->max < bkt->avg) {
            error_setg(errp, "bps_max/iops_max cannot be lower than bps/iops");
    return true; and probability:0.575
code:static void put_ebml_uint(ByteIOContext *pb, unsigned int elementid, uint64_t val)

{

    int i, bytes = 1;

    while (val >> bytes*8 && bytes < 8) bytes++;



    put_ebml_id(pb, elementid);

    put_ebml_num(pb, bytes, 0);

    for (i = bytes - 1; i >= 0; i--)

        put_byte(pb, val >> i*8);

}
 and probability:0.3333333333333333
code:PCIBus *pci_grackle_init(uint32_t base, qemu_irq *pic)

{

    DeviceState *dev;

    SysBusDevice *s;

    GrackleState *d;



    dev = qdev_create(NULL, "grackle");

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    d = FROM_SYSBUS(GrackleState, s);

    d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci",

                                         pci_grackle_set_irq,

                                         pci_grackle_map_irq,

                                         pic, 0, 4);



    pci_create_simple(d->host_state.bus, 0, "grackle");



    sysbus_mmio_map(s, 0, base);

    sysbus_mmio_map(s, 1, base + 0x00200000);



    return d->host_state.bus;

}
 and probability:0.2222222222222222
code:static void xan_unpack(unsigned char *dest, const unsigned char *src, int dest_len)

{

    unsigned char opcode;

    int size;

    unsigned char *dest_end = dest + dest_len;



    while (dest < dest_end) {

        opcode = *src++;



        if (opcode < 0xe0) {

            int size2, back;

            if ( (opcode & 0x80) == 0 ) {



                size = opcode & 3;



                back  = ((opcode & 0x60) << 3) + *src++ + 1;

                size2 = ((opcode & 0x1c) >> 2) + 3;



            } else if ( (opcode & 0x40) == 0 ) {



                size = *src >> 6;



                back  = (bytestream_get_be16(&src) & 0x3fff) + 1;

                size2 = (opcode & 0x3f) + 4;



            } else {



                size = opcode & 3;



                back  = ((opcode & 0x10) << 12) + bytestream_get_be16(&src) + 1;

                size2 = ((opcode & 0x0c) <<  6) + *src++ + 5;

                if (size + size2 > dest_end - dest)

                    return;

            }

            memcpy(dest, src, size);  dest += size;  src += size;

            av_memcpy_backptr(dest, back, size2);

            dest += size2;

        } else {

            int finish = opcode >= 0xfc;

            size = finish ? opcode & 3 : ((opcode & 0x1f) << 2) + 4;



            memcpy(dest, src, size);  dest += size;  src += size;

            if (finish)

                return;

        }

    }

}
 and probability:0.3888888888888889
code:static int adx_decode_frame(AVCodecContext *avctx, void *data,

                            int *got_frame_ptr, AVPacket *avpkt)

{

    int buf_size        = avpkt->size;

    ADXContext *c       = avctx->priv_data;

    int16_t *samples;

    const uint8_t *buf  = avpkt->data;

    int num_blocks, ch, ret;



    if (c->eof) {

        *got_frame_ptr = 0;

        return buf_size;

    }



    if (!c->header_parsed && buf_size >= 2 && AV_RB16(buf) == 0x8000) {

        int header_size;

        if ((ret = avpriv_adx_decode_header(avctx, buf, buf_size, &header_size,

                                            c->coeff)) < 0) {

            av_log(avctx, AV_LOG_ERROR, "error parsing ADX header\n");

            return AVERROR_INVALIDDATA;

        }

        c->channels      = avctx->channels;

        c->header_parsed = 1;

        if (buf_size < header_size)

            return AVERROR_INVALIDDATA;

        buf      += header_size;

        buf_size -= header_size;

    }

    if (!c->header_parsed)

        return AVERROR_INVALIDDATA;



    /* calculate number of blocks in the packet */

    num_blocks = buf_size / (BLOCK_SIZE * c->channels);



    /* if the packet is not an even multiple of BLOCK_SIZE, check for an EOF

       packet */

    if (!num_blocks || buf_size % (BLOCK_SIZE * avctx->channels)) {

        if (buf_size >= 4 && (AV_RB16(buf) & 0x8000)) {

            c->eof = 1;

            *got_frame_ptr = 0;

            return avpkt->size;

        }

        return AVERROR_INVALIDDATA;

    }



    /* get output buffer */

    c->frame.nb_samples = num_blocks * BLOCK_SAMPLES;

    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");

        return ret;

    }

    samples = (int16_t *)c->frame.data[0];



    while (num_blocks--) {

        for (ch = 0; ch < c->channels; ch++) {

            if (adx_decode(c, samples + ch, buf, ch)) {

                c->eof = 1;

                buf = avpkt->data + avpkt->size;

                break;

            }

            buf_size -= BLOCK_SIZE;

            buf      += BLOCK_SIZE;

        }

        samples += BLOCK_SAMPLES * c->channels;

    }



    *got_frame_ptr   = 1;

    *(AVFrame *)data = c->frame;



    return buf - avpkt->data;

}
 and probability:0.49206349206349204
code:static inline void RENAME(bgr15ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)

{

	int i;

        assert(src1==src2);

	for(i=0; i<width; i++)

	{

		int d0= ((uint32_t*)src1)[i];



		int dl= (d0&0x03E07C1F);

		int dh= ((d0>>5)&0x03E0F81F);



		int dh2= (dh>>11) + (dh<<21);

		int d= dh2 + dl;



		int b= d&0x7F;

		int r= (d>>10)&0x7F;

		int g= d>>21;

		dstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1-3)) + 128;

		dstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1-3)) + 128;

	}

}
 and probability:0.3333333333333333
code:static int matroska_parse_cluster_incremental(MatroskaDemuxContext *matroska)

{

    EbmlList *blocks_list;

    MatroskaBlock *blocks;

    int i, res;

    res = ebml_parse(matroska,

                     matroska_cluster_incremental_parsing,

                     &matroska->current_cluster);

    if (res == 1) {

        /* New Cluster */

        if (matroska->current_cluster_pos)

            ebml_level_end(matroska);

        ebml_free(matroska_cluster, &matroska->current_cluster);

        memset(&matroska->current_cluster, 0, sizeof(MatroskaCluster));

        matroska->current_cluster_num_blocks = 0;

        matroska->current_cluster_pos = avio_tell(matroska->ctx->pb);

        matroska->prev_pkt = NULL;

        /* sizeof the ID which was already read */

        if (matroska->current_id)

            matroska->current_cluster_pos -= 4;

        res = ebml_parse(matroska,

                         matroska_clusters_incremental,

                         &matroska->current_cluster);

        /* Try parsing the block again. */

        if (res == 1)

            res = ebml_parse(matroska,

                             matroska_cluster_incremental_parsing,

                             &matroska->current_cluster);

    }



    if (!res &&

        matroska->current_cluster_num_blocks <

            matroska->current_cluster.blocks.nb_elem) {

        blocks_list = &matroska->current_cluster.blocks;

        blocks = blocks_list->elem;



        matroska->current_cluster_num_blocks = blocks_list->nb_elem;

        i = blocks_list->nb_elem - 1;

        if (blocks[i].bin.size > 0 && blocks[i].bin.data) {

            int is_keyframe = blocks[i].non_simple ? !blocks[i].reference : -1;

            uint8_t* additional = blocks[i].additional.size > 0 ?

                                    blocks[i].additional.data : NULL;

            if (!blocks[i].non_simple)

                blocks[i].duration = 0;

            res = matroska_parse_block(matroska,

                                       blocks[i].bin.data, blocks[i].bin.size,

                                       blocks[i].bin.pos,

                                       matroska->current_cluster.timecode,

                                       blocks[i].duration, is_keyframe,

                                       additional, blocks[i].additional_id,

                                       blocks[i].additional.size,

                                       matroska->current_cluster_pos);

        }

    }



    if (res < 0)  matroska->done = 1;

    return res;

}
 and probability:0.5636363636363636
code:static int cache_read(URLContext *h, unsigned char *buf, int size)

{

    Context *c= h->priv_data;

    CacheEntry *entry, *next[2] = {NULL, NULL};

    int r;



    entry = av_tree_find(c->root, &c->logical_pos, cmp, (void**)next);



    if (!entry)

        entry = next[0];



    if (entry) {

        int64_t in_block_pos = c->logical_pos - entry->logical_pos;

        av_assert0(entry->logical_pos <= c->logical_pos);

        if (in_block_pos < entry->size) {

            int64_t physical_target = entry->physical_pos + in_block_pos;



            if (c->cache_pos != physical_target) {

                r = lseek(c->fd, physical_target, SEEK_SET);

            } else

                r = c->cache_pos;



            if (r >= 0) {

                c->cache_pos = r;

                r = read(c->fd, buf, FFMIN(size, entry->size - in_block_pos));

            }



            if (r > 0) {

                c->cache_pos += r;

                c->logical_pos += r;

                c->cache_hit ++;

                return r;

            }

        }

    }



    // Cache miss or some kind of fault with the cache



    if (c->logical_pos != c->inner_pos) {

        r = ffurl_seek(c->inner, c->logical_pos, SEEK_SET);

        if (r<0) {

            av_log(h, AV_LOG_ERROR, "Failed to perform internal seek\n");

            return r;

        }

        c->inner_pos = r;

    }



    r = ffurl_read(c->inner, buf, size);

    if (r == 0 && size>0) {

        c->is_true_eof = 1;

        av_assert0(c->end >= c->logical_pos);

    }

    if (r<=0)

        return r;

    c->inner_pos += r;



    c->cache_miss ++;



    add_entry(h, buf, r);

    c->logical_pos += r;

    c->end = FFMAX(c->end, c->logical_pos);



    return r;

}
 and probability:0.4807692307692308
code:const AVOption *av_opt_find(void *obj, const char *name, const char *unit,

                            int opt_flags, int search_flags)

{

    AVClass *c = *(AVClass**)obj;

    const AVOption *o = NULL;



    if (c->opt_find && search_flags & AV_OPT_SEARCH_CHILDREN &&

        (o = c->opt_find(obj, name, unit, opt_flags, search_flags)))

        return o;



    while (o = av_next_option(obj, o)) {

        if (!strcmp(o->name, name) && (!unit || (o->unit && !strcmp(o->unit, unit))) &&

            (o->flags & opt_flags) == opt_flags)

            return o;

    }

    return NULL;

}
 and probability:0.3333333333333333
code:static int vcr1_decode_frame(AVCodecContext *avctx, void *data,

                             int *got_frame, AVPacket *avpkt)

{

    VCR1Context *const a      = avctx->priv_data;

    AVFrame *const p          = data;

    const uint8_t *bytestream = avpkt->data;

    const uint8_t *bytestream_end = bytestream + avpkt->size;

    int i, x, y, ret;



    if(avpkt->size < 16 + avctx->height + avctx->width*avctx->height*5/8){

        av_log(avctx, AV_LOG_ERROR, "Insufficient input data.\n");

        return AVERROR(EINVAL);

    }



    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)

        return ret;

    p->pict_type = AV_PICTURE_TYPE_I;

    p->key_frame = 1;



    for (i = 0; i < 16; i++) {

        a->delta[i] = *bytestream++;

        bytestream++;

    }



    for (y = 0; y < avctx->height; y++) {

        int offset;

        uint8_t *luma = &p->data[0][y * p->linesize[0]];



        if ((y & 3) == 0) {

            uint8_t *cb = &p->data[1][(y >> 2) * p->linesize[1]];

            uint8_t *cr = &p->data[2][(y >> 2) * p->linesize[2]];



            av_assert0 (bytestream_end - bytestream >= 4 + avctx->width);



            for (i = 0; i < 4; i++)

                a->offset[i] = *bytestream++;



            offset = a->offset[0] - a->delta[bytestream[2] & 0xF];

            for (x = 0; x < avctx->width; x += 4) {

                luma[0]     = offset += a->delta[bytestream[2] & 0xF];

                luma[1]     = offset += a->delta[bytestream[2] >>  4];

                luma[2]     = offset += a->delta[bytestream[0] & 0xF];

                luma[3]     = offset += a->delta[bytestream[0] >>  4];

                luma       += 4;



                *cb++       = bytestream[3];

                *cr++       = bytestream[1];



                bytestream += 4;

            }

        } else {

            av_assert0 (bytestream_end - bytestream >= avctx->width / 2);



            offset = a->offset[y & 3] - a->delta[bytestream[2] & 0xF];



            for (x = 0; x < avctx->width; x += 8) {

                luma[0]     = offset += a->delta[bytestream[2] & 0xF];

                luma[1]     = offset += a->delta[bytestream[2] >>  4];

                luma[2]     = offset += a->delta[bytestream[3] & 0xF];

                luma[3]     = offset += a->delta[bytestream[3] >>  4];

                luma[4]     = offset += a->delta[bytestream[0] & 0xF];

                luma[5]     = offset += a->delta[bytestream[0] >>  4];

                luma[6]     = offset += a->delta[bytestream[1] & 0xF];

                luma[7]     = offset += a->delta[bytestream[1] >>  4];

                luma       += 8;

                bytestream += 4;

            }

        }

    }



    *got_frame = 1;



    return bytestream - avpkt->data;

}
 and probability:0.6833333333333333
code:static void fill_slice_long(AVCodecContext *avctx, DXVA_Slice_H264_Long *slice,

                            unsigned position, unsigned size)

{

    const H264Context *h = avctx->priv_data;

    struct dxva_context *ctx = avctx->hwaccel_context;

    unsigned list;



    memset(slice, 0, sizeof(*slice));

    slice->BSNALunitDataLocation = position;

    slice->SliceBytesInBuffer    = size;

    slice->wBadSliceChopping     = 0;



    slice->first_mb_in_slice     = (h->mb_y >> FIELD_OR_MBAFF_PICTURE(h)) * h->mb_width + h->mb_x;

    slice->NumMbsForSlice        = 0; /* XXX it is set once we have all slices */

    slice->BitOffsetToSliceData  = get_bits_count(&h->gb);

    slice->slice_type            = ff_h264_get_slice_type(h);

    if (h->slice_type_fixed)

        slice->slice_type += 5;

    slice->luma_log2_weight_denom       = h->luma_log2_weight_denom;

    slice->chroma_log2_weight_denom     = h->chroma_log2_weight_denom;

    if (h->list_count > 0)

        slice->num_ref_idx_l0_active_minus1 = h->ref_count[0] - 1;

    if (h->list_count > 1)

        slice->num_ref_idx_l1_active_minus1 = h->ref_count[1] - 1;

    slice->slice_alpha_c0_offset_div2   = h->slice_alpha_c0_offset / 2;

    slice->slice_beta_offset_div2       = h->slice_beta_offset     / 2;

    slice->Reserved8Bits                = 0;



    for (list = 0; list < 2; list++) {

        unsigned i;

        for (i = 0; i < FF_ARRAY_ELEMS(slice->RefPicList[list]); i++) {

            if (list < h->list_count && i < h->ref_count[list]) {

                const Picture *r = &h->ref_list[list][i];

                unsigned plane;

                fill_picture_entry(&slice->RefPicList[list][i],

                                   ff_dxva2_get_surface_index(ctx, r),

                                   r->reference == PICT_BOTTOM_FIELD);

                for (plane = 0; plane < 3; plane++) {

                    int w, o;

                    if (plane == 0 && h->luma_weight_flag[list]) {

                        w = h->luma_weight[i][list][0];

                        o = h->luma_weight[i][list][1];

                    } else if (plane >= 1 && h->chroma_weight_flag[list]) {

                        w = h->chroma_weight[i][list][plane-1][0];

                        o = h->chroma_weight[i][list][plane-1][1];

                    } else {

                        w = 1 << (plane == 0 ? h->luma_log2_weight_denom :

                                               h->chroma_log2_weight_denom);

                        o = 0;

                    }

                    slice->Weights[list][i][plane][0] = w;

                    slice->Weights[list][i][plane][1] = o;

                }

            } else {

                unsigned plane;

                slice->RefPicList[list][i].bPicEntry = 0xff;

                for (plane = 0; plane < 3; plane++) {

                    slice->Weights[list][i][plane][0] = 0;

                    slice->Weights[list][i][plane][1] = 0;

                }

            }

        }

    }

    slice->slice_qs_delta    = 0; /* XXX not implemented by FFmpeg */

    slice->slice_qp_delta    = h->qscale - h->pps.init_qp;

    slice->redundant_pic_cnt = h->redundant_pic_count;

    if (h->slice_type == AV_PICTURE_TYPE_B)

        slice->direct_spatial_mv_pred_flag = h->direct_spatial_mv_pred;

    slice->cabac_init_idc = h->pps.cabac ? h->cabac_init_idc : 0;

    if (h->deblocking_filter < 2)

        slice->disable_deblocking_filter_idc = 1 - h->deblocking_filter;

    else

        slice->disable_deblocking_filter_idc = h->deblocking_filter;

    slice->slice_id = h->current_slice - 1;

}
 and probability:0.7222222222222222
code:static char* mpjpeg_get_boundary(AVIOContext* pb)

{

    uint8_t *mime_type = NULL;

    const char *start;

    const char *end;

    uint8_t *res = NULL;

    int     len;



    /* get MIME type, and skip to the first parameter */

    av_opt_get(pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &mime_type);

    start = mime_type;

    while (start != NULL && *start != '\0') {

        start = strchr(start, ';');

        if (start)

            start = start+1;



        while (av_isspace(*start))

            start++;



        if (!av_stristart(start, "boundary=", &start)) {

            end = strchr(start, ';');

            if (end)

                len = end - start - 1;

            else

                len = strlen(start);

            res = av_strndup(start, len);

            break;

        }

    }



    av_freep(&mime_type);

    return res;

}
 and probability:0.20689655172413793
code:static void estimate_timings_from_pts(AVFormatContext *ic, int64_t old_offset)

{

    AVPacket pkt1, *pkt = &pkt1;

    AVStream *st;

    int read_size, i, ret;

    int64_t end_time;

    int64_t filesize, offset, duration;

    int retry = 0;



    /* flush packet queue */

    flush_packet_queue(ic);



    for (i = 0; i < ic->nb_streams; i++) {

        st = ic->streams[i];

        if (st->start_time == AV_NOPTS_VALUE &&

            st->first_dts == AV_NOPTS_VALUE &&

            st->codec->codec_type != AVMEDIA_TYPE_UNKNOWN)

            av_log(st->codec, AV_LOG_WARNING,

                   "start time for stream %d is not set in estimate_timings_from_pts\n", i);



        if (st->parser) {

            av_parser_close(st->parser);

            st->parser = NULL;

        }

    }



    /* estimate the end time (duration) */

    /* XXX: may need to support wrapping */

    filesize = ic->pb ? avio_size(ic->pb) : 0;

    end_time = AV_NOPTS_VALUE;

    do {

        offset = filesize - (DURATION_MAX_READ_SIZE << retry);

        if (offset < 0)

            offset = 0;



        avio_seek(ic->pb, offset, SEEK_SET);

        read_size = 0;

        for (;;) {

            if (read_size >= DURATION_MAX_READ_SIZE << (FFMAX(retry - 1, 0)))

                break;



            do {

                ret = ff_read_packet(ic, pkt);

            } while (ret == AVERROR(EAGAIN));

            if (ret != 0)

                break;

            read_size += pkt->size;

            st         = ic->streams[pkt->stream_index];

            if (pkt->pts != AV_NOPTS_VALUE &&

                (st->start_time != AV_NOPTS_VALUE ||

                 st->first_dts  != AV_NOPTS_VALUE)) {

                duration = end_time = pkt->pts + pkt->duration;

                if (st->start_time != AV_NOPTS_VALUE)

                    duration -= st->start_time;

                else

                    duration -= st->first_dts;

                if (duration > 0) {

                    if (st->duration == AV_NOPTS_VALUE || st->info->last_duration<= 0 ||

                        (st->duration < duration && FFABS(duration - st->info->last_duration) < 60LL*st->time_base.den / st->time_base.num))

                        st->duration = duration;

                    st->info->last_duration = duration;

                }

            }

            av_free_packet(pkt);

        }

    } while (end_time == AV_NOPTS_VALUE &&

             filesize > (DURATION_MAX_READ_SIZE << retry) &&

             ++retry <= DURATION_MAX_RETRY);



    /* warn about audio/video streams which duration could not be estimated */

    for (i = 0; i < ic->nb_streams; i++) {

        st = ic->streams[i];

        if (st->duration == AV_NOPTS_VALUE) {

            switch (st->codec->codec_type) {

            case AVMEDIA_TYPE_VIDEO:

            case AVMEDIA_TYPE_AUDIO:

                if (st->start_time != AV_NOPTS_VALUE || st->first_dts  != AV_NOPTS_VALUE) {

                    av_log(ic, AV_LOG_DEBUG, "stream %d : no PTS found at end of file, duration not set\n", i);

                } else

                    av_log(ic, AV_LOG_DEBUG, "stream %d : no TS found at start of file, duration not set\n", i);

            }

        }

    }

    fill_all_stream_timings(ic);



    avio_seek(ic->pb, old_offset, SEEK_SET);

    for (i = 0; i < ic->nb_streams; i++) {

        int j;



        st              = ic->streams[i];

        st->cur_dts     = st->first_dts;

        st->last_IP_pts = AV_NOPTS_VALUE;

        st->last_dts_for_order_check = AV_NOPTS_VALUE;

        for (j = 0; j < MAX_REORDER_DELAY + 1; j++)

            st->pts_buffer[j] = AV_NOPTS_VALUE;

    }

}
 and probability:0.45454545454545453
code:int init_put_byte(ByteIOContext *s,

                  unsigned char *buffer,

                  int buffer_size,

                  int write_flag,

                  void *opaque,

                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),

                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),

                  int64_t (*seek)(void *opaque, int64_t offset, int whence))

{

    s->buffer = buffer;

    s->buffer_size = buffer_size;

    s->buf_ptr = buffer;

    url_resetbuf(s, write_flag ? URL_WRONLY : URL_RDONLY);

    s->opaque = opaque;

    s->write_packet = write_packet;

    s->read_packet = read_packet;

    s->seek = seek;

    s->pos = 0;

    s->must_flush = 0;

    s->eof_reached = 0;

    s->error = 0;

    s->is_streamed = 0;

    s->max_packet_size = 0;

    s->update_checksum= NULL;

    if(!read_packet && !write_flag){

        s->pos = buffer_size;

        s->buf_end = s->buffer + buffer_size;

    }

    s->read_pause = NULL;

    s->read_seek  = NULL;

    return 0;

}
 and probability:0.5625
code:static void vc1_decode_skip_blocks(VC1Context *v)

{

    MpegEncContext *s = &v->s;



    if (!v->s.last_picture.f.data[0])

        return;



    ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END);

    s->first_slice_line = 1;

    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {

        s->mb_x = 0;

        init_block_index(v);

        ff_update_block_index(s);

        memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);

        memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);

        memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);

        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);

        s->first_slice_line = 0;

    }

    s->pict_type = AV_PICTURE_TYPE_P;

}
 and probability:0.631578947368421
code:static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel,

                                     const float *coefs, const FFPsyWindowInfo *wi)

{

    AacPsyContext *pctx = (AacPsyContext*) ctx->model_priv_data;

    AacPsyChannel *pch  = &pctx->ch[channel];

    int start = 0;

    int i, w, g;

    float desired_bits, desired_pe, delta_pe, reduction, spread_en[128] = {0};

    float a = 0.0f, active_lines = 0.0f, norm_fac = 0.0f;

    float pe = pctx->chan_bitrate > 32000 ? 0.0f : FFMAX(50.0f, 100.0f - pctx->chan_bitrate * 100.0f / 32000.0f);

    const int      num_bands   = ctx->num_bands[wi->num_windows == 8];

    const uint8_t *band_sizes  = ctx->bands[wi->num_windows == 8];

    AacPsyCoeffs  *coeffs      = pctx->psy_coef[wi->num_windows == 8];

    const float avoid_hole_thr = wi->num_windows == 8 ? PSY_3GPP_AH_THR_SHORT : PSY_3GPP_AH_THR_LONG;



    //calculate energies, initial thresholds and related values - 5.4.2 "Threshold Calculation"

    for (w = 0; w < wi->num_windows*16; w += 16) {

        for (g = 0; g < num_bands; g++) {

            AacPsyBand *band = &pch->band[w+g];



            float form_factor = 0.0f;

            band->energy = 0.0f;

            for (i = 0; i < band_sizes[g]; i++) {

                band->energy += coefs[start+i] * coefs[start+i];

                form_factor  += sqrtf(fabs(coefs[start+i]));

            }

            band->thr      = band->energy * 0.001258925f;

            band->nz_lines = form_factor / powf(band->energy / band_sizes[g], 0.25f);



            start += band_sizes[g];

        }

    }

    //modify thresholds and energies - spread, threshold in quiet, pre-echo control

    for (w = 0; w < wi->num_windows*16; w += 16) {

        AacPsyBand *bands = &pch->band[w];



        //5.4.2.3 "Spreading" & 5.4.3 "Spreaded Energy Calculation"

        spread_en[0] = bands[0].energy;

        for (g = 1; g < num_bands; g++) {

            bands[g].thr   = FFMAX(bands[g].thr,    bands[g-1].thr * coeffs[g].spread_hi[0]);

            spread_en[w+g] = FFMAX(bands[g].energy, spread_en[w+g-1] * coeffs[g].spread_hi[1]);

        }

        for (g = num_bands - 2; g >= 0; g--) {

            bands[g].thr   = FFMAX(bands[g].thr,   bands[g+1].thr * coeffs[g].spread_low[0]);

            spread_en[w+g] = FFMAX(spread_en[w+g], spread_en[w+g+1] * coeffs[g].spread_low[1]);

        }

        //5.4.2.4 "Threshold in quiet"

        for (g = 0; g < num_bands; g++) {

            AacPsyBand *band = &bands[g];



            band->thr_quiet = band->thr = FFMAX(band->thr, coeffs[g].ath);

            //5.4.2.5 "Pre-echo control"

            if (!(wi->window_type[0] == LONG_STOP_SEQUENCE || (wi->window_type[1] == LONG_START_SEQUENCE && !w)))

                band->thr = FFMAX(PSY_3GPP_RPEMIN*band->thr, FFMIN(band->thr,

                                  PSY_3GPP_RPELEV*pch->prev_band[w+g].thr_quiet));



            /* 5.6.1.3.1 "Prepatory steps of the perceptual entropy calculation" */

            pe += calc_pe_3gpp(band);

            a  += band->pe_const;

            active_lines += band->active_lines;



            /* 5.6.1.3.3 "Selection of the bands for avoidance of holes" */

            if (spread_en[w+g] * avoid_hole_thr > band->energy || coeffs[g].min_snr > 1.0f)

                band->avoid_holes = PSY_3GPP_AH_NONE;

            else

                band->avoid_holes = PSY_3GPP_AH_INACTIVE;

        }

    }



    /* 5.6.1.3.2 "Calculation of the desired perceptual entropy" */

    ctx->ch[channel].entropy = pe;

    desired_bits = calc_bit_demand(pctx, pe, ctx->bitres.bits, ctx->bitres.size, wi->num_windows == 8);

    desired_pe = PSY_3GPP_BITS_TO_PE(desired_bits);

    /* NOTE: PE correction is kept simple. During initial testing it had very

     *       little effect on the final bitrate. Probably a good idea to come

     *       back and do more testing later.

     */

    if (ctx->bitres.bits > 0)

        desired_pe *= av_clipf(pctx->pe.previous / PSY_3GPP_BITS_TO_PE(ctx->bitres.bits),

                               0.85f, 1.15f);

    pctx->pe.previous = PSY_3GPP_BITS_TO_PE(desired_bits);



    if (desired_pe < pe) {

        /* 5.6.1.3.4 "First Estimation of the reduction value" */

        for (w = 0; w < wi->num_windows*16; w += 16) {

            reduction = calc_reduction_3gpp(a, desired_pe, pe, active_lines);

            pe = 0.0f;

            a  = 0.0f;

            active_lines = 0.0f;

            for (g = 0; g < num_bands; g++) {

                AacPsyBand *band = &pch->band[w+g];



                band->thr = calc_reduced_thr_3gpp(band, coeffs[g].min_snr, reduction);

                /* recalculate PE */

                pe += calc_pe_3gpp(band);

                a  += band->pe_const;

                active_lines += band->active_lines;

            }

        }



        /* 5.6.1.3.5 "Second Estimation of the reduction value" */

        for (i = 0; i < 2; i++) {

            float pe_no_ah = 0.0f, desired_pe_no_ah;

            active_lines = a = 0.0f;

            for (w = 0; w < wi->num_windows*16; w += 16) {

                for (g = 0; g < num_bands; g++) {

                    AacPsyBand *band = &pch->band[w+g];



                    if (band->avoid_holes != PSY_3GPP_AH_ACTIVE) {

                        pe_no_ah += band->pe;

                        a        += band->pe_const;

                        active_lines += band->active_lines;

                    }

                }

            }

            desired_pe_no_ah = FFMAX(desired_pe - (pe - pe_no_ah), 0.0f);

            if (active_lines > 0.0f)

                reduction += calc_reduction_3gpp(a, desired_pe_no_ah, pe_no_ah, active_lines);



            pe = 0.0f;

            for (w = 0; w < wi->num_windows*16; w += 16) {

                for (g = 0; g < num_bands; g++) {

                    AacPsyBand *band = &pch->band[w+g];



                    if (active_lines > 0.0f)

                        band->thr = calc_reduced_thr_3gpp(band, coeffs[g].min_snr, reduction);

                    pe += calc_pe_3gpp(band);

                    band->norm_fac = band->active_lines / band->thr;

                    norm_fac += band->norm_fac;

                }

            }

            delta_pe = desired_pe - pe;

            if (fabs(delta_pe) > 0.05f * desired_pe)

                break;

        }



        if (pe < 1.15f * desired_pe) {

            /* 6.6.1.3.6 "Final threshold modification by linearization" */

            norm_fac = 1.0f / norm_fac;

            for (w = 0; w < wi->num_windows*16; w += 16) {

                for (g = 0; g < num_bands; g++) {

                    AacPsyBand *band = &pch->band[w+g];



                    if (band->active_lines > 0.5f) {

                        float delta_sfb_pe = band->norm_fac * norm_fac * delta_pe;

                        float thr = band->thr;



                        thr *= powf(2.0f, delta_sfb_pe / band->active_lines);

                        if (thr > coeffs[g].min_snr * band->energy && band->avoid_holes == PSY_3GPP_AH_INACTIVE)

                            thr = FFMAX(band->thr, coeffs[g].min_snr * band->energy);

                        band->thr = thr;

                    }

                }

            }

        } else {

            /* 5.6.1.3.7 "Further perceptual entropy reduction" */

            g = num_bands;

            while (pe > desired_pe && g--) {

                for (w = 0; w < wi->num_windows*16; w+= 16) {

                    AacPsyBand *band = &pch->band[w+g];

                    if (band->avoid_holes != PSY_3GPP_AH_NONE && coeffs[g].min_snr < PSY_SNR_1DB) {

                        coeffs[g].min_snr = PSY_SNR_1DB;

                        band->thr = band->energy * PSY_SNR_1DB;

                        pe += band->active_lines * 1.5f - band->pe;

                    }

                }

            }

            /* TODO: allow more holes (unused without mid/side) */

        }

    }



    for (w = 0; w < wi->num_windows*16; w += 16) {

        for (g = 0; g < num_bands; g++) {

            AacPsyBand *band     = &pch->band[w+g];

            FFPsyBand  *psy_band = &ctx->ch[channel].psy_bands[w+g];



            psy_band->threshold = band->thr;

            psy_band->energy    = band->energy;

        }

    }



    memcpy(pch->prev_band, pch->band, sizeof(pch->band));

}
 and probability:0.5828220858895705
code:decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,

                        int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3],

                        unsigned (*eob)[6][2], uint8_t (*p)[6][11],

                        int nnz, const int16_t *scan, const int16_t (*nb)[2],

                        const int16_t *band_counts, const int16_t *qmul)

{

    int i = 0, band = 0, band_left = band_counts[band];

    uint8_t *tp = p[0][nnz];

    uint8_t cache[1024];



    do {

        int val, rc;



        val = vp56_rac_get_prob_branchy(c, tp[0]); // eob

        eob[band][nnz][val]++;

        if (!val)

            break;



skip_eob:

        if (!vp56_rac_get_prob_branchy(c, tp[1])) { // zero

            cnt[band][nnz][0]++;

            if (!--band_left)

                band_left = band_counts[++band];

            cache[scan[i]] = 0;

            nnz            = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;

            tp             = p[band][nnz];

            if (++i == n_coeffs)

                break;  //invalid input; blocks should end with EOB

            goto skip_eob;

        }



        rc = scan[i];

        if (!vp56_rac_get_prob_branchy(c, tp[2])) { // one

            cnt[band][nnz][1]++;

            val       = 1;

            cache[rc] = 1;

        } else {

            // fill in p[3-10] (model fill) - only once per frame for each pos

            if (!tp[3])

                memcpy(&tp[3], ff_vp9_model_pareto8[tp[2]], 8);



            cnt[band][nnz][2]++;

            if (!vp56_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4

                if (!vp56_rac_get_prob_branchy(c, tp[4])) {

                    cache[rc] = val = 2;

                } else {

                    val       = 3 + vp56_rac_get_prob(c, tp[5]);

                    cache[rc] = 3;

                }

            } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { // cat1/2

                cache[rc] = 4;

                if (!vp56_rac_get_prob_branchy(c, tp[7])) {

                    val  =  vp56_rac_get_prob(c, 159) + 5;

                } else {

                    val  = (vp56_rac_get_prob(c, 165) << 1) + 7;

                    val +=  vp56_rac_get_prob(c, 145);

                }

            } else { // cat 3-6

                cache[rc] = 5;

                if (!vp56_rac_get_prob_branchy(c, tp[8])) {

                    if (!vp56_rac_get_prob_branchy(c, tp[9])) {

                        val  = 11 + (vp56_rac_get_prob(c, 173) << 2);

                        val +=      (vp56_rac_get_prob(c, 148) << 1);

                        val +=       vp56_rac_get_prob(c, 140);

                    } else {

                        val  = 19 + (vp56_rac_get_prob(c, 176) << 3);

                        val +=      (vp56_rac_get_prob(c, 155) << 2);

                        val +=      (vp56_rac_get_prob(c, 140) << 1);

                        val +=       vp56_rac_get_prob(c, 135);

                    }

                } else if (!vp56_rac_get_prob_branchy(c, tp[10])) {

                    val  = (vp56_rac_get_prob(c, 180) << 4) + 35;

                    val += (vp56_rac_get_prob(c, 157) << 3);

                    val += (vp56_rac_get_prob(c, 141) << 2);

                    val += (vp56_rac_get_prob(c, 134) << 1);

                    val +=  vp56_rac_get_prob(c, 130);

                } else {

                    val = 67;

                    if (!is8bitsperpixel) {

                        if (bpp == 12) {

                            val += vp56_rac_get_prob(c, 255) << 17;

                            val += vp56_rac_get_prob(c, 255) << 16;

                        }

                        val +=  (vp56_rac_get_prob(c, 255) << 15);

                        val +=  (vp56_rac_get_prob(c, 255) << 14);

                    }

                    val += (vp56_rac_get_prob(c, 254) << 13);

                    val += (vp56_rac_get_prob(c, 254) << 12);

                    val += (vp56_rac_get_prob(c, 254) << 11);

                    val += (vp56_rac_get_prob(c, 252) << 10);

                    val += (vp56_rac_get_prob(c, 249) << 9);

                    val += (vp56_rac_get_prob(c, 243) << 8);

                    val += (vp56_rac_get_prob(c, 230) << 7);

                    val += (vp56_rac_get_prob(c, 196) << 6);

                    val += (vp56_rac_get_prob(c, 177) << 5);

                    val += (vp56_rac_get_prob(c, 153) << 4);

                    val += (vp56_rac_get_prob(c, 140) << 3);

                    val += (vp56_rac_get_prob(c, 133) << 2);

                    val += (vp56_rac_get_prob(c, 130) << 1);

                    val +=  vp56_rac_get_prob(c, 129);

                }

            }

        }

#define STORE_COEF(c, i, v) do { \

    if (is8bitsperpixel) { \

        c[i] = v; \

    } else { \

        AV_WN32A(&c[i * 2], v); \

    } \

} while (0)

        if (!--band_left)

            band_left = band_counts[++band];

        if (is_tx32x32)

            STORE_COEF(coef, rc, ((vp8_rac_get(c) ? -val : val) * qmul[!!i]) / 2);

        else

            STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * qmul[!!i]);

        nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;

        tp = p[band][nnz];

    } while (++i < n_coeffs);



    return i;

}
 and probability:0.6724137931034483
code:static void set_pci_devfn(Object *obj, Visitor *v, void *opaque,

                          const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    uint32_t *ptr = qdev_get_prop_ptr(dev, prop);

    unsigned int slot, fn, n;

    Error *local_err = NULL;

    char *str = (char *)"";



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_str(v, &str, name, &local_err);

    if (local_err) {

        error_free(local_err);

        return set_int32(obj, v, opaque, name, errp);

    }



    if (sscanf(str, "%x.%x%n", &slot, &fn, &n) != 2) {

        fn = 0;

        if (sscanf(str, "%x%n", &slot, &n) != 1) {

            goto invalid;

        }

    }

    if (str[n] != '\0' || fn > 7 || slot > 31) {

        goto invalid;

    }

    *ptr = slot << 3 | fn;

    return;



invalid:

    error_set_from_qdev_prop_error(errp, EINVAL, dev, prop, str);

}
 and probability:0.09375
code:static void error_callback_bh(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co);

}
 and probability:0.0
code:void *colo_process_incoming_thread(void *opaque)

{

    MigrationIncomingState *mis = opaque;

    QEMUFile *fb = NULL;

    QIOChannelBuffer *bioc = NULL; /* Cache incoming device state */

    uint64_t total_size;

    uint64_t value;

    Error *local_err = NULL;



    migrate_set_state(&mis->state, MIGRATION_STATUS_ACTIVE,

                      MIGRATION_STATUS_COLO);



    failover_init_state();



    mis->to_src_file = qemu_file_get_return_path(mis->from_src_file);

    if (!mis->to_src_file) {

        error_report("COLO incoming thread: Open QEMUFile to_src_file failed");

        goto out;

    }

    /*

     * Note: the communication between Primary side and Secondary side

     * should be sequential, we set the fd to unblocked in migration incoming

     * coroutine, and here we are in the COLO incoming thread, so it is ok to

     * set the fd back to blocked.

     */

    qemu_file_set_blocking(mis->from_src_file, true);



    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);

    fb = qemu_fopen_channel_input(QIO_CHANNEL(bioc));

    object_unref(OBJECT(bioc));



    colo_send_message(mis->to_src_file, COLO_MESSAGE_CHECKPOINT_READY,

                      &local_err);

    if (local_err) {

        goto out;

    }



    while (mis->state == MIGRATION_STATUS_COLO) {

        int request;



        colo_wait_handle_message(mis->from_src_file, &request, &local_err);

        if (local_err) {

            goto out;

        }

        assert(request);

        if (failover_get_state() != FAILOVER_STATUS_NONE) {

            error_report("failover request");

            goto out;

        }



        /* FIXME: This is unnecessary for periodic checkpoint mode */

        colo_send_message(mis->to_src_file, COLO_MESSAGE_CHECKPOINT_REPLY,

                     &local_err);

        if (local_err) {

            goto out;

        }



        colo_receive_check_message(mis->from_src_file,

                           COLO_MESSAGE_VMSTATE_SEND, &local_err);

        if (local_err) {

            goto out;

        }



        value = colo_receive_message_value(mis->from_src_file,

                                 COLO_MESSAGE_VMSTATE_SIZE, &local_err);

        if (local_err) {

            goto out;

        }



        /*

         * Read VM device state data into channel buffer,

         * It's better to re-use the memory allocated.

         * Here we need to handle the channel buffer directly.

         */

        if (value > bioc->capacity) {

            bioc->capacity = value;

            bioc->data = g_realloc(bioc->data, bioc->capacity);

        }

        total_size = qemu_get_buffer(mis->from_src_file, bioc->data, value);

        if (total_size != value) {

            error_report("Got %" PRIu64 " VMState data, less than expected"

                        " %" PRIu64, total_size, value);

            goto out;

        }

        bioc->usage = total_size;

        qio_channel_io_seek(QIO_CHANNEL(bioc), 0, 0, NULL);



        colo_send_message(mis->to_src_file, COLO_MESSAGE_VMSTATE_RECEIVED,

                     &local_err);

        if (local_err) {

            goto out;

        }



        qemu_mutex_lock_iothread();

        qemu_system_reset(VMRESET_SILENT);

        if (qemu_loadvm_state(fb) < 0) {

            error_report("COLO: loadvm failed");

            qemu_mutex_unlock_iothread();

            goto out;

        }

        qemu_mutex_unlock_iothread();



        colo_send_message(mis->to_src_file, COLO_MESSAGE_VMSTATE_LOADED,

                     &local_err);

        if (local_err) {

            goto out;

        }

    }



out:

    /* Throw the unreported error message after exited from loop */

    if (local_err) {

        error_report_err(local_err);

    }



    if (fb) {

        qemu_fclose(fb);

    }



    if (mis->to_src_file) {

        qemu_fclose(mis->to_src_file);

    }

    migration_incoming_exit_colo();



    return NULL;

}
 and probability:0.17592592592592593
code:static int get_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_get_8s(f, v);

    return 0;

}
 and probability:0.0
code:static uint64_t virtio_pci_config_read(void *opaque, hwaddr addr,

                                       unsigned size)

{

    VirtIOPCIProxy *proxy = opaque;

    VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);

    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);

    uint64_t val = 0;

    if (addr < config) {

        return virtio_ioport_read(proxy, addr);

    }

    addr -= config;



    switch (size) {

    case 1:

        val = virtio_config_readb(vdev, addr);

        break;

    case 2:

        val = virtio_config_readw(vdev, addr);

        if (virtio_is_big_endian()) {

            val = bswap16(val);

        }

        break;

    case 4:

        val = virtio_config_readl(vdev, addr);

        if (virtio_is_big_endian()) {

            val = bswap32(val);

        }

        break;

    }

    return val;

}
 and probability:0.1
code:int net_init_socket(QemuOpts *opts, const char *name, VLANState *vlan)

{

    if (qemu_opt_get(opts, "fd")) {

        int fd;



        if (qemu_opt_get(opts, "listen") ||

            qemu_opt_get(opts, "connect") ||

            qemu_opt_get(opts, "mcast") ||

            qemu_opt_get(opts, "localaddr")) {

            error_report("listen=, connect=, mcast= and localaddr= is invalid with fd=");

            return -1;

        }



        fd = net_handle_fd_param(cur_mon, qemu_opt_get(opts, "fd"));

        if (fd == -1) {

            return -1;

        }



        if (!net_socket_fd_init(vlan, "socket", name, fd, 1)) {

            return -1;

        }

    } else if (qemu_opt_get(opts, "listen")) {

        const char *listen;



        if (qemu_opt_get(opts, "fd") ||

            qemu_opt_get(opts, "connect") ||

            qemu_opt_get(opts, "mcast") ||

            qemu_opt_get(opts, "localaddr")) {

            error_report("fd=, connect=, mcast= and localaddr= is invalid with listen=");

            return -1;

        }



        listen = qemu_opt_get(opts, "listen");



        if (net_socket_listen_init(vlan, "socket", name, listen) == -1) {

            return -1;

        }

    } else if (qemu_opt_get(opts, "connect")) {

        const char *connect;



        if (qemu_opt_get(opts, "fd") ||

            qemu_opt_get(opts, "listen") ||

            qemu_opt_get(opts, "mcast") ||

            qemu_opt_get(opts, "localaddr")) {

            error_report("fd=, listen=, mcast= and localaddr= is invalid with connect=");

            return -1;

        }



        connect = qemu_opt_get(opts, "connect");



        if (net_socket_connect_init(vlan, "socket", name, connect) == -1) {

            return -1;

        }

    } else if (qemu_opt_get(opts, "mcast")) {

        const char *mcast, *localaddr;



        if (qemu_opt_get(opts, "fd") ||

            qemu_opt_get(opts, "connect") ||

            qemu_opt_get(opts, "listen")) {

            error_report("fd=, connect= and listen= is invalid with mcast=");

            return -1;

        }



        mcast = qemu_opt_get(opts, "mcast");

        localaddr = qemu_opt_get(opts, "localaddr");



        if (net_socket_mcast_init(vlan, "socket", name, mcast, localaddr) == -1) {

            return -1;

        }

    } else if (qemu_opt_get(opts, "udp")) {

        const char *udp, *localaddr;



        if (qemu_opt_get(opts, "fd") ||

            qemu_opt_get(opts, "connect") ||

            qemu_opt_get(opts, "listen") ||

            qemu_opt_get(opts, "mcast")) {

            error_report("fd=, connect=, listen="

                         " and mcast= is invalid with udp=");

            return -1;

        }



        udp = qemu_opt_get(opts, "udp");

        localaddr = qemu_opt_get(opts, "localaddr");

        if (localaddr == NULL) {

                error_report("localaddr= is mandatory with udp=");

                return -1;

        }



        if (net_socket_udp_init(vlan, "udp", name, udp, localaddr) == -1) {

            return -1;

        }

    } else {

        error_report("-socket requires fd=, listen=,"

                     " connect=, mcast= or udp=");

        return -1;

    }

    return 0;

}
 and probability:0.0
code:static int dvvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *got_frame,

                                 AVPacket *avpkt)

{

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DVVideoContext *s = avctx->priv_data;

    const uint8_t* vsc_pack;

    int apt, is16_9, ret;

    const DVprofile *sys;



    sys = avpriv_dv_frame_profile2(avctx, s->sys, buf, buf_size);

    if (!sys || buf_size < sys->frame_size) {

        av_log(avctx, AV_LOG_ERROR, "could not find dv frame profile\n");

        return -1; /* NOTE: we only accept several full frames */

    }



    if (sys != s->sys) {

        ret = ff_dv_init_dynamic_tables(s, sys);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, "Error initializing the work tables.\n");

            return ret;

        }

        s->sys = sys;

    }



    s->frame            = data;

    s->frame->key_frame = 1;

    s->frame->pict_type = AV_PICTURE_TYPE_I;

    avctx->pix_fmt   = s->sys->pix_fmt;

    avctx->time_base = s->sys->time_base;



    ret = ff_set_dimensions(avctx, s->sys->width, s->sys->height);

    if (ret < 0)

        return ret;



    /* Determine the codec's sample_aspect ratio from the packet */

    vsc_pack = buf + 80*5 + 48 + 5;

    if ( *vsc_pack == dv_video_control ) {

        apt = buf[4] & 0x07;

        is16_9 = (vsc_pack && ((vsc_pack[2] & 0x07) == 0x02 || (!apt && (vsc_pack[2] & 0x07) == 0x07)));

        ff_set_sar(avctx, s->sys->sar[is16_9]);

    }



    if ((ret = ff_get_buffer(avctx, s->frame, 0)) < 0)

        return ret;

    s->frame->interlaced_frame = 1;

    s->frame->top_field_first  = 0;



    /* Determine the codec's field order from the packet */

    if ( *vsc_pack == dv_video_control ) {

        s->frame->top_field_first = !(vsc_pack[3] & 0x40);

    }



    s->buf = buf;

    avctx->execute(avctx, dv_decode_video_segment, s->work_chunks, NULL,

                   dv_work_pool_size(s->sys), sizeof(DVwork_chunk));



    emms_c();



    /* return image */

    *got_frame = 1;



    return s->sys->frame_size;

}
 and probability:0.5185185185185185
code:static int theora_decode_header(AVCodecContext *avctx, GetBitContext gb)

{

    Vp3DecodeContext *s = avctx->priv_data;



    s->theora = get_bits_long(&gb, 24);

    av_log(avctx, AV_LOG_INFO, "Theora bitstream version %X\n", s->theora);



    /* 3.2.0 aka alpha3 has the same frame orientation as original vp3 */

    /* but previous versions have the image flipped relative to vp3 */

    if (s->theora < 0x030200)

    {

        s->flipped_image = 1;

        av_log(avctx, AV_LOG_DEBUG, "Old (<alpha3) Theora bitstream, flipped image\n");

    }



    s->width = get_bits(&gb, 16) << 4;

    s->height = get_bits(&gb, 16) << 4;



    if(avcodec_check_dimensions(avctx, s->width, s->height)){

        av_log(avctx, AV_LOG_ERROR, "Invalid dimensions (%dx%d)\n", s->width, s->height);

        s->width= s->height= 0;

        return -1;

    }



    if (s->theora >= 0x030400)

    {

        skip_bits(&gb, 32); /* total number of superblocks in a frame */

        // fixme, the next field is 36bits long

        skip_bits(&gb, 32); /* total number of blocks in a frame */

        skip_bits(&gb, 4); /* total number of blocks in a frame */

        skip_bits(&gb, 32); /* total number of macroblocks in a frame */



        skip_bits(&gb, 24); /* frame width */

        skip_bits(&gb, 24); /* frame height */

    }

    else

    {

        skip_bits(&gb, 24); /* frame width */

        skip_bits(&gb, 24); /* frame height */

    }



    skip_bits(&gb, 8); /* offset x */

    skip_bits(&gb, 8); /* offset y */



    skip_bits(&gb, 32); /* fps numerator */

    skip_bits(&gb, 32); /* fps denumerator */

    skip_bits(&gb, 24); /* aspect numerator */

    skip_bits(&gb, 24); /* aspect denumerator */



    if (s->theora < 0x030200)

        skip_bits(&gb, 5); /* keyframe frequency force */

    skip_bits(&gb, 8); /* colorspace */

    if (s->theora >= 0x030400)

        skip_bits(&gb, 2); /* pixel format: 420,res,422,444 */

    skip_bits(&gb, 24); /* bitrate */



    skip_bits(&gb, 6); /* quality hint */



    if (s->theora >= 0x030200)

    {

        skip_bits(&gb, 5); /* keyframe frequency force */



        if (s->theora < 0x030400)

            skip_bits(&gb, 5); /* spare bits */

    }



//    align_get_bits(&gb);



    avctx->width = s->width;

    avctx->height = s->height;



    return 0;

}
 and probability:0.29310344827586204
code:static av_cold int init_buffers(SANMVideoContext *ctx)

{

    av_fast_padded_malloc(&ctx->frm0, &ctx->frm0_size, ctx->buf_size);

    av_fast_padded_malloc(&ctx->frm1, &ctx->frm1_size, ctx->buf_size);

    av_fast_padded_malloc(&ctx->frm2, &ctx->frm2_size, ctx->buf_size);

    if (!ctx->version)

        av_fast_padded_malloc(&ctx->stored_frame,

                              &ctx->stored_frame_size, ctx->buf_size);



    if (!ctx->frm0 || !ctx->frm1 || !ctx->frm2 ||

        (!ctx->stored_frame && !ctx->version)) {

        destroy_buffers(ctx);

        return AVERROR(ENOMEM);

    }



    return 0;

}
 and probability:0.5333333333333333
code:int unix_listen_opts(QemuOpts *opts)

{

    struct sockaddr_un un;

    const char *path = qemu_opt_get(opts, "path");

    int sock, fd;



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        perror("socket(unix)");

        return -1;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    if (path && strlen(path)) {

        snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);

    } else {

        char *tmpdir = getenv("TMPDIR");

        snprintf(un.sun_path, sizeof(un.sun_path), "%s/qemu-socket-XXXXXX",

                 tmpdir ? tmpdir : "/tmp");

        /*

         * This dummy fd usage silences the mktemp() unsecure warning.

         * Using mkstemp() doesn't make things more secure here

         * though.  bind() complains about existing files, so we have

         * to unlink first and thus re-open the race window.  The

         * worst case possible is bind() failing, i.e. a DoS attack.

         */

        fd = mkstemp(un.sun_path); close(fd);

        qemu_opt_set(opts, "path", un.sun_path);

    }



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, "bind(unix:%s): %s\n", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, "listen(unix:%s): %s\n", un.sun_path, strerror(errno));

        goto err;

    }



    if (sockets_debug)

        fprintf(stderr, "bind(unix:%s): OK\n", un.sun_path);

    return sock;



err:

    closesocket(sock);

    return -1;

}
 and probability:0.022727272727272728
code:static void bus_add_child(BusState *bus, DeviceState *child)

{

    char name[32];

    BusChild *kid = g_malloc0(sizeof(*kid));



    if (qdev_hotplug) {

        assert(bus->allow_hotplug);

    }



    kid->index = bus->max_index++;

    kid->child = child;

    object_ref(OBJECT(kid->child));



    QTAILQ_INSERT_HEAD(&bus->children, kid, sibling);



    /* This transfers ownership of kid->child to the property.  */

    snprintf(name, sizeof(name), "child[%d]", kid->index);

    object_property_add_link(OBJECT(bus), name,

                             object_get_typename(OBJECT(child)),

                             (Object **)&kid->child,

                             NULL);

}
 and probability:0.4444444444444444
code:build_ssdt(GArray *table_data, GArray *linker,

           AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc,

           PcPciInfo *pci, PcGuestInfo *guest_info)

{

    MachineState *machine = MACHINE(qdev_get_machine());

    uint32_t nr_mem = machine->ram_slots;

    unsigned acpi_cpus = guest_info->apic_id_limit;

    Aml *ssdt, *sb_scope, *scope, *pkg, *dev, *method, *crs, *field, *ifctx;

    PCIBus *bus = NULL;

    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    CrsRangeEntry *entry;

    int root_bus_limit = 0xFF;

    int i;



    ssdt = init_aml_allocator();

    /* The current AML generator can cover the APIC ID range [0..255],

     * inclusive, for VCPU hotplug. */

    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);

    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);



    /* Reserve space for header */

    acpi_data_push(ssdt->buf, sizeof(AcpiTableHeader));



    /* Extra PCI root buses are implemented  only for i440fx */

    bus = find_i440fx();

    if (bus) {

        QLIST_FOREACH(bus, &bus->child, sibling) {

            uint8_t bus_num = pci_bus_num(bus);

            uint8_t numa_node = pci_bus_numa_node(bus);



            /* look only for expander root buses */

            if (!pci_bus_is_root(bus)) {

                continue;

            }



            if (bus_num < root_bus_limit) {

                root_bus_limit = bus_num - 1;

            }



            scope = aml_scope("\\_SB");

            dev = aml_device("PC%.02X", bus_num);

            aml_append(dev, aml_name_decl("_UID", aml_int(bus_num)));

            aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A03")));

            aml_append(dev, aml_name_decl("_BBN", aml_int(bus_num)));



            if (numa_node != NUMA_NODE_UNASSIGNED) {

                aml_append(dev, aml_name_decl("_PXM", aml_int(numa_node)));

            }



            aml_append(dev, build_prt());

            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),

                            io_ranges, mem_ranges);

            aml_append(dev, aml_name_decl("_CRS", crs));

            aml_append(scope, dev);

            aml_append(ssdt, scope);

        }

    }



    scope = aml_scope("\\_SB.PCI0");

    /* build PCI0._CRS */

    crs = aml_resource_template();

    aml_append(crs,

        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,

                            0x0000, 0x0, root_bus_limit,

                            0x0000, root_bus_limit + 1));

    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));



    aml_append(crs,

        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                    AML_POS_DECODE, AML_ENTIRE_RANGE,

                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));



    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);

    for (i = 0; i < io_ranges->len; i++) {

        entry = g_ptr_array_index(io_ranges, i);

        aml_append(crs,

            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                        AML_POS_DECODE, AML_ENTIRE_RANGE,

                        0x0000, entry->base, entry->limit,

                        0x0000, entry->limit - entry->base + 1));

    }



    aml_append(crs,

        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                         AML_CACHEABLE, AML_READ_WRITE,

                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));



    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);

    for (i = 0; i < mem_ranges->len; i++) {

        entry = g_ptr_array_index(mem_ranges, i);

        aml_append(crs,

            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                             AML_NON_CACHEABLE, AML_READ_WRITE,

                             0, entry->base, entry->limit,

                             0, entry->limit - entry->base + 1));

    }



    if (pci->w64.begin) {

        aml_append(crs,

            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                             AML_CACHEABLE, AML_READ_WRITE,

                             0, pci->w64.begin, pci->w64.end - 1, 0,

                             pci->w64.end - pci->w64.begin));

    }

    aml_append(scope, aml_name_decl("_CRS", crs));



    /* reserve GPE0 block resources */

    dev = aml_device("GPE0");

    aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A06")));

    aml_append(dev, aml_name_decl("_UID", aml_string("GPE0 resources")));

    /* device present, functioning, decoding, not shown in UI */

    aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));

    crs = aml_resource_template();

    aml_append(crs,

        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)

    );

    aml_append(dev, aml_name_decl("_CRS", crs));

    aml_append(scope, dev);



    g_ptr_array_free(io_ranges, true);

    g_ptr_array_free(mem_ranges, true);



    /* reserve PCIHP resources */

    if (pm->pcihp_io_len) {

        dev = aml_device("PHPR");

        aml_append(dev, aml_name_decl("_HID", aml_string("PNP0A06")));

        aml_append(dev,

            aml_name_decl("_UID", aml_string("PCI Hotplug resources")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));

        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,

                   pm->pcihp_io_len)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));

        aml_append(scope, dev);

    }

    aml_append(ssdt, scope);



    /*  create S3_ / S4_ / S5_ packages if necessary */

    scope = aml_scope("\\");

    if (!pm->s3_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */

        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl("_S3", pkg));

    }



    if (!pm->s4_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */

        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(pm->s4_val));

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl("_S4", pkg));

    }



    pkg = aml_package(4);

    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */

    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(scope, aml_name_decl("_S5", pkg));

    aml_append(ssdt, scope);



    if (misc->applesmc_io_base) {

        scope = aml_scope("\\_SB.PCI0.ISA");

        dev = aml_device("SMC");



        aml_append(dev, aml_name_decl("_HID", aml_eisaid("APP0001")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,

                   0x01, APPLESMC_MAX_DATA_LENGTH)

        );

        aml_append(crs, aml_irq_no_flags(6));

        aml_append(dev, aml_name_decl("_CRS", crs));



        aml_append(scope, dev);

        aml_append(ssdt, scope);

    }



    if (misc->pvpanic_port) {

        scope = aml_scope("\\_SB.PCI0.ISA");



        dev = aml_device("PEVT");

        aml_append(dev, aml_name_decl("_HID", aml_string("QEMU0001")));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));



        aml_append(dev, aml_operation_region("PEOR", AML_SYSTEM_IO,

                                              misc->pvpanic_port, 1));

        field = aml_field("PEOR", AML_BYTE_ACC, AML_PRESERVE);

        aml_append(field, aml_named_field("PEPT", 8));

        aml_append(dev, field);



        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));



        method = aml_method("RDPT", 0);

        aml_append(method, aml_store(aml_name("PEPT"), aml_local(0)));

        aml_append(method, aml_return(aml_local(0)));

        aml_append(dev, method);



        method = aml_method("WRPT", 1);

        aml_append(method, aml_store(aml_arg(0), aml_name("PEPT")));

        aml_append(dev, method);



        aml_append(scope, dev);

        aml_append(ssdt, scope);

    }



    sb_scope = aml_scope("\\_SB");

    {

        /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */

        dev = aml_device("PCI0." stringify(CPU_HOTPLUG_RESOURCE_DEVICE));

        aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0A06")));

        aml_append(dev,

            aml_name_decl("_UID", aml_string("CPU Hotplug resources"))

        );

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl("_STA", aml_int(0xB)));

        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,

                   pm->cpu_hp_io_len)

        );

        aml_append(dev, aml_name_decl("_CRS", crs));

        aml_append(sb_scope, dev);

        /* declare CPU hotplug MMIO region and PRS field to access it */

        aml_append(sb_scope, aml_operation_region(

            "PRST", AML_SYSTEM_IO, pm->cpu_hp_io_base, pm->cpu_hp_io_len));

        field = aml_field("PRST", AML_BYTE_ACC, AML_PRESERVE);

        aml_append(field, aml_named_field("PRS", 256));

        aml_append(sb_scope, field);



        /* build Processor object for each processor */

        for (i = 0; i < acpi_cpus; i++) {

            dev = aml_processor(i, 0, 0, "CP%.02X", i);



            method = aml_method("_MAT", 0);

            aml_append(method, aml_return(aml_call1("CPMA", aml_int(i))));

            aml_append(dev, method);



            method = aml_method("_STA", 0);

            aml_append(method, aml_return(aml_call1("CPST", aml_int(i))));

            aml_append(dev, method);



            method = aml_method("_EJ0", 1);

            aml_append(method,

                aml_return(aml_call2("CPEJ", aml_int(i), aml_arg(0)))

            );

            aml_append(dev, method);



            aml_append(sb_scope, dev);

        }



        /* build this code:

         *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}

         */

        /* Arg0 = Processor ID = APIC ID */

        method = aml_method("NTFY", 2);

        for (i = 0; i < acpi_cpus; i++) {

            ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));

            aml_append(ifctx,

                aml_notify(aml_name("CP%.02X", i), aml_arg(1))

            );

            aml_append(method, ifctx);

        }

        aml_append(sb_scope, method);



        /* build "Name(CPON, Package() { One, One, ..., Zero, Zero, ... })"

         *

         * Note: The ability to create variable-sized packages was first

         * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages

         * ith up to 255 elements. Windows guests up to win2k8 fail when

         * VarPackageOp is used.

         */

        pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :

                                 aml_varpackage(acpi_cpus);



        for (i = 0; i < acpi_cpus; i++) {

            uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;

            aml_append(pkg, aml_int(b));

        }

        aml_append(sb_scope, aml_name_decl("CPON", pkg));



        /* build memory devices */

        assert(nr_mem <= ACPI_MAX_RAM_SLOTS);

        scope = aml_scope("\\_SB.PCI0." stringify(MEMORY_HOTPLUG_DEVICE));

        aml_append(scope,

            aml_name_decl(stringify(MEMORY_SLOTS_NUMBER), aml_int(nr_mem))

        );



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, pm->mem_hp_io_base, pm->mem_hp_io_base, 0,

                   pm->mem_hp_io_len)

        );

        aml_append(scope, aml_name_decl("_CRS", crs));



        aml_append(scope, aml_operation_region(

            stringify(MEMORY_HOTPLUG_IO_REGION), AML_SYSTEM_IO,

            pm->mem_hp_io_base, pm->mem_hp_io_len)

        );



        field = aml_field(stringify(MEMORY_HOTPLUG_IO_REGION), AML_DWORD_ACC,

                          AML_PRESERVE);

        aml_append(field, /* read only */

            aml_named_field(stringify(MEMORY_SLOT_ADDR_LOW), 32));

        aml_append(field, /* read only */

            aml_named_field(stringify(MEMORY_SLOT_ADDR_HIGH), 32));

        aml_append(field, /* read only */

            aml_named_field(stringify(MEMORY_SLOT_SIZE_LOW), 32));

        aml_append(field, /* read only */

            aml_named_field(stringify(MEMORY_SLOT_SIZE_HIGH), 32));

        aml_append(field, /* read only */

            aml_named_field(stringify(MEMORY_SLOT_PROXIMITY), 32));

        aml_append(scope, field);



        field = aml_field(stringify(MEMORY_HOTPLUG_IO_REGION), AML_BYTE_ACC,

                          AML_WRITE_AS_ZEROS);

        aml_append(field, aml_reserved_field(160 /* bits, Offset(20) */));

        aml_append(field, /* 1 if enabled, read only */

            aml_named_field(stringify(MEMORY_SLOT_ENABLED), 1));

        aml_append(field,

            /*(read) 1 if has a insert event. (write) 1 to clear event */

            aml_named_field(stringify(MEMORY_SLOT_INSERT_EVENT), 1));

        aml_append(field,

            /* (read) 1 if has a remove event. (write) 1 to clear event */

            aml_named_field(stringify(MEMORY_SLOT_REMOVE_EVENT), 1));

        aml_append(field,

            /* initiates device eject, write only */

            aml_named_field(stringify(MEMORY_SLOT_EJECT), 1));

        aml_append(scope, field);



        field = aml_field(stringify(MEMORY_HOTPLUG_IO_REGION), AML_DWORD_ACC,

                          AML_PRESERVE);

        aml_append(field, /* DIMM selector, write only */

            aml_named_field(stringify(MEMORY_SLOT_SLECTOR), 32));

        aml_append(field, /* _OST event code, write only */

            aml_named_field(stringify(MEMORY_SLOT_OST_EVENT), 32));

        aml_append(field, /* _OST status code, write only */

            aml_named_field(stringify(MEMORY_SLOT_OST_STATUS), 32));

        aml_append(scope, field);



        aml_append(sb_scope, scope);



        for (i = 0; i < nr_mem; i++) {

            #define BASEPATH "\\_SB.PCI0." stringify(MEMORY_HOTPLUG_DEVICE) "."

            const char *s;



            dev = aml_device("MP%02X", i);

            aml_append(dev, aml_name_decl("_UID", aml_string("0x%02X", i)));

            aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0C80")));



            method = aml_method("_CRS", 0);

            s = BASEPATH stringify(MEMORY_SLOT_CRS_METHOD);

            aml_append(method, aml_return(aml_call1(s, aml_name("_UID"))));

            aml_append(dev, method);



            method = aml_method("_STA", 0);

            s = BASEPATH stringify(MEMORY_SLOT_STATUS_METHOD);

            aml_append(method, aml_return(aml_call1(s, aml_name("_UID"))));

            aml_append(dev, method);



            method = aml_method("_PXM", 0);

            s = BASEPATH stringify(MEMORY_SLOT_PROXIMITY_METHOD);

            aml_append(method, aml_return(aml_call1(s, aml_name("_UID"))));

            aml_append(dev, method);



            method = aml_method("_OST", 3);

            s = BASEPATH stringify(MEMORY_SLOT_OST_METHOD);

            aml_append(method, aml_return(aml_call4(

                s, aml_name("_UID"), aml_arg(0), aml_arg(1), aml_arg(2)

            )));

            aml_append(dev, method);



            method = aml_method("_EJ0", 1);

            s = BASEPATH stringify(MEMORY_SLOT_EJECT_METHOD);

            aml_append(method, aml_return(aml_call2(

                       s, aml_name("_UID"), aml_arg(0))));

            aml_append(dev, method);



            aml_append(sb_scope, dev);

        }



        /* build Method(MEMORY_SLOT_NOTIFY_METHOD, 2) {

         *     If (LEqual(Arg0, 0x00)) {Notify(MP00, Arg1)} ... }

         */

        method = aml_method(stringify(MEMORY_SLOT_NOTIFY_METHOD), 2);

        for (i = 0; i < nr_mem; i++) {

            ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));

            aml_append(ifctx,

                aml_notify(aml_name("MP%.02X", i), aml_arg(1))

            );

            aml_append(method, ifctx);

        }

        aml_append(sb_scope, method);



        {

            Object *pci_host;

            PCIBus *bus = NULL;



            pci_host = acpi_get_i386_pci_host();

            if (pci_host) {

                bus = PCI_HOST_BRIDGE(pci_host)->bus;

            }



            if (bus) {

                Aml *scope = aml_scope("PCI0");

                /* Scan all PCI buses. Generate tables to support hotplug. */

                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);



                if (misc->tpm_version != TPM_VERSION_UNSPEC) {

                    dev = aml_device("ISA.TPM");

                    aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0C31")));

                    aml_append(dev, aml_name_decl("_STA", aml_int(0xF)));

                    crs = aml_resource_template();

                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,

                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));

                    aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ));

                    aml_append(dev, aml_name_decl("_CRS", crs));

                    aml_append(scope, dev);

                }



                aml_append(sb_scope, scope);

            }

        }

        aml_append(ssdt, sb_scope);

    }



    /* copy AML table into ACPI tables blob and patch header there */

    g_array_append_vals(table_data, ssdt->buf->data, ssdt->buf->len);

    build_header(linker, table_data,

        (void *)(table_data->data + table_data->len - ssdt->buf->len),

        "SSDT", ssdt->buf->len, 1);

    free_aml_allocator();

}
 and probability:0.13144329896907217
code:static void release_delayed_buffers(PerThreadContext *p)

{

    FrameThreadContext *fctx = p->parent;



    while (p->num_released_buffers > 0) {

        AVFrame *f = &p->released_buffers[--p->num_released_buffers];



        pthread_mutex_lock(&fctx->buffer_mutex);

        free_progress(f);

        f->thread_opaque = NULL;



        f->owner->release_buffer(f->owner, f);

        pthread_mutex_unlock(&fctx->buffer_mutex);

    }

}
 and probability:0.5833333333333334
code:double ff_lpc_calc_ref_coefs_f(LPCContext *s, const float *samples, int len,

                               int order, double *ref)

{

    int i;

    double signal = 0.0f, avg_err = 0.0f;

    double autoc[MAX_LPC_ORDER+1] = {0}, error[MAX_LPC_ORDER+1] = {0};

    const double a = 0.5f, b = 1.0f - a;



    /* Apply windowing */

    for (i = 0; i < len; i++) {

        double weight = a - b*cos((2*M_PI*i)/(len - 1));

        s->windowed_samples[i] = weight*samples[i];

    }



    s->lpc_compute_autocorr(s->windowed_samples, len, order, autoc);

    signal = autoc[0];

    compute_ref_coefs(autoc, order, ref, error);

    for (i = 0; i < order; i++)

        avg_err = (avg_err + error[i])/2.0f;

    return signal/avg_err;

}
 and probability:0.5263157894736842
code:int av_write_trailer(AVFormatContext *s)

{

    int ret, i;



    for (;; ) {

        AVPacket pkt;

        ret = interleave_packet(s, &pkt, NULL, 1);

        if (ret < 0) //FIXME cleanup needed for ret<0 ?

            goto fail;

        if (!ret)

            break;



        ret = s->oformat->write_packet(s, &pkt);

        if (ret >= 0)

            s->streams[pkt.stream_index]->nb_frames++;



        av_free_packet(&pkt);



        if (ret < 0)

            goto fail;

    }



    if (s->oformat->write_trailer)

        ret = s->oformat->write_trailer(s);



    if (!(s->oformat->flags & AVFMT_NOFILE))

        avio_flush(s->pb);



fail:

    for (i = 0; i < s->nb_streams; i++) {

        av_freep(&s->streams[i]->priv_data);

        av_freep(&s->streams[i]->index_entries);

    }

    if (s->oformat->priv_class)

        av_opt_free(s->priv_data);

    av_freep(&s->priv_data);

    return ret;

}
 and probability:0.3870967741935484
code:int av_dict_set(AVDictionary **pm, const char *key, const char *value,

                int flags)

{

    AVDictionary *m = *pm;

    AVDictionaryEntry *tag = av_dict_get(m, key, NULL, flags);

    char *oldval = NULL;



    if (!m)

        m = *pm = av_mallocz(sizeof(*m));



    if (tag) {

        if (flags & AV_DICT_DONT_OVERWRITE)

            return 0;

        if (flags & AV_DICT_APPEND)

            oldval = tag->value;

        else

            av_free(tag->value);

        av_free(tag->key);

        *tag = m->elems[--m->count];

    } else {

        AVDictionaryEntry *tmp = av_realloc(m->elems,

                                            (m->count + 1) * sizeof(*m->elems));

        if (tmp)

            m->elems = tmp;

        else

            return AVERROR(ENOMEM);

    }

    if (value) {

        if (flags & AV_DICT_DONT_STRDUP_KEY)

            m->elems[m->count].key = key;

        else

            m->elems[m->count].key = av_strdup(key);

        if (flags & AV_DICT_DONT_STRDUP_VAL) {

            m->elems[m->count].value = value;

        } else if (oldval && flags & AV_DICT_APPEND) {

            int len = strlen(oldval) + strlen(value) + 1;

            if (!(oldval = av_realloc(oldval, len)))

                return AVERROR(ENOMEM);

            av_strlcat(oldval, value, len);

            m->elems[m->count].value = oldval;

        } else

            m->elems[m->count].value = av_strdup(value);

        m->count++;

    }

    if (!m->count) {

        av_free(m->elems);

        av_freep(pm);

    }



    return 0;

}
 and probability:0.375
code:static void s390_virtio_rng_instance_init(Object *obj)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(obj);

    object_initialize(&dev->vdev, sizeof(dev->vdev), TYPE_VIRTIO_RNG);

    object_property_add_child(obj, "virtio-backend", OBJECT(&dev->vdev), NULL);

    object_property_add_link(obj, "rng", TYPE_RNG_BACKEND,

                             (Object **)&dev->vdev.conf.rng,


                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

} and probability:0.3333333333333333
code:static struct omap_sti_s *omap_sti_init(struct omap_target_agent_s *ta,

                MemoryRegion *sysmem,

                hwaddr channel_base, qemu_irq irq, omap_clk clk,

                CharDriverState *chr)

{

    struct omap_sti_s *s = (struct omap_sti_s *)

            g_malloc0(sizeof(struct omap_sti_s));



    s->irq = irq;

    omap_sti_reset(s);



    s->chr = chr ?: qemu_chr_new("null", "null", NULL);



    memory_region_init_io(&s->iomem, NULL, &omap_sti_ops, s, "omap.sti",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    memory_region_init_io(&s->iomem_fifo, NULL, &omap_sti_fifo_ops, s,

                          "omap.sti.fifo", 0x10000);

    memory_region_add_subregion(sysmem, channel_base, &s->iomem_fifo);



    return s;

}
 and probability:0.3333333333333333
code:void cpu_interrupt(CPUArchState *env, int mask)

{

    CPUState *cpu = ENV_GET_CPU(env);



    env->interrupt_request |= mask;

    cpu_unlink_tb(cpu);

}
 and probability:0.16666666666666666
code:static inline int read_huff_channels(MLPDecodeContext *m, GetBitContext *gbp,

                                     unsigned int substr, unsigned int pos)

{

    SubStream *s = &m->substream[substr];

    unsigned int mat, channel;



    for (mat = 0; mat < s->num_primitive_matrices; mat++)

        if (s->lsb_bypass[mat])

            m->bypassed_lsbs[pos + s->blockpos][mat] = get_bits1(gbp);



    for (channel = s->min_channel; channel <= s->max_channel; channel++) {

        ChannelParams *cp = &s->channel_params[channel];

        int codebook = cp->codebook;

        int quant_step_size = s->quant_step_size[channel];

        int lsb_bits = cp->huff_lsbs - quant_step_size;

        int result = 0;



        if (codebook > 0)

            result = get_vlc2(gbp, huff_vlc[codebook-1].table,

                            VLC_BITS, (9 + VLC_BITS - 1) / VLC_BITS);



        if (result < 0)

            return AVERROR_INVALIDDATA;



        if (lsb_bits > 0)

            result = (result << lsb_bits) + get_bits(gbp, lsb_bits);



        result  += cp->sign_huff_offset;

        result <<= quant_step_size;



        m->sample_buffer[pos + s->blockpos][channel] = result;

    }



    return 0;

}
 and probability:0.5185185185185185
code:static void superh_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    SuperHCPU *cpu = SUPERH_CPU(obj);

    CPUSH4State *env = &cpu->env;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    env->movcal_backup_tail = &(env->movcal_backup);



    if (tcg_enabled()) {

        sh4_translate_init();

    }

}
 and probability:0.25
code:void ff_estimate_b_frame_motion(MpegEncContext * s,

                             int mb_x, int mb_y)

{

    MotionEstContext * const c= &s->me;

    const int penalty_factor= c->mb_penalty_factor;

    int fmin, bmin, dmin, fbmin, bimin, fimin;

    int type=0;

    const int xy = mb_y*s->mb_stride + mb_x;

    init_ref(c, s->new_picture.f.data, s->last_picture.f.data,

             s->next_picture.f.data, 16 * mb_x, 16 * mb_y, 2);



    get_limits(s, 16*mb_x, 16*mb_y);



    c->skip=0;



    if (s->codec_id == AV_CODEC_ID_MPEG4 && s->next_picture.mbskip_table[xy]) {

        int score= direct_search(s, mb_x, mb_y); //FIXME just check 0,0



        score= ((unsigned)(score*score + 128*256))>>16;

        c->mc_mb_var_sum_temp += score;

        s->current_picture.mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE

        s->mb_type[mb_y*s->mb_stride + mb_x]= CANDIDATE_MB_TYPE_DIRECT0;



        return;

    }



    if (s->codec_id == AV_CODEC_ID_MPEG4)

        dmin= direct_search(s, mb_x, mb_y);

    else

        dmin= INT_MAX;

//FIXME penalty stuff for non mpeg4

    c->skip=0;

    fmin = estimate_motion_b(s, mb_x, mb_y, s->b_forw_mv_table, 0, s->f_code) +

           3 * penalty_factor;



    c->skip=0;

    bmin = estimate_motion_b(s, mb_x, mb_y, s->b_back_mv_table, 2, s->b_code) +

           2 * penalty_factor;

    av_dlog(s, " %d %d ", s->b_forw_mv_table[xy][0], s->b_forw_mv_table[xy][1]);



    c->skip=0;

    fbmin= bidir_refine(s, mb_x, mb_y) + penalty_factor;

    av_dlog(s, "%d %d %d %d\n", dmin, fmin, bmin, fbmin);



    if(s->flags & CODEC_FLAG_INTERLACED_ME){

//FIXME mb type penalty

        c->skip=0;

        c->current_mv_penalty= c->mv_penalty[s->f_code] + MAX_MV;

        fimin= interlaced_search(s, 0,

                                 s->b_field_mv_table[0], s->b_field_select_table[0],

                                 s->b_forw_mv_table[xy][0], s->b_forw_mv_table[xy][1], 0);

        c->current_mv_penalty= c->mv_penalty[s->b_code] + MAX_MV;

        bimin= interlaced_search(s, 2,

                                 s->b_field_mv_table[1], s->b_field_select_table[1],

                                 s->b_back_mv_table[xy][0], s->b_back_mv_table[xy][1], 0);

    }else

        fimin= bimin= INT_MAX;



    {

        int score= fmin;

        type = CANDIDATE_MB_TYPE_FORWARD;



        if (dmin <= score){

            score = dmin;

            type = CANDIDATE_MB_TYPE_DIRECT;

        }

        if(bmin<score){

            score=bmin;

            type= CANDIDATE_MB_TYPE_BACKWARD;

        }

        if(fbmin<score){

            score=fbmin;

            type= CANDIDATE_MB_TYPE_BIDIR;

        }

        if(fimin<score){

            score=fimin;

            type= CANDIDATE_MB_TYPE_FORWARD_I;

        }

        if(bimin<score){

            score=bimin;

            type= CANDIDATE_MB_TYPE_BACKWARD_I;

        }



        score= ((unsigned)(score*score + 128*256))>>16;

        c->mc_mb_var_sum_temp += score;

        s->current_picture.mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE

    }



    if(c->avctx->mb_decision > FF_MB_DECISION_SIMPLE){

        type= CANDIDATE_MB_TYPE_FORWARD | CANDIDATE_MB_TYPE_BACKWARD | CANDIDATE_MB_TYPE_BIDIR | CANDIDATE_MB_TYPE_DIRECT;

        if(fimin < INT_MAX)

            type |= CANDIDATE_MB_TYPE_FORWARD_I;

        if(bimin < INT_MAX)

            type |= CANDIDATE_MB_TYPE_BACKWARD_I;

        if(fimin < INT_MAX && bimin < INT_MAX){

            type |= CANDIDATE_MB_TYPE_BIDIR_I;

        }

         //FIXME something smarter

        if(dmin>256*256*16) type&= ~CANDIDATE_MB_TYPE_DIRECT; //do not try direct mode if it is invalid for this MB

        if(s->codec_id == AV_CODEC_ID_MPEG4 && type&CANDIDATE_MB_TYPE_DIRECT && s->flags&CODEC_FLAG_MV0 && *(uint32_t*)s->b_direct_mv_table[xy])

            type |= CANDIDATE_MB_TYPE_DIRECT0;

    }



    s->mb_type[mb_y*s->mb_stride + mb_x]= type;

}
 and probability:0.4065934065934066
code:xmit_seg(E1000State *s)

{

    uint16_t len, *sp;

    unsigned int frames = s->tx.tso_frames, css, sofar, n;

    struct e1000_tx *tp = &s->tx;



    if (tp->tse && tp->cptse) {

        css = tp->ipcss;

        DBGOUT(TXSUM, "frames %d size %d ipcss %d\n",

               frames, tp->size, css);

        if (tp->ip) {		// IPv4

            cpu_to_be16wu((uint16_t *)(tp->data+css+2),

                          tp->size - css);

            cpu_to_be16wu((uint16_t *)(tp->data+css+4),

                          be16_to_cpup((uint16_t *)(tp->data+css+4))+frames);

        } else			// IPv6

            cpu_to_be16wu((uint16_t *)(tp->data+css+4),

                          tp->size - css);

        css = tp->tucss;

        len = tp->size - css;

        DBGOUT(TXSUM, "tcp %d tucss %d len %d\n", tp->tcp, css, len);

        if (tp->tcp) {

            sofar = frames * tp->mss;

            cpu_to_be32wu((uint32_t *)(tp->data+css+4),	// seq

                be32_to_cpupu((uint32_t *)(tp->data+css+4))+sofar);

            if (tp->paylen - sofar > tp->mss)

                tp->data[css + 13] &= ~9;		// PSH, FIN

        } else	// UDP

            cpu_to_be16wu((uint16_t *)(tp->data+css+4), len);

        if (tp->sum_needed & E1000_TXD_POPTS_TXSM) {

            // add pseudo-header length before checksum calculation

            sp = (uint16_t *)(tp->data + tp->tucso);

            cpu_to_be16wu(sp, be16_to_cpup(sp) + len);

        }

        tp->tso_frames++;

    }



    if (tp->sum_needed & E1000_TXD_POPTS_TXSM)

        putsum(tp->data, tp->size, tp->tucso, tp->tucss, tp->tucse);

    if (tp->sum_needed & E1000_TXD_POPTS_IXSM)

        putsum(tp->data, tp->size, tp->ipcso, tp->ipcss, tp->ipcse);

    if (tp->vlan_needed) {

        memmove(tp->vlan, tp->data, 4);

        memmove(tp->data, tp->data + 4, 8);

        memcpy(tp->data + 8, tp->vlan_header, 4);

        qemu_send_packet(&s->nic->nc, tp->vlan, tp->size + 4);

    } else

        qemu_send_packet(&s->nic->nc, tp->data, tp->size);

    s->mac_reg[TPT]++;

    s->mac_reg[GPTC]++;

    n = s->mac_reg[TOTL];

    if ((s->mac_reg[TOTL] += s->tx.size) < n)

        s->mac_reg[TOTH]++;

}
 and probability:0.8076923076923077
code:static void omap_timer_clk_setup(struct omap_mpu_timer_s *timer)

{

    omap_clk_adduser(timer->clk,

                    qemu_allocate_irqs(omap_timer_clk_update, timer, 1)[0]);

    timer->rate = omap_clk_getrate(timer->clk);

}
 and probability:0.5
code:static int drive_init(struct drive_opt *arg, int snapshot,

                      QEMUMachine *machine)

{

    char buf[128];

    char file[1024];

    char devname[128];

    char serial[21];

    const char *mediastr = "";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriverState *bdrv;

    BlockDriver *drv = NULL;

    int max_devs;

    int index;

    int cache;

    int bdrv_flags, onerror;

    int drives_table_idx;

    char *str = arg->opt;

    static const char * const params[] = { "bus", "unit", "if", "index",

                                           "cyls", "heads", "secs", "trans",

                                           "media", "snapshot", "file",

                                           "cache", "format", "serial", "werror",

                                           NULL };



    if (check_params(buf, sizeof(buf), params, str) < 0) {

         fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n",

                         buf, str);

         return -1;

    }



    file[0] = 0;

    cyls = heads = secs = 0;

    bus_id = 0;

    unit_id = -1;

    translation = BIOS_ATA_TRANSLATION_AUTO;

    index = -1;

    cache = 3;



    if (machine->use_scsi) {

        type = IF_SCSI;

        max_devs = MAX_SCSI_DEVS;

        pstrcpy(devname, sizeof(devname), "scsi");

    } else {

        type = IF_IDE;

        max_devs = MAX_IDE_DEVS;

        pstrcpy(devname, sizeof(devname), "ide");

    }

    media = MEDIA_DISK;



    /* extract parameters */



    if (get_param_value(buf, sizeof(buf), "bus", str)) {

        bus_id = strtol(buf, NULL, 0);

	if (bus_id < 0) {

	    fprintf(stderr, "qemu: '%s' invalid bus id\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "unit", str)) {

        unit_id = strtol(buf, NULL, 0);

	if (unit_id < 0) {

	    fprintf(stderr, "qemu: '%s' invalid unit id\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "if", str)) {

        pstrcpy(devname, sizeof(devname), buf);

        if (!strcmp(buf, "ide")) {

	    type = IF_IDE;

            max_devs = MAX_IDE_DEVS;

        } else if (!strcmp(buf, "scsi")) {

	    type = IF_SCSI;

            max_devs = MAX_SCSI_DEVS;

        } else if (!strcmp(buf, "floppy")) {

	    type = IF_FLOPPY;

            max_devs = 0;

        } else if (!strcmp(buf, "pflash")) {

	    type = IF_PFLASH;

            max_devs = 0;

	} else if (!strcmp(buf, "mtd")) {

	    type = IF_MTD;

            max_devs = 0;

	} else if (!strcmp(buf, "sd")) {

	    type = IF_SD;

            max_devs = 0;

        } else if (!strcmp(buf, "virtio")) {

            type = IF_VIRTIO;

            max_devs = 0;

        } else {

            fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf);

            return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "index", str)) {

        index = strtol(buf, NULL, 0);

	if (index < 0) {

	    fprintf(stderr, "qemu: '%s' invalid index\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "cyls", str)) {

        cyls = strtol(buf, NULL, 0);

    }



    if (get_param_value(buf, sizeof(buf), "heads", str)) {

        heads = strtol(buf, NULL, 0);

    }



    if (get_param_value(buf, sizeof(buf), "secs", str)) {

        secs = strtol(buf, NULL, 0);

    }



    if (cyls || heads || secs) {

        if (cyls < 1 || cyls > 16383) {

            fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str);

	    return -1;

	}

        if (heads < 1 || heads > 16) {

            fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str);

	    return -1;

	}

        if (secs < 1 || secs > 63) {

            fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "trans", str)) {

        if (!cyls) {

            fprintf(stderr,

                    "qemu: '%s' trans must be used with cyls,heads and secs\n",

                    str);

            return -1;

        }

        if (!strcmp(buf, "none"))

            translation = BIOS_ATA_TRANSLATION_NONE;

        else if (!strcmp(buf, "lba"))

            translation = BIOS_ATA_TRANSLATION_LBA;

        else if (!strcmp(buf, "auto"))

            translation = BIOS_ATA_TRANSLATION_AUTO;

	else {

            fprintf(stderr, "qemu: '%s' invalid translation type\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "media", str)) {

        if (!strcmp(buf, "disk")) {

	    media = MEDIA_DISK;

	} else if (!strcmp(buf, "cdrom")) {

            if (cyls || secs || heads) {

                fprintf(stderr,

                        "qemu: '%s' invalid physical CHS format\n", str);

	        return -1;

            }

	    media = MEDIA_CDROM;

	} else {

	    fprintf(stderr, "qemu: '%s' invalid media\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "snapshot", str)) {

        if (!strcmp(buf, "on"))

	    snapshot = 1;

        else if (!strcmp(buf, "off"))

	    snapshot = 0;

	else {

	    fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), "cache", str)) {

        if (!strcmp(buf, "off") || !strcmp(buf, "none"))

            cache = 0;

        else if (!strcmp(buf, "writethrough"))

            cache = 1;

        else if (!strcmp(buf, "writeback"))

            cache = 2;

        else {

           fprintf(stderr, "qemu: invalid cache option\n");

           return -1;

        }

    }



    if (get_param_value(buf, sizeof(buf), "format", str)) {

       if (strcmp(buf, "?") == 0) {

            fprintf(stderr, "qemu: Supported formats:");

            bdrv_iterate_format(bdrv_format_print, NULL);

            fprintf(stderr, "\n");

	    return -1;

        }

        drv = bdrv_find_format(buf);

        if (!drv) {

            fprintf(stderr, "qemu: '%s' invalid format\n", buf);

            return -1;

        }

    }



    if (arg->file == NULL)

        get_param_value(file, sizeof(file), "file", str);

    else

        pstrcpy(file, sizeof(file), arg->file);



    if (!get_param_value(serial, sizeof(serial), "serial", str))

	    memset(serial, 0,  sizeof(serial));



    onerror = BLOCK_ERR_REPORT;

    if (get_param_value(buf, sizeof(serial), "werror", str)) {

        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {

            fprintf(stderr, "werror is no supported by this format\n");

            return -1;

        }

        if (!strcmp(buf, "ignore"))

            onerror = BLOCK_ERR_IGNORE;

        else if (!strcmp(buf, "enospc"))

            onerror = BLOCK_ERR_STOP_ENOSPC;

        else if (!strcmp(buf, "stop"))

            onerror = BLOCK_ERR_STOP_ANY;

        else if (!strcmp(buf, "report"))

            onerror = BLOCK_ERR_REPORT;

        else {

            fprintf(stderr, "qemu: '%s' invalid write error action\n", buf);

            return -1;

        }

    }



    /* compute bus and unit according index */



    if (index != -1) {

        if (bus_id != 0 || unit_id != -1) {

            fprintf(stderr,

                    "qemu: '%s' index cannot be used with bus and unit\n", str);

            return -1;

        }

        if (max_devs == 0)

        {

            unit_id = index;

            bus_id = 0;

        } else {

            unit_id = index % max_devs;

            bus_id = index / max_devs;

        }

    }



    /* if user doesn't specify a unit_id,

     * try to find the first free

     */



    if (unit_id == -1) {

       unit_id = 0;

       while (drive_get_index(type, bus_id, unit_id) != -1) {

           unit_id++;

           if (max_devs && unit_id >= max_devs) {

               unit_id -= max_devs;

               bus_id++;

           }

       }

    }



    /* check unit id */



    if (max_devs && unit_id >= max_devs) {

        fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n",

                        str, unit_id, max_devs - 1);

        return -1;

    }



    /*

     * ignore multiple definitions

     */



    if (drive_get_index(type, bus_id, unit_id) != -1)

        return 0;



    /* init */



    if (type == IF_IDE || type == IF_SCSI)

        mediastr = (media == MEDIA_CDROM) ? "-cd" : "-hd";

    if (max_devs)

        snprintf(buf, sizeof(buf), "%s%i%s%i",

                 devname, bus_id, mediastr, unit_id);

    else

        snprintf(buf, sizeof(buf), "%s%s%i",

                 devname, mediastr, unit_id);

    bdrv = bdrv_new(buf);

    drives_table_idx = drive_get_free_idx();

    drives_table[drives_table_idx].bdrv = bdrv;

    drives_table[drives_table_idx].type = type;

    drives_table[drives_table_idx].bus = bus_id;

    drives_table[drives_table_idx].unit = unit_id;

    drives_table[drives_table_idx].onerror = onerror;

    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;

    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));

    nb_drives++;



    switch(type) {

    case IF_IDE:

    case IF_SCSI:

        switch(media) {

	case MEDIA_DISK:

            if (cyls != 0) {

                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);

                bdrv_set_translation_hint(bdrv, translation);

            }

	    break;

	case MEDIA_CDROM:

            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);

	    break;

	}

        break;

    case IF_SD:

        /* FIXME: This isn't really a floppy, but it's a reasonable

           approximation.  */

    case IF_FLOPPY:

        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);

        break;

    case IF_PFLASH:

    case IF_MTD:

    case IF_VIRTIO:

        break;

    }

    if (!file[0])

        return 0;

    bdrv_flags = 0;

    if (snapshot) {

        bdrv_flags |= BDRV_O_SNAPSHOT;

        cache = 2; /* always use write-back with snapshot */

    }

    if (cache == 0) /* no caching */

        bdrv_flags |= BDRV_O_NOCACHE;

    else if (cache == 2) /* write-back */

        bdrv_flags |= BDRV_O_CACHE_WB;

    else if (cache == 3) /* not specified */

        bdrv_flags |= BDRV_O_CACHE_DEF;

    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0 || qemu_key_check(bdrv, file)) {

        fprintf(stderr, "qemu: could not open disk image %s\n",

                        file);

        return -1;

    }

    return 0;

}
 and probability:0.06289308176100629
code:static void qvirtio_pci_set_status(QVirtioDevice *d, uint8_t status)

{

    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;

    qpci_io_writeb(dev->pdev, dev->addr + VIRTIO_PCI_STATUS, status);

}
 and probability:0.2
code:static void test_acpi_piix4_tcg_cphp(void)

{

    test_data data;



    memset(&data, 0, sizeof(data));

    data.machine = MACHINE_PC;

    data.variant = ".cphp";

    test_acpi_one("-smp 2,cores=3,sockets=2,maxcpus=6",

                  &data);

    free_test_data(&data);

}
 and probability:0.0
code:void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,

                               int64_t bps_wr,

                               int64_t iops,

                               int64_t iops_rd,

                               int64_t iops_wr,

                               bool has_bps_max,

                               int64_t bps_max,

                               bool has_bps_rd_max,

                               int64_t bps_rd_max,

                               bool has_bps_wr_max,

                               int64_t bps_wr_max,

                               bool has_iops_max,

                               int64_t iops_max,

                               bool has_iops_rd_max,

                               int64_t iops_rd_max,

                               bool has_iops_wr_max,

                               int64_t iops_wr_max,

                               bool has_iops_size,

                               int64_t iops_size, Error **errp)

{

    ThrottleConfig cfg;

    BlockDriverState *bs;




    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    memset(&cfg, 0, sizeof(cfg));

    cfg.buckets[THROTTLE_BPS_TOTAL].avg = bps;

    cfg.buckets[THROTTLE_BPS_READ].avg  = bps_rd;

    cfg.buckets[THROTTLE_BPS_WRITE].avg = bps_wr;



    cfg.buckets[THROTTLE_OPS_TOTAL].avg = iops;

    cfg.buckets[THROTTLE_OPS_READ].avg  = iops_rd;

    cfg.buckets[THROTTLE_OPS_WRITE].avg = iops_wr;



    if (has_bps_max) {

        cfg.buckets[THROTTLE_BPS_TOTAL].max = bps_max;

    }

    if (has_bps_rd_max) {

        cfg.buckets[THROTTLE_BPS_READ].max = bps_rd_max;

    }

    if (has_bps_wr_max) {

        cfg.buckets[THROTTLE_BPS_WRITE].max = bps_wr_max;

    }

    if (has_iops_max) {

        cfg.buckets[THROTTLE_OPS_TOTAL].max = iops_max;

    }

    if (has_iops_rd_max) {

        cfg.buckets[THROTTLE_OPS_READ].max = iops_rd_max;

    }

    if (has_iops_wr_max) {

        cfg.buckets[THROTTLE_OPS_WRITE].max = iops_wr_max;

    }



    if (has_iops_size) {

        cfg.op_size = iops_size;

    }



    if (!check_throttle_config(&cfg, errp)) {

        return;

    }



    aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(aio_context);



    if (!bs->io_limits_enabled && throttle_enabled(&cfg)) {

        bdrv_io_limits_enable(bs);

    } else if (bs->io_limits_enabled && !throttle_enabled(&cfg)) {

        bdrv_io_limits_disable(bs);

    }



    if (bs->io_limits_enabled) {

        bdrv_set_io_limits(bs, &cfg);

    }



    aio_context_release(aio_context);

} and probability:0.21428571428571427
code:static void setup_frame(int sig, struct target_sigaction *ka,

                        target_sigset_t *set, CPUM68KState *env)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    abi_ulong retcode_addr;

    abi_ulong sc_addr;

    int err = 0;

    int i;



    frame_addr = get_sigframe(ka, env, sizeof *frame);

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))

	goto give_sigsegv;



    __put_user(sig, &frame->sig);



    sc_addr = frame_addr + offsetof(struct target_sigframe, sc);

    __put_user(sc_addr, &frame->psc);



    err |= setup_sigcontext(&frame->sc, env, set->sig[0]);

    if (err)

	goto give_sigsegv;



    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        if (__put_user(set->sig[i], &frame->extramask[i - 1]))

            goto give_sigsegv;

    }



    /* Set up to return from userspace.  */



    retcode_addr = frame_addr + offsetof(struct target_sigframe, retcode);

    __put_user(retcode_addr, &frame->pretcode);



    /* moveq #,d0; trap #0 */



    __put_user(0x70004e40 + (TARGET_NR_sigreturn << 16),

                      (long *)(frame->retcode));



    if (err)

        goto give_sigsegv;



    /* Set up to return from userspace */



    env->aregs[7] = frame_addr;

    env->pc = ka->_sa_handler;



    unlock_user_struct(frame, frame_addr, 1);

    return;



give_sigsegv:

    unlock_user_struct(frame, frame_addr, 1);

    force_sig(TARGET_SIGSEGV);

}
 and probability:0.3333333333333333
code:do_socket_read(GIOChannel *source,

               GIOCondition condition,

               gpointer data)

{

    int rv;

    int dwSendLength;

    int dwRecvLength;

    uint8_t pbRecvBuffer[APDUBufSize];

    static uint8_t pbSendBuffer[APDUBufSize];

    VReaderStatus reader_status;

    VReader *reader = NULL;

    static VSCMsgHeader mhHeader;

    VSCMsgError *error_msg;

    GError *err = NULL;



    static gchar *buf;

    static gsize br, to_read;

    static int state = STATE_HEADER;



    if (state == STATE_HEADER && to_read == 0) {

        buf = (gchar *)&mhHeader;

        to_read = sizeof(mhHeader);

    }



    if (to_read > 0) {

        g_io_channel_read_chars(source, (gchar *)buf, to_read, &br, &err);

        if (err != NULL) {

            g_error("error while reading: %s", err->message);

        }

        buf += br;

        to_read -= br;

        if (to_read != 0) {

            return TRUE;

        }

    }



    if (state == STATE_HEADER) {

        mhHeader.type = ntohl(mhHeader.type);

        mhHeader.reader_id = ntohl(mhHeader.reader_id);

        mhHeader.length = ntohl(mhHeader.length);

        if (verbose) {

            printf("Header: type=%d, reader_id=%u length=%d (0x%x)\n",

                   mhHeader.type, mhHeader.reader_id, mhHeader.length,

                   mhHeader.length);

        }

        switch (mhHeader.type) {

        case VSC_APDU:

        case VSC_Flush:

        case VSC_Error:

        case VSC_Init:

            buf = (gchar *)pbSendBuffer;

            to_read = mhHeader.length;

            state = STATE_MESSAGE;

            return TRUE;

        default:

            fprintf(stderr, "Unexpected message of type 0x%X\n", mhHeader.type);

            return FALSE;

        }

    }



    if (state == STATE_MESSAGE) {

        switch (mhHeader.type) {

        case VSC_APDU:

            if (verbose) {

                printf(" recv APDU: ");

                print_byte_array(pbSendBuffer, mhHeader.length);

            }

            /* Transmit received APDU */

            dwSendLength = mhHeader.length;

            dwRecvLength = sizeof(pbRecvBuffer);

            reader = vreader_get_reader_by_id(mhHeader.reader_id);

            reader_status = vreader_xfr_bytes(reader,

                                              pbSendBuffer, dwSendLength,

                                              pbRecvBuffer, &dwRecvLength);

            if (reader_status == VREADER_OK) {

                mhHeader.length = dwRecvLength;

                if (verbose) {

                    printf(" send response: ");

                    print_byte_array(pbRecvBuffer, mhHeader.length);

                }

                send_msg(VSC_APDU, mhHeader.reader_id,

                         pbRecvBuffer, dwRecvLength);

            } else {

                rv = reader_status; /* warning: not meaningful */

                send_msg(VSC_Error, mhHeader.reader_id, &rv, sizeof(uint32_t));

            }

            vreader_free(reader);

            reader = NULL; /* we've freed it, don't use it by accident

                              again */

            break;

        case VSC_Flush:

            /* TODO: actually flush */

            send_msg(VSC_FlushComplete, mhHeader.reader_id, NULL, 0);

            break;

        case VSC_Error:

            error_msg = (VSCMsgError *) pbSendBuffer;

            if (error_msg->code == VSC_SUCCESS) {

                qemu_mutex_lock(&pending_reader_lock);

                if (pending_reader) {

                    vreader_set_id(pending_reader, mhHeader.reader_id);

                    vreader_free(pending_reader);

                    pending_reader = NULL;

                    qemu_cond_signal(&pending_reader_condition);

                }

                qemu_mutex_unlock(&pending_reader_lock);

                break;

            }

            printf("warning: qemu refused to add reader\n");

            if (error_msg->code == VSC_CANNOT_ADD_MORE_READERS) {

                /* clear pending reader, qemu can't handle any more */

                qemu_mutex_lock(&pending_reader_lock);

                if (pending_reader) {

                    pending_reader = NULL;

                    /* make sure the event loop doesn't hang */

                    qemu_cond_signal(&pending_reader_condition);

                }

                qemu_mutex_unlock(&pending_reader_lock);

            }

            break;

        case VSC_Init:

            if (on_host_init(&mhHeader, (VSCMsgInit *)pbSendBuffer) < 0) {

                return FALSE;

            }

            break;

        default:

            g_assert_not_reached();

            return FALSE;

        }



        state = STATE_HEADER;

    }





    return TRUE;

}
 and probability:0.047244094488188976
code:static size_t buffered_get_rate_limit(void *opaque)

{

    QEMUFileBuffered *s = opaque;

  

    return s->xfer_limit;

}
 and probability:0.2
code:static void check_time(int wiggle)

{

    struct tm start, date[4], end;

    struct tm *datep;

    time_t ts;



    /*

     * This check assumes a few things.  First, we cannot guarantee that we get

     * a consistent reading from the wall clock because we may hit an edge of

     * the clock while reading.  To work around this, we read four clock readings

     * such that at least two of them should match.  We need to assume that one

     * reading is corrupt so we need four readings to ensure that we have at

     * least two consecutive identical readings

     *

     * It's also possible that we'll cross an edge reading the host clock so

     * simply check to make sure that the clock reading is within the period of

     * when we expect it to be.

     */



    ts = time(NULL);

    gmtime_r(&ts, &start);



    cmos_get_date_time(&date[0]);

    cmos_get_date_time(&date[1]);

    cmos_get_date_time(&date[2]);

    cmos_get_date_time(&date[3]);



    ts = time(NULL);

    gmtime_r(&ts, &end);



    if (tm_cmp(&date[0], &date[1]) == 0) {

        datep = &date[0];

    } else if (tm_cmp(&date[1], &date[2]) == 0) {

        datep = &date[1];

    } else if (tm_cmp(&date[2], &date[3]) == 0) {

        datep = &date[2];

    } else {

        g_assert_not_reached();

    }



    if (!(tm_cmp(&start, datep) <= 0 && tm_cmp(datep, &end) <= 0)) {

        time_t t, s;



        start.tm_isdst = datep->tm_isdst;



        t = mktime(datep);

        s = mktime(&start);

        if (t < s) {

            g_test_message("RTC is %ld second(s) behind wall-clock\n", (s - t));

        } else {

            g_test_message("RTC is %ld second(s) ahead of wall-clock\n", (t - s));

        }



        g_assert_cmpint(ABS(t - s), <=, wiggle);

    }

}
 and probability:0.2978723404255319
code:aio_ctx_finalize(GSource     *source)

{

    AioContext *ctx = (AioContext *) source;



    thread_pool_free(ctx->thread_pool);



#ifdef CONFIG_LINUX_AIO

    if (ctx->linux_aio) {

        laio_detach_aio_context(ctx->linux_aio, ctx);

        laio_cleanup(ctx->linux_aio);

        ctx->linux_aio = NULL;

    }

#endif



    qemu_lockcnt_lock(&ctx->list_lock);

    assert(!qemu_lockcnt_count(&ctx->list_lock));

    while (ctx->first_bh) {

        QEMUBH *next = ctx->first_bh->next;



        /* qemu_bh_delete() must have been called on BHs in this AioContext */

        assert(ctx->first_bh->deleted);



        g_free(ctx->first_bh);

        ctx->first_bh = next;

    }

    qemu_lockcnt_unlock(&ctx->list_lock);



    aio_set_event_notifier(ctx, &ctx->notifier, false, NULL, NULL);

    event_notifier_cleanup(&ctx->notifier);

    qemu_rec_mutex_destroy(&ctx->lock);

    qemu_lockcnt_destroy(&ctx->list_lock);

    timerlistgroup_deinit(&ctx->tlg);

}
 and probability:0.7037037037037037
code:static void bdrv_stats_iter(QObject *data, void *opaque)

{

    QDict *qdict;

    Monitor *mon = opaque;



    qdict = qobject_to_qdict(data);

    monitor_printf(mon, "%s:", qdict_get_str(qdict, "device"));



    qdict = qobject_to_qdict(qdict_get(qdict, "stats"));

    monitor_printf(mon, " rd_bytes=%" PRId64

                        " wr_bytes=%" PRId64

                        " rd_operations=%" PRId64

                        " wr_operations=%" PRId64

                        " flush_operations=%" PRId64

                        "\n",

                        qdict_get_int(qdict, "rd_bytes"),

                        qdict_get_int(qdict, "wr_bytes"),

                        qdict_get_int(qdict, "rd_operations"),

                        qdict_get_int(qdict, "wr_operations"),

                        qdict_get_int(qdict, "flush_operations"));

}
 and probability:0.0
code:static int nbd_send_negotiate(NBDClient *client)

{

    int csock = client->sock;

    char buf[8 + 8 + 8 + 128];

    int rc;

    const int myflags = (NBD_FLAG_HAS_FLAGS | NBD_FLAG_SEND_TRIM |

                         NBD_FLAG_SEND_FLUSH | NBD_FLAG_SEND_FUA);



    /* Negotiation header without options:

        [ 0 ..   7]   passwd       ("NBDMAGIC")

        [ 8 ..  15]   magic        (NBD_CLIENT_MAGIC)

        [16 ..  23]   size

        [24 ..  25]   server flags (0)

        [26 ..  27]   export flags

        [28 .. 151]   reserved     (0)



       Negotiation header with options, part 1:

        [ 0 ..   7]   passwd       ("NBDMAGIC")

        [ 8 ..  15]   magic        (NBD_OPTS_MAGIC)

        [16 ..  17]   server flags (0)



       part 2 (after options are sent):

        [18 ..  25]   size

        [26 ..  27]   export flags

        [28 .. 151]   reserved     (0)

     */



    qemu_set_block(csock);

    rc = -EINVAL;



    TRACE("Beginning negotiation.");

    memset(buf, 0, sizeof(buf));

    memcpy(buf, "NBDMAGIC", 8);

    if (client->exp) {

        assert ((client->exp->nbdflags & ~65535) == 0);

        cpu_to_be64w((uint64_t*)(buf + 8), NBD_CLIENT_MAGIC);

        cpu_to_be64w((uint64_t*)(buf + 16), client->exp->size);

        cpu_to_be16w((uint16_t*)(buf + 26), client->exp->nbdflags | myflags);

    } else {

        cpu_to_be64w((uint64_t*)(buf + 8), NBD_OPTS_MAGIC);

        cpu_to_be16w((uint16_t *)(buf + 16), NBD_FLAG_FIXED_NEWSTYLE);

    }



    if (client->exp) {

        if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {

            LOG("write failed");

            goto fail;

        }

    } else {

        if (write_sync(csock, buf, 18) != 18) {

            LOG("write failed");

            goto fail;

        }

        rc = nbd_receive_options(client);

        if (rc != 0) {

            LOG("option negotiation failed");

            goto fail;

        }



        assert ((client->exp->nbdflags & ~65535) == 0);

        cpu_to_be64w((uint64_t*)(buf + 18), client->exp->size);

        cpu_to_be16w((uint16_t*)(buf + 26), client->exp->nbdflags | myflags);

        if (write_sync(csock, buf + 18, sizeof(buf) - 18) != sizeof(buf) - 18) {

            LOG("write failed");

            goto fail;

        }

    }



    TRACE("Negotiation succeeded.");

    rc = 0;

fail:

    qemu_set_nonblock(csock);

    return rc;

}
 and probability:0.21212121212121213
code:void tcg_gen_mb(TCGBar mb_type)

{

    if (parallel_cpus) {

        tcg_gen_op1(INDEX_op_mb, mb_type);

    }

}
 and probability:0.0
code:void *virtqueue_alloc_element(size_t sz, unsigned out_num, unsigned in_num)

{

    VirtQueueElement *elem;

    size_t in_addr_ofs = QEMU_ALIGN_UP(sz, __alignof__(elem->in_addr[0]));

    size_t out_addr_ofs = in_addr_ofs + in_num * sizeof(elem->in_addr[0]);

    size_t out_addr_end = out_addr_ofs + out_num * sizeof(elem->out_addr[0]);

    size_t in_sg_ofs = QEMU_ALIGN_UP(out_addr_end, __alignof__(elem->in_sg[0]));

    size_t out_sg_ofs = in_sg_ofs + in_num * sizeof(elem->in_sg[0]);

    size_t out_sg_end = out_sg_ofs + out_num * sizeof(elem->out_sg[0]);



    assert(sz >= sizeof(VirtQueueElement));

    elem = g_malloc(out_sg_end);

    elem->out_num = out_num;

    elem->in_num = in_num;

    elem->in_addr = (void *)elem + in_addr_ofs;

    elem->out_addr = (void *)elem + out_addr_ofs;

    elem->in_sg = (void *)elem + in_sg_ofs;

    elem->out_sg = (void *)elem + out_sg_ofs;

    return elem;

}
 and probability:0.631578947368421
code:static int usb_serial_initfn(USBDevice *dev)

{

    USBSerialState *s = DO_UPCAST(USBSerialState, dev, dev);

    s->dev.speed = USB_SPEED_FULL;



    if (!s->cs) {

        error_report("Property chardev is required");

        return -1;

    }



    qemu_chr_add_handlers(s->cs, usb_serial_can_read, usb_serial_read,

                          usb_serial_event, s);

    usb_serial_handle_reset(dev);

    return 0;

}
 and probability:0.23076923076923078
code:DeviceState *nand_init(BlockDriverState *bdrv, int manf_id, int chip_id)

{

    DeviceState *dev;



    if (nand_flash_ids[chip_id].size == 0) {

        hw_error("%s: Unsupported NAND chip ID.\n", __FUNCTION__);

    }

    dev = DEVICE(object_new(TYPE_NAND));

    qdev_prop_set_uint8(dev, "manufacturer_id", manf_id);

    qdev_prop_set_uint8(dev, "chip_id", chip_id);

    if (bdrv) {

        qdev_prop_set_drive_nofail(dev, "drive", bdrv);

    }



    qdev_init_nofail(dev);

    return dev;

}
 and probability:0.06666666666666667
code:static void CALLBACK host_alarm_handler(UINT uTimerID, UINT uMsg,

                                        DWORD_PTR dwUser, DWORD_PTR dw1,

                                        DWORD_PTR dw2)

#else

static void host_alarm_handler(int host_signum)

#endif

{

#if 0

#define DISP_FREQ 1000

    {

        static int64_t delta_min = INT64_MAX;

        static int64_t delta_max, delta_cum, last_clock, delta, ti;

        static int count;

        ti = qemu_get_clock(vm_clock);

        if (last_clock != 0) {

            delta = ti - last_clock;

            if (delta < delta_min)

                delta_min = delta;

            if (delta > delta_max)

                delta_max = delta;

            delta_cum += delta;

            if (++count == DISP_FREQ) {

                printf("timer: min=%" PRId64 " us max=%" PRId64 " us avg=%" PRId64 " us avg_freq=%0.3f Hz\n",

                       muldiv64(delta_min, 1000000, ticks_per_sec),

                       muldiv64(delta_max, 1000000, ticks_per_sec),

                       muldiv64(delta_cum, 1000000 / DISP_FREQ, ticks_per_sec),

                       (double)ticks_per_sec / ((double)delta_cum / DISP_FREQ));

                count = 0;

                delta_min = INT64_MAX;

                delta_max = 0;

                delta_cum = 0;

            }

        }

        last_clock = ti;

    }

#endif

    if (alarm_has_dynticks(alarm_timer) ||

        (!use_icount &&

            qemu_timer_expired(active_timers[QEMU_TIMER_VIRTUAL],

                               qemu_get_clock(vm_clock))) ||

        qemu_timer_expired(active_timers[QEMU_TIMER_REALTIME],

                           qemu_get_clock(rt_clock))) {

        qemu_event_increment();

        alarm_timer->flags |= ALARM_FLAG_EXPIRED;



#ifndef CONFIG_IOTHREAD

        if (next_cpu) {

            /* stop the currently executing cpu because a timer occured */

            cpu_exit(next_cpu);

#ifdef CONFIG_KQEMU

            if (next_cpu->kqemu_enabled) {

                kqemu_cpu_interrupt(next_cpu);

            }

#endif

        }

#endif

        timer_alarm_pending = 1;

        qemu_notify_event();

    }

}
 and probability:0.15254237288135594
code:static bool get_phys_addr_lpae(CPUARMState *env, target_ulong address,

                               int access_type, ARMMMUIdx mmu_idx,

                               hwaddr *phys_ptr, MemTxAttrs *txattrs, int *prot,

                               target_ulong *page_size_ptr, uint32_t *fsr)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    /* Read an LPAE long-descriptor translation table. */

    MMUFaultType fault_type = translation_fault;

    uint32_t level = 1;

    uint32_t epd = 0;

    int32_t t0sz, t1sz;

    uint32_t tg;

    uint64_t ttbr;

    int ttbr_select;

    hwaddr descaddr, descmask;

    uint32_t tableattrs;

    target_ulong page_size;

    uint32_t attrs;

    int32_t stride = 9;

    int32_t va_size = 32;

    int inputsize;

    int32_t tbi = 0;

    TCR *tcr = regime_tcr(env, mmu_idx);

    int ap, ns, xn, pxn;

    uint32_t el = regime_el(env, mmu_idx);

    bool ttbr1_valid = true;



    /* TODO:

     * This code does not handle the different format TCR for VTCR_EL2.

     * This code also does not support shareability levels.

     * Attribute and permission bit handling should also be checked when adding

     * support for those page table walks.

     */

    if (arm_el_is_aa64(env, el)) {

        va_size = 64;

        if (el > 1) {

            if (mmu_idx != ARMMMUIdx_S2NS) {

                tbi = extract64(tcr->raw_tcr, 20, 1);

            }

        } else {

            if (extract64(address, 55, 1)) {

                tbi = extract64(tcr->raw_tcr, 38, 1);

            } else {

                tbi = extract64(tcr->raw_tcr, 37, 1);

            }

        }

        tbi *= 8;



        /* If we are in 64-bit EL2 or EL3 then there is no TTBR1, so mark it

         * invalid.

         */

        if (el > 1) {

            ttbr1_valid = false;

        }

    } else {

        /* There is no TTBR1 for EL2 */

        if (el == 2) {

            ttbr1_valid = false;

        }

    }



    /* Determine whether this address is in the region controlled by

     * TTBR0 or TTBR1 (or if it is in neither region and should fault).

     * This is a Non-secure PL0/1 stage 1 translation, so controlled by

     * TTBCR/TTBR0/TTBR1 in accordance with ARM ARM DDI0406C table B-32:

     */

    if (va_size == 64) {

        /* AArch64 translation.  */

        t0sz = extract32(tcr->raw_tcr, 0, 6);

        t0sz = MIN(t0sz, 39);

        t0sz = MAX(t0sz, 16);

    } else if (mmu_idx != ARMMMUIdx_S2NS) {

        /* AArch32 stage 1 translation.  */

        t0sz = extract32(tcr->raw_tcr, 0, 3);

    } else {

        /* AArch32 stage 2 translation.  */

        bool sext = extract32(tcr->raw_tcr, 4, 1);

        bool sign = extract32(tcr->raw_tcr, 3, 1);

        t0sz = sextract32(tcr->raw_tcr, 0, 4);



        /* If the sign-extend bit is not the same as t0sz[3], the result

         * is unpredictable. Flag this as a guest error.  */

        if (sign != sext) {

            qemu_log_mask(LOG_GUEST_ERROR,

                          "AArch32: VTCR.S / VTCR.T0SZ[3] missmatch\n");

        }

    }

    t1sz = extract32(tcr->raw_tcr, 16, 6);

    if (va_size == 64) {

        t1sz = MIN(t1sz, 39);

        t1sz = MAX(t1sz, 16);

    }

    if (t0sz && !extract64(address, va_size - t0sz, t0sz - tbi)) {

        /* there is a ttbr0 region and we are in it (high bits all zero) */

        ttbr_select = 0;

    } else if (ttbr1_valid && t1sz &&

               !extract64(~address, va_size - t1sz, t1sz - tbi)) {

        /* there is a ttbr1 region and we are in it (high bits all one) */

        ttbr_select = 1;

    } else if (!t0sz) {

        /* ttbr0 region is "everything not in the ttbr1 region" */

        ttbr_select = 0;

    } else if (!t1sz && ttbr1_valid) {

        /* ttbr1 region is "everything not in the ttbr0 region" */

        ttbr_select = 1;

    } else {

        /* in the gap between the two regions, this is a Translation fault */

        fault_type = translation_fault;

        goto do_fault;

    }



    /* Note that QEMU ignores shareability and cacheability attributes,

     * so we don't need to do anything with the SH, ORGN, IRGN fields

     * in the TTBCR.  Similarly, TTBCR:A1 selects whether we get the

     * ASID from TTBR0 or TTBR1, but QEMU's TLB doesn't currently

     * implement any ASID-like capability so we can ignore it (instead

     * we will always flush the TLB any time the ASID is changed).

     */

    if (ttbr_select == 0) {

        ttbr = regime_ttbr(env, mmu_idx, 0);

        if (el < 2) {

            epd = extract32(tcr->raw_tcr, 7, 1);

        }

        inputsize = va_size - t0sz;



        tg = extract32(tcr->raw_tcr, 14, 2);

        if (tg == 1) { /* 64KB pages */

            stride = 13;

        }

        if (tg == 2) { /* 16KB pages */

            stride = 11;

        }

    } else {

        /* We should only be here if TTBR1 is valid */

        assert(ttbr1_valid);



        ttbr = regime_ttbr(env, mmu_idx, 1);

        epd = extract32(tcr->raw_tcr, 23, 1);

        inputsize = va_size - t1sz;



        tg = extract32(tcr->raw_tcr, 30, 2);

        if (tg == 3)  { /* 64KB pages */

            stride = 13;

        }

        if (tg == 1) { /* 16KB pages */

            stride = 11;

        }

    }



    /* Here we should have set up all the parameters for the translation:

     * va_size, inputsize, ttbr, epd, stride, tbi

     */



    if (epd) {

        /* Translation table walk disabled => Translation fault on TLB miss

         * Note: This is always 0 on 64-bit EL2 and EL3.

         */

        goto do_fault;

    }



    if (mmu_idx != ARMMMUIdx_S2NS) {

        /* The starting level depends on the virtual address size (which can

         * be up to 48 bits) and the translation granule size. It indicates

         * the number of strides (stride bits at a time) needed to

         * consume the bits of the input address. In the pseudocode this is:

         *  level = 4 - RoundUp((inputsize - grainsize) / stride)

         * where their 'inputsize' is our 'inputsize', 'grainsize' is

         * our 'stride + 3' and 'stride' is our 'stride'.

         * Applying the usual "rounded up m/n is (m+n-1)/n" and simplifying:

         * = 4 - (inputsize - stride - 3 + stride - 1) / stride

         * = 4 - (inputsize - 4) / stride;

         */

        level = 4 - (inputsize - 4) / stride;

    } else {

        /* For stage 2 translations the starting level is specified by the

         * VTCR_EL2.SL0 field (whose interpretation depends on the page size)

         */

        int startlevel = extract32(tcr->raw_tcr, 6, 2);

        bool ok;



        if (va_size == 32 || stride == 9) {

            /* AArch32 or 4KB pages */

            level = 2 - startlevel;

        } else {

            /* 16KB or 64KB pages */

            level = 3 - startlevel;

        }



        /* Check that the starting level is valid. */

        ok = check_s2_startlevel(cpu, va_size == 64, level,

                                 inputsize, stride);

        if (!ok) {

            /* AArch64 reports these as level 0 faults.

             * AArch32 reports these as level 1 faults.

             */

            level = va_size == 64 ? 0 : 1;

            fault_type = translation_fault;

            goto do_fault;

        }

    }



    /* Clear the vaddr bits which aren't part of the within-region address,

     * so that we don't have to special case things when calculating the

     * first descriptor address.

     */

    if (va_size != inputsize) {

        address &= (1ULL << inputsize) - 1;

    }



    descmask = (1ULL << (stride + 3)) - 1;



    /* Now we can extract the actual base address from the TTBR */

    descaddr = extract64(ttbr, 0, 48);

    descaddr &= ~((1ULL << (inputsize - (stride * (4 - level)))) - 1);



    /* Secure accesses start with the page table in secure memory and

     * can be downgraded to non-secure at any step. Non-secure accesses

     * remain non-secure. We implement this by just ORing in the NSTable/NS

     * bits at each step.

     */

    tableattrs = regime_is_secure(env, mmu_idx) ? 0 : (1 << 4);

    for (;;) {

        uint64_t descriptor;

        bool nstable;



        descaddr |= (address >> (stride * (4 - level))) & descmask;

        descaddr &= ~7ULL;

        nstable = extract32(tableattrs, 4, 1);

        descriptor = arm_ldq_ptw(cs, descaddr, !nstable);

        if (!(descriptor & 1) ||

            (!(descriptor & 2) && (level == 3))) {

            /* Invalid, or the Reserved level 3 encoding */

            goto do_fault;

        }

        descaddr = descriptor & 0xfffffff000ULL;



        if ((descriptor & 2) && (level < 3)) {

            /* Table entry. The top five bits are attributes which  may

             * propagate down through lower levels of the table (and

             * which are all arranged so that 0 means "no effect", so

             * we can gather them up by ORing in the bits at each level).

             */

            tableattrs |= extract64(descriptor, 59, 5);

            level++;

            continue;

        }

        /* Block entry at level 1 or 2, or page entry at level 3.

         * These are basically the same thing, although the number

         * of bits we pull in from the vaddr varies.

         */

        page_size = (1ULL << ((stride * (4 - level)) + 3));

        descaddr |= (address & (page_size - 1));

        /* Extract attributes from the descriptor and merge with table attrs */

        attrs = extract64(descriptor, 2, 10)

            | (extract64(descriptor, 52, 12) << 10);

        attrs |= extract32(tableattrs, 0, 2) << 11; /* XN, PXN */

        attrs |= extract32(tableattrs, 3, 1) << 5; /* APTable[1] => AP[2] */

        /* The sense of AP[1] vs APTable[0] is reversed, as APTable[0] == 1

         * means "force PL1 access only", which means forcing AP[1] to 0.

         */

        if (extract32(tableattrs, 2, 1)) {

            attrs &= ~(1 << 4);

        }

        attrs |= nstable << 3; /* NS */

        break;

    }

    /* Here descaddr is the final physical address, and attributes

     * are all in attrs.

     */

    fault_type = access_fault;

    if ((attrs & (1 << 8)) == 0) {

        /* Access flag */

        goto do_fault;

    }



    ap = extract32(attrs, 4, 2);

    ns = extract32(attrs, 3, 1);

    xn = extract32(attrs, 12, 1);

    pxn = extract32(attrs, 11, 1);



    *prot = get_S1prot(env, mmu_idx, va_size == 64, ap, ns, xn, pxn);



    fault_type = permission_fault;

    if (!(*prot & (1 << access_type))) {

        goto do_fault;

    }



    if (ns) {

        /* The NS bit will (as required by the architecture) have no effect if

         * the CPU doesn't support TZ or this is a non-secure translation

         * regime, because the attribute will already be non-secure.

         */

        txattrs->secure = false;

    }

    *phys_ptr = descaddr;

    *page_size_ptr = page_size;

    return false;



do_fault:

    /* Long-descriptor format IFSR/DFSR value */

    *fsr = (1 << 9) | (fault_type << 2) | level;

    return true;

}
 and probability:0.12142857142857143
code:static int openfile(char *name, int flags, int growable)

{

	if (bs) {

		fprintf(stderr, "file open already, try 'help close'\n");

		return 1;

	}



	bs = bdrv_new("hda");

	if (!bs)

		return 1;



	if (growable) {

		flags |= BDRV_O_FILE;

	}



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, "%s: can't open device %s\n", progname, name);

		bs = NULL;

		return 1;

	}



	if (growable) {

		bs->growable = 1;

	}

	return 0;

}
 and probability:0.045454545454545456
code:static void visit_nested_struct(Visitor *v, void **native, Error **errp)

{

    visit_type_UserDefNested(v, (UserDefNested **)native, NULL, errp);

}
 and probability:0.0
code:static uint64_t bmdma_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    BMDMAState *bm = opaque;

    uint32_t val;



    if (size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;

    }



    switch(addr & 3) {

    case 0:

        val = bm->cmd;

        break;

    case 2:

        val = bm->status;

        break;

    default:

        val = 0xff;

        break;

    }

#ifdef DEBUG_IDE

    printf("bmdma: readb 0x%02x : 0x%02x\n", (uint8_t)addr, val);

#endif

    return val;

}
 and probability:0.13043478260869565
code:static void palmte_init(MachineState *machine)

{

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    MemoryRegion *address_space_mem = get_system_memory();

    struct omap_mpu_state_s *mpu;

    int flash_size = 0x00800000;

    int sdram_size = palmte_binfo.ram_size;

    static uint32_t cs0val = 0xffffffff;

    static uint32_t cs1val = 0x0000e1a0;

    static uint32_t cs2val = 0x0000e1a0;

    static uint32_t cs3val = 0xe1a0e1a0;

    int rom_size, rom_loaded = 0;

    MemoryRegion *flash = g_new(MemoryRegion, 1);

    MemoryRegion *cs = g_new(MemoryRegion, 4);



    mpu = omap310_mpu_init(address_space_mem, sdram_size, machine->cpu_type);



    /* External Flash (EMIFS) */

    memory_region_init_ram(flash, NULL, "palmte.flash", flash_size,

                           &error_fatal);

    memory_region_set_readonly(flash, true);

    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE, flash);



    memory_region_init_io(&cs[0], NULL, &static_ops, &cs0val, "palmte-cs0",

                          OMAP_CS0_SIZE - flash_size);

    memory_region_add_subregion(address_space_mem, OMAP_CS0_BASE + flash_size,

                                &cs[0]);

    memory_region_init_io(&cs[1], NULL, &static_ops, &cs1val, "palmte-cs1",

                          OMAP_CS1_SIZE);

    memory_region_add_subregion(address_space_mem, OMAP_CS1_BASE, &cs[1]);

    memory_region_init_io(&cs[2], NULL, &static_ops, &cs2val, "palmte-cs2",

                          OMAP_CS2_SIZE);

    memory_region_add_subregion(address_space_mem, OMAP_CS2_BASE, &cs[2]);

    memory_region_init_io(&cs[3], NULL, &static_ops, &cs3val, "palmte-cs3",

                          OMAP_CS3_SIZE);

    memory_region_add_subregion(address_space_mem, OMAP_CS3_BASE, &cs[3]);



    palmte_microwire_setup(mpu);



    qemu_add_kbd_event_handler(palmte_button_event, mpu);



    palmte_gpio_setup(mpu);



    /* Setup initial (reset) machine state */

    if (nb_option_roms) {

        rom_size = get_image_size(option_rom[0].name);

        if (rom_size > flash_size) {

            fprintf(stderr, "%s: ROM image too big (%x > %x)\n",

                            __FUNCTION__, rom_size, flash_size);

            rom_size = 0;

        }

        if (rom_size > 0) {

            rom_size = load_image_targphys(option_rom[0].name, OMAP_CS0_BASE,

                                           flash_size);

            rom_loaded = 1;

        }

        if (rom_size < 0) {

            fprintf(stderr, "%s: error loading '%s'\n",

                            __FUNCTION__, option_rom[0].name);

        }

    }



    if (!rom_loaded && !kernel_filename && !qtest_enabled()) {

        fprintf(stderr, "Kernel or ROM image must be specified\n");

        exit(1);

    }



    /* Load the kernel.  */

    palmte_binfo.kernel_filename = kernel_filename;

    palmte_binfo.kernel_cmdline = kernel_cmdline;

    palmte_binfo.initrd_filename = initrd_filename;

    arm_load_kernel(mpu->cpu, &palmte_binfo);

}
 and probability:0.2727272727272727
code:void configure_icount(const char *option)

{

    vmstate_register(NULL, 0, &vmstate_timers, &timers_state);

    if (!option)

        return;



    if (strcmp(option, "auto") != 0) {

        icount_time_shift = strtol(option, NULL, 0);

        use_icount = 1;

        return;

    }



    use_icount = 2;



    /* 125MIPS seems a reasonable initial guess at the guest speed.

       It will be corrected fairly quickly anyway.  */

    icount_time_shift = 3;



    /* Have both realtime and virtual time triggers for speed adjustment.

       The realtime trigger catches emulated time passing too slowly,

       the virtual time trigger catches emulated time passing too fast.

       Realtime triggers occur even when idle, so use them less frequently

       than VM triggers.  */

    icount_rt_timer = qemu_new_timer(rt_clock, icount_adjust_rt, NULL);

    qemu_mod_timer(icount_rt_timer,

                   qemu_get_clock(rt_clock) + 1000);

    icount_vm_timer = qemu_new_timer(vm_clock, icount_adjust_vm, NULL);

    qemu_mod_timer(icount_vm_timer,

                   qemu_get_clock(vm_clock) + get_ticks_per_sec() / 10);

}
 and probability:0.07692307692307693
code:struct omap_mmc_s *omap_mmc_init(hwaddr base,

                MemoryRegion *sysmem,

                BlockDriverState *bd,

                qemu_irq irq, qemu_irq dma[], omap_clk clk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = clk;

    s->lines = 1;	/* TODO: needs to be settable per-board */

    s->rev = 1;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, "omap.mmc", 0x800);

    memory_region_add_subregion(sysmem, base, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    return s;

}
 and probability:0.4090909090909091
code:static int v9fs_synth_utimensat(FsContext *fs_ctx, V9fsPath *path,

                                const struct timespec *buf)

{

    errno = EPERM;

    return 0;

}
 and probability:0.0
code:static int monitor_fprintf(FILE *stream, const char *fmt, ...)

{

    va_list ap;

    va_start(ap, fmt);

    monitor_vprintf((Monitor *)stream, fmt, ap);

    va_end(ap);

    return 0;

}
 and probability:0.0
code:static void hls_transform_unit(HEVCContext *s, int x0, int y0,

                               int xBase, int yBase, int cb_xBase, int cb_yBase,

                               int log2_cb_size, int log2_trafo_size,

                               int trafo_depth, int blk_idx)

{

    HEVCLocalContext *lc = &s->HEVClc;



    if (lc->cu.pred_mode == MODE_INTRA) {

        int trafo_size = 1 << log2_trafo_size;

        ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);



        s->hpc.intra_pred(s, x0, y0, log2_trafo_size, 0);

        if (log2_trafo_size > 2) {

            trafo_size = trafo_size << (s->sps->hshift[1] - 1);

            ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);

            s->hpc.intra_pred(s, x0, y0, log2_trafo_size - 1, 1);

            s->hpc.intra_pred(s, x0, y0, log2_trafo_size - 1, 2);

        } else if (blk_idx == 3) {

            trafo_size = trafo_size << s->sps->hshift[1];

            ff_hevc_set_neighbour_available(s, xBase, yBase,

                                            trafo_size, trafo_size);

            s->hpc.intra_pred(s, xBase, yBase, log2_trafo_size, 1);

            s->hpc.intra_pred(s, xBase, yBase, log2_trafo_size, 2);

        }

    }



    if (lc->tt.cbf_luma ||

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {

        int scan_idx   = SCAN_DIAG;

        int scan_idx_c = SCAN_DIAG;



        if (s->pps->cu_qp_delta_enabled_flag && !lc->tu.is_cu_qp_delta_coded) {

            lc->tu.cu_qp_delta = ff_hevc_cu_qp_delta_abs(s);

            if (lc->tu.cu_qp_delta != 0)

                if (ff_hevc_cu_qp_delta_sign_flag(s) == 1)

                    lc->tu.cu_qp_delta = -lc->tu.cu_qp_delta;

            lc->tu.is_cu_qp_delta_coded = 1;

            ff_hevc_set_qPy(s, x0, y0, cb_xBase, cb_yBase, log2_cb_size);

        }



        if (lc->cu.pred_mode == MODE_INTRA && log2_trafo_size < 4) {

            if (lc->tu.cur_intra_pred_mode >= 6 &&

                lc->tu.cur_intra_pred_mode <= 14) {

                scan_idx = SCAN_VERT;

            } else if (lc->tu.cur_intra_pred_mode >= 22 &&

                       lc->tu.cur_intra_pred_mode <= 30) {

                scan_idx = SCAN_HORIZ;

            }



            if (lc->pu.intra_pred_mode_c >=  6 &&

                lc->pu.intra_pred_mode_c <= 14) {

                scan_idx_c = SCAN_VERT;

            } else if (lc->pu.intra_pred_mode_c >= 22 &&

                       lc->pu.intra_pred_mode_c <= 30) {

                scan_idx_c = SCAN_HORIZ;

            }

        }



        if (lc->tt.cbf_luma)

            hls_residual_coding(s, x0, y0, log2_trafo_size, scan_idx, 0);

        if (log2_trafo_size > 2) {

            if (SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0))

                hls_residual_coding(s, x0, y0, log2_trafo_size - 1, scan_idx_c, 1);

            if (SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0))

                hls_residual_coding(s, x0, y0, log2_trafo_size - 1, scan_idx_c, 2);

        } else if (blk_idx == 3) {

            if (SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], xBase, yBase))

                hls_residual_coding(s, xBase, yBase, log2_trafo_size, scan_idx_c, 1);

            if (SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], xBase, yBase))

                hls_residual_coding(s, xBase, yBase, log2_trafo_size, scan_idx_c, 2);

        }

    }

}
 and probability:0.4925373134328358
code:static int tgv_decode_inter(TgvContext *s, AVFrame *frame,

                            const uint8_t *buf, const uint8_t *buf_end)

{

    int num_mvs;

    int num_blocks_raw;

    int num_blocks_packed;

    int vector_bits;

    int i,j,x,y;

    GetBitContext gb;

    int mvbits;

    const uint8_t *blocks_raw;



    if(buf_end - buf < 12)

        return AVERROR_INVALIDDATA;



    num_mvs           = AV_RL16(&buf[0]);

    num_blocks_raw    = AV_RL16(&buf[2]);

    num_blocks_packed = AV_RL16(&buf[4]);

    vector_bits       = AV_RL16(&buf[6]);

    buf += 12;



    if (vector_bits > MIN_CACHE_BITS || !vector_bits) {

        av_log(s->avctx, AV_LOG_ERROR,

               "Invalid value for motion vector bits: %d\n", vector_bits);

        return AVERROR_INVALIDDATA;

    }



    /* allocate codebook buffers as necessary */

    if (num_mvs > s->num_mvs) {

        s->mv_codebook = av_realloc(s->mv_codebook, num_mvs*2*sizeof(int));

        s->num_mvs = num_mvs;

    }



    if (num_blocks_packed > s->num_blocks_packed) {

        s->block_codebook = av_realloc(s->block_codebook, num_blocks_packed*16);

        s->num_blocks_packed = num_blocks_packed;

    }



    /* read motion vectors */

    mvbits = (num_mvs * 2 * 10 + 31) & ~31;



    if (buf_end - buf < (mvbits>>3) + 16*num_blocks_raw + 8*num_blocks_packed)

        return AVERROR_INVALIDDATA;



    init_get_bits(&gb, buf, mvbits);

    for (i = 0; i < num_mvs; i++) {

        s->mv_codebook[i][0] = get_sbits(&gb, 10);

        s->mv_codebook[i][1] = get_sbits(&gb, 10);

    }

    buf += mvbits >> 3;



    /* note ptr to uncompressed blocks */

    blocks_raw = buf;

    buf       += num_blocks_raw * 16;



    /* read compressed blocks */

    init_get_bits(&gb, buf, (buf_end - buf) << 3);

    for (i = 0; i < num_blocks_packed; i++) {

        int tmp[4];

        for (j = 0; j < 4; j++)

            tmp[j] = get_bits(&gb, 8);

        for (j = 0; j < 16; j++)

            s->block_codebook[i][15-j] = tmp[get_bits(&gb, 2)];

    }



    if (get_bits_left(&gb) < vector_bits *

        (s->avctx->height / 4) * (s->avctx->width / 4))

        return AVERROR_INVALIDDATA;



    /* read vectors and build frame */

    for (y = 0; y < s->avctx->height / 4; y++)

        for (x = 0; x < s->avctx->width / 4; x++) {

            unsigned int vector = get_bits(&gb, vector_bits);

            const uint8_t *src;

            int src_stride;



            if (vector < num_mvs) {

                int mx = x * 4 + s->mv_codebook[vector][0];

                int my = y * 4 + s->mv_codebook[vector][1];



                if (mx < 0 || mx + 4 > s->avctx->width ||

                    my < 0 || my + 4 > s->avctx->height) {

                    av_log(s->avctx, AV_LOG_ERROR, "MV %d %d out of picture\n", mx, my);

                    continue;

                }



                src = s->last_frame.data[0] + mx + my * s->last_frame.linesize[0];

                src_stride = s->last_frame.linesize[0];

            } else {

                int offset = vector - num_mvs;

                if (offset < num_blocks_raw)

                    src = blocks_raw + 16*offset;

                else if (offset - num_blocks_raw < num_blocks_packed)

                    src = s->block_codebook[offset - num_blocks_raw];

                else

                    continue;

                src_stride = 4;

            }



            for (j = 0; j < 4; j++)

                for (i = 0; i < 4; i++)

                    frame->data[0][(y * 4 + j) * frame->linesize[0] + (x * 4 + i)] =

                        src[j * src_stride + i];

    }



    return 0;

}
 and probability:0.5
code:void FUNCC(ff_h264_luma_dc_dequant_idct)(int16_t *_output, int16_t *_input, int qmul){

#define stride 16

    int i;

    int temp[16];

    static const uint8_t x_offset[4]={0, 2*stride, 8*stride, 10*stride};

    dctcoef *input = (dctcoef*)_input;

    dctcoef *output = (dctcoef*)_output;



    for(i=0; i<4; i++){

        const int z0= input[4*i+0] + input[4*i+1];

        const int z1= input[4*i+0] - input[4*i+1];

        const int z2= input[4*i+2] - input[4*i+3];

        const int z3= input[4*i+2] + input[4*i+3];



        temp[4*i+0]= z0+z3;

        temp[4*i+1]= z0-z3;

        temp[4*i+2]= z1-z2;

        temp[4*i+3]= z1+z2;

    }



    for(i=0; i<4; i++){

        const int offset= x_offset[i];

        const int z0= temp[4*0+i] + temp[4*2+i];

        const int z1= temp[4*0+i] - temp[4*2+i];

        const int z2= temp[4*1+i] - temp[4*3+i];

        const int z3= temp[4*1+i] + temp[4*3+i];



        output[stride* 0+offset]= ((((z0 + z3)*qmul + 128 ) >> 8));

        output[stride* 1+offset]= ((((z1 + z2)*qmul + 128 ) >> 8));

        output[stride* 4+offset]= ((((z1 - z2)*qmul + 128 ) >> 8));

        output[stride* 5+offset]= ((((z0 - z3)*qmul + 128 ) >> 8));

    }

#undef stride

}
 and probability:0.6666666666666666
code:static uint64_t qemu_rdma_make_wrid(uint64_t wr_id, uint64_t index,

                                         uint64_t chunk)

{

    uint64_t result = wr_id & RDMA_WRID_TYPE_MASK;



    result |= (index << RDMA_WRID_BLOCK_SHIFT);

    result |= (chunk << RDMA_WRID_CHUNK_SHIFT);



    return result;

}
 and probability:0.0
code:static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,

                                       Error **errp)

{

    Error *local_err = NULL;

    BlockMeasureInfo *info;

    uint64_t required = 0; /* bytes that contribute to required size */

    uint64_t virtual_size; /* disk size as seen by guest */

    uint64_t refcount_bits;

    uint64_t l2_tables;

    size_t cluster_size;

    int version;

    char *optstr;

    PreallocMode prealloc;

    bool has_backing_file;



    /* Parse image creation options */

    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);

    if (local_err) {

        goto err;

    }



    version = qcow2_opt_get_version_del(opts, &local_err);

    if (local_err) {

        goto err;

    }



    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);

    if (local_err) {

        goto err;

    }



    optstr = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);

    prealloc = qapi_enum_parse(PreallocMode_lookup, optstr,

                               PREALLOC_MODE__MAX, PREALLOC_MODE_OFF,

                               &local_err);

    g_free(optstr);

    if (local_err) {

        goto err;

    }



    optstr = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);

    has_backing_file = !!optstr;

    g_free(optstr);



    virtual_size = align_offset(qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0),

                                cluster_size);



    /* Check that virtual disk size is valid */

    l2_tables = DIV_ROUND_UP(virtual_size / cluster_size,

                             cluster_size / sizeof(uint64_t));

    if (l2_tables * sizeof(uint64_t) > QCOW_MAX_L1_SIZE) {

        error_setg(&local_err, "The image size is too large "

                               "(try using a larger cluster size)");

        goto err;

    }



    /* Account for input image */

    if (in_bs) {

        int64_t ssize = bdrv_getlength(in_bs);

        if (ssize < 0) {

            error_setg_errno(&local_err, -ssize,

                             "Unable to get image virtual_size");

            goto err;

        }



        virtual_size = align_offset(ssize, cluster_size);



        if (has_backing_file) {

            /* We don't how much of the backing chain is shared by the input

             * image and the new image file.  In the worst case the new image's

             * backing file has nothing in common with the input image.  Be

             * conservative and assume all clusters need to be written.

             */

            required = virtual_size;

        } else {

            int cluster_sectors = cluster_size / BDRV_SECTOR_SIZE;

            int64_t sector_num;

            int pnum = 0;



            for (sector_num = 0;

                 sector_num < ssize / BDRV_SECTOR_SIZE;

                 sector_num += pnum) {

                int nb_sectors = MAX(ssize / BDRV_SECTOR_SIZE - sector_num,

                                     INT_MAX);

                BlockDriverState *file;

                int64_t ret;



                ret = bdrv_get_block_status_above(in_bs, NULL,

                                                  sector_num, nb_sectors,

                                                  &pnum, &file);

                if (ret < 0) {

                    error_setg_errno(&local_err, -ret,

                                     "Unable to get block status");

                    goto err;

                }



                if (ret & BDRV_BLOCK_ZERO) {

                    /* Skip zero regions (safe with no backing file) */

                } else if ((ret & (BDRV_BLOCK_DATA | BDRV_BLOCK_ALLOCATED)) ==

                           (BDRV_BLOCK_DATA | BDRV_BLOCK_ALLOCATED)) {

                    /* Extend pnum to end of cluster for next iteration */

                    pnum = ROUND_UP(sector_num + pnum, cluster_sectors) -

                           sector_num;



                    /* Count clusters we've seen */

                    required += (sector_num % cluster_sectors + pnum) *

                                BDRV_SECTOR_SIZE;

                }

            }

        }

    }



    /* Take into account preallocation.  Nothing special is needed for

     * PREALLOC_MODE_METADATA since metadata is always counted.

     */

    if (prealloc == PREALLOC_MODE_FULL || prealloc == PREALLOC_MODE_FALLOC) {

        required = virtual_size;

    }



    info = g_new(BlockMeasureInfo, 1);

    info->fully_allocated =

        qcow2_calc_prealloc_size(virtual_size, cluster_size,

                                 ctz32(refcount_bits));



    /* Remove data clusters that are not required.  This overestimates the

     * required size because metadata needed for the fully allocated file is

     * still counted.

     */

    info->required = info->fully_allocated - virtual_size + required;

    return info;



err:

    error_propagate(errp, local_err);

    return NULL;

}
 and probability:0.09401709401709402
code:static target_ulong disas_insn(DisasContext *s, CPUState *cpu)

{

    CPUX86State *env = cpu->env_ptr;

    int b, prefixes;

    int shift;

    TCGMemOp ot, aflag, dflag;

    int modrm, reg, rm, mod, op, opreg, val;

    target_ulong next_eip, tval;

    int rex_w, rex_r;

    target_ulong pc_start = s->base.pc_next;



    s->pc_start = s->pc = pc_start;

    prefixes = 0;

    s->override = -1;

    rex_w = -1;

    rex_r = 0;

#ifdef TARGET_X86_64

    s->rex_x = 0;

    s->rex_b = 0;

    x86_64_hregs = 0;

#endif

    s->rip_offset = 0; /* for relative ip address */

    s->vex_l = 0;

    s->vex_v = 0;

    if (sigsetjmp(s->jmpbuf, 0) != 0) {

        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        return s->pc;

    }



 next_byte:

    b = x86_ldub_code(env, s);

    /* Collect prefixes.  */

    switch (b) {

    case 0xf3:

        prefixes |= PREFIX_REPZ;

        goto next_byte;

    case 0xf2:

        prefixes |= PREFIX_REPNZ;

        goto next_byte;

    case 0xf0:

        prefixes |= PREFIX_LOCK;

        goto next_byte;

    case 0x2e:

        s->override = R_CS;

        goto next_byte;

    case 0x36:

        s->override = R_SS;

        goto next_byte;

    case 0x3e:

        s->override = R_DS;

        goto next_byte;

    case 0x26:

        s->override = R_ES;

        goto next_byte;

    case 0x64:

        s->override = R_FS;

        goto next_byte;

    case 0x65:

        s->override = R_GS;

        goto next_byte;

    case 0x66:

        prefixes |= PREFIX_DATA;

        goto next_byte;

    case 0x67:

        prefixes |= PREFIX_ADR;

        goto next_byte;

#ifdef TARGET_X86_64

    case 0x40 ... 0x4f:

        if (CODE64(s)) {

            /* REX prefix */

            rex_w = (b >> 3) & 1;

            rex_r = (b & 0x4) << 1;

            s->rex_x = (b & 0x2) << 2;

            REX_B(s) = (b & 0x1) << 3;

            x86_64_hregs = 1; /* select uniform byte register addressing */

            goto next_byte;

        }

        break;

#endif

    case 0xc5: /* 2-byte VEX */

    case 0xc4: /* 3-byte VEX */

        /* VEX prefixes cannot be used except in 32-bit mode.

           Otherwise the instruction is LES or LDS.  */

        if (s->code32 && !s->vm86) {

            static const int pp_prefix[4] = {

                0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ

            };

            int vex3, vex2 = x86_ldub_code(env, s);



            if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {

                /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b,

                   otherwise the instruction is LES or LDS.  */

                break;

            }

            s->pc++;



            /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */

            if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ

                            | PREFIX_LOCK | PREFIX_DATA)) {

                goto illegal_op;

            }

#ifdef TARGET_X86_64

            if (x86_64_hregs) {

                goto illegal_op;

            }

#endif

            rex_r = (~vex2 >> 4) & 8;

            if (b == 0xc5) {

                vex3 = vex2;

                b = x86_ldub_code(env, s);

            } else {

#ifdef TARGET_X86_64

                s->rex_x = (~vex2 >> 3) & 8;

                s->rex_b = (~vex2 >> 2) & 8;

#endif

                vex3 = x86_ldub_code(env, s);

                rex_w = (vex3 >> 7) & 1;

                switch (vex2 & 0x1f) {

                case 0x01: /* Implied 0f leading opcode bytes.  */

                    b = x86_ldub_code(env, s) | 0x100;

                    break;

                case 0x02: /* Implied 0f 38 leading opcode bytes.  */

                    b = 0x138;

                    break;

                case 0x03: /* Implied 0f 3a leading opcode bytes.  */

                    b = 0x13a;

                    break;

                default:   /* Reserved for future use.  */

                    goto unknown_op;

                }

            }

            s->vex_v = (~vex3 >> 3) & 0xf;

            s->vex_l = (vex3 >> 2) & 1;

            prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;

        }

        break;

    }



    /* Post-process prefixes.  */

    if (CODE64(s)) {

        /* In 64-bit mode, the default data size is 32-bit.  Select 64-bit

           data with rex_w, and 16-bit data with 0x66; rex_w takes precedence

           over 0x66 if both are present.  */

        dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);

        /* In 64-bit mode, 0x67 selects 32-bit addressing.  */

        aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);

    } else {

        /* In 16/32-bit mode, 0x66 selects the opposite data size.  */

        if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {

            dflag = MO_32;

        } else {

            dflag = MO_16;

        }

        /* In 16/32-bit mode, 0x67 selects the opposite addressing.  */

        if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {

            aflag = MO_32;

        }  else {

            aflag = MO_16;

        }

    }



    s->prefix = prefixes;

    s->aflag = aflag;

    s->dflag = dflag;



    /* now check op code */

 reswitch:

    switch(b) {

    case 0x0f:

        /**************************/

        /* extended op code */

        b = x86_ldub_code(env, s) | 0x100;

        goto reswitch;



        /**************************/

        /* arith & logic */

    case 0x00 ... 0x05:

    case 0x08 ... 0x0d:

    case 0x10 ... 0x15:

    case 0x18 ... 0x1d:

    case 0x20 ... 0x25:

    case 0x28 ... 0x2d:

    case 0x30 ... 0x35:

    case 0x38 ... 0x3d:

        {

            int op, f, val;

            op = (b >> 3) & 7;

            f = (b >> 1) & 3;



            ot = mo_b_d(b, dflag);



            switch(f) {

            case 0: /* OP Ev, Gv */

                modrm = x86_ldub_code(env, s);

                reg = ((modrm >> 3) & 7) | rex_r;

                mod = (modrm >> 6) & 3;

                rm = (modrm & 7) | REX_B(s);

                if (mod != 3) {

                    gen_lea_modrm(env, s, modrm);

                    opreg = OR_TMP0;

                } else if (op == OP_XORL && rm == reg) {

                xor_zero:

                    /* xor reg, reg optimisation */

                    set_cc_op(s, CC_OP_CLR);

                    tcg_gen_movi_tl(cpu_T0, 0);

                    gen_op_mov_reg_v(ot, reg, cpu_T0);

                    break;

                } else {

                    opreg = rm;

                }

                gen_op_mov_v_reg(ot, cpu_T1, reg);

                gen_op(s, op, ot, opreg);

                break;

            case 1: /* OP Gv, Ev */

                modrm = x86_ldub_code(env, s);

                mod = (modrm >> 6) & 3;

                reg = ((modrm >> 3) & 7) | rex_r;

                rm = (modrm & 7) | REX_B(s);

                if (mod != 3) {

                    gen_lea_modrm(env, s, modrm);

                    gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

                } else if (op == OP_XORL && rm == reg) {

                    goto xor_zero;

                } else {

                    gen_op_mov_v_reg(ot, cpu_T1, rm);

                }

                gen_op(s, op, ot, reg);

                break;

            case 2: /* OP A, Iv */

                val = insn_get(env, s, ot);

                tcg_gen_movi_tl(cpu_T1, val);

                gen_op(s, op, ot, OR_EAX);

                break;

            }

        }

        break;



    case 0x82:

        if (CODE64(s))

            goto illegal_op;

    case 0x80: /* GRP1 */

    case 0x81:

    case 0x83:

        {

            int val;



            ot = mo_b_d(b, dflag);



            modrm = x86_ldub_code(env, s);

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);

            op = (modrm >> 3) & 7;



            if (mod != 3) {

                if (b == 0x83)

                    s->rip_offset = 1;

                else

                    s->rip_offset = insn_const_size(ot);

                gen_lea_modrm(env, s, modrm);

                opreg = OR_TMP0;

            } else {

                opreg = rm;

            }



            switch(b) {

            default:

            case 0x80:

            case 0x81:

            case 0x82:

                val = insn_get(env, s, ot);

                break;

            case 0x83:

                val = (int8_t)insn_get(env, s, MO_8);

                break;

            }

            tcg_gen_movi_tl(cpu_T1, val);

            gen_op(s, op, ot, opreg);

        }

        break;



        /**************************/

        /* inc, dec, and other misc arith */

    case 0x40 ... 0x47: /* inc Gv */

        ot = dflag;

        gen_inc(s, ot, OR_EAX + (b & 7), 1);

        break;

    case 0x48 ... 0x4f: /* dec Gv */

        ot = dflag;

        gen_inc(s, ot, OR_EAX + (b & 7), -1);

        break;

    case 0xf6: /* GRP3 */

    case 0xf7:

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        op = (modrm >> 3) & 7;

        if (mod != 3) {

            if (op == 0) {

                s->rip_offset = insn_const_size(ot);

            }

            gen_lea_modrm(env, s, modrm);

            /* For those below that handle locked memory, don't load here.  */

            if (!(s->prefix & PREFIX_LOCK)

                || op != 2) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }



        switch(op) {

        case 0: /* test */

            val = insn_get(env, s, ot);

            tcg_gen_movi_tl(cpu_T1, val);

            gen_op_testl_T0_T1_cc();

            set_cc_op(s, CC_OP_LOGICB + ot);

            break;

        case 2: /* not */

            if (s->prefix & PREFIX_LOCK) {

                if (mod == 3) {

                    goto illegal_op;

                }

                tcg_gen_movi_tl(cpu_T0, ~0);

                tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,

                                            s->mem_index, ot | MO_LE);

            } else {

                tcg_gen_not_tl(cpu_T0, cpu_T0);

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

            break;

        case 3: /* neg */

            if (s->prefix & PREFIX_LOCK) {

                TCGLabel *label1;

                TCGv a0, t0, t1, t2;



                if (mod == 3) {

                    goto illegal_op;

                }

                a0 = tcg_temp_local_new();

                t0 = tcg_temp_local_new();

                label1 = gen_new_label();



                tcg_gen_mov_tl(a0, cpu_A0);

                tcg_gen_mov_tl(t0, cpu_T0);



                gen_set_label(label1);

                t1 = tcg_temp_new();

                t2 = tcg_temp_new();

                tcg_gen_mov_tl(t2, t0);

                tcg_gen_neg_tl(t1, t0);

                tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,

                                          s->mem_index, ot | MO_LE);

                tcg_temp_free(t1);

                tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);



                tcg_temp_free(t2);

                tcg_temp_free(a0);

                tcg_gen_mov_tl(cpu_T0, t0);

                tcg_temp_free(t0);

            } else {

                tcg_gen_neg_tl(cpu_T0, cpu_T0);

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

            gen_op_update_neg_cc();

            set_cc_op(s, CC_OP_SUBB + ot);

            break;

        case 4: /* mul */

            switch(ot) {

            case MO_8:

                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);

                tcg_gen_ext8u_tl(cpu_T0, cpu_T0);

                tcg_gen_ext8u_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);

                set_cc_op(s, CC_OP_MULB);

                break;

            case MO_16:

                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

                tcg_gen_ext16u_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);

                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

                set_cc_op(s, CC_OP_MULW);

                break;

            default:

            case MO_32:

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);

                tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                                  cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULL);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],

                                  cpu_T0, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULQ);

                break;

#endif

            }

            break;

        case 5: /* imul */

            switch(ot) {

            case MO_8:

                gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);

                tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

                tcg_gen_ext8s_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);

                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

                set_cc_op(s, CC_OP_MULB);

                break;

            case MO_16:

                gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);

                tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

                tcg_gen_ext16s_tl(cpu_T1, cpu_T1);

                /* XXX: use 32 bit mul which could be faster */

                tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

                tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);

                tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

                tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);

                gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

                set_cc_op(s, CC_OP_MULW);

                break;

            default:

            case MO_32:

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);

                tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                                  cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);

                tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);

                tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);

                tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);

                set_cc_op(s, CC_OP_MULL);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],

                                  cpu_T0, cpu_regs[R_EAX]);

                tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);

                tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);

                tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);

                set_cc_op(s, CC_OP_MULQ);

                break;

#endif

            }

            break;

        case 6: /* div */

            switch(ot) {

            case MO_8:

                gen_helper_divb_AL(cpu_env, cpu_T0);

                break;

            case MO_16:

                gen_helper_divw_AX(cpu_env, cpu_T0);

                break;

            default:

            case MO_32:

                gen_helper_divl_EAX(cpu_env, cpu_T0);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                gen_helper_divq_EAX(cpu_env, cpu_T0);

                break;

#endif

            }

            break;

        case 7: /* idiv */

            switch(ot) {

            case MO_8:

                gen_helper_idivb_AL(cpu_env, cpu_T0);

                break;

            case MO_16:

                gen_helper_idivw_AX(cpu_env, cpu_T0);

                break;

            default:

            case MO_32:

                gen_helper_idivl_EAX(cpu_env, cpu_T0);

                break;

#ifdef TARGET_X86_64

            case MO_64:

                gen_helper_idivq_EAX(cpu_env, cpu_T0);

                break;

#endif

            }

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0xfe: /* GRP4 */

    case 0xff: /* GRP5 */

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        op = (modrm >> 3) & 7;

        if (op >= 2 && b == 0xfe) {

            goto unknown_op;

        }

        if (CODE64(s)) {

            if (op == 2 || op == 4) {

                /* operand size for jumps is 64 bit */

                ot = MO_64;

            } else if (op == 3 || op == 5) {

                ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;

            } else if (op == 6) {

                /* default push size is 64 bit */

                ot = mo_pushpop(s, dflag);

            }

        }

        if (mod != 3) {

            gen_lea_modrm(env, s, modrm);

            if (op >= 2 && op != 3 && op != 5)

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }



        switch(op) {

        case 0: /* inc Ev */

            if (mod != 3)

                opreg = OR_TMP0;

            else

                opreg = rm;

            gen_inc(s, ot, opreg, 1);

            break;

        case 1: /* dec Ev */

            if (mod != 3)

                opreg = OR_TMP0;

            else

                opreg = rm;

            gen_inc(s, ot, opreg, -1);

            break;

        case 2: /* call Ev */

            /* XXX: optimize if memory (no 'and' is necessary) */

            if (dflag == MO_16) {

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

            }

            next_eip = s->pc - s->cs_base;

            tcg_gen_movi_tl(cpu_T1, next_eip);

            gen_push_v(s, cpu_T1);

            gen_op_jmp_v(cpu_T0);

            gen_bnd_jmp(s);

            gen_jr(s, cpu_T0);

            break;

        case 3: /* lcall Ev */

            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 1 << ot);

            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        do_lcall:

            if (s->pe && !s->vm86) {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,

                                           tcg_const_i32(dflag - 1),

                                           tcg_const_tl(s->pc - s->cs_base));

            } else {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,

                                      tcg_const_i32(dflag - 1),

                                      tcg_const_i32(s->pc - s->cs_base));

            }

            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));

            gen_jr(s, cpu_tmp4);

            break;

        case 4: /* jmp Ev */

            if (dflag == MO_16) {

                tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

            }

            gen_op_jmp_v(cpu_T0);

            gen_bnd_jmp(s);

            gen_jr(s, cpu_T0);

            break;

        case 5: /* ljmp Ev */

            gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 1 << ot);

            gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        do_ljmp:

            if (s->pe && !s->vm86) {

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,

                                          tcg_const_tl(s->pc - s->cs_base));

            } else {

                gen_op_movl_seg_T0_vm(R_CS);

                gen_op_jmp_v(cpu_T1);

            }

            tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip));

            gen_jr(s, cpu_tmp4);

            break;

        case 6: /* push Ev */

            gen_push_v(s, cpu_T0);

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0x84: /* test Ev, Gv */

    case 0x85:

        ot = mo_b_d(b, dflag);



        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_op_mov_v_reg(ot, cpu_T1, reg);

        gen_op_testl_T0_T1_cc();

        set_cc_op(s, CC_OP_LOGICB + ot);

        break;



    case 0xa8: /* test eAX, Iv */

    case 0xa9:

        ot = mo_b_d(b, dflag);

        val = insn_get(env, s, ot);



        gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);

        tcg_gen_movi_tl(cpu_T1, val);

        gen_op_testl_T0_T1_cc();

        set_cc_op(s, CC_OP_LOGICB + ot);

        break;



    case 0x98: /* CWDE/CBW */

        switch (dflag) {

#ifdef TARGET_X86_64

        case MO_64:

            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);

            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);

            break;

#endif

        case MO_32:

            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);

            break;

        case MO_16:

            gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);

            tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

            break;

        default:

            tcg_abort();

        }

        break;

    case 0x99: /* CDQ/CWD */

        switch (dflag) {

#ifdef TARGET_X86_64

        case MO_64:

            gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);

            gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);

            break;

#endif

        case MO_32:

            gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);

            tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);

            gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);

            break;

        case MO_16:

            gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);

            gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);

            break;

        default:

            tcg_abort();

        }

        break;

    case 0x1af: /* imul Gv, Ev */

    case 0x69: /* imul Gv, Ev, I */

    case 0x6b:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        if (b == 0x69)

            s->rip_offset = insn_const_size(ot);

        else if (b == 0x6b)

            s->rip_offset = 1;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        if (b == 0x69) {

            val = insn_get(env, s, ot);

            tcg_gen_movi_tl(cpu_T1, val);

        } else if (b == 0x6b) {

            val = (int8_t)insn_get(env, s, MO_8);

            tcg_gen_movi_tl(cpu_T1, val);

        } else {

            gen_op_mov_v_reg(ot, cpu_T1, reg);

        }

        switch (ot) {

#ifdef TARGET_X86_64

        case MO_64:

            tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);

            tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);

            tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);

            break;

#endif

        case MO_32:

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

            tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

            tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,

                              cpu_tmp2_i32, cpu_tmp3_i32);

            tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);

            tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);

            tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);

            tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);

            break;

        default:

            tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

            tcg_gen_ext16s_tl(cpu_T1, cpu_T1);

            /* XXX: use 32 bit mul which could be faster */

            tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);

            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

            tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);

            tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);

            gen_op_mov_reg_v(ot, reg, cpu_T0);

            break;

        }

        set_cc_op(s, CC_OP_MULB + ot);

        break;

    case 0x1c0:

    case 0x1c1: /* xadd Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        gen_op_mov_v_reg(ot, cpu_T0, reg);

        if (mod == 3) {

            rm = (modrm & 7) | REX_B(s);

            gen_op_mov_v_reg(ot, cpu_T1, rm);

            tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

        } else {

            gen_lea_modrm(env, s, modrm);

            if (s->prefix & PREFIX_LOCK) {

                tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,

                                            s->mem_index, ot | MO_LE);

                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

            } else {

                gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

                tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);

                gen_op_st_v(s, ot, cpu_T0, cpu_A0);

            }

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        }

        gen_op_update2_cc();

        set_cc_op(s, CC_OP_ADDB + ot);

        break;

    case 0x1b0:

    case 0x1b1: /* cmpxchg Ev, Gv */

        {

            TCGv oldv, newv, cmpv;



            ot = mo_b_d(b, dflag);

            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            oldv = tcg_temp_new();

            newv = tcg_temp_new();

            cmpv = tcg_temp_new();

            gen_op_mov_v_reg(ot, newv, reg);

            tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);



            if (s->prefix & PREFIX_LOCK) {

                if (mod == 3) {

                    goto illegal_op;

                }

                gen_lea_modrm(env, s, modrm);

                tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,

                                          s->mem_index, ot | MO_LE);

                gen_op_mov_reg_v(ot, R_EAX, oldv);

            } else {

                if (mod == 3) {

                    rm = (modrm & 7) | REX_B(s);

                    gen_op_mov_v_reg(ot, oldv, rm);

                } else {

                    gen_lea_modrm(env, s, modrm);

                    gen_op_ld_v(s, ot, oldv, cpu_A0);

                    rm = 0; /* avoid warning */

                }

                gen_extu(ot, oldv);

                gen_extu(ot, cmpv);

                /* store value = (old == cmp ? new : old);  */

                tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);

                if (mod == 3) {

                    gen_op_mov_reg_v(ot, R_EAX, oldv);

                    gen_op_mov_reg_v(ot, rm, newv);

                } else {

                    /* Perform an unconditional store cycle like physical cpu;

                       must be before changing accumulator to ensure

                       idempotency if the store faults and the instruction

                       is restarted */

                    gen_op_st_v(s, ot, newv, cpu_A0);

                    gen_op_mov_reg_v(ot, R_EAX, oldv);

                }

            }

            tcg_gen_mov_tl(cpu_cc_src, oldv);

            tcg_gen_mov_tl(cpu_cc_srcT, cmpv);

            tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);

            set_cc_op(s, CC_OP_SUBB + ot);

            tcg_temp_free(oldv);

            tcg_temp_free(newv);

            tcg_temp_free(cmpv);

        }

        break;

    case 0x1c7: /* cmpxchg8b */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if ((mod == 3) || ((modrm & 0x38) != 0x8))

            goto illegal_op;

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            if (!(s->cpuid_ext_features & CPUID_EXT_CX16))

                goto illegal_op;

            gen_lea_modrm(env, s, modrm);

            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {

                gen_helper_cmpxchg16b(cpu_env, cpu_A0);

            } else {

                gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);

            }

        } else

#endif        

        {

            if (!(s->cpuid_features & CPUID_CX8))

                goto illegal_op;

            gen_lea_modrm(env, s, modrm);

            if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {

                gen_helper_cmpxchg8b(cpu_env, cpu_A0);

            } else {

                gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);

            }

        }

        set_cc_op(s, CC_OP_EFLAGS);

        break;



        /**************************/

        /* push/pop */

    case 0x50 ... 0x57: /* push */

        gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));

        gen_push_v(s, cpu_T0);

        break;

    case 0x58 ... 0x5f: /* pop */

        ot = gen_pop_T0(s);

        /* NOTE: order is important for pop %sp */

        gen_pop_update(s, ot);

        gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);

        break;

    case 0x60: /* pusha */

        if (CODE64(s))

            goto illegal_op;

        gen_pusha(s);

        break;

    case 0x61: /* popa */

        if (CODE64(s))

            goto illegal_op;

        gen_popa(s);

        break;

    case 0x68: /* push Iv */

    case 0x6a:

        ot = mo_pushpop(s, dflag);

        if (b == 0x68)

            val = insn_get(env, s, ot);

        else

            val = (int8_t)insn_get(env, s, MO_8);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_push_v(s, cpu_T0);

        break;

    case 0x8f: /* pop Ev */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        ot = gen_pop_T0(s);

        if (mod == 3) {

            /* NOTE: order is important for pop %sp */

            gen_pop_update(s, ot);

            rm = (modrm & 7) | REX_B(s);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

        } else {

            /* NOTE: order is important too for MMU exceptions */

            s->popl_esp_hack = 1 << ot;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            s->popl_esp_hack = 0;

            gen_pop_update(s, ot);

        }

        break;

    case 0xc8: /* enter */

        {

            int level;

            val = x86_lduw_code(env, s);

            level = x86_ldub_code(env, s);

            gen_enter(s, val, level);

        }

        break;

    case 0xc9: /* leave */

        gen_leave(s);

        break;

    case 0x06: /* push es */

    case 0x0e: /* push cs */

    case 0x16: /* push ss */

    case 0x1e: /* push ds */

        if (CODE64(s))

            goto illegal_op;

        gen_op_movl_T0_seg(b >> 3);

        gen_push_v(s, cpu_T0);

        break;

    case 0x1a0: /* push fs */

    case 0x1a8: /* push gs */

        gen_op_movl_T0_seg((b >> 3) & 7);

        gen_push_v(s, cpu_T0);

        break;

    case 0x07: /* pop es */

    case 0x17: /* pop ss */

    case 0x1f: /* pop ds */

        if (CODE64(s))

            goto illegal_op;

        reg = b >> 3;

        ot = gen_pop_T0(s);

        gen_movl_seg_T0(s, reg);

        gen_pop_update(s, ot);

        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            if (reg == R_SS) {

                s->tf = 0;

                gen_eob_inhibit_irq(s, true);

            } else {

                gen_eob(s);

            }

        }

        break;

    case 0x1a1: /* pop fs */

    case 0x1a9: /* pop gs */

        ot = gen_pop_T0(s);

        gen_movl_seg_T0(s, (b >> 3) & 7);

        gen_pop_update(s, ot);

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;



        /**************************/

        /* mov */

    case 0x88:

    case 0x89: /* mov Gv, Ev */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        /* generate a generic store */

        gen_ldst_modrm(env, s, modrm, ot, reg, 1);

        break;

    case 0xc6:

    case 0xc7: /* mov Ev, Iv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod != 3) {

            s->rip_offset = insn_const_size(ot);

            gen_lea_modrm(env, s, modrm);

        }

        val = insn_get(env, s, ot);

        tcg_gen_movi_tl(cpu_T0, val);

        if (mod != 3) {

            gen_op_st_v(s, ot, cpu_T0, cpu_A0);

        } else {

            gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);

        }

        break;

    case 0x8a:

    case 0x8b: /* mov Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_op_mov_reg_v(ot, reg, cpu_T0);

        break;

    case 0x8e: /* mov seg, Gv */

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        if (reg >= 6 || reg == R_CS)

            goto illegal_op;

        gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

        gen_movl_seg_T0(s, reg);

        /* Note that reg == R_SS in gen_movl_seg_T0 always sets is_jmp.  */

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            if (reg == R_SS) {

                s->tf = 0;

                gen_eob_inhibit_irq(s, true);

            } else {

                gen_eob(s);

            }

        }

        break;

    case 0x8c: /* mov Gv, seg */

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        if (reg >= 6)

            goto illegal_op;

        gen_op_movl_T0_seg(reg);

        ot = mod == 3 ? dflag : MO_16;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

        break;



    case 0x1b6: /* movzbS Gv, Eb */

    case 0x1b7: /* movzwS Gv, Eb */

    case 0x1be: /* movsbS Gv, Eb */

    case 0x1bf: /* movswS Gv, Eb */

        {

            TCGMemOp d_ot;

            TCGMemOp s_ot;



            /* d_ot is the size of destination */

            d_ot = dflag;

            /* ot is the size of source */

            ot = (b & 1) + MO_8;

            /* s_ot is the sign+size of source */

            s_ot = b & 8 ? MO_SIGN | ot : ot;



            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);



            if (mod == 3) {

                if (s_ot == MO_SB && byte_reg_is_xH(rm)) {

                    tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);

                } else {

                    gen_op_mov_v_reg(ot, cpu_T0, rm);

                    switch (s_ot) {

                    case MO_UB:

                        tcg_gen_ext8u_tl(cpu_T0, cpu_T0);

                        break;

                    case MO_SB:

                        tcg_gen_ext8s_tl(cpu_T0, cpu_T0);

                        break;

                    case MO_UW:

                        tcg_gen_ext16u_tl(cpu_T0, cpu_T0);

                        break;

                    default:

                    case MO_SW:

                        tcg_gen_ext16s_tl(cpu_T0, cpu_T0);

                        break;

                    }

                }

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            } else {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            }

        }

        break;



    case 0x8d: /* lea */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        reg = ((modrm >> 3) & 7) | rex_r;

        {

            AddressParts a = gen_lea_modrm_0(env, s, modrm);

            TCGv ea = gen_lea_modrm_1(a);

            gen_lea_v_seg(s, s->aflag, ea, -1, -1);

            gen_op_mov_reg_v(dflag, reg, cpu_A0);

        }

        break;



    case 0xa0: /* mov EAX, Ov */

    case 0xa1:

    case 0xa2: /* mov Ov, EAX */

    case 0xa3:

        {

            target_ulong offset_addr;



            ot = mo_b_d(b, dflag);

            switch (s->aflag) {

#ifdef TARGET_X86_64

            case MO_64:

                offset_addr = x86_ldq_code(env, s);

                break;

#endif

            default:

                offset_addr = insn_get(env, s, s->aflag);

                break;

            }

            tcg_gen_movi_tl(cpu_A0, offset_addr);

            gen_add_A0_ds_seg(s);

            if ((b & 2) == 0) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(ot, R_EAX, cpu_T0);

            } else {

                gen_op_mov_v_reg(ot, cpu_T0, R_EAX);

                gen_op_st_v(s, ot, cpu_T0, cpu_A0);

            }

        }

        break;

    case 0xd7: /* xlat */

        tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);

        tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);

        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);

        gen_extu(s->aflag, cpu_A0);

        gen_add_A0_ds_seg(s);

        gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);

        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);

        break;

    case 0xb0 ... 0xb7: /* mov R, Ib */

        val = insn_get(env, s, MO_8);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);

        break;

    case 0xb8 ... 0xbf: /* mov R, Iv */

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            uint64_t tmp;

            /* 64 bit case */

            tmp = x86_ldq_code(env, s);

            reg = (b & 7) | REX_B(s);

            tcg_gen_movi_tl(cpu_T0, tmp);

            gen_op_mov_reg_v(MO_64, reg, cpu_T0);

        } else

#endif

        {

            ot = dflag;

            val = insn_get(env, s, ot);

            reg = (b & 7) | REX_B(s);

            tcg_gen_movi_tl(cpu_T0, val);

            gen_op_mov_reg_v(ot, reg, cpu_T0);

        }

        break;



    case 0x91 ... 0x97: /* xchg R, EAX */

    do_xchg_reg_eax:

        ot = dflag;

        reg = (b & 7) | REX_B(s);

        rm = R_EAX;

        goto do_xchg_reg;

    case 0x86:

    case 0x87: /* xchg Ev, Gv */

        ot = mo_b_d(b, dflag);

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        if (mod == 3) {

            rm = (modrm & 7) | REX_B(s);

        do_xchg_reg:

            gen_op_mov_v_reg(ot, cpu_T0, reg);

            gen_op_mov_v_reg(ot, cpu_T1, rm);

            gen_op_mov_reg_v(ot, rm, cpu_T0);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        } else {

            gen_lea_modrm(env, s, modrm);

            gen_op_mov_v_reg(ot, cpu_T0, reg);

            /* for xchg, lock is implicit */

            tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,

                                   s->mem_index, ot | MO_LE);

            gen_op_mov_reg_v(ot, reg, cpu_T1);

        }

        break;

    case 0xc4: /* les Gv */

        /* In CODE64 this is VEX3; see above.  */

        op = R_ES;

        goto do_lxx;

    case 0xc5: /* lds Gv */

        /* In CODE64 this is VEX2; see above.  */

        op = R_DS;

        goto do_lxx;

    case 0x1b2: /* lss Gv */

        op = R_SS;

        goto do_lxx;

    case 0x1b4: /* lfs Gv */

        op = R_FS;

        goto do_lxx;

    case 0x1b5: /* lgs Gv */

        op = R_GS;

    do_lxx:

        ot = dflag != MO_16 ? MO_32 : MO_16;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_lea_modrm(env, s, modrm);

        gen_op_ld_v(s, ot, cpu_T1, cpu_A0);

        gen_add_A0_im(s, 1 << ot);

        /* load the segment first to handle exceptions properly */

        gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);

        gen_movl_seg_T0(s, op);

        /* then put the data */

        gen_op_mov_reg_v(ot, reg, cpu_T1);

        if (s->base.is_jmp) {

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;



        /************************/

        /* shifts */

    case 0xc0:

    case 0xc1:

        /* shift Ev,Ib */

        shift = 2;

    grp2:

        {

            ot = mo_b_d(b, dflag);

            modrm = x86_ldub_code(env, s);

            mod = (modrm >> 6) & 3;

            op = (modrm >> 3) & 7;



            if (mod != 3) {

                if (shift == 2) {

                    s->rip_offset = 1;

                }

                gen_lea_modrm(env, s, modrm);

                opreg = OR_TMP0;

            } else {

                opreg = (modrm & 7) | REX_B(s);

            }



            /* simpler op */

            if (shift == 0) {

                gen_shift(s, op, ot, opreg, OR_ECX);

            } else {

                if (shift == 2) {

                    shift = x86_ldub_code(env, s);

                }

                gen_shifti(s, op, ot, opreg, shift);

            }

        }

        break;

    case 0xd0:

    case 0xd1:

        /* shift Ev,1 */

        shift = 1;

        goto grp2;

    case 0xd2:

    case 0xd3:

        /* shift Ev,cl */

        shift = 0;

        goto grp2;



    case 0x1a4: /* shld imm */

        op = 0;

        shift = 1;

        goto do_shiftd;

    case 0x1a5: /* shld cl */

        op = 0;

        shift = 0;

        goto do_shiftd;

    case 0x1ac: /* shrd imm */

        op = 1;

        shift = 1;

        goto do_shiftd;

    case 0x1ad: /* shrd cl */

        op = 1;

        shift = 0;

    do_shiftd:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        reg = ((modrm >> 3) & 7) | rex_r;

        if (mod != 3) {

            gen_lea_modrm(env, s, modrm);

            opreg = OR_TMP0;

        } else {

            opreg = rm;

        }

        gen_op_mov_v_reg(ot, cpu_T1, reg);



        if (shift) {

            TCGv imm = tcg_const_tl(x86_ldub_code(env, s));

            gen_shiftd_rm_T1(s, ot, opreg, op, imm);

            tcg_temp_free(imm);

        } else {

            gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);

        }

        break;



        /************************/

        /* floats */

    case 0xd8 ... 0xdf:

        if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {

            /* if CR0.EM or CR0.TS are set, generate an FPU exception */

            /* XXX: what to do if illegal op ? */

            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

            break;

        }

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        rm = modrm & 7;

        op = ((b & 7) << 3) | ((modrm >> 3) & 7);

        if (mod != 3) {

            /* memory op */

            gen_lea_modrm(env, s, modrm);

            switch(op) {

            case 0x00 ... 0x07: /* fxxxs */

            case 0x10 ... 0x17: /* fixxxl */

            case 0x20 ... 0x27: /* fxxxl */

            case 0x30 ... 0x37: /* fixxx */

                {

                    int op1;

                    op1 = op & 7;



                    switch(op >> 4) {

                    case 0:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 1:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 2:

                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);

                        break;

                    case 3:

                    default:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LESW);

                        gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);

                        break;

                    }



                    gen_helper_fp_arith_ST0_FT0(op1);

                    if (op1 == 3) {

                        /* fcomp needs pop */

                        gen_helper_fpop(cpu_env);

                    }

                }

                break;

            case 0x08: /* flds */

            case 0x0a: /* fsts */

            case 0x0b: /* fstps */

            case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */

            case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */

            case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */

                switch(op & 7) {

                case 0:

                    switch(op >> 4) {

                    case 0:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 1:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    case 2:

                        tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);

                        break;

                    case 3:

                    default:

                        tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LESW);

                        gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);

                        break;

                    }

                    break;

                case 1:

                    /* XXX: the corresponding CPUID bit must be tested ! */

                    switch(op >> 4) {

                    case 1:

                        gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 2:

                        gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);

                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        break;

                    case 3:

                    default:

                        gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUW);

                        break;

                    }

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    switch(op >> 4) {

                    case 0:

                        gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 1:

                        gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUL);

                        break;

                    case 2:

                        gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);

                        tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,

                                            s->mem_index, MO_LEQ);

                        break;

                    case 3:

                    default:

                        gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);

                        tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                            s->mem_index, MO_LEUW);

                        break;

                    }

                    if ((op & 7) == 3)

                        gen_helper_fpop(cpu_env);

                    break;

                }

                break;

            case 0x0c: /* fldenv mem */

                gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x0d: /* fldcw mem */

                tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                gen_helper_fldcw(cpu_env, cpu_tmp2_i32);

                break;

            case 0x0e: /* fnstenv mem */

                gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x0f: /* fnstcw mem */

                gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);

                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                break;

            case 0x1d: /* fldt mem */

                gen_helper_fldt_ST0(cpu_env, cpu_A0);

                break;

            case 0x1f: /* fstpt mem */

                gen_helper_fstt_ST0(cpu_env, cpu_A0);

                gen_helper_fpop(cpu_env);

                break;

            case 0x2c: /* frstor mem */

                gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x2e: /* fnsave mem */

                gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));

                break;

            case 0x2f: /* fnstsw mem */

                gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);

                tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,

                                    s->mem_index, MO_LEUW);

                break;

            case 0x3c: /* fbld */

                gen_helper_fbld_ST0(cpu_env, cpu_A0);

                break;

            case 0x3e: /* fbstp */

                gen_helper_fbst_ST0(cpu_env, cpu_A0);

                gen_helper_fpop(cpu_env);

                break;

            case 0x3d: /* fildll */

                tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);

                gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);

                break;

            case 0x3f: /* fistpll */

                gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);

                tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);

                gen_helper_fpop(cpu_env);

                break;

            default:

                goto unknown_op;

            }

        } else {

            /* register float ops */

            opreg = rm;



            switch(op) {

            case 0x08: /* fld sti */

                gen_helper_fpush(cpu_env);

                gen_helper_fmov_ST0_STN(cpu_env,

                                        tcg_const_i32((opreg + 1) & 7));

                break;

            case 0x09: /* fxchg sti */

            case 0x29: /* fxchg4 sti, undocumented op */

            case 0x39: /* fxchg7 sti, undocumented op */

                gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x0a: /* grp d9/2 */

                switch(rm) {

                case 0: /* fnop */

                    /* check exceptions (FreeBSD FPU probe) */

                    gen_helper_fwait(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x0c: /* grp d9/4 */

                switch(rm) {

                case 0: /* fchs */

                    gen_helper_fchs_ST0(cpu_env);

                    break;

                case 1: /* fabs */

                    gen_helper_fabs_ST0(cpu_env);

                    break;

                case 4: /* ftst */

                    gen_helper_fldz_FT0(cpu_env);

                    gen_helper_fcom_ST0_FT0(cpu_env);

                    break;

                case 5: /* fxam */

                    gen_helper_fxam_ST0(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x0d: /* grp d9/5 */

                {

                    switch(rm) {

                    case 0:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fld1_ST0(cpu_env);

                        break;

                    case 1:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldl2t_ST0(cpu_env);

                        break;

                    case 2:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldl2e_ST0(cpu_env);

                        break;

                    case 3:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldpi_ST0(cpu_env);

                        break;

                    case 4:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldlg2_ST0(cpu_env);

                        break;

                    case 5:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldln2_ST0(cpu_env);

                        break;

                    case 6:

                        gen_helper_fpush(cpu_env);

                        gen_helper_fldz_ST0(cpu_env);

                        break;

                    default:

                        goto unknown_op;

                    }

                }

                break;

            case 0x0e: /* grp d9/6 */

                switch(rm) {

                case 0: /* f2xm1 */

                    gen_helper_f2xm1(cpu_env);

                    break;

                case 1: /* fyl2x */

                    gen_helper_fyl2x(cpu_env);

                    break;

                case 2: /* fptan */

                    gen_helper_fptan(cpu_env);

                    break;

                case 3: /* fpatan */

                    gen_helper_fpatan(cpu_env);

                    break;

                case 4: /* fxtract */

                    gen_helper_fxtract(cpu_env);

                    break;

                case 5: /* fprem1 */

                    gen_helper_fprem1(cpu_env);

                    break;

                case 6: /* fdecstp */

                    gen_helper_fdecstp(cpu_env);

                    break;

                default:

                case 7: /* fincstp */

                    gen_helper_fincstp(cpu_env);

                    break;

                }

                break;

            case 0x0f: /* grp d9/7 */

                switch(rm) {

                case 0: /* fprem */

                    gen_helper_fprem(cpu_env);

                    break;

                case 1: /* fyl2xp1 */

                    gen_helper_fyl2xp1(cpu_env);

                    break;

                case 2: /* fsqrt */

                    gen_helper_fsqrt(cpu_env);

                    break;

                case 3: /* fsincos */

                    gen_helper_fsincos(cpu_env);

                    break;

                case 5: /* fscale */

                    gen_helper_fscale(cpu_env);

                    break;

                case 4: /* frndint */

                    gen_helper_frndint(cpu_env);

                    break;

                case 6: /* fsin */

                    gen_helper_fsin(cpu_env);

                    break;

                default:

                case 7: /* fcos */

                    gen_helper_fcos(cpu_env);

                    break;

                }

                break;

            case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */

            case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */

            case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */

                {

                    int op1;



                    op1 = op & 7;

                    if (op >= 0x20) {

                        gen_helper_fp_arith_STN_ST0(op1, opreg);

                        if (op >= 0x30)

                            gen_helper_fpop(cpu_env);

                    } else {

                        gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                        gen_helper_fp_arith_ST0_FT0(op1);

                    }

                }

                break;

            case 0x02: /* fcom */

            case 0x22: /* fcom2, undocumented op */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcom_ST0_FT0(cpu_env);

                break;

            case 0x03: /* fcomp */

            case 0x23: /* fcomp3, undocumented op */

            case 0x32: /* fcomp5, undocumented op */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcom_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                break;

            case 0x15: /* da/5 */

                switch(rm) {

                case 1: /* fucompp */

                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));

                    gen_helper_fucom_ST0_FT0(cpu_env);

                    gen_helper_fpop(cpu_env);

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x1c:

                switch(rm) {

                case 0: /* feni (287 only, just do nop here) */

                    break;

                case 1: /* fdisi (287 only, just do nop here) */

                    break;

                case 2: /* fclex */

                    gen_helper_fclex(cpu_env);

                    break;

                case 3: /* fninit */

                    gen_helper_fninit(cpu_env);

                    break;

                case 4: /* fsetpm (287 only, just do nop here) */

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x1d: /* fucomi */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucomi_ST0_FT0(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x1e: /* fcomi */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcomi_ST0_FT0(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x28: /* ffree sti */

                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x2a: /* fst sti */

                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));

                break;

            case 0x2b: /* fstp sti */

            case 0x0b: /* fstp1 sti, undocumented op */

            case 0x3a: /* fstp8 sti, undocumented op */

            case 0x3b: /* fstp9 sti, undocumented op */

                gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));

                gen_helper_fpop(cpu_env);

                break;

            case 0x2c: /* fucom st(i) */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucom_ST0_FT0(cpu_env);

                break;

            case 0x2d: /* fucomp st(i) */

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucom_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                break;

            case 0x33: /* de/3 */

                switch(rm) {

                case 1: /* fcompp */

                    gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));

                    gen_helper_fcom_ST0_FT0(cpu_env);

                    gen_helper_fpop(cpu_env);

                    gen_helper_fpop(cpu_env);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x38: /* ffreep sti, undocumented op */

                gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fpop(cpu_env);

                break;

            case 0x3c: /* df/4 */

                switch(rm) {

                case 0:

                    gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);

                    tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);

                    gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);

                    break;

                default:

                    goto unknown_op;

                }

                break;

            case 0x3d: /* fucomip */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fucomi_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x3e: /* fcomip */

                if (!(s->cpuid_features & CPUID_CMOV)) {

                    goto illegal_op;

                }

                gen_update_cc_op(s);

                gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));

                gen_helper_fcomi_ST0_FT0(cpu_env);

                gen_helper_fpop(cpu_env);

                set_cc_op(s, CC_OP_EFLAGS);

                break;

            case 0x10 ... 0x13: /* fcmovxx */

            case 0x18 ... 0x1b:

                {

                    int op1;

                    TCGLabel *l1;

                    static const uint8_t fcmov_cc[8] = {

                        (JCC_B << 1),

                        (JCC_Z << 1),

                        (JCC_BE << 1),

                        (JCC_P << 1),

                    };



                    if (!(s->cpuid_features & CPUID_CMOV)) {

                        goto illegal_op;

                    }

                    op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);

                    l1 = gen_new_label();

                    gen_jcc1_noeob(s, op1, l1);

                    gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));

                    gen_set_label(l1);

                }

                break;

            default:

                goto unknown_op;

            }

        }

        break;

        /************************/

        /* string ops */



    case 0xa4: /* movsS */

    case 0xa5:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_movs(s, ot);

        }

        break;



    case 0xaa: /* stosS */

    case 0xab:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_stos(s, ot);

        }

        break;

    case 0xac: /* lodsS */

    case 0xad:

        ot = mo_b_d(b, dflag);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_lods(s, ot);

        }

        break;

    case 0xae: /* scasS */

    case 0xaf:

        ot = mo_b_d(b, dflag);

        if (prefixes & PREFIX_REPNZ) {

            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);

        } else if (prefixes & PREFIX_REPZ) {

            gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);

        } else {

            gen_scas(s, ot);

        }

        break;



    case 0xa6: /* cmpsS */

    case 0xa7:

        ot = mo_b_d(b, dflag);

        if (prefixes & PREFIX_REPNZ) {

            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);

        } else if (prefixes & PREFIX_REPZ) {

            gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);

        } else {

            gen_cmps(s, ot);

        }

        break;

    case 0x6c: /* insS */

    case 0x6d:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base, 

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_ins(s, ot);

            if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                gen_jmp(s, s->pc - s->cs_base);

            }

        }

        break;

    case 0x6e: /* outsS */

    case 0x6f:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes) | 4);

        if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {

            gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);

        } else {

            gen_outs(s, ot);

            if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                gen_jmp(s, s->pc - s->cs_base);

            }

        }

        break;



        /************************/

        /* port I/O */



    case 0xe4:

    case 0xe5:

        ot = mo_b_d32(b, dflag);

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_movi_i32(cpu_tmp2_i32, val);

        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);

        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xe6:

    case 0xe7:

        ot = mo_b_d32(b, dflag);

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T0, val);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes));

        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);



        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_movi_i32(cpu_tmp2_i32, val);

        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xec:

    case 0xed:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);

        gen_op_mov_reg_v(ot, R_EAX, cpu_T1);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0xee:

    case 0xef:

        ot = mo_b_d32(b, dflag);

        tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);

        gen_check_io(s, ot, pc_start - s->cs_base,

                     svm_is_rep(prefixes));

        gen_op_mov_v_reg(ot, cpu_T1, R_EAX);



        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_start();

	}

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);

        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);

        gen_bpt_io(s, cpu_tmp2_i32, ot);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;



        /************************/

        /* control */

    case 0xc2: /* ret im */

        val = x86_ldsw_code(env, s);

        ot = gen_pop_T0(s);

        gen_stack_update(s, val + (1 << ot));

        /* Note that gen_pop_T0 uses a zero-extending load.  */

        gen_op_jmp_v(cpu_T0);

        gen_bnd_jmp(s);

        gen_jr(s, cpu_T0);

        break;

    case 0xc3: /* ret */

        ot = gen_pop_T0(s);

        gen_pop_update(s, ot);

        /* Note that gen_pop_T0 uses a zero-extending load.  */

        gen_op_jmp_v(cpu_T0);

        gen_bnd_jmp(s);

        gen_jr(s, cpu_T0);

        break;

    case 0xca: /* lret im */

        val = x86_ldsw_code(env, s);

    do_lret:

        if (s->pe && !s->vm86) {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),

                                      tcg_const_i32(val));

        } else {

            gen_stack_A0(s);

            /* pop offset */

            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);

            /* NOTE: keeping EIP updated is not a problem in case of

               exception */

            gen_op_jmp_v(cpu_T0);

            /* pop selector */

            gen_add_A0_im(s, 1 << dflag);

            gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);

            gen_op_movl_seg_T0_vm(R_CS);

            /* add stack offset */

            gen_stack_update(s, val + (2 << dflag));

        }

        gen_eob(s);

        break;

    case 0xcb: /* lret */

        val = 0;

        goto do_lret;

    case 0xcf: /* iret */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);

        if (!s->pe) {

            /* real mode */

            gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));

            set_cc_op(s, CC_OP_EFLAGS);

        } else if (s->vm86) {

            if (s->iopl != 3) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));

                set_cc_op(s, CC_OP_EFLAGS);

            }

        } else {

            gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),

                                      tcg_const_i32(s->pc - s->cs_base));

            set_cc_op(s, CC_OP_EFLAGS);

        }

        gen_eob(s);

        break;

    case 0xe8: /* call im */

        {

            if (dflag != MO_16) {

                tval = (int32_t)insn_get(env, s, MO_32);

            } else {

                tval = (int16_t)insn_get(env, s, MO_16);

            }

            next_eip = s->pc - s->cs_base;

            tval += next_eip;

            if (dflag == MO_16) {

                tval &= 0xffff;

            } else if (!CODE64(s)) {

                tval &= 0xffffffff;

            }

            tcg_gen_movi_tl(cpu_T0, next_eip);

            gen_push_v(s, cpu_T0);

            gen_bnd_jmp(s);

            gen_jmp(s, tval);

        }

        break;

    case 0x9a: /* lcall im */

        {

            unsigned int selector, offset;



            if (CODE64(s))

                goto illegal_op;

            ot = dflag;

            offset = insn_get(env, s, ot);

            selector = insn_get(env, s, MO_16);



            tcg_gen_movi_tl(cpu_T0, selector);

            tcg_gen_movi_tl(cpu_T1, offset);

        }

        goto do_lcall;

    case 0xe9: /* jmp im */

        if (dflag != MO_16) {

            tval = (int32_t)insn_get(env, s, MO_32);

        } else {

            tval = (int16_t)insn_get(env, s, MO_16);

        }

        tval += s->pc - s->cs_base;

        if (dflag == MO_16) {

            tval &= 0xffff;

        } else if (!CODE64(s)) {

            tval &= 0xffffffff;

        }

        gen_bnd_jmp(s);

        gen_jmp(s, tval);

        break;

    case 0xea: /* ljmp im */

        {

            unsigned int selector, offset;



            if (CODE64(s))

                goto illegal_op;

            ot = dflag;

            offset = insn_get(env, s, ot);

            selector = insn_get(env, s, MO_16);



            tcg_gen_movi_tl(cpu_T0, selector);

            tcg_gen_movi_tl(cpu_T1, offset);

        }

        goto do_ljmp;

    case 0xeb: /* jmp Jb */

        tval = (int8_t)insn_get(env, s, MO_8);

        tval += s->pc - s->cs_base;

        if (dflag == MO_16) {

            tval &= 0xffff;

        }

        gen_jmp(s, tval);

        break;

    case 0x70 ... 0x7f: /* jcc Jb */

        tval = (int8_t)insn_get(env, s, MO_8);

        goto do_jcc;

    case 0x180 ... 0x18f: /* jcc Jv */

        if (dflag != MO_16) {

            tval = (int32_t)insn_get(env, s, MO_32);

        } else {

            tval = (int16_t)insn_get(env, s, MO_16);

        }

    do_jcc:

        next_eip = s->pc - s->cs_base;

        tval += next_eip;

        if (dflag == MO_16) {

            tval &= 0xffff;

        }

        gen_bnd_jmp(s);

        gen_jcc(s, b, tval, next_eip);

        break;



    case 0x190 ... 0x19f: /* setcc Gv */

        modrm = x86_ldub_code(env, s);

        gen_setcc1(s, b, cpu_T0);

        gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);

        break;

    case 0x140 ... 0x14f: /* cmov Gv, Ev */

        if (!(s->cpuid_features & CPUID_CMOV)) {

            goto illegal_op;

        }

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        gen_cmovcc1(env, s, ot, b, modrm, reg);

        break;



        /************************/

        /* flags */

    case 0x9c: /* pushf */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_helper_read_eflags(cpu_T0, cpu_env);

            gen_push_v(s, cpu_T0);

        }

        break;

    case 0x9d: /* popf */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            ot = gen_pop_T0(s);

            if (s->cpl == 0) {

                if (dflag != MO_16) {

                    gen_helper_write_eflags(cpu_env, cpu_T0,

                                            tcg_const_i32((TF_MASK | AC_MASK |

                                                           ID_MASK | NT_MASK |

                                                           IF_MASK |

                                                           IOPL_MASK)));

                } else {

                    gen_helper_write_eflags(cpu_env, cpu_T0,

                                            tcg_const_i32((TF_MASK | AC_MASK |

                                                           ID_MASK | NT_MASK |

                                                           IF_MASK | IOPL_MASK)

                                                          & 0xffff));

                }

            } else {

                if (s->cpl <= s->iopl) {

                    if (dflag != MO_16) {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                                tcg_const_i32((TF_MASK |

                                                               AC_MASK |

                                                               ID_MASK |

                                                               NT_MASK |

                                                               IF_MASK)));

                    } else {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                                tcg_const_i32((TF_MASK |

                                                               AC_MASK |

                                                               ID_MASK |

                                                               NT_MASK |

                                                               IF_MASK)

                                                              & 0xffff));

                    }

                } else {

                    if (dflag != MO_16) {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                           tcg_const_i32((TF_MASK | AC_MASK |

                                                          ID_MASK | NT_MASK)));

                    } else {

                        gen_helper_write_eflags(cpu_env, cpu_T0,

                                           tcg_const_i32((TF_MASK | AC_MASK |

                                                          ID_MASK | NT_MASK)

                                                         & 0xffff));

                    }

                }

            }

            gen_pop_update(s, ot);

            set_cc_op(s, CC_OP_EFLAGS);

            /* abort translation because TF/AC flag may change */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;

    case 0x9e: /* sahf */

        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))

            goto illegal_op;

        gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);

        gen_compute_eflags(s);

        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);

        tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);

        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);

        break;

    case 0x9f: /* lahf */

        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))

            goto illegal_op;

        gen_compute_eflags(s);

        /* Note: gen_compute_eflags() only gives the condition codes */

        tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);

        gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);

        break;

    case 0xf5: /* cmc */

        gen_compute_eflags(s);

        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);

        break;

    case 0xf8: /* clc */

        gen_compute_eflags(s);

        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);

        break;

    case 0xf9: /* stc */

        gen_compute_eflags(s);

        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);

        break;

    case 0xfc: /* cld */

        tcg_gen_movi_i32(cpu_tmp2_i32, 1);

        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));

        break;

    case 0xfd: /* std */

        tcg_gen_movi_i32(cpu_tmp2_i32, -1);

        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));

        break;



        /************************/

        /* bit operations */

    case 0x1ba: /* bt/bts/btr/btc Gv, im */

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        op = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        if (mod != 3) {

            s->rip_offset = 1;

            gen_lea_modrm(env, s, modrm);

            if (!(s->prefix & PREFIX_LOCK)) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }

        /* load shift */

        val = x86_ldub_code(env, s);

        tcg_gen_movi_tl(cpu_T1, val);

        if (op < 4)

            goto unknown_op;

        op -= 4;

        goto bt_op;

    case 0x1a3: /* bt Gv, Ev */

        op = 0;

        goto do_btx;

    case 0x1ab: /* bts */

        op = 1;

        goto do_btx;

    case 0x1b3: /* btr */

        op = 2;

        goto do_btx;

    case 0x1bb: /* btc */

        op = 3;

    do_btx:

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        mod = (modrm >> 6) & 3;

        rm = (modrm & 7) | REX_B(s);

        gen_op_mov_v_reg(MO_32, cpu_T1, reg);

        if (mod != 3) {

            AddressParts a = gen_lea_modrm_0(env, s, modrm);

            /* specific case: we need to add a displacement */

            gen_exts(ot, cpu_T1);

            tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);

            tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);

            tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);

            gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

            if (!(s->prefix & PREFIX_LOCK)) {

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

            }

        } else {

            gen_op_mov_v_reg(ot, cpu_T0, rm);

        }

    bt_op:

        tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);

        tcg_gen_movi_tl(cpu_tmp0, 1);

        tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);

        if (s->prefix & PREFIX_LOCK) {

            switch (op) {

            case 0: /* bt */

                /* Needs no atomic ops; we surpressed the normal

                   memory load for LOCK above so do it now.  */

                gen_op_ld_v(s, ot, cpu_T0, cpu_A0);

                break;

            case 1: /* bts */

                tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                           s->mem_index, ot | MO_LE);

                break;

            case 2: /* btr */

                tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);

                tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                            s->mem_index, ot | MO_LE);

                break;

            default:

            case 3: /* btc */

                tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,

                                            s->mem_index, ot | MO_LE);

                break;

            }

            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);

        } else {

            tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);

            switch (op) {

            case 0: /* bt */

                /* Data already loaded; nothing to do.  */

                break;

            case 1: /* bts */

                tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            case 2: /* btr */

                tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            default:

            case 3: /* btc */

                tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);

                break;

            }

            if (op != 0) {

                if (mod != 3) {

                    gen_op_st_v(s, ot, cpu_T0, cpu_A0);

                } else {

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                }

            }

        }



        /* Delay all CC updates until after the store above.  Note that

           C is the result of the test, Z is unchanged, and the others

           are all undefined.  */

        switch (s->cc_op) {

        case CC_OP_MULB ... CC_OP_MULQ:

        case CC_OP_ADDB ... CC_OP_ADDQ:

        case CC_OP_ADCB ... CC_OP_ADCQ:

        case CC_OP_SUBB ... CC_OP_SUBQ:

        case CC_OP_SBBB ... CC_OP_SBBQ:

        case CC_OP_LOGICB ... CC_OP_LOGICQ:

        case CC_OP_INCB ... CC_OP_INCQ:

        case CC_OP_DECB ... CC_OP_DECQ:

        case CC_OP_SHLB ... CC_OP_SHLQ:

        case CC_OP_SARB ... CC_OP_SARQ:

        case CC_OP_BMILGB ... CC_OP_BMILGQ:

            /* Z was going to be computed from the non-zero status of CC_DST.

               We can get that same Z value (and the new C value) by leaving

               CC_DST alone, setting CC_SRC, and using a CC_OP_SAR of the

               same width.  */

            tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);

            set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);

            break;

        default:

            /* Otherwise, generate EFLAGS and replace the C bit.  */

            gen_compute_eflags(s);

            tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,

                               ctz32(CC_C), 1);

            break;

        }

        break;

    case 0x1bc: /* bsf / tzcnt */

    case 0x1bd: /* bsr / lzcnt */

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;

        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_extu(ot, cpu_T0);



        /* Note that lzcnt and tzcnt are in different extensions.  */

        if ((prefixes & PREFIX_REPZ)

            && (b & 1

                ? s->cpuid_ext3_features & CPUID_EXT3_ABM

                : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {

            int size = 8 << ot;

            /* For lzcnt/tzcnt, C bit is defined related to the input. */

            tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

            if (b & 1) {

                /* For lzcnt, reduce the target_ulong result by the

                   number of zeros that we expect to find at the top.  */

                tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);

                tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);

            } else {

                /* For tzcnt, a zero input must return the operand size.  */

                tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);

            }

            /* For lzcnt/tzcnt, Z bit is defined related to the result.  */

            gen_op_update1_cc();

            set_cc_op(s, CC_OP_BMILGB + ot);

        } else {

            /* For bsr/bsf, only the Z bit is defined and it is related

               to the input and not the result.  */

            tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);

            set_cc_op(s, CC_OP_LOGICB + ot);



            /* ??? The manual says that the output is undefined when the

               input is zero, but real hardware leaves it unchanged, and

               real programs appear to depend on that.  Accomplish this

               by passing the output as the value to return upon zero.  */

            if (b & 1) {

                /* For bsr, return the bit index of the first 1 bit,

                   not the count of leading zeros.  */

                tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);

                tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);

                tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);

            } else {

                tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);

            }

        }

        gen_op_mov_reg_v(ot, reg, cpu_T0);

        break;

        /************************/

        /* bcd */

    case 0x27: /* daa */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_daa(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x2f: /* das */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_das(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x37: /* aaa */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_aaa(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0x3f: /* aas */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_helper_aas(cpu_env);

        set_cc_op(s, CC_OP_EFLAGS);

        break;

    case 0xd4: /* aam */

        if (CODE64(s))

            goto illegal_op;

        val = x86_ldub_code(env, s);

        if (val == 0) {

            gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);

        } else {

            gen_helper_aam(cpu_env, tcg_const_i32(val));

            set_cc_op(s, CC_OP_LOGICB);

        }

        break;

    case 0xd5: /* aad */

        if (CODE64(s))

            goto illegal_op;

        val = x86_ldub_code(env, s);

        gen_helper_aad(cpu_env, tcg_const_i32(val));

        set_cc_op(s, CC_OP_LOGICB);

        break;

        /************************/

        /* misc */

    case 0x90: /* nop */

        /* XXX: correct lock test for all insn */

        if (prefixes & PREFIX_LOCK) {

            goto illegal_op;

        }

        /* If REX_B is set, then this is xchg eax, r8d, not a nop.  */

        if (REX_B(s)) {

            goto do_xchg_reg_eax;

        }

        if (prefixes & PREFIX_REPZ) {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));

            s->base.is_jmp = DISAS_NORETURN;

        }

        break;

    case 0x9b: /* fwait */

        if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==

            (HF_MP_MASK | HF_TS_MASK)) {

            gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

        } else {

            gen_helper_fwait(cpu_env);

        }

        break;

    case 0xcc: /* int3 */

        gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);

        break;

    case 0xcd: /* int N */

        val = x86_ldub_code(env, s);

        if (s->vm86 && s->iopl != 3) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);

        }

        break;

    case 0xce: /* into */

        if (CODE64(s))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));

        break;

#ifdef WANT_ICEBP

    case 0xf1: /* icebp (undocumented, exits to external debugger) */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);

#if 1

        gen_debug(s, pc_start - s->cs_base);

#else

        /* start debug */

        tb_flush(CPU(x86_env_get_cpu(env)));

        qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);

#endif

        break;

#endif

    case 0xfa: /* cli */

        if (!s->vm86) {

            if (s->cpl <= s->iopl) {

                gen_helper_cli(cpu_env);

            } else {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            }

        } else {

            if (s->iopl == 3) {

                gen_helper_cli(cpu_env);

            } else {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            }

        }

        break;

    case 0xfb: /* sti */

        if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {

            gen_helper_sti(cpu_env);

            /* interruptions are enabled only the first insn after sti */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob_inhibit_irq(s, true);

        } else {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        }

        break;

    case 0x62: /* bound */

        if (CODE64(s))

            goto illegal_op;

        ot = dflag;

        modrm = x86_ldub_code(env, s);

        reg = (modrm >> 3) & 7;

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_op_mov_v_reg(ot, cpu_T0, reg);

        gen_lea_modrm(env, s, modrm);

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        if (ot == MO_16) {

            gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);

        } else {

            gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);

        }

        break;

    case 0x1c8 ... 0x1cf: /* bswap reg */

        reg = (b & 7) | REX_B(s);

#ifdef TARGET_X86_64

        if (dflag == MO_64) {

            gen_op_mov_v_reg(MO_64, cpu_T0, reg);

            tcg_gen_bswap64_i64(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_64, reg, cpu_T0);

        } else

#endif

        {

            gen_op_mov_v_reg(MO_32, cpu_T0, reg);

            tcg_gen_ext32u_tl(cpu_T0, cpu_T0);

            tcg_gen_bswap32_tl(cpu_T0, cpu_T0);

            gen_op_mov_reg_v(MO_32, reg, cpu_T0);

        }

        break;

    case 0xd6: /* salc */

        if (CODE64(s))

            goto illegal_op;

        gen_compute_eflags_c(s, cpu_T0);

        tcg_gen_neg_tl(cpu_T0, cpu_T0);

        gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);

        break;

    case 0xe0: /* loopnz */

    case 0xe1: /* loopz */

    case 0xe2: /* loop */

    case 0xe3: /* jecxz */

        {

            TCGLabel *l1, *l2, *l3;



            tval = (int8_t)insn_get(env, s, MO_8);

            next_eip = s->pc - s->cs_base;

            tval += next_eip;

            if (dflag == MO_16) {

                tval &= 0xffff;

            }



            l1 = gen_new_label();

            l2 = gen_new_label();

            l3 = gen_new_label();

            b &= 3;

            switch(b) {

            case 0: /* loopnz */

            case 1: /* loopz */

                gen_op_add_reg_im(s->aflag, R_ECX, -1);

                gen_op_jz_ecx(s->aflag, l3);

                gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);

                break;

            case 2: /* loop */

                gen_op_add_reg_im(s->aflag, R_ECX, -1);

                gen_op_jnz_ecx(s->aflag, l1);

                break;

            default:

            case 3: /* jcxz */

                gen_op_jz_ecx(s->aflag, l1);

                break;

            }



            gen_set_label(l3);

            gen_jmp_im(next_eip);

            tcg_gen_br(l2);



            gen_set_label(l1);

            gen_jmp_im(tval);

            gen_set_label(l2);

            gen_eob(s);

        }

        break;

    case 0x130: /* wrmsr */

    case 0x132: /* rdmsr */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            if (b & 2) {

                gen_helper_rdmsr(cpu_env);

            } else {

                gen_helper_wrmsr(cpu_env);

            }

        }

        break;

    case 0x131: /* rdtsc */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_start();

	}

        gen_helper_rdtsc(cpu_env);

        if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

            gen_io_end();

            gen_jmp(s, s->pc - s->cs_base);

        }

        break;

    case 0x133: /* rdpmc */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_rdpmc(cpu_env);

        break;

    case 0x134: /* sysenter */

        /* For Intel SYSENTER is valid on 64-bit */

        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)

            goto illegal_op;

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysenter(cpu_env);

            gen_eob(s);

        }

        break;

    case 0x135: /* sysexit */

        /* For Intel SYSEXIT is valid on 64-bit */

        if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)

            goto illegal_op;

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));

            gen_eob(s);

        }

        break;

#ifdef TARGET_X86_64

    case 0x105: /* syscall */

        /* XXX: is it usable in real mode ? */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));

        /* TF handling for the syscall insn is different. The TF bit is  checked

           after the syscall insn completes. This allows #DB to not be

           generated after one has entered CPL0 if TF is set in FMASK.  */

        gen_eob_worker(s, false, true);

        break;

    case 0x107: /* sysret */

        if (!s->pe) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));

            /* condition codes are modified only in long mode */

            if (s->lma) {

                set_cc_op(s, CC_OP_EFLAGS);

            }

            /* TF handling for the sysret insn is different. The TF bit is

               checked after the sysret insn completes. This allows #DB to be

               generated "as if" the syscall insn in userspace has just

               completed.  */

            gen_eob_worker(s, false, true);

        }

        break;

#endif

    case 0x1a2: /* cpuid */

        gen_update_cc_op(s);

        gen_jmp_im(pc_start - s->cs_base);

        gen_helper_cpuid(cpu_env);

        break;

    case 0xf4: /* hlt */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));

            s->base.is_jmp = DISAS_NORETURN;

        }

        break;

    case 0x100:

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        op = (modrm >> 3) & 7;

        switch(op) {

        case 0: /* sldt */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env,

                             offsetof(CPUX86State, ldt.selector));

            ot = mod == 3 ? dflag : MO_16;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 2: /* lldt */

            if (!s->pe || s->vm86)

                goto illegal_op;

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);

                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_lldt(cpu_env, cpu_tmp2_i32);

            }

            break;

        case 1: /* str */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env,

                             offsetof(CPUX86State, tr.selector));

            ot = mod == 3 ? dflag : MO_16;

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 3: /* ltr */

            if (!s->pe || s->vm86)

                goto illegal_op;

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);

                gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

                gen_helper_ltr(cpu_env, cpu_tmp2_i32);

            }

            break;

        case 4: /* verr */

        case 5: /* verw */

            if (!s->pe || s->vm86)

                goto illegal_op;

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            gen_update_cc_op(s);

            if (op == 4) {

                gen_helper_verr(cpu_env, cpu_T0);

            } else {

                gen_helper_verw(cpu_env, cpu_T0);

            }

            set_cc_op(s, CC_OP_EFLAGS);

            break;

        default:

            goto unknown_op;

        }

        break;



    case 0x101:

        modrm = x86_ldub_code(env, s);

        switch (modrm) {

        CASE_MODRM_MEM_OP(0): /* sgdt */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0,

                             cpu_env, offsetof(CPUX86State, gdt.limit));

            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);

            gen_add_A0_im(s, 2);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            break;



        case 0xc8: /* monitor */

            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);

            gen_extu(s->aflag, cpu_A0);

            gen_add_A0_ds_seg(s);

            gen_helper_monitor(cpu_env, cpu_A0);

            break;



        case 0xc9: /* mwait */

            if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));

            gen_eob(s);

            break;



        case 0xca: /* clac */

            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)

                || s->cpl != 0) {

                goto illegal_op;

            }

            gen_helper_clac(cpu_env);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xcb: /* stac */

            if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)

                || s->cpl != 0) {

                goto illegal_op;

            }

            gen_helper_stac(cpu_env);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(1): /* sidt */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));

            gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);

            gen_add_A0_im(s, 2);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            break;



        case 0xd0: /* xgetbv */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA

                                 | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);

            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);

            break;



        case 0xd1: /* xsetbv */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (s->prefix & (PREFIX_LOCK | PREFIX_DATA

                                 | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);

            /* End TB because translation flags may change.  */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xd8: /* VMRUN */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),

                             tcg_const_i32(s->pc - pc_start));

            tcg_gen_exit_tb(0);

            s->base.is_jmp = DISAS_NORETURN;

            break;



        case 0xd9: /* VMMCALL */

            if (!(s->flags & HF_SVME_MASK)) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmmcall(cpu_env);

            break;



        case 0xda: /* VMLOAD */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        case 0xdb: /* VMSAVE */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        case 0xdc: /* STGI */

            if ((!(s->flags & HF_SVME_MASK)

                   && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))

                || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_stgi(cpu_env);

            break;



        case 0xdd: /* CLGI */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_clgi(cpu_env);

            break;



        case 0xde: /* SKINIT */

            if ((!(s->flags & HF_SVME_MASK)

                 && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))

                || !s->pe) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_skinit(cpu_env);

            break;



        case 0xdf: /* INVLPGA */

            if (!(s->flags & HF_SVME_MASK) || !s->pe) {

                goto illegal_op;

            }

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));

            break;



        CASE_MODRM_MEM_OP(2): /* lgdt */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);

            gen_lea_modrm(env, s, modrm);

            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 2);

            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));

            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));

            break;



        CASE_MODRM_MEM_OP(3): /* lidt */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);

            gen_lea_modrm(env, s, modrm);

            gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);

            gen_add_A0_im(s, 2);

            gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);

            if (dflag == MO_16) {

                tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);

            }

            tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));

            tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));

            break;



        CASE_MODRM_OP(4): /* smsw */

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);

            tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));

            if (CODE64(s)) {

                mod = (modrm >> 6) & 3;

                ot = (mod != 3 ? MO_16 : s->dflag);

            } else {

                ot = MO_16;

            }

            gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);

            break;

        case 0xee: /* rdpkru */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);

            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);

            break;

        case 0xef: /* wrpkru */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);

            gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);

            break;

        CASE_MODRM_OP(6): /* lmsw */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            gen_helper_lmsw(cpu_env, cpu_T0);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(7): /* invlpg */

            if (s->cpl != 0) {

                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                break;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            gen_lea_modrm(env, s, modrm);

            gen_helper_invlpg(cpu_env, cpu_A0);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        case 0xf8: /* swapgs */

#ifdef TARGET_X86_64

            if (CODE64(s)) {

                if (s->cpl != 0) {

                    gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

                } else {

                    tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);

                    tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,

                                  offsetof(CPUX86State, kernelgsbase));

                    tcg_gen_st_tl(cpu_T0, cpu_env,

                                  offsetof(CPUX86State, kernelgsbase));

                }

                break;

            }

#endif

            goto illegal_op;



        case 0xf9: /* rdtscp */

            if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {

                goto illegal_op;

            }

            gen_update_cc_op(s);

            gen_jmp_im(pc_start - s->cs_base);

            if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                gen_io_start();

            }

            gen_helper_rdtscp(cpu_env);

            if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                gen_io_end();

                gen_jmp(s, s->pc - s->cs_base);

            }

            break;



        default:

            goto unknown_op;

        }

        break;



    case 0x108: /* invd */

    case 0x109: /* wbinvd */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);

            /* nothing to do */

        }

        break;

    case 0x63: /* arpl or movslS (x86_64) */

#ifdef TARGET_X86_64

        if (CODE64(s)) {

            int d_ot;

            /* d_ot is the size of destination */

            d_ot = dflag;



            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            mod = (modrm >> 6) & 3;

            rm = (modrm & 7) | REX_B(s);



            if (mod == 3) {

                gen_op_mov_v_reg(MO_32, cpu_T0, rm);

                /* sign extend */

                if (d_ot == MO_64) {

                    tcg_gen_ext32s_tl(cpu_T0, cpu_T0);

                }

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            } else {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);

                gen_op_mov_reg_v(d_ot, reg, cpu_T0);

            }

        } else

#endif

        {

            TCGLabel *label1;

            TCGv t0, t1, t2, a0;



            if (!s->pe || s->vm86)

                goto illegal_op;

            t0 = tcg_temp_local_new();

            t1 = tcg_temp_local_new();

            t2 = tcg_temp_local_new();

            ot = MO_16;

            modrm = x86_ldub_code(env, s);

            reg = (modrm >> 3) & 7;

            mod = (modrm >> 6) & 3;

            rm = modrm & 7;

            if (mod != 3) {

                gen_lea_modrm(env, s, modrm);

                gen_op_ld_v(s, ot, t0, cpu_A0);

                a0 = tcg_temp_local_new();

                tcg_gen_mov_tl(a0, cpu_A0);

            } else {

                gen_op_mov_v_reg(ot, t0, rm);

                TCGV_UNUSED(a0);

            }

            gen_op_mov_v_reg(ot, t1, reg);

            tcg_gen_andi_tl(cpu_tmp0, t0, 3);

            tcg_gen_andi_tl(t1, t1, 3);

            tcg_gen_movi_tl(t2, 0);

            label1 = gen_new_label();

            tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);

            tcg_gen_andi_tl(t0, t0, ~3);

            tcg_gen_or_tl(t0, t0, t1);

            tcg_gen_movi_tl(t2, CC_Z);

            gen_set_label(label1);

            if (mod != 3) {

                gen_op_st_v(s, ot, t0, a0);

                tcg_temp_free(a0);

           } else {

                gen_op_mov_reg_v(ot, rm, t0);

            }

            gen_compute_eflags(s);

            tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);

            tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);

            tcg_temp_free(t0);

            tcg_temp_free(t1);

            tcg_temp_free(t2);

        }

        break;

    case 0x102: /* lar */

    case 0x103: /* lsl */

        {

            TCGLabel *label1;

            TCGv t0;

            if (!s->pe || s->vm86)

                goto illegal_op;

            ot = dflag != MO_16 ? MO_32 : MO_16;

            modrm = x86_ldub_code(env, s);

            reg = ((modrm >> 3) & 7) | rex_r;

            gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);

            t0 = tcg_temp_local_new();

            gen_update_cc_op(s);

            if (b == 0x102) {

                gen_helper_lar(t0, cpu_env, cpu_T0);

            } else {

                gen_helper_lsl(t0, cpu_env, cpu_T0);

            }

            tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);

            label1 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);

            gen_op_mov_reg_v(ot, reg, t0);

            gen_set_label(label1);

            set_cc_op(s, CC_OP_EFLAGS);

            tcg_temp_free(t0);

        }

        break;

    case 0x118:

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        op = (modrm >> 3) & 7;

        switch(op) {

        case 0: /* prefetchnta */

        case 1: /* prefetchnt0 */

        case 2: /* prefetchnt0 */

        case 3: /* prefetchnt0 */

            if (mod == 3)

                goto illegal_op;

            gen_nop_modrm(env, s, modrm);

            /* nothing more to do */

            break;

        default: /* nop (multi byte) */

            gen_nop_modrm(env, s, modrm);

            break;

        }

        break;

    case 0x11a:

        modrm = x86_ldub_code(env, s);

        if (s->flags & HF_MPX_EN_MASK) {

            mod = (modrm >> 6) & 3;

            reg = ((modrm >> 3) & 7) | rex_r;

            if (prefixes & PREFIX_REPZ) {

                /* bndcl */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);

            } else if (prefixes & PREFIX_REPNZ) {

                /* bndcu */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                TCGv_i64 notu = tcg_temp_new_i64();

                tcg_gen_not_i64(notu, cpu_bndu[reg]);

                gen_bndck(env, s, modrm, TCG_COND_GTU, notu);

                tcg_temp_free_i64(notu);

            } else if (prefixes & PREFIX_DATA) {

                /* bndmov -- from reg/mem */

                if (reg >= 4 || s->aflag == MO_16) {

                    goto illegal_op;

                }

                if (mod == 3) {

                    int reg2 = (modrm & 7) | REX_B(s);

                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {

                        goto illegal_op;

                    }

                    if (s->flags & HF_MPX_IU_MASK) {

                        tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);

                        tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);

                    }

                } else {

                    gen_lea_modrm(env, s, modrm);

                    if (CODE64(s)) {

                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);

                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                    } else {

                        tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);

                        tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                    }

                    /* bnd registers are now in-use */

                    gen_set_hflag(s, HF_MPX_IU_MASK);

                }

            } else if (mod != 3) {

                /* bndldx */

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16

                    || a.base < -1) {

                    goto illegal_op;

                }

                if (a.base >= 0) {

                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);

                } else {

                    tcg_gen_movi_tl(cpu_A0, 0);

                }

                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

                if (a.index >= 0) {

                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);

                } else {

                    tcg_gen_movi_tl(cpu_T0, 0);

                }

                if (CODE64(s)) {

                    gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);

                    tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,

                                   offsetof(CPUX86State, mmx_t0.MMX_Q(0)));

                } else {

                    gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);

                    tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);

                    tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);

                }

                gen_set_hflag(s, HF_MPX_IU_MASK);

            }

        }

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x11b:

        modrm = x86_ldub_code(env, s);

        if (s->flags & HF_MPX_EN_MASK) {

            mod = (modrm >> 6) & 3;

            reg = ((modrm >> 3) & 7) | rex_r;

            if (mod != 3 && (prefixes & PREFIX_REPZ)) {

                /* bndmk */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (a.base >= 0) {

                    tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);

                    if (!CODE64(s)) {

                        tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);

                    }

                } else if (a.base == -1) {

                    /* no base register has lower bound of 0 */

                    tcg_gen_movi_i64(cpu_bndl[reg], 0);

                } else {

                    /* rip-relative generates #ud */

                    goto illegal_op;

                }

                tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));

                if (!CODE64(s)) {

                    tcg_gen_ext32u_tl(cpu_A0, cpu_A0);

                }

                tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);

                /* bnd registers are now in-use */

                gen_set_hflag(s, HF_MPX_IU_MASK);

                break;

            } else if (prefixes & PREFIX_REPNZ) {

                /* bndcn */

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16) {

                    goto illegal_op;

                }

                gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);

            } else if (prefixes & PREFIX_DATA) {

                /* bndmov -- to reg/mem */

                if (reg >= 4 || s->aflag == MO_16) {

                    goto illegal_op;

                }

                if (mod == 3) {

                    int reg2 = (modrm & 7) | REX_B(s);

                    if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {

                        goto illegal_op;

                    }

                    if (s->flags & HF_MPX_IU_MASK) {

                        tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);

                        tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);

                    }

                } else {

                    gen_lea_modrm(env, s, modrm);

                    if (CODE64(s)) {

                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);

                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEQ);

                    } else {

                        tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                        tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);

                        tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,

                                            s->mem_index, MO_LEUL);

                    }

                }

            } else if (mod != 3) {

                /* bndstx */

                AddressParts a = gen_lea_modrm_0(env, s, modrm);

                if (reg >= 4

                    || (prefixes & PREFIX_LOCK)

                    || s->aflag == MO_16

                    || a.base < -1) {

                    goto illegal_op;

                }

                if (a.base >= 0) {

                    tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);

                } else {

                    tcg_gen_movi_tl(cpu_A0, 0);

                }

                gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);

                if (a.index >= 0) {

                    tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);

                } else {

                    tcg_gen_movi_tl(cpu_T0, 0);

                }

                if (CODE64(s)) {

                    gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,

                                        cpu_bndl[reg], cpu_bndu[reg]);

                } else {

                    gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,

                                        cpu_bndl[reg], cpu_bndu[reg]);

                }

            }

        }

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */

        modrm = x86_ldub_code(env, s);

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x120: /* mov reg, crN */

    case 0x122: /* mov crN, reg */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            modrm = x86_ldub_code(env, s);

            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).

             * AMD documentation (24594.pdf) and testing of

             * intel 386 and 486 processors all show that the mod bits

             * are assumed to be 1's, regardless of actual values.

             */

            rm = (modrm & 7) | REX_B(s);

            reg = ((modrm >> 3) & 7) | rex_r;

            if (CODE64(s))

                ot = MO_64;

            else

                ot = MO_32;

            if ((prefixes & PREFIX_LOCK) && (reg == 0) &&

                (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {

                reg = 8;

            }

            switch(reg) {

            case 0:

            case 2:

            case 3:

            case 4:

            case 8:

                gen_update_cc_op(s);

                gen_jmp_im(pc_start - s->cs_base);

                if (b & 2) {

                    if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                        gen_io_start();

                    }

                    gen_op_mov_v_reg(ot, cpu_T0, rm);

                    gen_helper_write_crN(cpu_env, tcg_const_i32(reg),

                                         cpu_T0);

                    if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                        gen_io_end();

                    }

                    gen_jmp_im(s->pc - s->cs_base);

                    gen_eob(s);

                } else {

                    if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                        gen_io_start();

                    }

                    gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));

                    gen_op_mov_reg_v(ot, rm, cpu_T0);

                    if (tb_cflags(s->base.tb) & CF_USE_ICOUNT) {

                        gen_io_end();

                    }

                }

                break;

            default:

                goto unknown_op;

            }

        }

        break;

    case 0x121: /* mov reg, drN */

    case 0x123: /* mov drN, reg */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            modrm = x86_ldub_code(env, s);

            /* Ignore the mod bits (assume (modrm&0xc0)==0xc0).

             * AMD documentation (24594.pdf) and testing of

             * intel 386 and 486 processors all show that the mod bits

             * are assumed to be 1's, regardless of actual values.

             */

            rm = (modrm & 7) | REX_B(s);

            reg = ((modrm >> 3) & 7) | rex_r;

            if (CODE64(s))

                ot = MO_64;

            else

                ot = MO_32;

            if (reg >= 8) {

                goto illegal_op;

            }

            if (b & 2) {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);

                gen_op_mov_v_reg(ot, cpu_T0, rm);

                tcg_gen_movi_i32(cpu_tmp2_i32, reg);

                gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);

                gen_jmp_im(s->pc - s->cs_base);

                gen_eob(s);

            } else {

                gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);

                tcg_gen_movi_i32(cpu_tmp2_i32, reg);

                gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);

                gen_op_mov_reg_v(ot, rm, cpu_T0);

            }

        }

        break;

    case 0x106: /* clts */

        if (s->cpl != 0) {

            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        } else {

            gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);

            gen_helper_clts(cpu_env);

            /* abort block because static cpu state changed */

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

        }

        break;

    /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */

    case 0x1c3: /* MOVNTI reg, mem */

        if (!(s->cpuid_features & CPUID_SSE2))

            goto illegal_op;

        ot = mo_64_32(dflag);

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        reg = ((modrm >> 3) & 7) | rex_r;

        /* generate a generic store */

        gen_ldst_modrm(env, s, modrm, ot, reg, 1);

        break;

    case 0x1ae:

        modrm = x86_ldub_code(env, s);

        switch (modrm) {

        CASE_MODRM_MEM_OP(0): /* fxsave */

            if (!(s->cpuid_features & CPUID_FXSR)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            gen_helper_fxsave(cpu_env, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(1): /* fxrstor */

            if (!(s->cpuid_features & CPUID_FXSR)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            gen_helper_fxrstor(cpu_env, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(2): /* ldmxcsr */

            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {

                goto illegal_op;

            }

            if (s->flags & HF_TS_MASK) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);

            gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);

            break;



        CASE_MODRM_MEM_OP(3): /* stmxcsr */

            if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {

                goto illegal_op;

            }

            if (s->flags & HF_TS_MASK) {

                gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);

                break;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));

            gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);

            break;



        CASE_MODRM_MEM_OP(4): /* xsave */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (prefixes & (PREFIX_LOCK | PREFIX_DATA

                                | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);

            break;



        CASE_MODRM_MEM_OP(5): /* xrstor */

            if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                || (prefixes & (PREFIX_LOCK | PREFIX_DATA

                                | PREFIX_REPZ | PREFIX_REPNZ))) {

                goto illegal_op;

            }

            gen_lea_modrm(env, s, modrm);

            tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                  cpu_regs[R_EDX]);

            gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);

            /* XRSTOR is how MPX is enabled, which changes how

               we translate.  Thus we need to end the TB.  */

            gen_update_cc_op(s);

            gen_jmp_im(s->pc - s->cs_base);

            gen_eob(s);

            break;



        CASE_MODRM_MEM_OP(6): /* xsaveopt / clwb */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            if (prefixes & PREFIX_DATA) {

                /* clwb */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {

                    goto illegal_op;

                }

                gen_nop_modrm(env, s, modrm);

            } else {

                /* xsaveopt */

                if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0

                    || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0

                    || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {

                    goto illegal_op;

                }

                gen_lea_modrm(env, s, modrm);

                tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],

                                      cpu_regs[R_EDX]);

                gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);

            }

            break;



        CASE_MODRM_MEM_OP(7): /* clflush / clflushopt */

            if (prefixes & PREFIX_LOCK) {

                goto illegal_op;

            }

            if (prefixes & PREFIX_DATA) {

                /* clflushopt */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {

                    goto illegal_op;

                }

            } else {

                /* clflush */

                if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))

                    || !(s->cpuid_features & CPUID_CLFLUSH)) {

                    goto illegal_op;

                }

            }

            gen_nop_modrm(env, s, modrm);

            break;



        case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */

        case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */

        case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */

        case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */

            if (CODE64(s)

                && (prefixes & PREFIX_REPZ)

                && !(prefixes & PREFIX_LOCK)

                && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {

                TCGv base, treg, src, dst;



                /* Preserve hflags bits by testing CR4 at runtime.  */

                tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);

                gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);



                base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];

                treg = cpu_regs[(modrm & 7) | REX_B(s)];



                if (modrm & 0x10) {

                    /* wr*base */

                    dst = base, src = treg;

                } else {

                    /* rd*base */

                    dst = treg, src = base;

                }



                if (s->dflag == MO_32) {

                    tcg_gen_ext32u_tl(dst, src);

                } else {

                    tcg_gen_mov_tl(dst, src);

                }

                break;

            }

            goto unknown_op;



        case 0xf8: /* sfence / pcommit */

            if (prefixes & PREFIX_DATA) {

                /* pcommit */

                if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)

                    || (prefixes & PREFIX_LOCK)) {

                    goto illegal_op;

                }

                break;

            }

            /* fallthru */

        case 0xf9 ... 0xff: /* sfence */

            if (!(s->cpuid_features & CPUID_SSE)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);

            break;

        case 0xe8 ... 0xef: /* lfence */

            if (!(s->cpuid_features & CPUID_SSE)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);

            break;

        case 0xf0 ... 0xf7: /* mfence */

            if (!(s->cpuid_features & CPUID_SSE2)

                || (prefixes & PREFIX_LOCK)) {

                goto illegal_op;

            }

            tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);

            break;



        default:

            goto unknown_op;

        }

        break;



    case 0x10d: /* 3DNow! prefetch(w) */

        modrm = x86_ldub_code(env, s);

        mod = (modrm >> 6) & 3;

        if (mod == 3)

            goto illegal_op;

        gen_nop_modrm(env, s, modrm);

        break;

    case 0x1aa: /* rsm */

        gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);

        if (!(s->flags & HF_SMM_MASK))

            goto illegal_op;

        gen_update_cc_op(s);

        gen_jmp_im(s->pc - s->cs_base);

        gen_helper_rsm(cpu_env);

        gen_eob(s);

        break;

    case 0x1b8: /* SSE4.2 popcnt */

        if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=

             PREFIX_REPZ)

            goto illegal_op;

        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))

            goto illegal_op;



        modrm = x86_ldub_code(env, s);

        reg = ((modrm >> 3) & 7) | rex_r;



        if (s->prefix & PREFIX_DATA) {

            ot = MO_16;

        } else {

            ot = mo_64_32(dflag);

        }



        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);

        gen_extu(ot, cpu_T0);

        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);

        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);

        gen_op_mov_reg_v(ot, reg, cpu_T0);



        set_cc_op(s, CC_OP_POPCNT);

        break;

    case 0x10e ... 0x10f:

        /* 3DNow! instructions, ignore prefixes */

        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);

    case 0x110 ... 0x117:

    case 0x128 ... 0x12f:

    case 0x138 ... 0x13a:

    case 0x150 ... 0x179:

    case 0x17c ... 0x17f:

    case 0x1c2:

    case 0x1c4 ... 0x1c6:

    case 0x1d0 ... 0x1fe:

        gen_sse(env, s, b, pc_start, rex_r);

        break;

    default:

        goto unknown_op;

    }

    return s->pc;

 illegal_op:

    gen_illegal_opcode(s);

    return s->pc;

 unknown_op:

    gen_unknown_opcode(env, s);

    return s->pc;

}
 and probability:0.13586520460016047
code:static int kvm_mce_in_exception(CPUState *env)

{

    struct kvm_msr_entry msr_mcg_status = {

        .index = MSR_MCG_STATUS,

    };

    int r;



    r = kvm_get_msr(env, &msr_mcg_status, 1);

    if (r == -1 || r == 0) {

        return -1;

    }

    return !!(msr_mcg_status.data & MCG_STATUS_MCIP);

}
 and probability:0.0
code:static void count_cpreg(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_array_len++;

    }

}
 and probability:0.36363636363636365
code:static inline uint32_t efsctsiz(uint32_t val)

{

    CPU_FloatU u;



    u.l = val;

    /* NaN are not treated the same way IEEE 754 does */

    if (unlikely(float32_is_nan(u.f)))

        return 0;



    return float32_to_int32_round_to_zero(u.f, &env->vec_status);

}
 and probability:0.1111111111111111
code:static void scsi_unrealize(SCSIDevice *s, Error **errp)

{

    scsi_device_purge_requests(s, SENSE_CODE(NO_SENSE));

    blockdev_mark_auto_del(s->conf.blk);

}
 and probability:0.2
code:int slirp_is_inited(void)

{

    return slirp_inited;

}
 and probability:0.0
code:int pit_get_gate(PITState *pit, int channel)

{

    PITChannelState *s = &pit->channels[channel];

    return s->gate;

}
 and probability:0.4
code:void pci_register_bar(PCIDevice *pci_dev, int region_num,

                      uint8_t type, MemoryRegion *memory)

{

    PCIIORegion *r;

    uint32_t addr; /* offset in pci config space */

    uint64_t wmask;

    pcibus_t size = memory_region_size(memory);



    assert(region_num >= 0);

    assert(region_num < PCI_NUM_REGIONS);

    if (size & (size-1)) {

        fprintf(stderr, "ERROR: PCI region size must be pow2 "

                    "type=0x%x, size=0x%"FMT_PCIBUS"\n", type, size);

        exit(1);

    }



    r = &pci_dev->io_regions[region_num];

    r->addr = PCI_BAR_UNMAPPED;

    r->size = size;

    r->type = type;

    r->memory = memory;

    r->address_space = type & PCI_BASE_ADDRESS_SPACE_IO

                        ? pci_dev->bus->address_space_io

                        : pci_dev->bus->address_space_mem;



    wmask = ~(size - 1);

    if (region_num == PCI_ROM_SLOT) {

        /* ROM enable bit is writable */

        wmask |= PCI_ROM_ADDRESS_ENABLE;

    }



    addr = pci_bar(pci_dev, region_num);

    pci_set_long(pci_dev->config + addr, type);



    if (!(r->type & PCI_BASE_ADDRESS_SPACE_IO) &&

        r->type & PCI_BASE_ADDRESS_MEM_TYPE_64) {

        pci_set_quad(pci_dev->wmask + addr, wmask);

        pci_set_quad(pci_dev->cmask + addr, ~0ULL);

    } else {

        pci_set_long(pci_dev->wmask + addr, wmask & 0xffffffff);

        pci_set_long(pci_dev->cmask + addr, 0xffffffff);

    }

}
 and probability:0.4473684210526316
code:static int configure_accelerator(void)

{

    const char *p = NULL;

    char buf[10];

    int i, ret;

    bool accel_initalised = 0;

    bool init_failed = 0;



    QemuOptsList *list = qemu_find_opts("machine");

    if (!QTAILQ_EMPTY(&list->head)) {

        p = qemu_opt_get(QTAILQ_FIRST(&list->head), "accel");

    }



    if (p == NULL) {

        /* Use the default "accelerator", tcg */

        p = "tcg";

    }



    while (!accel_initalised && *p != '\0') {

        if (*p == ':') {

            p++;

        }

        p = get_opt_name(buf, sizeof (buf), p, ':');

        for (i = 0; i < ARRAY_SIZE(accel_list); i++) {

            if (strcmp(accel_list[i].opt_name, buf) == 0) {

                ret = accel_list[i].init();

                if (ret < 0) {

                    init_failed = 1;

                    if (!accel_list[i].available()) {

                        printf("%s not supported for this target\n",

                               accel_list[i].name);

                    } else {

                        fprintf(stderr, "failed to initialize %s: %s\n",

                                accel_list[i].name,

                                strerror(-ret));

                    }

                } else {

                    accel_initalised = 1;

                    *(accel_list[i].allowed) = 1;

                }

                break;

            }

        }

        if (i == ARRAY_SIZE(accel_list)) {

            fprintf(stderr, "\"%s\" accelerator does not exist.\n", buf);

        }

    }



    if (!accel_initalised) {

        fprintf(stderr, "No accelerator found!\n");

        exit(1);

    }



    if (init_failed) {

        fprintf(stderr, "Back to %s accelerator.\n", accel_list[i].name);

    }



    return !accel_initalised;

}
 and probability:0.24528301886792453
code:static int mss4_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MSS4Context *c = avctx->priv_data;

    GetBitContext gb;

    GetByteContext bc;

    uint8_t *dst[3];

    int width, height, quality, frame_type;

    int x, y, i, mb_width, mb_height, blk_type;

    int ret;



    if (buf_size < HEADER_SIZE) {

        av_log(avctx, AV_LOG_ERROR,

               "Frame should have at least %d bytes, got %d instead\n",

               HEADER_SIZE, buf_size);

        return AVERROR_INVALIDDATA;

    }



    bytestream2_init(&bc, buf, buf_size);

    width      = bytestream2_get_be16(&bc);

    height     = bytestream2_get_be16(&bc);

    bytestream2_skip(&bc, 2);

    quality    = bytestream2_get_byte(&bc);

    frame_type = bytestream2_get_byte(&bc);



    if (width > avctx->width ||

        height != avctx->height) {

        av_log(avctx, AV_LOG_ERROR, "Invalid frame dimensions %dx%d\n",

               width, height);

        return AVERROR_INVALIDDATA;

    }

    if (quality < 1 || quality > 100) {

        av_log(avctx, AV_LOG_ERROR, "Invalid quality setting %d\n", quality);

        return AVERROR_INVALIDDATA;

    }

    if ((frame_type & ~3) || frame_type == 3) {

        av_log(avctx, AV_LOG_ERROR, "Invalid frame type %d\n", frame_type);

        return AVERROR_INVALIDDATA;

    }



    if (frame_type != SKIP_FRAME && !bytestream2_get_bytes_left(&bc)) {

        av_log(avctx, AV_LOG_ERROR,

               "Empty frame found but it is not a skip frame.\n");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_reget_buffer(avctx, c->pic)) < 0)

        return ret;

    c->pic->key_frame = (frame_type == INTRA_FRAME);

    c->pic->pict_type = (frame_type == INTRA_FRAME) ? AV_PICTURE_TYPE_I

                                                   : AV_PICTURE_TYPE_P;

    if (frame_type == SKIP_FRAME) {

        *got_frame      = 1;

        if ((ret = av_frame_ref(data, c->pic)) < 0)

            return ret;



        return buf_size;

    }



    if (c->quality != quality) {

        c->quality = quality;

        for (i = 0; i < 2; i++)

            ff_mss34_gen_quant_mat(c->quant_mat[i], quality, !i);

    }



    init_get_bits8(&gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE));



    mb_width  = FFALIGN(width,  16) >> 4;

    mb_height = FFALIGN(height, 16) >> 4;

    dst[0] = c->pic->data[0];

    dst[1] = c->pic->data[1];

    dst[2] = c->pic->data[2];



    memset(c->prev_vec, 0, sizeof(c->prev_vec));

    for (y = 0; y < mb_height; y++) {

        memset(c->dc_cache, 0, sizeof(c->dc_cache));

        for (x = 0; x < mb_width; x++) {

            blk_type = decode012(&gb);

            switch (blk_type) {

            case DCT_BLOCK:

                if (mss4_decode_dct_block(c, &gb, dst, x, y) < 0) {

                    av_log(avctx, AV_LOG_ERROR,

                           "Error decoding DCT block %d,%d\n",

                           x, y);

                    return AVERROR_INVALIDDATA;

                }

                break;

            case IMAGE_BLOCK:

                if (mss4_decode_image_block(c, &gb, dst, x, y) < 0) {

                    av_log(avctx, AV_LOG_ERROR,

                           "Error decoding VQ block %d,%d\n",

                           x, y);

                    return AVERROR_INVALIDDATA;

                }

                break;

            case SKIP_BLOCK:

                if (frame_type == INTRA_FRAME) {

                    av_log(avctx, AV_LOG_ERROR, "Skip block in intra frame\n");

                    return AVERROR_INVALIDDATA;

                }

                break;

            }

            if (blk_type != DCT_BLOCK)

                mss4_update_dc_cache(c, x);

        }

        dst[0] += c->pic->linesize[0] * 16;

        dst[1] += c->pic->linesize[1] * 16;

        dst[2] += c->pic->linesize[2] * 16;

    }



    if ((ret = av_frame_ref(data, c->pic)) < 0)

        return ret;



    *got_frame      = 1;



    return buf_size;

}
 and probability:0.25471698113207547
code:static void guest_phys_blocks_region_add(MemoryListener *listener,

                                         MemoryRegionSection *section)

{

    GuestPhysListener *g;

    uint64_t section_size;

    hwaddr target_start, target_end;

    uint8_t *host_addr;

    GuestPhysBlock *predecessor;



    /* we only care about RAM */

    if (!memory_region_is_ram(section->mr) ||

        memory_region_is_skip_dump(section->mr)) {

        return;

    }



    g            = container_of(listener, GuestPhysListener, listener);

    section_size = int128_get64(section->size);

    target_start = section->offset_within_address_space;

    target_end   = target_start + section_size;

    host_addr    = memory_region_get_ram_ptr(section->mr) +

                   section->offset_within_region;

    predecessor  = NULL;



    /* find continuity in guest physical address space */

    if (!QTAILQ_EMPTY(&g->list->head)) {

        hwaddr predecessor_size;



        predecessor = QTAILQ_LAST(&g->list->head, GuestPhysBlockHead);

        predecessor_size = predecessor->target_end - predecessor->target_start;



        /* the memory API guarantees monotonically increasing traversal */

        g_assert(predecessor->target_end <= target_start);



        /* we want continuity in both guest-physical and host-virtual memory */

        if (predecessor->target_end < target_start ||

            predecessor->host_addr + predecessor_size != host_addr) {

            predecessor = NULL;

        }

    }



    if (predecessor == NULL) {

        /* isolated mapping, allocate it and add it to the list */

        GuestPhysBlock *block = g_malloc0(sizeof *block);



        block->target_start = target_start;

        block->target_end   = target_end;

        block->host_addr    = host_addr;

        block->mr           = section->mr;

        memory_region_ref(section->mr);



        QTAILQ_INSERT_TAIL(&g->list->head, block, next);

        ++g->list->num;

    } else {

        /* expand predecessor until @target_end; predecessor's start doesn't

         * change

         */

        predecessor->target_end = target_end;

    }



#ifdef DEBUG_GUEST_PHYS_REGION_ADD

    fprintf(stderr, "%s: target_start=" TARGET_FMT_plx " target_end="

            TARGET_FMT_plx ": %s (count: %u)\n", __FUNCTION__, target_start,

            target_end, predecessor ? "joined" : "added", g->list->num);

#endif

}
 and probability:0.41818181818181815
code:InputEvent *replay_read_input_event(void)

{

    InputEvent evt;

    KeyValue keyValue;

    InputKeyEvent key;

    key.key = &keyValue;

    InputBtnEvent btn;

    InputMoveEvent rel;

    InputMoveEvent abs;



    evt.type = replay_get_dword();

    switch (evt.type) {

    case INPUT_EVENT_KIND_KEY:

        evt.u.key = &key;

        evt.u.key->key->type = replay_get_dword();



        switch (evt.u.key->key->type) {

        case KEY_VALUE_KIND_NUMBER:

            evt.u.key->key->u.number = replay_get_qword();

            evt.u.key->down = replay_get_byte();

            break;

        case KEY_VALUE_KIND_QCODE:

            evt.u.key->key->u.qcode = (QKeyCode)replay_get_dword();

            evt.u.key->down = replay_get_byte();

            break;

        case KEY_VALUE_KIND__MAX:

            /* keep gcc happy */

            break;

        }

        break;

    case INPUT_EVENT_KIND_BTN:

        evt.u.btn = &btn;

        evt.u.btn->button = (InputButton)replay_get_dword();

        evt.u.btn->down = replay_get_byte();

        break;

    case INPUT_EVENT_KIND_REL:

        evt.u.rel = &rel;

        evt.u.rel->axis = (InputAxis)replay_get_dword();

        evt.u.rel->value = replay_get_qword();

        break;

    case INPUT_EVENT_KIND_ABS:

        evt.u.abs = &abs;

        evt.u.abs->axis = (InputAxis)replay_get_dword();

        evt.u.abs->value = replay_get_qword();

        break;

    case INPUT_EVENT_KIND__MAX:

        /* keep gcc happy */

        break;

    }



    return qapi_clone_InputEvent(&evt);

}
 and probability:0.24489795918367346
code:build_fadt(GArray *table_data, GArray *linker, AcpiPmInfo *pm,

           unsigned facs, unsigned dsdt)

{

    AcpiFadtDescriptorRev1 *fadt = acpi_data_push(table_data, sizeof(*fadt));



    fadt->firmware_ctrl = cpu_to_le32(facs);

    /* FACS address to be filled by Guest linker */

    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,

                                   ACPI_BUILD_TABLE_FILE,

                                   table_data, &fadt->firmware_ctrl,

                                   sizeof fadt->firmware_ctrl);



    fadt->dsdt = cpu_to_le32(dsdt);

    /* DSDT address to be filled by Guest linker */

    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,

                                   ACPI_BUILD_TABLE_FILE,

                                   table_data, &fadt->dsdt,

                                   sizeof fadt->dsdt);



    fadt_setup(fadt, pm);



    build_header(linker, table_data,

                 (void *)fadt, "FACP", sizeof(*fadt), 1, NULL);

}
 and probability:0.45
code:vpc_co_pwritev(BlockDriverState *bs, uint64_t offset, uint64_t bytes,

               QEMUIOVector *qiov, int flags)

{

    BDRVVPCState *s = bs->opaque;

    int64_t image_offset;

    int64_t n_bytes;

    int64_t bytes_done = 0;

    int ret;

    VHDFooter *footer =  (VHDFooter *) s->footer_buf;

    QEMUIOVector local_qiov;



    if (be32_to_cpu(footer->type) == VHD_FIXED) {

        return bdrv_co_pwritev(bs->file->bs, offset, bytes, qiov, 0);

    }



    qemu_co_mutex_lock(&s->lock);

    qemu_iovec_init(&local_qiov, qiov->niov);



    while (bytes > 0) {

        image_offset = get_image_offset(bs, offset, true);

        n_bytes = MIN(bytes, s->block_size - (offset % s->block_size));



        if (image_offset == -1) {

            image_offset = alloc_block(bs, offset);

            if (image_offset < 0) {

                ret = image_offset;

                goto fail;

            }

        }



        qemu_iovec_reset(&local_qiov);

        qemu_iovec_concat(&local_qiov, qiov, bytes_done, n_bytes);



        ret = bdrv_co_pwritev(bs->file->bs, image_offset, n_bytes,

                              &local_qiov, 0);

        if (ret < 0) {

            goto fail;

        }



        bytes -= n_bytes;

        offset += n_bytes;

        bytes_done += n_bytes;

    }



    ret = 0;

fail:

    qemu_iovec_destroy(&local_qiov);

    qemu_co_mutex_unlock(&s->lock);



    return ret;

}
 and probability:0.3333333333333333
code:static int debugcon_parse(const char *devname)

{

    QemuOpts *opts;



    if (!qemu_chr_new("debugcon", devname, NULL)) {

        exit(1);

    }

    opts = qemu_opts_create(qemu_find_opts("device"), "debugcon", 1, NULL);

    if (!opts) {

        fprintf(stderr, "qemu: already have a debugcon device\n");

        exit(1);

    }

    qemu_opt_set(opts, "driver", "isa-debugcon", &error_abort);

    qemu_opt_set(opts, "chardev", "debugcon", &error_abort);

    return 0;

}
 and probability:0.0
code:static void qemu_rbd_parse_filename(const char *filename, QDict *options,

                                    Error **errp)

{

    const char *start;

    char *p, *buf, *keypairs;

    char *found_str;

    size_t max_keypair_size;

    Error *local_err = NULL;



    if (!strstart(filename, "rbd:", &start)) {

        error_setg(errp, "File name must start with 'rbd:'");

        return;

    }



    max_keypair_size = strlen(start) + 1;

    buf = g_strdup(start);

    keypairs = g_malloc0(max_keypair_size);

    p = buf;



    found_str = qemu_rbd_next_tok(RBD_MAX_POOL_NAME_SIZE, p,

                                  '/', "pool name", &p, &local_err);

    if (local_err) {

        goto done;

    }

    if (!p) {

        error_setg(errp, "Pool name is required");

        goto done;

    }

    qemu_rbd_unescape(found_str);

    qdict_put(options, "pool", qstring_from_str(found_str));



    if (strchr(p, '@')) {

        found_str = qemu_rbd_next_tok(RBD_MAX_IMAGE_NAME_SIZE, p,

                                      '@', "object name", &p, &local_err);

        if (local_err) {

            goto done;

        }

        qemu_rbd_unescape(found_str);

        qdict_put(options, "image", qstring_from_str(found_str));



        found_str = qemu_rbd_next_tok(RBD_MAX_SNAP_NAME_SIZE, p,

                                      ':', "snap name", &p, &local_err);

        if (local_err) {

            goto done;

        }

        qemu_rbd_unescape(found_str);

        qdict_put(options, "snapshot", qstring_from_str(found_str));

    } else {

        found_str = qemu_rbd_next_tok(RBD_MAX_IMAGE_NAME_SIZE, p,

                                      ':', "object name", &p, &local_err);

        if (local_err) {

            goto done;

        }

        qemu_rbd_unescape(found_str);

        qdict_put(options, "image", qstring_from_str(found_str));

    }

    if (!p) {

        goto done;

    }



    found_str = qemu_rbd_next_tok(RBD_MAX_CONF_NAME_SIZE, p,

                                  '\0', "configuration", &p, &local_err);

    if (local_err) {

        goto done;

    }



    p = found_str;



    /* The following are essentially all key/value pairs, and we treat

     * 'id' and 'conf' a bit special.  Key/value pairs may be in any order. */

    while (p) {

        char *name, *value;

        name = qemu_rbd_next_tok(RBD_MAX_CONF_NAME_SIZE, p,

                                 '=', "conf option name", &p, &local_err);

        if (local_err) {

            break;

        }



        if (!p) {

            error_setg(errp, "conf option %s has no value", name);

            break;

        }



        qemu_rbd_unescape(name);



        value = qemu_rbd_next_tok(RBD_MAX_CONF_VAL_SIZE, p,

                                  ':', "conf option value", &p, &local_err);

        if (local_err) {

            break;

        }

        qemu_rbd_unescape(value);



        if (!strcmp(name, "conf")) {

            qdict_put(options, "conf", qstring_from_str(value));

        } else if (!strcmp(name, "id")) {

            qdict_put(options, "user" , qstring_from_str(value));

        } else {

            /* FIXME: This is pretty ugly, and not the right way to do this.

             *        These should be contained in a structure, and then

             *        passed explicitly as individual key/value pairs to

             *        rados.  Consider this legacy code that needs to be

             *        updated. */

            char *tmp = g_malloc0(max_keypair_size);

            /* only use a delimiter if it is not the first keypair found */

            /* These are sets of unknown key/value pairs we'll pass along

             * to ceph */

            if (keypairs[0]) {

                snprintf(tmp, max_keypair_size, ":%s=%s", name, value);

                pstrcat(keypairs, max_keypair_size, tmp);

            } else {

                snprintf(keypairs, max_keypair_size, "%s=%s", name, value);

            }

            g_free(tmp);

        }

    }



    if (keypairs[0]) {

        qdict_put(options, "keyvalue-pairs", qstring_from_str(keypairs));

    }





done:

    if (local_err) {

        error_propagate(errp, local_err);

    }

    g_free(buf);

    g_free(keypairs);

    return;

}
 and probability:0.02631578947368421
code:static void register_multipage(MemoryRegionSection *section)

{

    target_phys_addr_t start_addr = section->offset_within_address_space;

    ram_addr_t size = section->size;

    target_phys_addr_t addr;

    uint16_t section_index = phys_section_add(section);



    assert(size);



    addr = start_addr;

    phys_page_set(addr >> TARGET_PAGE_BITS, size >> TARGET_PAGE_BITS,

                  section_index);

}
 and probability:0.18181818181818182
code:static int gdb_breakpoint_insert(CPUState *env, target_ulong addr,

                                 target_ulong len, int type)

{

    switch (type) {

    case GDB_BREAKPOINT_SW:

    case GDB_BREAKPOINT_HW:

        return cpu_breakpoint_insert(env, addr, BP_GDB, NULL);

#ifndef CONFIG_USER_ONLY

    case GDB_WATCHPOINT_WRITE:

    case GDB_WATCHPOINT_READ:

    case GDB_WATCHPOINT_ACCESS:

        return cpu_watchpoint_insert(env, addr, len, xlat_gdb_type[type],

                                     NULL);

#endif

    default:

        return -ENOSYS;

    }

}
 and probability:0.05555555555555555
code:ResampleContext *ff_audio_resample_init(AVAudioResampleContext *avr)

{

    ResampleContext *c;

    int out_rate    = avr->out_sample_rate;

    int in_rate     = avr->in_sample_rate;

    double factor   = FFMIN(out_rate * avr->cutoff / in_rate, 1.0);

    int phase_count = 1 << avr->phase_shift;

    int felem_size;



    if (avr->internal_sample_fmt != AV_SAMPLE_FMT_S16P &&

        avr->internal_sample_fmt != AV_SAMPLE_FMT_S32P &&

        avr->internal_sample_fmt != AV_SAMPLE_FMT_FLTP &&

        avr->internal_sample_fmt != AV_SAMPLE_FMT_DBLP) {

        av_log(avr, AV_LOG_ERROR, "Unsupported internal format for "

               "resampling: %s\n",

               av_get_sample_fmt_name(avr->internal_sample_fmt));

        return NULL;

    }

    c = av_mallocz(sizeof(*c));

    if (!c)

        return NULL;



    c->avr           = avr;

    c->phase_shift   = avr->phase_shift;

    c->phase_mask    = phase_count - 1;

    c->linear        = avr->linear_interp;

    c->factor        = factor;

    c->filter_length = FFMAX((int)ceil(avr->filter_size / factor), 1);

    c->filter_type   = avr->filter_type;

    c->kaiser_beta   = avr->kaiser_beta;



    switch (avr->internal_sample_fmt) {

    case AV_SAMPLE_FMT_DBLP:

        c->resample_one  = resample_one_dbl;

        c->resample_nearest = resample_nearest_dbl;

        c->set_filter    = set_filter_dbl;

        break;

    case AV_SAMPLE_FMT_FLTP:

        c->resample_one  = resample_one_flt;

        c->resample_nearest = resample_nearest_flt;

        c->set_filter    = set_filter_flt;

        break;

    case AV_SAMPLE_FMT_S32P:

        c->resample_one  = resample_one_s32;

        c->resample_nearest = resample_nearest_s32;

        c->set_filter    = set_filter_s32;

        break;

    case AV_SAMPLE_FMT_S16P:

        c->resample_one  = resample_one_s16;

        c->resample_nearest = resample_nearest_s16;

        c->set_filter    = set_filter_s16;

        break;

    }



    felem_size = av_get_bytes_per_sample(avr->internal_sample_fmt);

    c->filter_bank = av_mallocz(c->filter_length * (phase_count + 1) * felem_size);

    if (!c->filter_bank)

        goto error;



    if (build_filter(c) < 0)

        goto error;



    memcpy(&c->filter_bank[(c->filter_length * phase_count + 1) * felem_size],

           c->filter_bank, (c->filter_length - 1) * felem_size);

    memcpy(&c->filter_bank[c->filter_length * phase_count * felem_size],

           &c->filter_bank[(c->filter_length - 1) * felem_size], felem_size);



    c->compensation_distance = 0;

    if (!av_reduce(&c->src_incr, &c->dst_incr, out_rate,

                   in_rate * (int64_t)phase_count, INT32_MAX / 2))

        goto error;

    c->ideal_dst_incr = c->dst_incr;



    c->padding_size   = (c->filter_length - 1) / 2;

    c->index = -phase_count * ((c->filter_length - 1) / 2);

    c->frac  = 0;



    /* allocate internal buffer */

    c->buffer = ff_audio_data_alloc(avr->resample_channels, 0,

                                    avr->internal_sample_fmt,

                                    "resample buffer");

    if (!c->buffer)

        goto error;



    av_log(avr, AV_LOG_DEBUG, "resample: %s from %d Hz to %d Hz\n",

           av_get_sample_fmt_name(avr->internal_sample_fmt),

           avr->in_sample_rate, avr->out_sample_rate);



    return c;



error:

    ff_audio_data_free(&c->buffer);

    av_free(c->filter_bank);

    av_free(c);

    return NULL;

}
 and probability:0.6190476190476191
code:static inline void stl_phys_internal(target_phys_addr_t addr, uint32_t val,

                                     enum device_endian endian)

{

    uint8_t *ptr;

    MemoryRegionSection *section;



    section = phys_page_find(addr >> TARGET_PAGE_BITS);



    if (!memory_region_is_ram(section->mr) || section->readonly) {

        addr = memory_region_section_addr(section, addr);

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

#if defined(TARGET_WORDS_BIGENDIAN)

        if (endian == DEVICE_LITTLE_ENDIAN) {

            val = bswap32(val);

        }

#else

        if (endian == DEVICE_BIG_ENDIAN) {

            val = bswap32(val);

        }

#endif

        io_mem_write(section->mr, addr, val, 4);

    } else {

        unsigned long addr1;

        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)

            + memory_region_section_addr(section, addr);

        /* RAM case */

        ptr = qemu_get_ram_ptr(addr1);

        switch (endian) {

        case DEVICE_LITTLE_ENDIAN:

            stl_le_p(ptr, val);

            break;

        case DEVICE_BIG_ENDIAN:

            stl_be_p(ptr, val);

            break;

        default:

            stl_p(ptr, val);

            break;

        }

        invalidate_and_set_dirty(addr1, 4);

    }

}
 and probability:0.12195121951219512
code:static int usb_hub_handle_control(USBDevice *dev, int request, int value,

                                  int index, int length, uint8_t *data)

{

    USBHubState *s = (USBHubState *)dev;

    int ret;



    ret = usb_desc_handle_control(dev, request, value, index, length, data);

    if (ret >= 0) {

        return ret;

    }



    switch(request) {

    case DeviceRequest | USB_REQ_GET_STATUS:

        data[0] = (1 << USB_DEVICE_SELF_POWERED) |

            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);

        data[1] = 0x00;

        ret = 2;

        break;

    case DeviceOutRequest | USB_REQ_CLEAR_FEATURE:

        if (value == USB_DEVICE_REMOTE_WAKEUP) {

            dev->remote_wakeup = 0;

        } else {

            goto fail;

        }

        ret = 0;

        break;

    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:

        if (value == 0 && index != 0x81) { /* clear ep halt */

            goto fail;

        }

        ret = 0;

        break;

    case DeviceOutRequest | USB_REQ_SET_FEATURE:

        if (value == USB_DEVICE_REMOTE_WAKEUP) {

            dev->remote_wakeup = 1;

        } else {

            goto fail;

        }

        ret = 0;

        break;

    case DeviceRequest | USB_REQ_GET_CONFIGURATION:

        data[0] = 1;

        ret = 1;

        break;

    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        ret = 0;

        break;

    case DeviceRequest | USB_REQ_GET_INTERFACE:

        data[0] = 0;

        ret = 1;

        break;

    case DeviceOutRequest | USB_REQ_SET_INTERFACE:

        ret = 0;

        break;

        /* usb specific requests */

    case GetHubStatus:

        data[0] = 0;

        data[1] = 0;

        data[2] = 0;

        data[3] = 0;

        ret = 4;

        break;

    case GetPortStatus:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            data[0] = port->wPortStatus;

            data[1] = port->wPortStatus >> 8;

            data[2] = port->wPortChange;

            data[3] = port->wPortChange >> 8;

            ret = 4;

        }

        break;

    case SetHubFeature:

    case ClearHubFeature:

        if (value == 0 || value == 1) {

        } else {

            goto fail;

        }

        ret = 0;

        break;

    case SetPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;

            USBDevice *dev;

            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            dev = port->port.dev;

            switch(value) {

            case PORT_SUSPEND:

                port->wPortStatus |= PORT_STAT_SUSPEND;

                break;

            case PORT_RESET:

                if (dev) {

                    usb_send_msg(dev, USB_MSG_RESET);

                    port->wPortChange |= PORT_STAT_C_RESET;

                    /* set enable bit */

                    port->wPortStatus |= PORT_STAT_ENABLE;

                }

                break;

            case PORT_POWER:

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case ClearPortFeature:

        {

            unsigned int n = index - 1;

            USBHubPort *port;



            if (n >= NUM_PORTS) {

                goto fail;

            }

            port = &s->ports[n];

            switch(value) {

            case PORT_ENABLE:

                port->wPortStatus &= ~PORT_STAT_ENABLE;

                break;

            case PORT_C_ENABLE:

                port->wPortChange &= ~PORT_STAT_C_ENABLE;

                break;

            case PORT_SUSPEND:

                port->wPortStatus &= ~PORT_STAT_SUSPEND;

                break;

            case PORT_C_SUSPEND:

                port->wPortChange &= ~PORT_STAT_C_SUSPEND;

                break;

            case PORT_C_CONNECTION:

                port->wPortChange &= ~PORT_STAT_C_CONNECTION;

                break;

            case PORT_C_OVERCURRENT:

                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;

                break;

            case PORT_C_RESET:

                port->wPortChange &= ~PORT_STAT_C_RESET;

                break;

            default:

                goto fail;

            }

            ret = 0;

        }

        break;

    case GetHubDescriptor:

        {

            unsigned int n, limit, var_hub_size = 0;

            memcpy(data, qemu_hub_hub_descriptor,

                   sizeof(qemu_hub_hub_descriptor));

            data[2] = NUM_PORTS;



            /* fill DeviceRemovable bits */

            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;

            for (n = 7; n < limit; n++) {

                data[n] = 0x00;

                var_hub_size++;

            }



            /* fill PortPwrCtrlMask bits */

            limit = limit + ((NUM_PORTS + 7) / 8);

            for (;n < limit; n++) {

                data[n] = 0xff;

                var_hub_size++;

            }



            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;

            data[0] = ret;

            break;

        }

    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }

    return ret;

}
 and probability:0.24157303370786518
code:void nbd_client_close(BlockDriverState *bs)

{

    NbdClientSession *client = nbd_get_client_session(bs);

    struct nbd_request request = {

        .type = NBD_CMD_DISC,

        .from = 0,

        .len = 0

    };



    if (client->ioc == NULL) {

        return;

    }



    nbd_send_request(client->ioc, &request);



    nbd_teardown_connection(bs);

}
 and probability:0.14285714285714285
code:static int handle_tsch(S390CPU *cpu)

{

    CPUS390XState *env = &cpu->env;

    CPUState *cs = CPU(cpu);

    struct kvm_run *run = cs->kvm_run;

    int ret;



    cpu_synchronize_state(cs);



    ret = ioinst_handle_tsch(env, env->regs[1], run->s390_tsch.ipb);

    if (ret >= 0) {

        /* Success; set condition code. */

        setcc(cpu, ret);

        ret = 0;

    } else if (ret < -1) {

        /*

         * Failure.

         * If an I/O interrupt had been dequeued, we have to reinject it.

         */

        if (run->s390_tsch.dequeued) {

            uint16_t subchannel_id = run->s390_tsch.subchannel_id;

            uint16_t subchannel_nr = run->s390_tsch.subchannel_nr;

            uint32_t io_int_parm = run->s390_tsch.io_int_parm;

            uint32_t io_int_word = run->s390_tsch.io_int_word;

            uint32_t type = ((subchannel_id & 0xff00) << 24) |

                ((subchannel_id & 0x00060) << 22) | (subchannel_nr << 16);



            kvm_s390_interrupt_internal(cpu, type,

                                        ((uint32_t)subchannel_id << 16)

                                        | subchannel_nr,

                                        ((uint64_t)io_int_parm << 32)

                                        | io_int_word, 1);

        }

        ret = 0;

    }

    return ret;

}
 and probability:0.23529411764705882
code:static int read_password(char *buf, int buf_size)

{

    uint8_t ch;

    int i, ret;



    printf("password: ");

    fflush(stdout);

    term_init();

    i = 0;

    for(;;) {

        ret = read(0, &ch, 1);

        if (ret == -1) {

            if (errno == EAGAIN || errno == EINTR) {

                continue;

            } else {

                break;

            }

        } else if (ret == 0) {

            ret = -1;

            break;

        } else {

            if (ch == '\r') {

                ret = 0;

                break;

            }

            if (i < (buf_size - 1))

                buf[i++] = ch;

        }

    }

    term_exit();

    buf[i] = '\0';

    printf("\n");

    return ret;

}
 and probability:0.09090909090909091
code:static uint64_t exynos4210_rtc_read(void *opaque, target_phys_addr_t offset,

        unsigned size)

{

    uint32_t value = 0;

    Exynos4210RTCState *s = (Exynos4210RTCState *)opaque;



    switch (offset) {

    case INTP:

        value = s->reg_intp;

        break;

    case RTCCON:

        value = s->reg_rtccon;

        break;

    case TICCNT:

        value = s->reg_ticcnt;

        break;

    case RTCALM:

        value = s->reg_rtcalm;

        break;

    case ALMSEC:

        value = s->reg_almsec;

        break;

    case ALMMIN:

        value = s->reg_almmin;

        break;

    case ALMHOUR:

        value = s->reg_almhour;

        break;

    case ALMDAY:

        value = s->reg_almday;

        break;

    case ALMMON:

        value = s->reg_almmon;

        break;

    case ALMYEAR:

        value = s->reg_almyear;

        break;



    case BCDSEC:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_sec);

        break;

    case BCDMIN:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_min);

        break;

    case BCDHOUR:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_hour);

        break;

    case BCDDAYWEEK:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_wday);

        break;

    case BCDDAY:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_mday);

        break;

    case BCDMON:

        value = (uint32_t)to_bcd((uint8_t)s->current_tm.tm_mon + 1);

        break;

    case BCDYEAR:

        value = BCD3DIGITS(s->current_tm.tm_year);

        break;



    case CURTICNT:

        s->reg_curticcnt = ptimer_get_count(s->ptimer);

        value = s->reg_curticcnt;

        break;



    default:

        fprintf(stderr,

                "[exynos4210.rtc: bad read offset " TARGET_FMT_plx "]\n",

                offset);

        break;

    }

    return value;

}
 and probability:0.2753623188405797
code:static int read_tfra(MOVContext *mov, AVIOContext *f)

{

    MOVFragmentIndex* index = NULL;

    int version, fieldlength, i, j, err;

    int64_t pos = avio_tell(f);

    uint32_t size = avio_rb32(f);

    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {

        return -1;

    }

    av_log(mov->fc, AV_LOG_VERBOSE, "found tfra\n");

    index = av_mallocz(sizeof(MOVFragmentIndex));

    if (!index) {

        return AVERROR(ENOMEM);

    }

    mov->fragment_index_count++;

    if ((err = av_reallocp(&mov->fragment_index_data,

                           mov->fragment_index_count *

                           sizeof(MOVFragmentIndex*))) < 0) {

        av_freep(&index);

        return err;

    }

    mov->fragment_index_data[mov->fragment_index_count - 1] =

        index;



    version = avio_r8(f);

    avio_rb24(f);

    index->track_id = avio_rb32(f);

    fieldlength = avio_rb32(f);

    index->item_count = avio_rb32(f);

    index->items = av_mallocz(

            index->item_count * sizeof(MOVFragmentIndexItem));

    if (!index->items) {

        return AVERROR(ENOMEM);

    }

    for (i = 0; i < index->item_count; i++) {

        int64_t time, offset;

        if (version == 1) {

            time   = avio_rb64(f);

            offset = avio_rb64(f);

        } else {

            time   = avio_rb32(f);

            offset = avio_rb32(f);

        }

        index->items[i].time = time;

        index->items[i].moof_offset = offset;

        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)

            avio_r8(f);

        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)

            avio_r8(f);

        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)

            avio_r8(f);

    }



    avio_seek(f, pos + size, SEEK_SET);

    return 0;

}
 and probability:0.3148148148148148
code:void ff_h264_direct_ref_list_init(H264Context * const h){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    Picture * const cur = s->current_picture_ptr;

    int list, j, field;

    int sidx= (s->picture_structure&1)^1;

    int ref1sidx = (ref1->f.reference&1)^1;



    for(list=0; list<2; list++){

        cur->ref_count[sidx][list] = h->ref_count[list];

        for(j=0; j<h->ref_count[list]; j++)

            cur->ref_poc[sidx][list][j] = 4 * h->ref_list[list][j].frame_num + (h->ref_list[list][j].f.reference & 3);

    }



    if(s->picture_structure == PICT_FRAME){

        memcpy(cur->ref_count[1], cur->ref_count[0], sizeof(cur->ref_count[0]));

        memcpy(cur->ref_poc  [1], cur->ref_poc  [0], sizeof(cur->ref_poc  [0]));

    }



    cur->mbaff= FRAME_MBAFF;



    h->col_fieldoff= 0;

    if(s->picture_structure == PICT_FRAME){

        int cur_poc = s->current_picture_ptr->poc;

        int *col_poc = h->ref_list[1]->field_poc;

        h->col_parity= (FFABS(col_poc[0] - cur_poc) >= FFABS(col_poc[1] - cur_poc));

        ref1sidx=sidx= h->col_parity;

    } else if (!(s->picture_structure & h->ref_list[1][0].f.reference) && !h->ref_list[1][0].mbaff) { // FL -> FL & differ parity

        h->col_fieldoff = 2 * h->ref_list[1][0].f.reference - 3;

    }



    if (cur->f.pict_type != AV_PICTURE_TYPE_B || h->direct_spatial_mv_pred)

        return;



    for(list=0; list<2; list++){

        fill_colmap(h, h->map_col_to_list0, list, sidx, ref1sidx, 0);

        if(FRAME_MBAFF)

        for(field=0; field<2; field++)

            fill_colmap(h, h->map_col_to_list0_field[field], list, field, field, 1);

    }

}
 and probability:0.7428571428571429
code:static int make_ydt24_entry(int p1, int p2, int16_t *ydt)

{

    int lo, hi;



    lo = ydt[p1];

    hi = ydt[p2];

    return (lo + (hi << 8) + (hi << 16)) << 1;

}
 and probability:0.42857142857142855
code:static uint64_t fw_cfg_comb_read(void *opaque, hwaddr addr,

                                 unsigned size)

{

    return fw_cfg_read(opaque);

}
 and probability:0.0
code:static int xan_decode_frame(AVCodecContext *avctx,
                            void *data, int *data_size,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int ret, buf_size = avpkt->size;
    XanContext *s = avctx->priv_data;
    if (avctx->codec->id == CODEC_ID_XAN_WC3) {
        const uint8_t *buf_end = buf + buf_size;
        int tag = 0;
        while (buf_end - buf > 8 && tag != VGA__TAG) {
            unsigned *tmpptr;
            uint32_t new_pal;
            int size;
            int i;
            tag  = bytestream_get_le32(&buf);
            size = bytestream_get_be32(&buf);
            size = FFMIN(size, buf_end - buf);
            switch (tag) {
            case PALT_TAG:
                if (size < PALETTE_SIZE)
                if (s->palettes_count >= PALETTES_MAX)
                tmpptr = av_realloc(s->palettes, (s->palettes_count + 1) * AVPALETTE_SIZE);
                if (!tmpptr)
                    return AVERROR(ENOMEM);
                s->palettes = tmpptr;
                tmpptr += s->palettes_count * AVPALETTE_COUNT;
                for (i = 0; i < PALETTE_COUNT; i++) {
#if RUNTIME_GAMMA
                    int r = gamma_corr(*buf++);
                    int g = gamma_corr(*buf++);
                    int b = gamma_corr(*buf++);
#else
                    int r = gamma_lookup[*buf++];
                    int g = gamma_lookup[*buf++];
                    int b = gamma_lookup[*buf++];
#endif
                    *tmpptr++ = (r << 16) | (g << 8) | b;
                }
                s->palettes_count++;
                break;
            case SHOT_TAG:
                if (size < 4)
                new_pal = bytestream_get_le32(&buf);
                if (new_pal < s->palettes_count) {
                    s->cur_palette = new_pal;
                } else
                    av_log(avctx, AV_LOG_ERROR, "Invalid palette selected\n");
                break;
            case VGA__TAG:
                break;
            default:
                buf += size;
                break;
            }
        }
        buf_size = buf_end - buf;
    }
    if ((ret = avctx->get_buffer(avctx, &s->current_frame))) {
        av_log(s->avctx, AV_LOG_ERROR, "get_buffer() failed\n");
        return ret;
    }
    s->current_frame.reference = 3;
    if (!s->frame_size)
        s->frame_size = s->current_frame.linesize[0] * s->avctx->height;
    memcpy(s->current_frame.data[1], s->palettes + s->cur_palette * AVPALETTE_COUNT, AVPALETTE_SIZE);
    s->buf = buf;
    s->size = buf_size;
    if (xan_wc3_decode_frame(s) < 0)
    /* release the last frame if it is allocated */
    if (s->last_frame.data[0])
        avctx->release_buffer(avctx, &s->last_frame);
    *data_size = sizeof(AVFrame);
    *(AVFrame*)data = s->current_frame;
    /* shuffle frames */
    FFSWAP(AVFrame, s->current_frame, s->last_frame);
    /* always report that the buffer was completely consumed */
    return buf_size;
} and probability:0.46835443037974683
code:void do_405_check_sat (void)

{

    if (!likely(((T1 ^ T2) >> 31) || !((T0 ^ T2) >> 31))) {

        /* Saturate result */

        if (T2 >> 31) {

            T0 = INT32_MIN;

        } else {

            T0 = INT32_MAX;

        }

    }

}
 and probability:0.0
code:void *grow_array(void *array, int elem_size, int *size, int new_size)

{

    if (new_size >= INT_MAX / elem_size) {

        av_log(NULL, AV_LOG_ERROR, "Array too big.\n");

        exit(1);

    }

    if (*size < new_size) {

        uint8_t *tmp = av_realloc(array, new_size*elem_size);

        if (!tmp) {

            av_log(NULL, AV_LOG_ERROR, "Could not alloc buffer.\n");

            exit(1);

        }

        memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);

        *size = new_size;

        return tmp;

    }

    return array;

}
 and probability:0.2777777777777778
code:static int select_input_file(uint8_t *no_packet)

{

    int64_t ipts_min = INT64_MAX;

    int i, file_index = -1;



    for (i = 0; i < nb_input_streams; i++) {

        InputStream *ist = input_streams[i];

        int64_t ipts     = ist->pts;



        if (ist->discard || no_packet[ist->file_index])

            continue;

        if (!input_files[ist->file_index]->eof_reached) {

            if (ipts < ipts_min) {

                ipts_min = ipts;

                file_index = ist->file_index;

            }

        }

    }



    return file_index;

}
 and probability:0.3333333333333333
code:static target_ulong get_psr(void)

{

    helper_compute_psr();



#if !defined (TARGET_SPARC64)

    return env->version | (env->psr & PSR_ICC) |

        (env->psref? PSR_EF : 0) |

        (env->psrpil << 8) |

        (env->psrs? PSR_S : 0) |

        (env->psrps? PSR_PS : 0) |

        (env->psret? PSR_ET : 0) | env->cwp;

#else

    return env->version | (env->psr & PSR_ICC) |

        (env->psref? PSR_EF : 0) |

        (env->psrpil << 8) |

        (env->psrs? PSR_S : 0) |

        (env->psrps? PSR_PS : 0) | env->cwp;

#endif

}
 and probability:0.6111111111111112
code:void qpci_iounmap(QPCIDevice *dev, void *data)

{

    /* FIXME */

}
 and probability:0.0
code:int rom_add_file(const char *file, const char *fw_dir,
                 hwaddr addr, int32_t bootindex,
                 bool option_rom, MemoryRegion *mr)
{
    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());
    Rom *rom;
    int rc, fd = -1;
    char devpath[100];
    rom = g_malloc0(sizeof(*rom));
    rom->name = g_strdup(file);
    rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);
    if (rom->path == NULL) {
        rom->path = g_strdup(file);
    fd = open(rom->path, O_RDONLY | O_BINARY);
    if (fd == -1) {
        fprintf(stderr, "Could not open option rom '%s': %s\n",
                rom->path, strerror(errno));
        goto err;
        rom->fw_dir  = g_strdup(fw_dir);
        rom->fw_file = g_strdup(file);
    rom->addr     = addr;
    rom->romsize  = lseek(fd, 0, SEEK_END);
    if (rom->romsize == -1) {
        fprintf(stderr, "rom: file %-20s: get size error: %s\n",
                rom->name, strerror(errno));
        goto err;
    rom->datasize = rom->romsize;
    rom->data     = g_malloc0(rom->datasize);
    lseek(fd, 0, SEEK_SET);
    rc = read(fd, rom->data, rom->datasize);
    if (rc != rom->datasize) {
        fprintf(stderr, "rom: file %-20s: read error: rc=%d (expected %zd)\n",
                rom->name, rc, rom->datasize);
        goto err;
    close(fd);
    rom_insert(rom);
    if (rom->fw_file && fw_cfg) {
        const char *basename;
        char fw_file_name[FW_CFG_MAX_FILE_PATH];
        void *data;
        basename = strrchr(rom->fw_file, '/');
        if (basename) {
            basename++;
        } else {
            basename = rom->fw_file;
        snprintf(fw_file_name, sizeof(fw_file_name), "%s/%s", rom->fw_dir,
                 basename);
        snprintf(devpath, sizeof(devpath), "/rom@%s", fw_file_name);
        if ((!option_rom || mc->option_rom_has_mr) && mc->rom_file_has_mr) {
            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);
        } else {
            data = rom->data;
        fw_cfg_add_file(fw_cfg, fw_file_name, data, rom->romsize);
    } else {
        if (mr) {
            rom->mr = mr;
            snprintf(devpath, sizeof(devpath), "/rom@%s", file);
        } else {
            snprintf(devpath, sizeof(devpath), "/rom@" TARGET_FMT_plx, addr);
    add_boot_device_path(bootindex, NULL, devpath);
    return 0;
err:
    if (fd != -1)
        close(fd);
    g_free(rom->data);
    g_free(rom->path);
    g_free(rom->name);
    g_free(rom);
    return -1; and probability:0.43478260869565216
code:static inline int find_pte (CPUState *env, mmu_ctx_t *ctx, int h, int rw)

{

#if defined(TARGET_PPC64)

    if (env->mmu_model == POWERPC_MMU_64B ||

        env->mmu_model == POWERPC_MMU_64BRIDGE)

        return find_pte64(ctx, h, rw);

#endif



    return find_pte32(ctx, h, rw);

}
 and probability:0.2222222222222222
code:static void vfio_probe_nvidia_bar5_quirk(VFIOPCIDevice *vdev, int nr)

{

    VFIOQuirk *quirk;

    VFIONvidiaBAR5Quirk *bar5;

    VFIOConfigWindowQuirk *window;



    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||

        !vdev->has_vga || nr != 5) {

        return;

    }



    quirk = g_malloc0(sizeof(*quirk));

    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 4);

    quirk->nr_mem = 4;

    bar5 = quirk->data = g_malloc0(sizeof(*bar5) +

                                   (sizeof(VFIOConfigWindowMatch) * 2));

    window = &bar5->window;



    window->vdev = vdev;

    window->address_offset = 0x8;

    window->data_offset = 0xc;

    window->nr_matches = 2;

    window->matches[0].match = 0x1800;

    window->matches[0].mask = PCI_CONFIG_SPACE_SIZE - 1;

    window->matches[1].match = 0x88000;

    window->matches[1].mask = PCIE_CONFIG_SPACE_SIZE - 1;

    window->bar = nr;

    window->addr_mem = bar5->addr_mem = &quirk->mem[0];

    window->data_mem = bar5->data_mem = &quirk->mem[1];



    memory_region_init_io(window->addr_mem, OBJECT(vdev),

                          &vfio_generic_window_address_quirk, window,

                          "vfio-nvidia-bar5-window-address-quirk", 4);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        window->address_offset,

                                        window->addr_mem, 1);

    memory_region_set_enabled(window->addr_mem, false);



    memory_region_init_io(window->data_mem, OBJECT(vdev),

                          &vfio_generic_window_data_quirk, window,

                          "vfio-nvidia-bar5-window-data-quirk", 4);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        window->data_offset,

                                        window->data_mem, 1);

    memory_region_set_enabled(window->data_mem, false);



    memory_region_init_io(&quirk->mem[2], OBJECT(vdev),

                          &vfio_nvidia_bar5_quirk_master, bar5,

                          "vfio-nvidia-bar5-master-quirk", 4);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        0, &quirk->mem[2], 1);



    memory_region_init_io(&quirk->mem[3], OBJECT(vdev),

                          &vfio_nvidia_bar5_quirk_enable, bar5,

                          "vfio-nvidia-bar5-enable-quirk", 4);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        4, &quirk->mem[3], 1);



    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);



    trace_vfio_quirk_nvidia_bar5_probe(vdev->vbasedev.name);

}
 and probability:0.6792452830188679
code:static PXA2xxI2SState *pxa2xx_i2s_init(MemoryRegion *sysmem,

                hwaddr base,

                qemu_irq irq, qemu_irq rx_dma, qemu_irq tx_dma)

{

    PXA2xxI2SState *s = (PXA2xxI2SState *)

            g_malloc0(sizeof(PXA2xxI2SState));



    s->irq = irq;

    s->rx_dma = rx_dma;

    s->tx_dma = tx_dma;

    s->data_req = pxa2xx_i2s_data_req;



    pxa2xx_i2s_reset(s);



    memory_region_init_io(&s->iomem, NULL, &pxa2xx_i2s_ops, s,

                          "pxa2xx-i2s", 0x100000);

    memory_region_add_subregion(sysmem, base, &s->iomem);



    vmstate_register(NULL, base, &vmstate_pxa2xx_i2s, s);



    return s;

}
 and probability:0.35294117647058826
code:static void unimp_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = unimp_realize;

    dc->props = unimp_properties;






} and probability:0.3333333333333333
code:int ff_get_qtpalette(int codec_id, AVIOContext *pb, uint32_t *palette)

{

    int tmp, bit_depth, color_table_id, greyscale, i;



    avio_seek(pb, 82, SEEK_CUR);



    /* Get the bit depth and greyscale state */

    tmp = avio_rb16(pb);

    bit_depth = tmp & 0x1F;

    greyscale = tmp & 0x20;



    /* Get the color table ID */

    color_table_id = avio_rb16(pb);



    /* Do not create a greyscale palette for Cinepak */

    if (greyscale && codec_id == AV_CODEC_ID_CINEPAK)

        return 0;



    /* If the depth is 1, 2, 4, or 8 bpp, file is palettized. */

    if ((bit_depth == 1 || bit_depth == 2 || bit_depth == 4 || bit_depth == 8)) {

        int color_count, color_start, color_end;

        uint32_t a, r, g, b;



        /* Ignore the greyscale bit for 1-bit video and sample

         * descriptions containing a color table. */

        if (greyscale && bit_depth > 1 && color_table_id) {

            int color_index, color_dec;

            /* compute the greyscale palette */

            color_count = 1 << bit_depth;

            color_index = 255;

            color_dec   = 256 / (color_count - 1);

            for (i = 0; i < color_count; i++) {

                r = g = b = color_index;

                palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | (b);

                color_index -= color_dec;

                if (color_index < 0)

                    color_index = 0;

            }

        } else if (color_table_id) {

            /* The color table ID is non-zero. Interpret this as

             * being -1, which means use the default Macintosh

             * color table */

            const uint8_t *color_table;

            color_count = 1 << bit_depth;

            if (bit_depth == 1)

                color_table = ff_qt_default_palette_2;

            else if (bit_depth == 2)

                color_table = ff_qt_default_palette_4;

            else if (bit_depth == 4)

                color_table = ff_qt_default_palette_16;

            else

                color_table = ff_qt_default_palette_256;

            for (i = 0; i < color_count; i++) {

                r = color_table[i * 3 + 0];

                g = color_table[i * 3 + 1];

                b = color_table[i * 3 + 2];

                palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | (b);

            }

        } else {

            /* The color table ID is 0; the color table is in the sample

             * description */

            color_start = avio_rb32(pb);

            avio_rb16(pb); /* color table flags */

            color_end = avio_rb16(pb);

            if ((color_start <= 255) && (color_end <= 255)) {

                for (i = color_start; i <= color_end; i++) {

                    /* each A, R, G, or B component is 16 bits;

                     * only use the top 8 bits */

                    a = avio_r8(pb);

                    avio_r8(pb);

                    r = avio_r8(pb);

                    avio_r8(pb);

                    g = avio_r8(pb);

                    avio_r8(pb);

                    b = avio_r8(pb);

                    avio_r8(pb);

                    palette[i] = (a << 24 ) | (r << 16) | (g << 8) | (b);

                }

            }

        }



        return 1;

    }



    return 0;

}
 and probability:0.14102564102564102
code:AVCodecParserContext *av_parser_init(int codec_id)

{

    AVCodecParserContext *s = NULL;

    AVCodecParser *parser;

    int ret;



    if(codec_id == AV_CODEC_ID_NONE)

        return NULL;



    for(parser = av_first_parser; parser != NULL; parser = parser->next) {

        if (parser->codec_ids[0] == codec_id ||

            parser->codec_ids[1] == codec_id ||

            parser->codec_ids[2] == codec_id ||

            parser->codec_ids[3] == codec_id ||

            parser->codec_ids[4] == codec_id)

            goto found;

    }

    return NULL;

 found:

    s = av_mallocz(sizeof(AVCodecParserContext));

    if (!s)

        goto err_out;

    s->parser = parser;

    s->priv_data = av_mallocz(parser->priv_data_size);

    if (!s->priv_data)

        goto err_out;

    s->fetch_timestamp=1;

    s->pict_type = AV_PICTURE_TYPE_I;

    if (parser->parser_init) {

        if (ff_lock_avcodec(NULL) < 0)

            goto err_out;

        ret = parser->parser_init(s);

        ff_unlock_avcodec();

        if (ret != 0)

            goto err_out;

    }

    s->key_frame = -1;

    s->convergence_duration = 0;

    s->dts_sync_point       = INT_MIN;

    s->dts_ref_dts_delta    = INT_MIN;

    s->pts_dts_delta        = INT_MIN;

    return s;



err_out:

    if (s)

        av_freep(&s->priv_data);

    av_free(s);

    return NULL;

}
 and probability:0.41304347826086957
code:static int ra288_decode_frame(AVCodecContext * avctx, void *data,

                              int *got_frame_ptr, AVPacket *avpkt)

{

    AVFrame *frame     = data;

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    float *out;

    int i, ret;

    RA288Context *ractx = avctx->priv_data;

    GetBitContext gb;



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR,

               "Error! Input buffer is too small [%d<%d]\n",

               buf_size, avctx->block_align);

        return AVERROR_INVALIDDATA;

    }



    /* get output buffer */

    frame->nb_samples = RA288_BLOCK_SIZE * RA288_BLOCKS_PER_FRAME;

    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)

        return ret;

    out = (float *)frame->data[0];



    init_get_bits8(&gb, buf, avctx->block_align);



    for (i=0; i < RA288_BLOCKS_PER_FRAME; i++) {

        float gain = amptable[get_bits(&gb, 3)];

        int cb_coef = get_bits(&gb, 6 + (i&1));



        decode(ractx, gain, cb_coef);



        memcpy(out, &ractx->sp_hist[70 + 36], RA288_BLOCK_SIZE * sizeof(*out));

        out += RA288_BLOCK_SIZE;



        if ((i & 7) == 3) {

            backward_filter(ractx, ractx->sp_hist, ractx->sp_rec, syn_window,

                            ractx->sp_lpc, syn_bw_tab, 36, 40, 35, 70);



            backward_filter(ractx, ractx->gain_hist, ractx->gain_rec, gain_window,

                            ractx->gain_lpc, gain_bw_tab, 10, 8, 20, 28);

        }

    }



    *got_frame_ptr = 1;



    return avctx->block_align;

}
 and probability:0.5
code:int avcodec_check_dimensions(void *av_log_ctx, unsigned int w, unsigned int h){

    if((int)w>0 && (int)h>0 && (w+128)*(uint64_t)(h+128) < INT_MAX/4)

        return 0;



    av_log(av_log_ctx, AV_LOG_ERROR, "picture size invalid (%ux%u)\n", w, h);

    return -1;

}
 and probability:0.16666666666666666
code:static int find_unused_picture(MpegEncContext *s, int shared)

{

    int i;



    if (shared) {

        for (i = 0; i < MAX_PICTURE_COUNT; i++) {

            if (s->picture[i].f.data[0] == NULL)

                return i;

        }

    } else {

        for (i = 0; i < MAX_PICTURE_COUNT; i++) {

            if (pic_is_unused(s, &s->picture[i]))

                return i;

        }

    }



    return AVERROR_INVALIDDATA;

}
 and probability:0.25
code:static int av_always_inline mlp_thd_probe(AVProbeData *p, uint32_t sync)

{

    const uint8_t *buf, *last_buf = p->buf, *end = p->buf + p->buf_size;

    int frames = 0, valid = 0, size = 0;



    for (buf = p->buf; buf + 8 <= end; buf++) {

        if (AV_RB32(buf + 4) == sync) {

            frames++;

            if (last_buf + size == buf) {

                valid++;

            }

            last_buf = buf;

            size = (AV_RB16(buf) & 0xfff) * 2;

        } else if (buf - last_buf == size) {

            size += (AV_RB16(buf) & 0xfff) * 2;

        }

    }

    if (valid >= 100)

        return AVPROBE_SCORE_MAX;

    return 0;

}
 and probability:0.45
code:void gic_complete_irq(GICState *s, int cpu, int irq)

{

    int update = 0;

    int cm = 1 << cpu;

    DPRINTF("EOI %d\n", irq);

    if (irq >= s->num_irq) {

        /* This handles two cases:

         * 1. If software writes the ID of a spurious interrupt [ie 1023]

         * to the GICC_EOIR, the GIC ignores that write.

         * 2. If software writes the number of a non-existent interrupt

         * this must be a subcase of "value written does not match the last

         * valid interrupt value read from the Interrupt Acknowledge

         * register" and so this is UNPREDICTABLE. We choose to ignore it.

         */

        return;

    }

    if (s->running_irq[cpu] == 1023)

        return; /* No active IRQ.  */



    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

        /* Mark level triggered interrupts as pending if they are still

           raised.  */

        if (!GIC_TEST_EDGE_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)

            && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {

            DPRINTF("Set %d pending mask %x\n", irq, cm);

            GIC_SET_PENDING(irq, cm);

            update = 1;

        }

    }



    if (irq != s->running_irq[cpu]) {

        /* Complete an IRQ that is not currently running.  */

        int tmp = s->running_irq[cpu];

        while (s->last_active[tmp][cpu] != 1023) {

            if (s->last_active[tmp][cpu] == irq) {

                s->last_active[tmp][cpu] = s->last_active[irq][cpu];

                break;

            }

            tmp = s->last_active[tmp][cpu];

        }

        if (update) {

            gic_update(s);

        }

    } else {

        /* Complete the current running IRQ.  */

        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);

    }

}
 and probability:0.21739130434782608
code:static void core_commit(MemoryListener *listener)

{

    PhysPageMap info = cur_map;

    cur_map = next_map;

    phys_sections_clear(&info);

}
 and probability:0.0
code:static int ppc_hash32_pte_update_flags(struct mmu_ctx_hash32 *ctx, target_ulong *pte1p,

                                       int ret, int rwx)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE32_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE32_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE32_R_C)) {

        if (rwx == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE32_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
 and probability:0.22727272727272727
code:static int raw_eject(BlockDriverState *bs, int eject_flag)

{

    BDRVRawState *s = bs->opaque;



    switch(s->type) {

    case FTYPE_CD:

        if (eject_flag) {

            if (ioctl (s->fd, CDROMEJECT, NULL) < 0)

                perror("CDROMEJECT");

        } else {

            if (ioctl (s->fd, CDROMCLOSETRAY, NULL) < 0)

                perror("CDROMEJECT");

        }

        break;

    case FTYPE_FD:

        {

            int fd;

            if (s->fd >= 0) {

                close(s->fd);

                s->fd = -1;

                raw_close_fd_pool(s);

            }

            fd = open(bs->filename, s->fd_open_flags | O_NONBLOCK);

            if (fd >= 0) {

                if (ioctl(fd, FDEJECT, 0) < 0)

                    perror("FDEJECT");

                close(fd);

            }

        }

        break;

    default:

        return -ENOTSUP;

    }

    return 0;

}
 and probability:0.23529411764705882
code:static void usage(void)

{

    const struct qemu_argument *arginfo;

    int maxarglen;

    int maxenvlen;



    printf("usage: qemu-" TARGET_ARCH " [options] program [arguments...]\n"

           "Linux CPU emulator (compiled for " TARGET_ARCH " emulation)\n"

           "\n"

           "Options and associated environment variables:\n"

           "\n");



    maxarglen = maxenvlen = 0;



    for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {

        if (strlen(arginfo->env) > maxenvlen) {

            maxenvlen = strlen(arginfo->env);

        }

        if (strlen(arginfo->argv) > maxarglen) {

            maxarglen = strlen(arginfo->argv);

        }

    }



    printf("%-*s%-*sDescription\n", maxarglen+3, "Argument",

            maxenvlen+1, "Env-variable");



    for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {

        if (arginfo->has_arg) {

            printf("-%s %-*s %-*s %s\n", arginfo->argv,

                    (int)(maxarglen-strlen(arginfo->argv)), arginfo->example,

                    maxenvlen, arginfo->env, arginfo->help);

        } else {

            printf("-%-*s %-*s %s\n", maxarglen+1, arginfo->argv,

                    maxenvlen, arginfo->env,

                    arginfo->help);

        }

    }



    printf("\n"

           "Defaults:\n"

           "QEMU_LD_PREFIX  = %s\n"

           "QEMU_STACK_SIZE = %ld byte\n",

           interp_prefix,

           guest_stack_size);



    printf("\n"

           "You can use -E and -U options or the QEMU_SET_ENV and\n"

           "QEMU_UNSET_ENV environment variables to set and unset\n"

           "environment variables for the target process.\n"

           "It is possible to provide several variables by separating them\n"

           "by commas in getsubopt(3) style. Additionally it is possible to\n"

           "provide the -E and -U options multiple times.\n"

           "The following lines are equivalent:\n"

           "    -E var1=val2 -E var2=val2 -U LD_PRELOAD -U LD_DEBUG\n"

           "    -E var1=val2,var2=val2 -U LD_PRELOAD,LD_DEBUG\n"

           "    QEMU_SET_ENV=var1=val2,var2=val2 QEMU_UNSET_ENV=LD_PRELOAD,LD_DEBUG\n"

           "Note that if you provide several changes to a single variable\n"

           "the last change will stay in effect.\n");



    exit(1);

}
 and probability:0.2830188679245283
code:static void qemu_rbd_complete_aio(RADOSCB *rcb)

{

    RBDAIOCB *acb = rcb->acb;

    int64_t r;



    r = rcb->ret;



    if (acb->cmd == RBD_AIO_WRITE ||

        acb->cmd == RBD_AIO_DISCARD) {

        if (r < 0) {

            acb->ret = r;

            acb->error = 1;

        } else if (!acb->error) {

            acb->ret = rcb->size;

        }

    } else {

        if (r < 0) {

            memset(rcb->buf, 0, rcb->size);

            acb->ret = r;

            acb->error = 1;

        } else if (r < rcb->size) {

            memset(rcb->buf + r, 0, rcb->size - r);

            if (!acb->error) {

                acb->ret = rcb->size;

            }

        } else if (!acb->error) {

            acb->ret = r;

        }

    }

    /* Note that acb->bh can be NULL in case where the aio was cancelled */

    acb->bh = qemu_bh_new(rbd_aio_bh_cb, acb);

    qemu_bh_schedule(acb->bh);

    g_free(rcb);

}
 and probability:0.59375
code:static gboolean gd_window_key_event(GtkWidget *widget, GdkEventKey *key, void *opaque)

{

    GtkDisplayState *s = opaque;

    GtkAccelGroupEntry *entries;

    guint n_entries = 0;

    gboolean propagate_accel = TRUE;

    gboolean handled = FALSE;



    entries = gtk_accel_group_query(s->accel_group, key->keyval,

                                    key->state, &n_entries);

    if (n_entries) {

        const char *quark = g_quark_to_string(entries[0].accel_path_quark);



        if (gd_is_grab_active(s) && strstart(quark, "<QEMU>/File/", NULL)) {

            propagate_accel = FALSE;

        }

    }



    if (!handled && propagate_accel) {

        handled = gtk_window_activate_key(GTK_WINDOW(widget), key);

    }

    if (handled) {

        gtk_release_modifiers(s);

    } else {

        handled = gtk_window_propagate_key_event(GTK_WINDOW(widget), key);

    }



    return handled;

}
 and probability:0.12
code:static av_always_inline void hl_decode_mb_predict_luma(H264Context *h,

                                                       int mb_type, int is_h264,

                                                       int simple,

                                                       int transform_bypass,

                                                       int pixel_shift,

                                                       int *block_offset,

                                                       int linesize,

                                                       uint8_t *dest_y, int p)

{

    void (*idct_add)(uint8_t *dst, int16_t *block, int stride);

    void (*idct_dc_add)(uint8_t *dst, int16_t *block, int stride);

    int i;

    int qscale = p == 0 ? h->qscale : h->chroma_qp[p - 1];

    block_offset += 16 * p;

    if (IS_INTRA4x4(mb_type)) {

        if (IS_8x8DCT(mb_type)) {

            if (transform_bypass) {

                idct_dc_add =

                idct_add    = h->h264dsp.h264_add_pixels8_clear;

            } else {

                idct_dc_add = h->h264dsp.h264_idct8_dc_add;

                idct_add    = h->h264dsp.h264_idct8_add;

            }

            for (i = 0; i < 16; i += 4) {

                uint8_t *const ptr = dest_y + block_offset[i];

                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];

                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {

                    h->hpc.pred8x8l_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                } else {

                    const int nnz = h->non_zero_count_cache[scan8[i + p * 16]];

                    h->hpc.pred8x8l[dir](ptr, (h->topleft_samples_available << i) & 0x8000,

                                         (h->topright_samples_available << i) & 0x4000, linesize);

                    if (nnz) {

                        if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))

                            idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                        else

                            idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                    }

                }

            }

        } else {

            if (transform_bypass) {

                idct_dc_add  =

                idct_add     = h->h264dsp.h264_add_pixels4_clear;

            } else {

                idct_dc_add = h->h264dsp.h264_idct_dc_add;

                idct_add    = h->h264dsp.h264_idct_add;

            }

            for (i = 0; i < 16; i++) {

                uint8_t *const ptr = dest_y + block_offset[i];

                const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];



                if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {

                    h->hpc.pred4x4_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                } else {

                    uint8_t *topright;

                    int nnz, tr;

                    uint64_t tr_high;

                    if (dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED) {

                        const int topright_avail = (h->topright_samples_available << i) & 0x8000;

                        av_assert2(h->mb_y || linesize <= block_offset[i]);

                        if (!topright_avail) {

                            if (pixel_shift) {

                                tr_high  = ((uint16_t *)ptr)[3 - linesize / 2] * 0x0001000100010001ULL;

                                topright = (uint8_t *)&tr_high;

                            } else {

                                tr       = ptr[3 - linesize] * 0x01010101u;

                                topright = (uint8_t *)&tr;

                            }

                        } else

                            topright = ptr + (4 << pixel_shift) - linesize;

                    } else

                        topright = NULL;



                    h->hpc.pred4x4[dir](ptr, topright, linesize);

                    nnz = h->non_zero_count_cache[scan8[i + p * 16]];

                    if (nnz) {

                        if (is_h264) {

                            if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))

                                idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                            else

                                idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);

                        } else if (CONFIG_SVQ3_DECODER)

                            ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize, qscale, 0);

                    }

                }

            }

        }

    } else {

        h->hpc.pred16x16[h->intra16x16_pred_mode](dest_y, linesize);

        if (is_h264) {

            if (h->non_zero_count_cache[scan8[LUMA_DC_BLOCK_INDEX + p]]) {

                if (!transform_bypass)

                    h->h264dsp.h264_luma_dc_dequant_idct(h->mb + (p * 256 << pixel_shift),

                                                         h->mb_luma_dc[p],

                                                         h->dequant4_coeff[p][qscale][0]);

                else {

                    static const uint8_t dc_mapping[16] = {

                         0 * 16,  1 * 16,  4 * 16,  5 * 16,

                         2 * 16,  3 * 16,  6 * 16,  7 * 16,

                         8 * 16,  9 * 16, 12 * 16, 13 * 16,

                        10 * 16, 11 * 16, 14 * 16, 15 * 16

                    };

                    for (i = 0; i < 16; i++)

                        dctcoef_set(h->mb + (p * 256 << pixel_shift),

                                    pixel_shift, dc_mapping[i],

                                    dctcoef_get(h->mb_luma_dc[p],

                                                pixel_shift, i));

                }

            }

        } else if (CONFIG_SVQ3_DECODER)

            ff_svq3_luma_dc_dequant_idct_c(h->mb + p * 256,

                                           h->mb_luma_dc[p], qscale);

    }

}
 and probability:0.4424778761061947
code:static void mcf_fec_do_tx(mcf_fec_state *s)

{

    uint32_t addr;

    mcf_fec_bd bd;

    int frame_size;

    int len;

    uint8_t frame[FEC_MAX_FRAME_SIZE];

    uint8_t *ptr;



    DPRINTF("do_tx\n");

    ptr = frame;

    frame_size = 0;

    addr = s->tx_descriptor;

    while (1) {

        mcf_fec_read_bd(&bd, addr);

        DPRINTF("tx_bd %x flags %04x len %d data %08x\n",

                addr, bd.flags, bd.length, bd.data);

        if ((bd.flags & FEC_BD_R) == 0) {

            /* Run out of descriptors to transmit.  */

            break;

        }

        len = bd.length;

        if (frame_size + len > FEC_MAX_FRAME_SIZE) {

            len = FEC_MAX_FRAME_SIZE - frame_size;

            s->eir |= FEC_INT_BABT;

        }

        cpu_physical_memory_read(bd.data, ptr, len);

        ptr += len;

        frame_size += len;

        if (bd.flags & FEC_BD_L) {

            /* Last buffer in frame.  */

            DPRINTF("Sending packet\n");

            qemu_send_packet(qemu_get_queue(s->nic), frame, len);

            ptr = frame;

            frame_size = 0;

            s->eir |= FEC_INT_TXF;

        }

        s->eir |= FEC_INT_TXB;

        bd.flags &= ~FEC_BD_R;

        /* Write back the modified descriptor.  */

        mcf_fec_write_bd(&bd, addr);

        /* Advance to the next descriptor.  */

        if ((bd.flags & FEC_BD_W) != 0) {

            addr = s->etdsr;

        } else {

            addr += 8;

        }

    }

    s->tx_descriptor = addr;

}
 and probability:0.24489795918367346
code:static void bonito_spciconf_writel(void *opaque, target_phys_addr_t addr,

                                   uint32_t val)

{

    PCIBonitoState *s = opaque;

    uint32_t pciaddr;

    uint16_t status;



    DPRINTF("bonito_spciconf_writel "TARGET_FMT_plx" val %x \n", addr, val);

    assert((addr&0x3)==0);



    pciaddr = bonito_sbridge_pciaddr(s, addr);



    if (pciaddr == 0xffffffff) {

        return;

    }



    /* set the pci address in s->config_reg */

    s->pcihost->config_reg = (pciaddr) | (1u << 31);

    pci_data_write(s->pcihost->bus, s->pcihost->config_reg, val, 4);



    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */

    status = pci_get_word(s->dev.config + PCI_STATUS);

    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);

    pci_set_word(s->dev.config + PCI_STATUS, status);

}
 and probability:0.2
code:void ide_init2_with_non_qdev_drives(IDEBus *bus, DriveInfo *hd0,

                                    DriveInfo *hd1, qemu_irq irq)

{

    int i;

    DriveInfo *dinfo;



    for(i = 0; i < 2; i++) {

        dinfo = i == 0 ? hd0 : hd1;

        ide_init1(bus, i);

        if (dinfo) {

            if (ide_init_drive(&bus->ifs[i], dinfo->bdrv,

                               dinfo->media_cd ? IDE_CD : IDE_HD, NULL,

                               *dinfo->serial ? dinfo->serial : NULL) < 0) {

                error_report("Can't set up IDE drive %s", dinfo->id);

                exit(1);

            }

            bdrv_attach_dev_nofail(dinfo->bdrv, &bus->ifs[i]);

        } else {

            ide_reset(&bus->ifs[i]);

        }

    }

    bus->irq = irq;

    bus->dma = &ide_dma_nop;

}
 and probability:0.391304347826087
code:static void pxa2xx_ssp_write(void *opaque, hwaddr addr,

                             uint64_t value64, unsigned size)

{

    PXA2xxSSPState *s = (PXA2xxSSPState *) opaque;

    uint32_t value = value64;



    switch (addr) {

    case SSCR0:

        s->sscr[0] = value & 0xc7ffffff;

        s->enable = value & SSCR0_SSE;

        if (value & SSCR0_MOD)

            printf("%s: Attempt to use network mode\n", __FUNCTION__);

        if (s->enable && SSCR0_DSS(value) < 4)

            printf("%s: Wrong data size: %i bits\n", __FUNCTION__,

                            SSCR0_DSS(value));

        if (!(value & SSCR0_SSE)) {

            s->sssr = 0;

            s->ssitr = 0;

            s->rx_level = 0;

        }

        pxa2xx_ssp_fifo_update(s);

        break;



    case SSCR1:

        s->sscr[1] = value;

        if (value & (SSCR1_LBM | SSCR1_EFWR))

            printf("%s: Attempt to use SSP test mode\n", __FUNCTION__);

        pxa2xx_ssp_fifo_update(s);

        break;



    case SSPSP:

        s->sspsp = value;

        break;



    case SSTO:

        s->ssto = value;

        break;



    case SSITR:

        s->ssitr = value & SSITR_INT;

        pxa2xx_ssp_int_update(s);

        break;



    case SSSR:

        s->sssr &= ~(value & SSSR_RW);

        pxa2xx_ssp_int_update(s);

        break;



    case SSDR:

        if (SSCR0_UWIRE(s->sscr[0])) {

            if (s->sscr[1] & SSCR1_MWDS)

                value &= 0xffff;

            else

                value &= 0xff;

        } else

            /* Note how 32bits overflow does no harm here */

            value &= (1 << SSCR0_DSS(s->sscr[0])) - 1;



        /* Data goes from here to the Tx FIFO and is shifted out from

         * there directly to the slave, no need to buffer it.

         */

        if (s->enable) {

            uint32_t readval;

            readval = ssi_transfer(s->bus, value);

            if (s->rx_level < 0x10) {

                s->rx_fifo[(s->rx_start + s->rx_level ++) & 0xf] = readval;

            } else {

                s->sssr |= SSSR_ROR;

            }

        }

        pxa2xx_ssp_fifo_update(s);

        break;



    case SSTSA:

        s->sstsa = value;

        break;



    case SSRSA:

        s->ssrsa = value;

        break;



    case SSACD:

        s->ssacd = value;

        break;



    default:

        printf("%s: Bad register " REG_FMT "\n", __FUNCTION__, addr);

        break;

    }

}
 and probability:0.28205128205128205
code:static int pci_ne2000_init(PCIDevice *pci_dev)

{

    PCINE2000State *d = DO_UPCAST(PCINE2000State, dev, pci_dev);

    NE2000State *s;

    uint8_t *pci_conf;



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_REALTEK);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_REALTEK_8029);

    pci_config_set_class(pci_conf, PCI_CLASS_NETWORK_ETHERNET);

    /* TODO: RST# value should be 0. PCI spec 6.2.4 */

    pci_conf[PCI_INTERRUPT_PIN] = 1; // interrupt pin 0



    pci_register_bar(&d->dev, 0, 0x100,

                           PCI_BASE_ADDRESS_SPACE_IO, ne2000_map);

    s = &d->ne2000;

    s->irq = d->dev.irq[0];



    qemu_macaddr_default_if_unset(&s->c.macaddr);

    ne2000_reset(s);



    s->nic = qemu_new_nic(&net_ne2000_info, &s->c,

                          pci_dev->qdev.info->name, pci_dev->qdev.id, s);

    qemu_format_nic_info_str(&s->nic->nc, s->c.macaddr.a);



    if (!pci_dev->qdev.hotplugged) {

        static int loaded = 0;

        if (!loaded) {

            rom_add_option("pxe-ne2k_pci.rom", -1);

            loaded = 1;

        }

    }



    add_boot_device_path(s->c.bootindex, &pci_dev->qdev, "/ethernet-phy@0");



    return 0;

}
 and probability:0.36666666666666664
code:static void inc_refcounts(BlockDriverState *bs,

                          uint16_t *refcount_table,

                          int refcount_table_size,

                          int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    int64_t start, last, cluster_offset;

    int k;



    if (size <= 0)

        return;



    start = offset & ~(s->cluster_size - 1);

    last = (offset + size - 1) & ~(s->cluster_size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k < 0 || k >= refcount_table_size) {

            fprintf(stderr, "ERROR: invalid cluster offset=0x%" PRIx64 "\n",

                cluster_offset);

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, "ERROR: overflow cluster offset=0x%" PRIx64

                    "\n", cluster_offset);

            }

        }

    }

}
 and probability:0.23076923076923078
code:static int pte_check_hash32(struct mmu_ctx_hash32 *ctx, target_ulong pte0,

                            target_ulong pte1, int h, int rw, int type)

{

    target_ulong mmask;

    int access, ret, pp;



    ret = -1;

    /* Check validity and table match */

    if ((pte0 & HPTE32_V_VALID) && (h == !!(pte0 & HPTE32_V_SECONDARY))) {

        /* Check vsid & api */

        mmask = PTE_CHECK_MASK;

        pp = pte1 & HPTE32_R_PP;

        if (HPTE32_V_COMPARE(pte0, ctx->ptem)) {

            if (ctx->raddr != (hwaddr)-1ULL) {

                /* all matches should have equal RPN, WIMG & PP */

                if ((ctx->raddr & mmask) != (pte1 & mmask)) {

                    qemu_log("Bad RPN/WIMG/PP\n");

                    return -3;

                }

            }

            /* Compute access rights */

            access = ppc_hash32_pp_check(ctx->key, pp, ctx->nx);

            /* Keep the matching PTE informations */

            ctx->raddr = pte1;

            ctx->prot = access;

            ret = ppc_hash32_check_prot(ctx->prot, rw, type);

            if (ret == 0) {

                /* Access granted */

                LOG_MMU("PTE access granted !\n");

            } else {

                /* Access right violation */

                LOG_MMU("PTE access rejected\n");

            }

        }

    }



    return ret;

}
 and probability:0.19444444444444445
code:static int aio_read_f(int argc, char **argv)

{

    int nr_iov, c;

    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));



    while ((c = getopt(argc, argv, "CP:qv")) != EOF) {

        switch (c) {

        case 'C':

            ctx->Cflag = 1;

            break;

        case 'P':

            ctx->Pflag = 1;

            ctx->pattern = parse_pattern(optarg);

            if (ctx->pattern < 0) {

                free(ctx);

                return 0;

            }

            break;

        case 'q':

            ctx->qflag = 1;

            break;

        case 'v':

            ctx->vflag = 1;

            break;

        default:

            free(ctx);

            return command_usage(&aio_read_cmd);

        }

    }



    if (optind > argc - 2) {

        free(ctx);

        return command_usage(&aio_read_cmd);

    }



    ctx->offset = cvtnum(argv[optind]);

    if (ctx->offset < 0) {

        printf("non-numeric length argument -- %s\n", argv[optind]);

        free(ctx);

        return 0;

    }

    optind++;



    if (ctx->offset & 0x1ff) {

        printf("offset %" PRId64 " is not sector aligned\n",

               ctx->offset);

        free(ctx);

        return 0;

    }



    nr_iov = argc - optind;

    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, 0xab);

    if (ctx->buf == NULL) {

        free(ctx);

        return 0;

    }



    gettimeofday(&ctx->t1, NULL);

    bdrv_aio_readv(bs, ctx->offset >> 9, &ctx->qiov,

                   ctx->qiov.size >> 9, aio_read_done, ctx);

    return 0;

}
 and probability:0.4642857142857143
code:static void scsi_free_request(SCSIRequest *req)

{

    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);



    qemu_vfree(r->iov.iov_base);

}
 and probability:0.2
code:void ff_mjpeg_encode_picture_header(AVCodecContext *avctx, PutBitContext *pb,

                                    ScanTable *intra_scantable,

                                    uint16_t intra_matrix[64])

{

    int chroma_h_shift, chroma_v_shift;

    const int lossless = avctx->codec_id != AV_CODEC_ID_MJPEG;

    int hsample[3], vsample[3];



    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &chroma_h_shift,

                                     &chroma_v_shift);



    if (avctx->codec->id == AV_CODEC_ID_LJPEG &&

        avctx->pix_fmt   == AV_PIX_FMT_BGR24) {

        vsample[0] = hsample[0] =

        vsample[1] = hsample[1] =

        vsample[2] = hsample[2] = 1;

    } else {

        vsample[0] = 2;

        vsample[1] = 2 >> chroma_v_shift;

        vsample[2] = 2 >> chroma_v_shift;

        hsample[0] = 2;

        hsample[1] = 2 >> chroma_h_shift;

        hsample[2] = 2 >> chroma_h_shift;

    }



    put_marker(pb, SOI);



    jpeg_put_comments(avctx, pb);



    jpeg_table_header(pb, intra_scantable, intra_matrix);



    switch (avctx->codec_id) {

    case AV_CODEC_ID_MJPEG:  put_marker(pb, SOF0 ); break;

    case AV_CODEC_ID_LJPEG:  put_marker(pb, SOF3 ); break;

    default: assert(0);

    }



    put_bits(pb, 16, 17);

    if (lossless && avctx->pix_fmt == AV_PIX_FMT_BGR24)

        put_bits(pb, 8, 9); /* 9 bits/component RCT */

    else

        put_bits(pb, 8, 8); /* 8 bits/component */

    put_bits(pb, 16, avctx->height);

    put_bits(pb, 16, avctx->width);

    put_bits(pb, 8, 3); /* 3 components */



    /* Y component */

    put_bits(pb, 8, 1); /* component number */

    put_bits(pb, 4, hsample[0]); /* H factor */

    put_bits(pb, 4, vsample[0]); /* V factor */

    put_bits(pb, 8, 0); /* select matrix */



    /* Cb component */

    put_bits(pb, 8, 2); /* component number */

    put_bits(pb, 4, hsample[1]); /* H factor */

    put_bits(pb, 4, vsample[1]); /* V factor */

    put_bits(pb, 8, 0); /* select matrix */



    /* Cr component */

    put_bits(pb, 8, 3); /* component number */

    put_bits(pb, 4, hsample[2]); /* H factor */

    put_bits(pb, 4, vsample[2]); /* V factor */

    put_bits(pb, 8, 0); /* select matrix */



    /* scan header */

    put_marker(pb, SOS);

    put_bits(pb, 16, 12); /* length */

    put_bits(pb, 8, 3); /* 3 components */



    /* Y component */

    put_bits(pb, 8, 1); /* index */

    put_bits(pb, 4, 0); /* DC huffman table index */

    put_bits(pb, 4, 0); /* AC huffman table index */



    /* Cb component */

    put_bits(pb, 8, 2); /* index */

    put_bits(pb, 4, 1); /* DC huffman table index */

    put_bits(pb, 4, lossless ? 0 : 1); /* AC huffman table index */



    /* Cr component */

    put_bits(pb, 8, 3); /* index */

    put_bits(pb, 4, 1); /* DC huffman table index */

    put_bits(pb, 4, lossless ? 0 : 1); /* AC huffman table index */



    put_bits(pb, 8, lossless ? avctx->prediction_method + 1 : 0); /* Ss (not used) */



    switch (avctx->codec_id) {

    case AV_CODEC_ID_MJPEG:  put_bits(pb, 8, 63); break; /* Se (not used) */

    case AV_CODEC_ID_LJPEG:  put_bits(pb, 8,  0); break; /* not used */

    default: assert(0);

    }



    put_bits(pb, 8, 0); /* Ah/Al (not used) */

}
 and probability:0.3246753246753247
code:int qemu_paio_error(struct qemu_paiocb *aiocb)

{

    ssize_t ret = qemu_paio_return(aiocb);



    if (ret < 0)

        ret = -ret;

    else

        ret = 0;



    return ret;

}
 and probability:0.0
code:static void arm_gic_common_reset(DeviceState *dev)

{

    GICState *s = ARM_GIC_COMMON(dev);

    int i;

    memset(s->irq_state, 0, GIC_MAXIRQ * sizeof(gic_irq_state));

    for (i = 0 ; i < s->num_cpu; i++) {

        if (s->revision == REV_11MPCORE) {

            s->priority_mask[i] = 0xf0;

        } else {

            s->priority_mask[i] = 0;

        }

        s->current_pending[i] = 1023;

        s->running_irq[i] = 1023;

        s->running_priority[i] = 0x100;

        s->cpu_enabled[i] = false;

    }

    for (i = 0; i < GIC_NR_SGIS; i++) {

        GIC_SET_ENABLED(i, ALL_CPU_MASK);

        GIC_SET_EDGE_TRIGGER(i);

    }

    if (s->num_cpu == 1) {

        /* For uniprocessor GICs all interrupts always target the sole CPU */

        for (i = 0; i < GIC_MAXIRQ; i++) {

            s->irq_target[i] = 1;

        }

    }

    s->ctlr = 0;

}
 and probability:0.5
code:static int guess_disk_lchs(BlockDriverState *bs,

                           int *pcylinders, int *pheads, int *psectors)

{

    uint8_t buf[BDRV_SECTOR_SIZE];

    int i, heads, sectors, cylinders;

    struct partition *p;

    uint32_t nr_sects;

    uint64_t nb_sectors;



    bdrv_get_geometry(bs, &nb_sectors);



    /**

     * The function will be invoked during startup not only in sync I/O mode,

     * but also in async I/O mode. So the I/O throttling function has to

     * be disabled temporarily here, not permanently.

     */

    if (bdrv_read_unthrottled(bs, 0, buf, 1) < 0) {

        return -1;

    }

    /* test msdos magic */

    if (buf[510] != 0x55 || buf[511] != 0xaa) {

        return -1;

    }

    for (i = 0; i < 4; i++) {

        p = ((struct partition *)(buf + 0x1be)) + i;

        nr_sects = le32_to_cpu(p->nr_sects);

        if (nr_sects && p->end_head) {

            /* We make the assumption that the partition terminates on

               a cylinder boundary */

            heads = p->end_head + 1;

            sectors = p->end_sector & 63;

            if (sectors == 0) {

                continue;

            }

            cylinders = nb_sectors / (heads * sectors);

            if (cylinders < 1 || cylinders > 16383) {

                continue;

            }

            *pheads = heads;

            *psectors = sectors;

            *pcylinders = cylinders;

            trace_hd_geometry_lchs_guess(bs, cylinders, heads, sectors);

            return 0;

        }

    }

    return -1;

}
 and probability:0.24444444444444444
code:static mode_t v9mode_to_mode(uint32_t mode, V9fsString *extension)

{

    mode_t ret;



    ret = mode & 0777;

    if (mode & P9_STAT_MODE_DIR) {

        ret |= S_IFDIR;

    }



    if (mode & P9_STAT_MODE_SYMLINK) {

        ret |= S_IFLNK;

    }

    if (mode & P9_STAT_MODE_SOCKET) {

        ret |= S_IFSOCK;

    }

    if (mode & P9_STAT_MODE_NAMED_PIPE) {

        ret |= S_IFIFO;

    }

    if (mode & P9_STAT_MODE_DEVICE) {

        if (extension && extension->data[0] == 'c') {

            ret |= S_IFCHR;

        } else {

            ret |= S_IFBLK;

        }

    }



    if (!(ret&~0777)) {

        ret |= S_IFREG;

    }



    if (mode & P9_STAT_MODE_SETUID) {

        ret |= S_ISUID;

    }

    if (mode & P9_STAT_MODE_SETGID) {

        ret |= S_ISGID;

    }

    if (mode & P9_STAT_MODE_SETVTX) {

        ret |= S_ISVTX;

    }



    return ret;

}
 and probability:0.02702702702702703
code:int kvm_cpu_exec(CPUState *cpu)

{

    struct kvm_run *run = cpu->kvm_run;

    int ret, run_ret;



    DPRINTF("kvm_cpu_exec()\n");



    if (kvm_arch_process_async_events(cpu)) {

        cpu->exit_request = 0;

        return EXCP_HLT;

    }



    do {

        MemTxAttrs attrs;



        if (cpu->kvm_vcpu_dirty) {

            kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);

            cpu->kvm_vcpu_dirty = false;

        }



        kvm_arch_pre_run(cpu, run);

        if (cpu->exit_request) {

            DPRINTF("interrupt exit requested\n");

            /*

             * KVM requires us to reenter the kernel after IO exits to complete

             * instruction emulation. This self-signal will ensure that we

             * leave ASAP again.

             */

            qemu_cpu_kick_self();

        }

        qemu_mutex_unlock_iothread();



        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);



        qemu_mutex_lock_iothread();

        attrs = kvm_arch_post_run(cpu, run);



        if (run_ret < 0) {

            if (run_ret == -EINTR || run_ret == -EAGAIN) {

                DPRINTF("io window exit\n");

                ret = EXCP_INTERRUPT;

                break;

            }

            fprintf(stderr, "error: kvm run failed %s\n",

                    strerror(-run_ret));

#ifdef TARGET_PPC

            if (run_ret == -EBUSY) {

                fprintf(stderr,

                        "This is probably because your SMT is enabled.\n"

                        "VCPU can only run on primary threads with all "

                        "secondary threads offline.\n");

            }

#endif

            ret = -1;

            break;

        }



        trace_kvm_run_exit(cpu->cpu_index, run->exit_reason);

        switch (run->exit_reason) {

        case KVM_EXIT_IO:

            DPRINTF("handle_io\n");

            kvm_handle_io(run->io.port, attrs,

                          (uint8_t *)run + run->io.data_offset,

                          run->io.direction,

                          run->io.size,

                          run->io.count);

            ret = 0;

            break;

        case KVM_EXIT_MMIO:

            DPRINTF("handle_mmio\n");

            address_space_rw(&address_space_memory,

                             run->mmio.phys_addr, attrs,

                             run->mmio.data,

                             run->mmio.len,

                             run->mmio.is_write);

            ret = 0;

            break;

        case KVM_EXIT_IRQ_WINDOW_OPEN:

            DPRINTF("irq_window_open\n");

            ret = EXCP_INTERRUPT;

            break;

        case KVM_EXIT_SHUTDOWN:

            DPRINTF("shutdown\n");

            qemu_system_reset_request();

            ret = EXCP_INTERRUPT;

            break;

        case KVM_EXIT_UNKNOWN:

            fprintf(stderr, "KVM: unknown exit, hardware reason %" PRIx64 "\n",

                    (uint64_t)run->hw.hardware_exit_reason);

            ret = -1;

            break;

        case KVM_EXIT_INTERNAL_ERROR:

            ret = kvm_handle_internal_error(cpu, run);

            break;

        case KVM_EXIT_SYSTEM_EVENT:

            switch (run->system_event.type) {

            case KVM_SYSTEM_EVENT_SHUTDOWN:

                qemu_system_shutdown_request();

                ret = EXCP_INTERRUPT;

                break;

            case KVM_SYSTEM_EVENT_RESET:

                qemu_system_reset_request();

                ret = EXCP_INTERRUPT;

                break;

            default:

                DPRINTF("kvm_arch_handle_exit\n");

                ret = kvm_arch_handle_exit(cpu, run);

                break;

            }

            break;

        default:

            DPRINTF("kvm_arch_handle_exit\n");

            ret = kvm_arch_handle_exit(cpu, run);

            break;

        }

    } while (ret == 0);



    if (ret < 0) {

        cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);

        vm_stop(RUN_STATE_INTERNAL_ERROR);

    }



    cpu->exit_request = 0;

    return ret;

}
 and probability:0.16666666666666666
code:void HELPER(crypto_aese)(CPUARMState *env, uint32_t rd, uint32_t rm,

                         uint32_t decrypt)

{

    static uint8_t const sbox[][256] = { {

        /* S-box for encryption */

        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,

        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,

        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,

        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,

        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,

        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,

        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,

        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,

        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,

        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,

        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,

        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,

        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,

        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,

        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,

        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,

        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,

        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,

        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,

        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,

        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,

        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,

        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,

        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,

        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,

        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,

        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,

        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,

        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,

        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,

        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,

        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16

    }, {

        /* S-box for decryption */

        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,

        0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,

        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,

        0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,

        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,

        0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,

        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,

        0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,

        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,

        0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,

        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,

        0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,

        0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,

        0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,

        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,

        0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,

        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,

        0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,

        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,

        0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,

        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,

        0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,

        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,

        0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,

        0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,

        0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,

        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,

        0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,

        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,

        0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,

        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,

        0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d

    } };

    static uint8_t const shift[][16] = {

        /* ShiftRows permutation vector for encryption */

        { 0,  5, 10, 15, 4, 9, 14,  3, 8, 13, 2,  7, 12, 1, 6, 11 },

        /* ShiftRows permutation vector for decryption */

        { 0, 13, 10,  7, 4, 1, 14, 11, 8,  5, 2, 15, 12, 9, 6,  3 },

    };

    union AES_STATE rk = { .l = {

        float64_val(env->vfp.regs[rm]),

        float64_val(env->vfp.regs[rm + 1])

    } };

    union AES_STATE st = { .l = {

        float64_val(env->vfp.regs[rd]),

        float64_val(env->vfp.regs[rd + 1])

    } };

    int i;



    assert(decrypt < 2);



    /* xor state vector with round key */

    rk.l[0] ^= st.l[0];

    rk.l[1] ^= st.l[1];



    /* combine ShiftRows operation and sbox substitution */

    for (i = 0; i < 16; i++) {

        st.bytes[i] = sbox[decrypt][rk.bytes[shift[decrypt][i]]];

    }



    env->vfp.regs[rd] = make_float64(st.l[0]);

    env->vfp.regs[rd + 1] = make_float64(st.l[1]);

}
 and probability:0.10204081632653061
code:Visitor *string_output_get_visitor(StringOutputVisitor *sov)

{

    return &sov->visitor;

}
 and probability:0.25
code:static void spr_write_tbl (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbl(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
 and probability:0.09090909090909091
code:static int mig_save_device_dirty(QEMUFile *f, BlkMigDevState *bmds,

                                 int is_async)

{

    BlkMigBlock *blk;

    BlockDriverState *bs = blk_bs(bmds->blk);

    int64_t total_sectors = bmds->total_sectors;

    int64_t sector;

    int nr_sectors;

    int ret = -EIO;



    for (sector = bmds->cur_dirty; sector < bmds->total_sectors;) {

        blk_mig_lock();

        if (bmds_aio_inflight(bmds, sector)) {

            blk_mig_unlock();

            blk_drain(bmds->blk);

        } else {

            blk_mig_unlock();

        }

        if (bdrv_get_dirty(bs, bmds->dirty_bitmap, sector)) {



            if (total_sectors - sector < BDRV_SECTORS_PER_DIRTY_CHUNK) {

                nr_sectors = total_sectors - sector;

            } else {

                nr_sectors = BDRV_SECTORS_PER_DIRTY_CHUNK;

            }

            bdrv_reset_dirty_bitmap(bmds->dirty_bitmap, sector, nr_sectors);



            blk = g_new(BlkMigBlock, 1);

            blk->buf = g_malloc(BLOCK_SIZE);

            blk->bmds = bmds;

            blk->sector = sector;

            blk->nr_sectors = nr_sectors;



            if (is_async) {

                blk->iov.iov_base = blk->buf;

                blk->iov.iov_len = nr_sectors * BDRV_SECTOR_SIZE;

                qemu_iovec_init_external(&blk->qiov, &blk->iov, 1);



                blk->aiocb = blk_aio_preadv(bmds->blk,

                                            sector * BDRV_SECTOR_SIZE,

                                            &blk->qiov, 0, blk_mig_read_cb,

                                            blk);



                blk_mig_lock();

                block_mig_state.submitted++;

                bmds_set_aio_inflight(bmds, sector, nr_sectors, 1);

                blk_mig_unlock();

            } else {

                ret = blk_pread(bmds->blk, sector * BDRV_SECTOR_SIZE, blk->buf,

                                nr_sectors * BDRV_SECTOR_SIZE);

                if (ret < 0) {

                    goto error;

                }

                blk_send(f, blk);



                g_free(blk->buf);

                g_free(blk);

            }



            sector += nr_sectors;

            bmds->cur_dirty = sector;



            break;

        }

        sector += BDRV_SECTORS_PER_DIRTY_CHUNK;

        bmds->cur_dirty = sector;

    }



    return (bmds->cur_dirty >= bmds->total_sectors);



error:

    DPRINTF("Error reading sector %" PRId64 "\n", sector);

    g_free(blk->buf);

    g_free(blk);

    return ret;

}
 and probability:0.4307692307692308
code:static int kvm_get_xcrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    int i, ret;

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs()) {

        return 0;

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_XCRS, &xcrs);

    if (ret < 0) {

        return ret;

    }



    for (i = 0; i < xcrs.nr_xcrs; i++) {

        /* Only support xcr0 now */

        if (xcrs.xcrs[i].xcr == 0) {

            env->xcr0 = xcrs.xcrs[i].value;

            break;

        }

    }

    return 0;

}
 and probability:0.19047619047619047
code:uint64_t timer_expire_time_ns(QEMUTimer *ts)

{

    return timer_pending(ts) ? ts->expire_time : -1;

}
 and probability:0.25
code:static int default_fdset_dup_fd_add(int64_t fdset_id, int dup_fd)

{

    return -1;

}
 and probability:0.0
code:static void gen_mfc0 (CPUState *env, DisasContext *ctx, int reg, int sel)

{

    const char *rn = "invalid";



    if (sel != 0)

        check_insn(env, ctx, ISA_MIPS32);



    switch (reg) {

    case 0:

        switch (sel) {

        case 0:

            gen_op_mfc0_index();

            rn = "Index";

            break;

        case 1:

            check_mips_mt(env, ctx);

            gen_op_mfc0_mvpcontrol();

            rn = "MVPControl";

            break;

        case 2:

            check_mips_mt(env, ctx);

            gen_op_mfc0_mvpconf0();

            rn = "MVPConf0";

            break;

        case 3:

            check_mips_mt(env, ctx);

            gen_op_mfc0_mvpconf1();

            rn = "MVPConf1";

            break;

        default:

            goto die;

        }

        break;

    case 1:

        switch (sel) {

        case 0:

            gen_op_mfc0_random();

            rn = "Random";

            break;

        case 1:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpecontrol();

            rn = "VPEControl";

            break;

        case 2:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpeconf0();

            rn = "VPEConf0";

            break;

        case 3:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpeconf1();

            rn = "VPEConf1";

            break;

        case 4:

            check_mips_mt(env, ctx);

            gen_op_mfc0_yqmask();

            rn = "YQMask";

            break;

        case 5:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpeschedule();

            rn = "VPESchedule";

            break;

        case 6:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpeschefback();

            rn = "VPEScheFBack";

            break;

        case 7:

            check_mips_mt(env, ctx);

            gen_op_mfc0_vpeopt();

            rn = "VPEOpt";

            break;

        default:

            goto die;

        }

        break;

    case 2:

        switch (sel) {

        case 0:

            gen_op_mfc0_entrylo0();

            rn = "EntryLo0";

            break;

        case 1:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tcstatus();

            rn = "TCStatus";

            break;

        case 2:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tcbind();

            rn = "TCBind";

            break;

        case 3:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tcrestart();

            rn = "TCRestart";

            break;

        case 4:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tchalt();

            rn = "TCHalt";

            break;

        case 5:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tccontext();

            rn = "TCContext";

            break;

        case 6:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tcschedule();

            rn = "TCSchedule";

            break;

        case 7:

            check_mips_mt(env, ctx);

            gen_op_mfc0_tcschefback();

            rn = "TCScheFBack";

            break;

        default:

            goto die;

        }

        break;

    case 3:

        switch (sel) {

        case 0:

            gen_op_mfc0_entrylo1();

            rn = "EntryLo1";

            break;

        default:

            goto die;

        }

        break;

    case 4:

        switch (sel) {

        case 0:

            gen_op_mfc0_context();

            rn = "Context";

            break;

        case 1:

//            gen_op_mfc0_contextconfig(); /* SmartMIPS ASE */

            rn = "ContextConfig";

//            break;

        default:

            goto die;

        }

        break;

    case 5:

        switch (sel) {

        case 0:

            gen_op_mfc0_pagemask();

            rn = "PageMask";

            break;

        case 1:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_pagegrain();

            rn = "PageGrain";

            break;

        default:

            goto die;

        }

        break;

    case 6:

        switch (sel) {

        case 0:

            gen_op_mfc0_wired();

            rn = "Wired";

            break;

        case 1:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsconf0();

            rn = "SRSConf0";

            break;

        case 2:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsconf1();

            rn = "SRSConf1";

            break;

        case 3:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsconf2();

            rn = "SRSConf2";

            break;

        case 4:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsconf3();

            rn = "SRSConf3";

            break;

        case 5:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsconf4();

            rn = "SRSConf4";

            break;

        default:

            goto die;

        }

        break;

    case 7:

        switch (sel) {

        case 0:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_hwrena();

            rn = "HWREna";

            break;

        default:

            goto die;

        }

        break;

    case 8:

        switch (sel) {

        case 0:

            gen_op_mfc0_badvaddr();

            rn = "BadVaddr";

            break;

        default:

            goto die;

       }

        break;

    case 9:

        switch (sel) {

        case 0:

            gen_op_mfc0_count();

            rn = "Count";

            break;

        /* 6,7 are implementation dependent */

        default:

            goto die;

        }

        break;

    case 10:

        switch (sel) {

        case 0:

            gen_op_mfc0_entryhi();

            rn = "EntryHi";

            break;

        default:

            goto die;

        }

        break;

    case 11:

        switch (sel) {

        case 0:

            gen_op_mfc0_compare();

            rn = "Compare";

            break;

        /* 6,7 are implementation dependent */

        default:

            goto die;

        }

        break;

    case 12:

        switch (sel) {

        case 0:

            gen_op_mfc0_status();

            rn = "Status";

            break;

        case 1:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_intctl();

            rn = "IntCtl";

            break;

        case 2:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsctl();

            rn = "SRSCtl";

            break;

        case 3:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_srsmap();

            rn = "SRSMap";

            break;

        default:

            goto die;

       }

        break;

    case 13:

        switch (sel) {

        case 0:

            gen_op_mfc0_cause();

            rn = "Cause";

            break;

        default:

            goto die;

       }

        break;

    case 14:

        switch (sel) {

        case 0:

            gen_op_mfc0_epc();

            rn = "EPC";

            break;

        default:

            goto die;

        }

        break;

    case 15:

        switch (sel) {

        case 0:

            gen_op_mfc0_prid();

            rn = "PRid";

            break;

        case 1:

            check_insn(env, ctx, ISA_MIPS32R2);

            gen_op_mfc0_ebase();

            rn = "EBase";

            break;

        default:

            goto die;

       }

        break;

    case 16:

        switch (sel) {

        case 0:

            gen_op_mfc0_config0();

            rn = "Config";

            break;

        case 1:

            gen_op_mfc0_config1();

            rn = "Config1";

            break;

        case 2:

            gen_op_mfc0_config2();

            rn = "Config2";

            break;

        case 3:

            gen_op_mfc0_config3();

            rn = "Config3";

            break;

        /* 4,5 are reserved */

        /* 6,7 are implementation dependent */

        case 6:

            gen_op_mfc0_config6();

            rn = "Config6";

            break;

        case 7:

            gen_op_mfc0_config7();

            rn = "Config7";

            break;

        default:

            goto die;

        }

        break;

    case 17:

        switch (sel) {

        case 0:

            gen_op_mfc0_lladdr();

            rn = "LLAddr";

            break;

        default:

            goto die;

        }

        break;

    case 18:

        switch (sel) {

        case 0 ... 7:

            gen_op_mfc0_watchlo(sel);

            rn = "WatchLo";

            break;

        default:

            goto die;

        }

        break;

    case 19:

        switch (sel) {

        case 0 ...7:

            gen_op_mfc0_watchhi(sel);

            rn = "WatchHi";

            break;

        default:

            goto die;

        }

        break;

    case 20:

        switch (sel) {

        case 0:

#if defined(TARGET_MIPSN32) || defined(TARGET_MIPS64)

            check_insn(env, ctx, ISA_MIPS3);

            gen_op_mfc0_xcontext();

            rn = "XContext";

            break;

#endif

        default:

            goto die;

        }

        break;

    case 21:

       /* Officially reserved, but sel 0 is used for R1x000 framemask */

        switch (sel) {

        case 0:

            gen_op_mfc0_framemask();

            rn = "Framemask";

            break;

        default:

            goto die;

        }

        break;

    case 22:

        /* ignored */

        rn = "'Diagnostic"; /* implementation dependent */

        break;

    case 23:

        switch (sel) {

        case 0:

            gen_op_mfc0_debug(); /* EJTAG support */

            rn = "Debug";

            break;

        case 1:

//            gen_op_mfc0_tracecontrol(); /* PDtrace support */

            rn = "TraceControl";

//            break;

        case 2:

//            gen_op_mfc0_tracecontrol2(); /* PDtrace support */

            rn = "TraceControl2";

//            break;

        case 3:

//            gen_op_mfc0_usertracedata(); /* PDtrace support */

            rn = "UserTraceData";

//            break;

        case 4:

//            gen_op_mfc0_debug(); /* PDtrace support */

            rn = "TraceBPC";

//            break;

        default:

            goto die;

        }

        break;

    case 24:

        switch (sel) {

        case 0:

            gen_op_mfc0_depc(); /* EJTAG support */

            rn = "DEPC";

            break;

        default:

            goto die;

        }

        break;

    case 25:

        switch (sel) {

        case 0:

            gen_op_mfc0_performance0();

            rn = "Performance0";

            break;

        case 1:

//            gen_op_mfc0_performance1();

            rn = "Performance1";

//            break;

        case 2:

//            gen_op_mfc0_performance2();

            rn = "Performance2";

//            break;

        case 3:

//            gen_op_mfc0_performance3();

            rn = "Performance3";

//            break;

        case 4:

//            gen_op_mfc0_performance4();

            rn = "Performance4";

//            break;

        case 5:

//            gen_op_mfc0_performance5();

            rn = "Performance5";

//            break;

        case 6:

//            gen_op_mfc0_performance6();

            rn = "Performance6";

//            break;

        case 7:

//            gen_op_mfc0_performance7();

            rn = "Performance7";

//            break;

        default:

            goto die;

        }

        break;

    case 26:

       rn = "ECC";

       break;

    case 27:

        switch (sel) {

        /* ignored */

        case 0 ... 3:

            rn = "CacheErr";

            break;

        default:

            goto die;

        }

        break;

    case 28:

        switch (sel) {

        case 0:

        case 2:

        case 4:

        case 6:

            gen_op_mfc0_taglo();

            rn = "TagLo";

            break;

        case 1:

        case 3:

        case 5:

        case 7:

            gen_op_mfc0_datalo();

            rn = "DataLo";

            break;

        default:

            goto die;

        }

        break;

    case 29:

        switch (sel) {

        case 0:

        case 2:

        case 4:

        case 6:

            gen_op_mfc0_taghi();

            rn = "TagHi";

            break;

        case 1:

        case 3:

        case 5:

        case 7:

            gen_op_mfc0_datahi();

            rn = "DataHi";

            break;

        default:

            goto die;

        }

        break;

    case 30:

        switch (sel) {

        case 0:

            gen_op_mfc0_errorepc();

            rn = "ErrorEPC";

            break;

        default:

            goto die;

        }

        break;

    case 31:

        switch (sel) {

        case 0:

            gen_op_mfc0_desave(); /* EJTAG support */

            rn = "DESAVE";

            break;

        default:

            goto die;

        }

        break;

    default:

       goto die;

    }

#if defined MIPS_DEBUG_DISAS

    if (loglevel & CPU_LOG_TB_IN_ASM) {

        fprintf(logfile, "mfc0 %s (reg %d sel %d)\n",

                rn, reg, sel);

    }

#endif

    return;



die:

#if defined MIPS_DEBUG_DISAS

    if (loglevel & CPU_LOG_TB_IN_ASM) {

        fprintf(logfile, "mfc0 %s (reg %d sel %d)\n",

                rn, reg, sel);

    }

#endif

    generate_exception(ctx, EXCP_RI);

}
 and probability:0.0
code:intptr_t (*checkasm_check_func(intptr_t (*func)(), const char *name, ...))()

{

    char name_buf[256];

    intptr_t (*ref)() = func;

    CheckasmFuncVersion *v;

    int name_length;

    va_list arg;



    va_start(arg, name);

    name_length = vsnprintf(name_buf, sizeof(name_buf), name, arg);

    va_end(arg);



    if (!func || name_length <= 0 || name_length >= sizeof(name_buf))

        return NULL;



    state.current_func = get_func(name_buf, name_length);

    v = &state.current_func->versions;



    if (v->func) {

        CheckasmFuncVersion *prev;

        do {

            /* Only test functions that haven't already been tested */

            if (v->func == func)

                return NULL;



            if (v->ok)

                ref = v->func;



            prev = v;

        } while ((v = v->next));



        v = prev->next = checkasm_malloc(sizeof(CheckasmFuncVersion));

    }



    v->func = func;

    v->ok = 1;

    v->cpu = state.cpu_flag;

    state.current_func_ver = v;



    if (state.cpu_flag)

        state.num_checked++;



    return ref;

}
 and probability:0.3235294117647059
code:static hwaddr vfio_container_granularity(VFIOContainer *container)

{

    return (hwaddr)1 << ctz64(container->iova_pgsizes);

}
 and probability:0.25
code:void apic_init_reset(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    int i;



    if (!s) {

        return;

    }

    s->tpr = 0;

    s->spurious_vec = 0xff;

    s->log_dest = 0;

    s->dest_mode = 0xf;

    memset(s->isr, 0, sizeof(s->isr));

    memset(s->tmr, 0, sizeof(s->tmr));

    memset(s->irr, 0, sizeof(s->irr));

    for (i = 0; i < APIC_LVT_NB; i++) {

        s->lvt[i] = APIC_LVT_MASKED;

    }

    s->esr = 0;

    memset(s->icr, 0, sizeof(s->icr));

    s->divide_conf = 0;

    s->count_shift = 0;

    s->initial_count = 0;

    s->initial_count_load_time = 0;

    s->next_time = 0;

    s->wait_for_sipi = !cpu_is_bsp(s->cpu);



    if (s->timer) {

        timer_del(s->timer);

    }

    s->timer_expiry = -1;



    if (info->reset) {

        info->reset(s);

    }

}
 and probability:0.6470588235294118
code:static void gen_msa(CPUMIPSState *env, DisasContext *ctx)

{

    uint32_t opcode = ctx->opcode;

    check_insn(ctx, ASE_MSA);

    check_msa_access(ctx);



    switch (MASK_MSA_MINOR(opcode)) {

    case OPC_MSA_I8_00:

    case OPC_MSA_I8_01:

    case OPC_MSA_I8_02:

        gen_msa_i8(env, ctx);

        break;

    case OPC_MSA_I5_06:

    case OPC_MSA_I5_07:

        gen_msa_i5(env, ctx);

        break;

    case OPC_MSA_BIT_09:

    case OPC_MSA_BIT_0A:

        gen_msa_bit(env, ctx);

        break;

    case OPC_MSA_3R_0D:

    case OPC_MSA_3R_0E:

    case OPC_MSA_3R_0F:

    case OPC_MSA_3R_10:

    case OPC_MSA_3R_11:

    case OPC_MSA_3R_12:

    case OPC_MSA_3R_13:

    case OPC_MSA_3R_14:

    case OPC_MSA_3R_15:

        gen_msa_3r(env, ctx);

        break;

    case OPC_MSA_ELM:

        gen_msa_elm(env, ctx);

        break;

    case OPC_MSA_3RF_1A:

    case OPC_MSA_3RF_1B:

    case OPC_MSA_3RF_1C:

        gen_msa_3rf(env, ctx);

        break;

    case OPC_MSA_VEC:

        gen_msa_vec(env, ctx);

        break;

    case OPC_LD_B:

    case OPC_LD_H:

    case OPC_LD_W:

    case OPC_LD_D:

    case OPC_ST_B:

    case OPC_ST_H:

    case OPC_ST_W:

    case OPC_ST_D:

        {

            int32_t s10 = sextract32(ctx->opcode, 16, 10);

            uint8_t rs = (ctx->opcode >> 11) & 0x1f;

            uint8_t wd = (ctx->opcode >> 6) & 0x1f;

            uint8_t df = (ctx->opcode >> 0) & 0x3;



            TCGv_i32 tdf = tcg_const_i32(df);

            TCGv_i32 twd = tcg_const_i32(wd);

            TCGv_i32 trs = tcg_const_i32(rs);

            TCGv_i32 ts10 = tcg_const_i32(s10);



            switch (MASK_MSA_MINOR(opcode)) {

            case OPC_LD_B:

            case OPC_LD_H:

            case OPC_LD_W:

            case OPC_LD_D:

                save_cpu_state(ctx, 1);

                gen_helper_msa_ld_df(cpu_env, tdf, twd, trs, ts10);

                break;

            case OPC_ST_B:

            case OPC_ST_H:

            case OPC_ST_W:

            case OPC_ST_D:

                save_cpu_state(ctx, 1);

                gen_helper_msa_st_df(cpu_env, tdf, twd, trs, ts10);

                break;

            }



            tcg_temp_free_i32(twd);

            tcg_temp_free_i32(tdf);

            tcg_temp_free_i32(trs);

            tcg_temp_free_i32(ts10);

        }

        break;

    default:

        MIPS_INVAL("MSA instruction");

        generate_exception(ctx, EXCP_RI);

        break;

    }



}
 and probability:0.05813953488372093
code:int bdrv_snapshot_load_tmp(BlockDriverState *bs,

        const char *snapshot_name)

{

    BlockDriver *drv = bs->drv;

    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!bs->read_only) {

        return -EINVAL;

    }

    if (drv->bdrv_snapshot_load_tmp) {

        return drv->bdrv_snapshot_load_tmp(bs, snapshot_name);

    }

    return -ENOTSUP;

}
 and probability:0.26666666666666666
code:static void io_watch_poll_finalize(GSource *source)

{

    IOWatchPoll *iwp = io_watch_poll_from_source(source);

    g_source_destroy(iwp->src);

    g_source_unref(iwp->src);

    iwp->src = NULL;

}
 and probability:0.42857142857142855
code:static void omap_pin_cfg_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                struct omap_mpu_state_s *mpu)

{

    memory_region_init_io(&mpu->pin_cfg_iomem, &omap_pin_cfg_ops, mpu,

                          "omap-pin-cfg", 0x800);

    memory_region_add_subregion(system_memory, base, &mpu->pin_cfg_iomem);

    omap_pin_cfg_reset(mpu);

}
 and probability:0.2222222222222222
code:void cpu_x86_inject_mce(CPUState *cenv, int bank, uint64_t status,

                        uint64_t mcg_status, uint64_t addr, uint64_t misc,

                        int broadcast)

{

    unsigned bank_num = cenv->mcg_cap & 0xff;

    CPUState *env;

    int flag = 0;



    if (bank >= bank_num || !(status & MCI_STATUS_VAL)) {

        return;

    }



    if (broadcast) {

        if (!cpu_x86_support_mca_broadcast(cenv)) {

            fprintf(stderr, "Current CPU does not support broadcast\n");

            return;

        }

    }



    if (kvm_enabled()) {

        if (broadcast) {

            flag |= MCE_BROADCAST;

        }



        kvm_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc, flag);

    } else {

        qemu_inject_x86_mce(cenv, bank, status, mcg_status, addr, misc);

        if (broadcast) {

            for (env = first_cpu; env != NULL; env = env->next_cpu) {

                if (cenv == env) {

                    continue;

                }

                qemu_inject_x86_mce(env, 1, MCI_STATUS_VAL | MCI_STATUS_UC,

                                    MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0);

            }

        }

    }

}
 and probability:0.058823529411764705
code:static void psy_3gpp_analyze(FFPsyContext *ctx, int channel,

                             const float *coefs, const FFPsyWindowInfo *wi)

{

    AacPsyContext *pctx = (AacPsyContext*) ctx->model_priv_data;

    AacPsyChannel *pch  = &pctx->ch[channel];

    int start = 0;

    int i, w, g;

    const int num_bands       = ctx->num_bands[wi->num_windows == 8];

    const uint8_t* band_sizes = ctx->bands[wi->num_windows == 8];

    AacPsyCoeffs *coeffs     = &pctx->psy_coef[wi->num_windows == 8];



    //calculate energies, initial thresholds and related values - 5.4.2 "Threshold Calculation"

    for (w = 0; w < wi->num_windows*16; w += 16) {

        for (g = 0; g < num_bands; g++) {

            AacPsyBand *band = &pch->band[w+g];

            band->energy = 0.0f;

            for (i = 0; i < band_sizes[g]; i++)

                band->energy += coefs[start+i] * coefs[start+i];

            band->thr     = band->energy * 0.001258925f;

            start        += band_sizes[g];



            ctx->psy_bands[channel*PSY_MAX_BANDS+w+g].energy = band->energy;

        }

    }

    //modify thresholds - spread, threshold in quiet - 5.4.3 "Spreaded Energy Calculation"

    for (w = 0; w < wi->num_windows*16; w += 16) {

        AacPsyBand *band = &pch->band[w];

        for (g = 1; g < num_bands; g++)

            band[g].thr = FFMAX(band[g].thr, band[g-1].thr * coeffs->spread_hi [g]);

        for (g = num_bands - 2; g >= 0; g--)

            band[g].thr = FFMAX(band[g].thr, band[g+1].thr * coeffs->spread_low[g]);

        for (g = 0; g < num_bands; g++) {

            band[g].thr_quiet = band[g].thr = FFMAX(band[g].thr, coeffs->ath[g]);

            if (!(wi->window_type[0] == LONG_STOP_SEQUENCE || (wi->window_type[1] == LONG_START_SEQUENCE && !w)))

                band[g].thr = FFMAX(PSY_3GPP_RPEMIN*band[g].thr, FFMIN(band[g].thr,

                                    PSY_3GPP_RPELEV*pch->prev_band[w+g].thr_quiet));



            ctx->psy_bands[channel*PSY_MAX_BANDS+w+g].threshold = band[g].thr;

        }

    }

    memcpy(pch->prev_band, pch->band, sizeof(pch->band));

}
 and probability:0.6923076923076923
code:static void dbdma_writel (void *opaque,

                          target_phys_addr_t addr, uint32_t value)

{

    int channel = addr >> DBDMA_CHANNEL_SHIFT;

    DBDMA_channel *ch = (DBDMA_channel *)opaque + channel;

    int reg = (addr - (channel << DBDMA_CHANNEL_SHIFT)) >> 2;



    DBDMA_DPRINTF("writel 0x" TARGET_FMT_plx " <= 0x%08x\n", addr, value);

    DBDMA_DPRINTF("channel 0x%x reg 0x%x\n",

                  (uint32_t)addr >> DBDMA_CHANNEL_SHIFT, reg);



    /* cmdptr cannot be modified if channel is RUN or ACTIVE */



    if (reg == DBDMA_CMDPTR_LO &&

        (ch->regs[DBDMA_STATUS] & cpu_to_be32(RUN | ACTIVE)))

	return;



    ch->regs[reg] = value;



    switch(reg) {

    case DBDMA_CONTROL:

        dbdma_control_write(ch);

        break;

    case DBDMA_CMDPTR_LO:

        /* 16-byte aligned */

        ch->regs[DBDMA_CMDPTR_LO] &= cpu_to_be32(~0xf);

        dbdma_cmdptr_load(ch);

        break;

    case DBDMA_STATUS:

    case DBDMA_INTR_SEL:

    case DBDMA_BRANCH_SEL:

    case DBDMA_WAIT_SEL:

        /* nothing to do */

        break;

    case DBDMA_XFER_MODE:

    case DBDMA_CMDPTR_HI:

    case DBDMA_DATA2PTR_HI:

    case DBDMA_DATA2PTR_LO:

    case DBDMA_ADDRESS_HI:

    case DBDMA_BRANCH_ADDR_HI:

    case DBDMA_RES1:

    case DBDMA_RES2:

    case DBDMA_RES3:

    case DBDMA_RES4:

        /* unused */

        break;

    }

}
 and probability:0.11627906976744186
code:static uint64_t omap_os_timer_read(void *opaque, target_phys_addr_t addr,

                                   unsigned size)

{

    struct omap_32khz_timer_s *s = (struct omap_32khz_timer_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 4) {

        return omap_badwidth_read32(opaque, addr);

    }



    switch (offset) {

    case 0x00:	/* TVR */

        return s->timer.reset_val;



    case 0x04:	/* TCR */

        return omap_timer_read(&s->timer);



    case 0x08:	/* CR */

        return (s->timer.ar << 3) | (s->timer.it_ena << 2) | s->timer.st;



    default:

        break;

    }

    OMAP_BAD_REG(addr);

    return 0;

}
 and probability:0.14285714285714285
code:static uint64_t ahci_mem_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    AHCIState *s = opaque;

    uint32_t val = 0;



    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {

        switch (addr) {

        case HOST_CAP:

            val = s->control_regs.cap;

            break;

        case HOST_CTL:

            val = s->control_regs.ghc;

            break;

        case HOST_IRQ_STAT:

            val = s->control_regs.irqstatus;

            break;

        case HOST_PORTS_IMPL:

            val = s->control_regs.impl;

            break;

        case HOST_VERSION:

            val = s->control_regs.version;

            break;

        }



        DPRINTF(-1, "(addr 0x%08X), val 0x%08X\n", (unsigned) addr, val);

    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&

               (addr < (AHCI_PORT_REGS_START_ADDR +

                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {

        val = ahci_port_read(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,

                             addr & AHCI_PORT_ADDR_OFFSET_MASK);

    }



    return val;

}
 and probability:0.25
code:static inline uint16_t get_hwc_color(SM501State *state, int crt, int index)

{

    uint32_t color_reg = 0;

    uint16_t color_565 = 0;



    if (index == 0) {

        return 0;

    }



    switch (index) {

    case 1:

    case 2:

        color_reg = crt ? state->dc_crt_hwc_color_1_2

                        : state->dc_panel_hwc_color_1_2;

        break;

    case 3:

        color_reg = crt ? state->dc_crt_hwc_color_3

                        : state->dc_panel_hwc_color_3;

        break;

    default:

        printf("invalid hw cursor color.\n");

        abort();

    }



    switch (index) {

    case 1:

    case 3:

        color_565 = (uint16_t)(color_reg & 0xFFFF);

        break;

    case 2:

        color_565 = (uint16_t)((color_reg >> 16) & 0xFFFF);

        break;

    }

    return color_565;

}
 and probability:0.125
code:mlt_compensate_output(COOKContext *q, float *decode_buffer,

                      cook_gains *gains, float *previous_buffer,

                      int16_t *out, int chan)

{

    int j;



    cook_imlt(q, decode_buffer, q->mono_mdct_output);

    gain_compensate(q, gains, previous_buffer);



    /* Clip and convert floats to 16 bits.

     */

    for (j = 0; j < q->samples_per_channel; j++) {

        out[chan + q->nb_channels * j] =

          av_clip(lrintf(q->mono_mdct_output[j]), -32768, 32767);

    }

}
 and probability:0.5
code:int main(int argc, char **argv){

    int in_sample_rate, out_sample_rate, ch ,i, flush_count;

    uint64_t in_ch_layout, out_ch_layout;

    enum AVSampleFormat in_sample_fmt, out_sample_fmt;

    uint8_t array_in[SAMPLES*8*8];

    uint8_t array_mid[SAMPLES*8*8*3];

    uint8_t array_out[SAMPLES*8*8+100];

    uint8_t *ain[SWR_CH_MAX];

    uint8_t *aout[SWR_CH_MAX];

    uint8_t *amid[SWR_CH_MAX];

    int flush_i=0;

    int mode;

    int num_tests = 10000;

    uint32_t seed = 0;

    uint32_t rand_seed = 0;

    int remaining_tests[FF_ARRAY_ELEMS(rates) * FF_ARRAY_ELEMS(layouts) * FF_ARRAY_ELEMS(formats) * FF_ARRAY_ELEMS(layouts) * FF_ARRAY_ELEMS(formats)];

    int max_tests = FF_ARRAY_ELEMS(remaining_tests);

    int test;

    int specific_test= -1;



    struct SwrContext * forw_ctx= NULL;

    struct SwrContext *backw_ctx= NULL;



    if (argc > 1) {

        if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {

            av_log(NULL, AV_LOG_INFO, "Usage: swresample-test [<num_tests>[ <test>]]  \n"

                   "num_tests           Default is %d\n", num_tests);

            return 0;

        }

        num_tests = strtol(argv[1], NULL, 0);

        if(num_tests < 0) {

            num_tests = -num_tests;

            rand_seed = time(0);

        }

        if(num_tests<= 0 || num_tests>max_tests)

            num_tests = max_tests;

        if(argc > 2) {

            specific_test = strtol(argv[1], NULL, 0);

        }

    }



    for(i=0; i<max_tests; i++)

        remaining_tests[i] = i;



    for(test=0; test<num_tests; test++){

        unsigned r;

        uint_rand(seed);

        r = (seed * (uint64_t)(max_tests - test)) >>32;

        FFSWAP(int, remaining_tests[r], remaining_tests[max_tests - test - 1]);

    }

    qsort(remaining_tests + max_tests - num_tests, num_tests, sizeof(remaining_tests[0]), (void*)cmp);

    in_sample_rate=16000;

    for(test=0; test<num_tests; test++){

        char  in_layout_string[256];

        char out_layout_string[256];

        unsigned vector= remaining_tests[max_tests - test - 1];

        int in_ch_count;

        int out_count, mid_count, out_ch_count;



        in_ch_layout    = layouts[vector % FF_ARRAY_ELEMS(layouts)]; vector /= FF_ARRAY_ELEMS(layouts);

        out_ch_layout   = layouts[vector % FF_ARRAY_ELEMS(layouts)]; vector /= FF_ARRAY_ELEMS(layouts);

        in_sample_fmt   = formats[vector % FF_ARRAY_ELEMS(formats)]; vector /= FF_ARRAY_ELEMS(formats);

        out_sample_fmt  = formats[vector % FF_ARRAY_ELEMS(formats)]; vector /= FF_ARRAY_ELEMS(formats);

        out_sample_rate = rates  [vector % FF_ARRAY_ELEMS(rates  )]; vector /= FF_ARRAY_ELEMS(rates);

        av_assert0(!vector);



        if(specific_test == 0){

            if(out_sample_rate != in_sample_rate || in_ch_layout != out_ch_layout)

                continue;

        }



        in_ch_count= av_get_channel_layout_nb_channels(in_ch_layout);

        out_ch_count= av_get_channel_layout_nb_channels(out_ch_layout);

        av_get_channel_layout_string( in_layout_string, sizeof( in_layout_string),  in_ch_count,  in_ch_layout);

        av_get_channel_layout_string(out_layout_string, sizeof(out_layout_string), out_ch_count, out_ch_layout);

        fprintf(stderr, "TEST: %s->%s, rate:%5d->%5d, fmt:%s->%s\n",

                in_layout_string, out_layout_string,

                in_sample_rate, out_sample_rate,

                av_get_sample_fmt_name(in_sample_fmt), av_get_sample_fmt_name(out_sample_fmt));

        forw_ctx  = swr_alloc_set_opts(forw_ctx, out_ch_layout, out_sample_fmt,  out_sample_rate,

                                                    in_ch_layout,  in_sample_fmt,  in_sample_rate,

                                        0, 0);

        backw_ctx = swr_alloc_set_opts(backw_ctx, in_ch_layout,  in_sample_fmt,             in_sample_rate,

                                                    out_ch_layout, out_sample_fmt, out_sample_rate,

                                        0, 0);

        if(swr_init( forw_ctx) < 0)

            fprintf(stderr, "swr_init(->) failed\n");

        if(swr_init(backw_ctx) < 0)

            fprintf(stderr, "swr_init(<-) failed\n");

        if(!forw_ctx)

            fprintf(stderr, "Failed to init forw_cts\n");

        if(!backw_ctx)

            fprintf(stderr, "Failed to init backw_ctx\n");

                //FIXME test planar

        setup_array(ain , array_in ,  in_sample_fmt,   SAMPLES);

        setup_array(amid, array_mid, out_sample_fmt, 3*SAMPLES);

        setup_array(aout, array_out,  in_sample_fmt           ,   SAMPLES);

#if 0

        for(ch=0; ch<in_ch_count; ch++){

            for(i=0; i<SAMPLES; i++)

                set(ain, ch, i, in_ch_count, in_sample_fmt, sin(i*i*3/SAMPLES));

        }

#else

        audiogen(ain, in_sample_fmt, in_ch_count, SAMPLES/6+1, SAMPLES);

#endif

        mode = uint_rand(rand_seed) % 3;

        if(mode==0 /*|| out_sample_rate == in_sample_rate*/) {

            mid_count= swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain, SAMPLES);

        } else if(mode==1){

            mid_count= swr_convert(forw_ctx, amid,         0, (const uint8_t **)ain, SAMPLES);

            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);

        } else {

            int tmp_count;

            mid_count= swr_convert(forw_ctx, amid,         0, (const uint8_t **)ain,       1);

            av_assert0(mid_count==0);

            shift(ain,  1, in_ch_count, in_sample_fmt);

            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);

            shift(amid,  mid_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;

            mid_count+=swr_convert(forw_ctx, amid,         2, (const uint8_t **)ain,       2);

            shift(amid,  mid_count-tmp_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;

            shift(ain,  2, in_ch_count, in_sample_fmt);

            mid_count+=swr_convert(forw_ctx, amid,         1, (const uint8_t **)ain, SAMPLES-3);

            shift(amid,  mid_count-tmp_count, out_ch_count, out_sample_fmt); tmp_count = mid_count;

            shift(ain, -3, in_ch_count, in_sample_fmt);

            mid_count+=swr_convert(forw_ctx, amid, 3*SAMPLES, (const uint8_t **)ain,       0);

            shift(amid,  -tmp_count, out_ch_count, out_sample_fmt);

        }

        out_count= swr_convert(backw_ctx,aout, SAMPLES, (const uint8_t **)amid, mid_count);



        for(ch=0; ch<in_ch_count; ch++){

            double sse, maxdiff=0;

            double sum_a= 0;

            double sum_b= 0;

            double sum_aa= 0;

            double sum_bb= 0;

            double sum_ab= 0;

            for(i=0; i<out_count; i++){

                double a= get(ain , ch, i, in_ch_count, in_sample_fmt);

                double b= get(aout, ch, i, in_ch_count, in_sample_fmt);

                sum_a += a;

                sum_b += b;

                sum_aa+= a*a;

                sum_bb+= b*b;

                sum_ab+= a*b;

                maxdiff= FFMAX(maxdiff, FFABS(a-b));

            }

            sse= sum_aa + sum_bb - 2*sum_ab;

            if(sse < 0 && sse > -0.00001) sse=0; //fix rounding error



            fprintf(stderr, "[e:%f c:%f max:%f] len:%5d\n", sqrt(sse/out_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, out_count);

        }



        flush_i++;

        flush_i%=21;

        flush_count = swr_convert(backw_ctx,aout, flush_i, 0, 0);

        shift(aout,  flush_i, in_ch_count, in_sample_fmt);

        flush_count+= swr_convert(backw_ctx,aout, SAMPLES-flush_i, 0, 0);

        shift(aout, -flush_i, in_ch_count, in_sample_fmt);

        if(flush_count){

            for(ch=0; ch<in_ch_count; ch++){

                double sse, maxdiff=0;

                double sum_a= 0;

                double sum_b= 0;

                double sum_aa= 0;

                double sum_bb= 0;

                double sum_ab= 0;

                for(i=0; i<flush_count; i++){

                    double a= get(ain , ch, i+out_count, in_ch_count, in_sample_fmt);

                    double b= get(aout, ch, i, in_ch_count, in_sample_fmt);

                    sum_a += a;

                    sum_b += b;

                    sum_aa+= a*a;

                    sum_bb+= b*b;

                    sum_ab+= a*b;

                    maxdiff= FFMAX(maxdiff, FFABS(a-b));

                }

                sse= sum_aa + sum_bb - 2*sum_ab;

                if(sse < 0 && sse > -0.00001) sse=0; //fix rounding error



                fprintf(stderr, "[e:%f c:%f max:%f] len:%5d F:%3d\n", sqrt(sse/flush_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, flush_count, flush_i);

            }

        }





        fprintf(stderr, "\n");

    }



    return 0;

}
 and probability:0.3314285714285714
code:void MPV_decode_mb_internal(MpegEncContext *s, DCTELEM block[12][64],

                            int is_mpeg12)

{

    const int mb_xy = s->mb_y * s->mb_stride + s->mb_x;

    if(CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration){

        ff_xvmc_decode_mb(s);//xvmc uses pblocks

        return;

    }



    if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {

       /* save DCT coefficients */

       int i,j;

       DCTELEM *dct = &s->current_picture.f.dct_coeff[mb_xy * 64 * 6];

       av_log(s->avctx, AV_LOG_DEBUG, "DCT coeffs of MB at %dx%d:\n", s->mb_x, s->mb_y);

       for(i=0; i<6; i++){

           for(j=0; j<64; j++){

               *dct++ = block[i][s->dsp.idct_permutation[j]];

               av_log(s->avctx, AV_LOG_DEBUG, "%5d", dct[-1]);

           }

           av_log(s->avctx, AV_LOG_DEBUG, "\n");

       }

    }



    s->current_picture.f.qscale_table[mb_xy] = s->qscale;



    /* update DC predictors for P macroblocks */

    if (!s->mb_intra) {

        if (!is_mpeg12 && (s->h263_pred || s->h263_aic)) {

            if(s->mbintra_table[mb_xy])

                ff_clean_intra_table_entries(s);

        } else {

            s->last_dc[0] =

            s->last_dc[1] =

            s->last_dc[2] = 128 << s->intra_dc_precision;

        }

    }

    else if (!is_mpeg12 && (s->h263_pred || s->h263_aic))

        s->mbintra_table[mb_xy]=1;



    if ((s->flags&CODEC_FLAG_PSNR) || !(s->encoding && (s->intra_only || s->pict_type==AV_PICTURE_TYPE_B) && s->avctx->mb_decision != FF_MB_DECISION_RD)) { //FIXME precalc

        uint8_t *dest_y, *dest_cb, *dest_cr;

        int dct_linesize, dct_offset;

        op_pixels_func (*op_pix)[4];

        qpel_mc_func (*op_qpix)[16];

        const int linesize   = s->current_picture.f.linesize[0]; //not s->linesize as this would be wrong for field pics

        const int uvlinesize = s->current_picture.f.linesize[1];

        const int readable= s->pict_type != AV_PICTURE_TYPE_B || s->encoding || s->avctx->draw_horiz_band;

        const int block_size = 8;



        /* avoid copy if macroblock skipped in last frame too */

        /* skip only during decoding as we might trash the buffers during encoding a bit */

        if(!s->encoding){

            uint8_t *mbskip_ptr = &s->mbskip_table[mb_xy];



            if (s->mb_skipped) {

                s->mb_skipped= 0;

                assert(s->pict_type!=AV_PICTURE_TYPE_I);

                *mbskip_ptr = 1;

            } else if(!s->current_picture.f.reference) {

                *mbskip_ptr = 1;

            } else{

                *mbskip_ptr = 0; /* not skipped */

            }

        }



        dct_linesize = linesize << s->interlaced_dct;

        dct_offset   = s->interlaced_dct ? linesize : linesize * block_size;



        if(readable){

            dest_y=  s->dest[0];

            dest_cb= s->dest[1];

            dest_cr= s->dest[2];

        }else{

            dest_y = s->b_scratchpad;

            dest_cb= s->b_scratchpad+16*linesize;

            dest_cr= s->b_scratchpad+32*linesize;

        }



        if (!s->mb_intra) {

            /* motion handling */

            /* decoding or more than one mb_type (MC was already done otherwise) */

            if(!s->encoding){



                if(HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_FRAME) {

                    if (s->mv_dir & MV_DIR_FORWARD) {

                        ff_thread_await_progress(&s->last_picture_ptr->f,

                                                 ff_MPV_lowest_referenced_row(s, 0),

                                                 0);

                    }

                    if (s->mv_dir & MV_DIR_BACKWARD) {

                        ff_thread_await_progress(&s->next_picture_ptr->f,

                                                 ff_MPV_lowest_referenced_row(s, 1),

                                                 0);

                    }

                }



                op_qpix= s->me.qpel_put;

                if ((!s->no_rounding) || s->pict_type==AV_PICTURE_TYPE_B){

                    op_pix = s->dsp.put_pixels_tab;

                }else{

                    op_pix = s->dsp.put_no_rnd_pixels_tab;

                }

                if (s->mv_dir & MV_DIR_FORWARD) {

                    MPV_motion(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f.data, op_pix, op_qpix);

                    op_pix = s->dsp.avg_pixels_tab;

                    op_qpix= s->me.qpel_avg;

                }

                if (s->mv_dir & MV_DIR_BACKWARD) {

                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture.f.data, op_pix, op_qpix);

                }

            }



            /* skip dequant / idct if we are really late ;) */

            if(s->avctx->skip_idct){

                if(  (s->avctx->skip_idct >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)

                   ||(s->avctx->skip_idct >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)

                   || s->avctx->skip_idct >= AVDISCARD_ALL)

                    goto skip_idct;

            }



            /* add dct residue */

            if(s->encoding || !(   s->msmpeg4_version || s->codec_id==CODEC_ID_MPEG1VIDEO || s->codec_id==CODEC_ID_MPEG2VIDEO

                                || (s->codec_id==CODEC_ID_MPEG4 && !s->mpeg_quant))){

                add_dequant_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);

                add_dequant_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);

                add_dequant_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);

                add_dequant_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);



                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){

                    if (s->chroma_y_shift){

                        add_dequant_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);

                        add_dequant_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);

                    }else{

                        dct_linesize >>= 1;

                        dct_offset >>=1;

                        add_dequant_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);

                        add_dequant_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);

                    }

                }

            } else if(is_mpeg12 || (s->codec_id != CODEC_ID_WMV2)){

                add_dct(s, block[0], 0, dest_y                          , dct_linesize);

                add_dct(s, block[1], 1, dest_y              + block_size, dct_linesize);

                add_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize);

                add_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize);



                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){

                    if(s->chroma_y_shift){//Chroma420

                        add_dct(s, block[4], 4, dest_cb, uvlinesize);

                        add_dct(s, block[5], 5, dest_cr, uvlinesize);

                    }else{

                        //chroma422

                        dct_linesize = uvlinesize << s->interlaced_dct;

                        dct_offset   = s->interlaced_dct ? uvlinesize : uvlinesize*block_size;



                        add_dct(s, block[4], 4, dest_cb, dct_linesize);

                        add_dct(s, block[5], 5, dest_cr, dct_linesize);

                        add_dct(s, block[6], 6, dest_cb+dct_offset, dct_linesize);

                        add_dct(s, block[7], 7, dest_cr+dct_offset, dct_linesize);

                        if(!s->chroma_x_shift){//Chroma444

                            add_dct(s, block[8], 8, dest_cb+block_size, dct_linesize);

                            add_dct(s, block[9], 9, dest_cr+block_size, dct_linesize);

                            add_dct(s, block[10], 10, dest_cb+block_size+dct_offset, dct_linesize);

                            add_dct(s, block[11], 11, dest_cr+block_size+dct_offset, dct_linesize);

                        }

                    }

                }//fi gray

            }

            else if (CONFIG_WMV2_DECODER || CONFIG_WMV2_ENCODER) {

                ff_wmv2_add_mb(s, block, dest_y, dest_cb, dest_cr);

            }

        } else {

            /* dct only in intra block */

            if(s->encoding || !(s->codec_id==CODEC_ID_MPEG1VIDEO || s->codec_id==CODEC_ID_MPEG2VIDEO)){

                put_dct(s, block[0], 0, dest_y                          , dct_linesize, s->qscale);

                put_dct(s, block[1], 1, dest_y              + block_size, dct_linesize, s->qscale);

                put_dct(s, block[2], 2, dest_y + dct_offset             , dct_linesize, s->qscale);

                put_dct(s, block[3], 3, dest_y + dct_offset + block_size, dct_linesize, s->qscale);



                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){

                    if(s->chroma_y_shift){

                        put_dct(s, block[4], 4, dest_cb, uvlinesize, s->chroma_qscale);

                        put_dct(s, block[5], 5, dest_cr, uvlinesize, s->chroma_qscale);

                    }else{

                        dct_offset >>=1;

                        dct_linesize >>=1;

                        put_dct(s, block[4], 4, dest_cb,              dct_linesize, s->chroma_qscale);

                        put_dct(s, block[5], 5, dest_cr,              dct_linesize, s->chroma_qscale);

                        put_dct(s, block[6], 6, dest_cb + dct_offset, dct_linesize, s->chroma_qscale);

                        put_dct(s, block[7], 7, dest_cr + dct_offset, dct_linesize, s->chroma_qscale);

                    }

                }

            }else{

                s->dsp.idct_put(dest_y                          , dct_linesize, block[0]);

                s->dsp.idct_put(dest_y              + block_size, dct_linesize, block[1]);

                s->dsp.idct_put(dest_y + dct_offset             , dct_linesize, block[2]);

                s->dsp.idct_put(dest_y + dct_offset + block_size, dct_linesize, block[3]);



                if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){

                    if(s->chroma_y_shift){

                        s->dsp.idct_put(dest_cb, uvlinesize, block[4]);

                        s->dsp.idct_put(dest_cr, uvlinesize, block[5]);

                    }else{



                        dct_linesize = uvlinesize << s->interlaced_dct;

                        dct_offset   = s->interlaced_dct? uvlinesize : uvlinesize*block_size;



                        s->dsp.idct_put(dest_cb,              dct_linesize, block[4]);

                        s->dsp.idct_put(dest_cr,              dct_linesize, block[5]);

                        s->dsp.idct_put(dest_cb + dct_offset, dct_linesize, block[6]);

                        s->dsp.idct_put(dest_cr + dct_offset, dct_linesize, block[7]);

                        if(!s->chroma_x_shift){//Chroma444

                            s->dsp.idct_put(dest_cb + block_size,              dct_linesize, block[8]);

                            s->dsp.idct_put(dest_cr + block_size,              dct_linesize, block[9]);

                            s->dsp.idct_put(dest_cb + block_size + dct_offset, dct_linesize, block[10]);

                            s->dsp.idct_put(dest_cr + block_size + dct_offset, dct_linesize, block[11]);

                        }

                    }

                }//gray

            }

        }

skip_idct:

        if(!readable){

            s->dsp.put_pixels_tab[0][0](s->dest[0], dest_y ,   linesize,16);

            s->dsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[1], dest_cb, uvlinesize,16 >> s->chroma_y_shift);

            s->dsp.put_pixels_tab[s->chroma_x_shift][0](s->dest[2], dest_cr, uvlinesize,16 >> s->chroma_y_shift);

        }

    }

}
 and probability:0.6285714285714286
code:int ff_h264_decode_ref_pic_marking(H264Context *h, GetBitContext *gb,

                                   int first_slice)

{

    int i, ret;

    MMCO mmco_temp[MAX_MMCO_COUNT], *mmco = mmco_temp;

    int mmco_index = 0;



    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields

        skip_bits1(gb); // broken_link

        if (get_bits1(gb)) {

            mmco[0].opcode   = MMCO_LONG;

            mmco[0].long_arg = 0;

            mmco_index       = 1;

        }

    } else {

        if (get_bits1(gb)) { // adaptive_ref_pic_marking_mode_flag

            for (i = 0; i < MAX_MMCO_COUNT; i++) {

                MMCOOpcode opcode = get_ue_golomb_31(gb);



                mmco[i].opcode = opcode;

                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {

                    mmco[i].short_pic_num =

                        (h->curr_pic_num - get_ue_golomb(gb) - 1) &

                            (h->max_pic_num - 1);

#if 0

                    if (mmco[i].short_pic_num >= h->short_ref_count ||

                        !h->short_ref[mmco[i].short_pic_num]) {

                        av_log(s->avctx, AV_LOG_ERROR,

                               "illegal short ref in memory management control "

                               "operation %d\n", mmco);

                        return -1;

                    }

#endif

                }

                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||

                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {

                    unsigned int long_arg = get_ue_golomb_31(gb);

                    if (long_arg >= 32 ||

                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&

                                             long_arg == 16) &&

                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               "illegal long ref in memory management control "

                               "operation %d\n", opcode);

                        return -1;

                    }

                    mmco[i].long_arg = long_arg;

                }



                if (opcode > (unsigned) MMCO_LONG) {

                    av_log(h->avctx, AV_LOG_ERROR,

                           "illegal memory management control operation %d\n",

                           opcode);

                    return -1;

                }

                if (opcode == MMCO_END)

                    break;

            }

            mmco_index = i;

        } else {

            if (first_slice) {

                ret = ff_generate_sliding_window_mmcos(h, first_slice);

                if (ret < 0 && h->avctx->err_recognition & AV_EF_EXPLODE)

                    return ret;

            }

            mmco_index = -1;

        }

    }



    if (first_slice && mmco_index != -1) {

        memcpy(h->mmco, mmco_temp, sizeof(h->mmco));

        h->mmco_index = mmco_index;

    } else if (!first_slice && mmco_index >= 0 &&

               (mmco_index != h->mmco_index ||

                check_opcodes(h->mmco, mmco_temp, mmco_index))) {

        av_log(h->avctx, AV_LOG_ERROR,

               "Inconsistent MMCO state between slices [%d, %d]\n",

               mmco_index, h->mmco_index);

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
 and probability:0.2692307692307692
code:static int init_input_stream(int ist_index, char *error, int error_len)

{

    int i;

    InputStream *ist = input_streams[ist_index];

    if (ist->decoding_needed) {

        AVCodec *codec = ist->dec;

        if (!codec) {

            snprintf(error, error_len, "Decoder (codec id %d) not found for input stream #%d:%d",

                    ist->st->codec->codec_id, ist->file_index, ist->st->index);

            return AVERROR(EINVAL);

        }



        /* update requested sample format for the decoder based on the

           corresponding encoder sample format */

        for (i = 0; i < nb_output_streams; i++) {

            OutputStream *ost = output_streams[i];

            if (ost->source_index == ist_index) {

                update_sample_fmt(ist->st->codec, codec, ost->st->codec);

                break;

            }

        }



        if (codec->type == AVMEDIA_TYPE_VIDEO && codec->capabilities & CODEC_CAP_DR1) {

            ist->st->codec->get_buffer     = codec_get_buffer;

            ist->st->codec->release_buffer = codec_release_buffer;

            ist->st->codec->opaque         = &ist->buffer_pool;

        }



        if (!av_dict_get(ist->opts, "threads", NULL, 0))

            av_dict_set(&ist->opts, "threads", "auto", 0);

        if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {

            snprintf(error, error_len, "Error while opening decoder for input stream #%d:%d",

                    ist->file_index, ist->st->index);

            return AVERROR(EINVAL);

        }

        assert_codec_experimental(ist->st->codec, 0);

        assert_avoptions(ist->opts);

    }



    ist->last_dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;

    ist->next_dts = AV_NOPTS_VALUE;

    init_pts_correction(&ist->pts_ctx);

    ist->is_start = 1;



    return 0;

}
 and probability:0.5365853658536586
code:build_tpm_tcpa(GArray *table_data, BIOSLinker *linker, GArray *tcpalog)

{

    Acpi20Tcpa *tcpa = acpi_data_push(table_data, sizeof *tcpa);



    tcpa->platform_class = cpu_to_le16(TPM_TCPA_ACPI_CLASS_CLIENT);

    tcpa->log_area_minimum_length = cpu_to_le32(TPM_LOG_AREA_MINIMUM_SIZE);

    acpi_data_push(tcpalog, le32_to_cpu(tcpa->log_area_minimum_length));



    bios_linker_loader_alloc(linker, ACPI_BUILD_TPMLOG_FILE, tcpalog, 1,

                             false /* high memory */);



    /* log area start address to be filled by Guest linker */

    bios_linker_loader_add_pointer(linker, ACPI_BUILD_TABLE_FILE,

                                   ACPI_BUILD_TPMLOG_FILE,

                                   &tcpa->log_area_start_address,

                                   sizeof(tcpa->log_area_start_address));



    build_header(linker, table_data,

                 (void *)tcpa, "TCPA", sizeof(*tcpa), 2, NULL, NULL);

}
 and probability:0.5
code:static CharDriverState *qemu_chr_open_udp_fd(int fd)

{

    CharDriverState *chr = NULL;

    NetCharDriver *s = NULL;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(NetCharDriver));



    s->fd = fd;

    s->chan = io_channel_from_socket(s->fd);

    s->bufcnt = 0;

    s->bufptr = 0;

    chr->opaque = s;

    chr->chr_write = udp_chr_write;

    chr->chr_update_read_handler = udp_chr_update_read_handler;

    chr->chr_close = udp_chr_close;

    /* be isn't opened until we get a connection */

    chr->explicit_be_open = true;

    return chr;

}
 and probability:0.5
code:static int get_pix_fmt_score(enum AVPixelFormat dst_pix_fmt,

                              enum AVPixelFormat src_pix_fmt,

                              unsigned *lossp, unsigned consider)

{

    const AVPixFmtDescriptor *src_desc = av_pix_fmt_desc_get(src_pix_fmt);

    const AVPixFmtDescriptor *dst_desc = av_pix_fmt_desc_get(dst_pix_fmt);

    int src_color, dst_color;

    int src_min_depth, src_max_depth, dst_min_depth, dst_max_depth;

    int ret, loss, i, nb_components;

    int score = INT_MAX - 1;



    if (dst_pix_fmt >= AV_PIX_FMT_NB || dst_pix_fmt <= AV_PIX_FMT_NONE)

        return ~0;



    /* compute loss */

    *lossp = loss = 0;



    if (dst_pix_fmt == src_pix_fmt)

        return INT_MAX;



    if ((ret = get_pix_fmt_depth(&src_min_depth, &src_max_depth, src_pix_fmt)) < 0)

        return ret;

    if ((ret = get_pix_fmt_depth(&dst_min_depth, &dst_max_depth, dst_pix_fmt)) < 0)

        return ret;



    src_color = get_color_type(src_desc);

    dst_color = get_color_type(dst_desc);

    if (dst_pix_fmt == AV_PIX_FMT_PAL8)

        nb_components = FFMIN(src_desc->nb_components, 4);

    else

        nb_components = FFMIN(src_desc->nb_components, dst_desc->nb_components);



    for (i = 0; i < nb_components; i++) {

        int depth_minus1 = (dst_pix_fmt == AV_PIX_FMT_PAL8) ? 7/nb_components : (dst_desc->comp[i].depth - 1);

        if (src_desc->comp[i].depth - 1 > depth_minus1 && (consider & FF_LOSS_DEPTH)) {

            loss |= FF_LOSS_DEPTH;

            score -= 65536 >> depth_minus1;

        }

    }



    if (consider & FF_LOSS_RESOLUTION) {

        if (dst_desc->log2_chroma_w > src_desc->log2_chroma_w) {

            loss |= FF_LOSS_RESOLUTION;

            score -= 256 << dst_desc->log2_chroma_w;

        }

        if (dst_desc->log2_chroma_h > src_desc->log2_chroma_h) {

            loss |= FF_LOSS_RESOLUTION;

            score -= 256 << dst_desc->log2_chroma_h;

        }

        // don't favor 422 over 420 if downsampling is needed, because 420 has much better support on the decoder side

        if (dst_desc->log2_chroma_w == 1 && src_desc->log2_chroma_w == 0 &&

            dst_desc->log2_chroma_h == 1 && src_desc->log2_chroma_h == 0 ) {

            score += 512;

        }

    }



    if(consider & FF_LOSS_COLORSPACE)

    switch(dst_color) {

    case FF_COLOR_RGB:

        if (src_color != FF_COLOR_RGB &&

            src_color != FF_COLOR_GRAY)

            loss |= FF_LOSS_COLORSPACE;

        break;

    case FF_COLOR_GRAY:

        if (src_color != FF_COLOR_GRAY)

            loss |= FF_LOSS_COLORSPACE;

        break;

    case FF_COLOR_YUV:

        if (src_color != FF_COLOR_YUV)

            loss |= FF_LOSS_COLORSPACE;

        break;

    case FF_COLOR_YUV_JPEG:

        if (src_color != FF_COLOR_YUV_JPEG &&

            src_color != FF_COLOR_YUV &&

            src_color != FF_COLOR_GRAY)

            loss |= FF_LOSS_COLORSPACE;

        break;

    default:

        /* fail safe test */

        if (src_color != dst_color)

            loss |= FF_LOSS_COLORSPACE;

        break;

    }

    if(loss & FF_LOSS_COLORSPACE)

        score -= (nb_components * 65536) >> FFMIN(dst_desc->comp[0].depth - 1, src_desc->comp[0].depth - 1);



    if (dst_color == FF_COLOR_GRAY &&

        src_color != FF_COLOR_GRAY && (consider & FF_LOSS_CHROMA)) {

        loss |= FF_LOSS_CHROMA;

        score -= 2 * 65536;

    }

    if (!pixdesc_has_alpha(dst_desc) && (pixdesc_has_alpha(src_desc) && (consider & FF_LOSS_ALPHA))) {

        loss |= FF_LOSS_ALPHA;

        score -= 65536;

    }

    if (dst_pix_fmt == AV_PIX_FMT_PAL8 && (consider & FF_LOSS_COLORQUANT) &&

        (src_pix_fmt != AV_PIX_FMT_PAL8 && (src_color != FF_COLOR_GRAY || (pixdesc_has_alpha(src_desc) && (consider & FF_LOSS_ALPHA))))) {

        loss |= FF_LOSS_COLORQUANT;

        score -= 65536;

    }



    *lossp = loss;

    return score;

}
 and probability:0.2127659574468085
code:static void pc_init1(ram_addr_t ram_size,

                     const char *boot_device,

                     const char *kernel_filename, const char *kernel_cmdline,

                     const char *initrd_filename,

                     int pci_enabled, const char *cpu_model)

{

    char *filename;

    int ret, linux_boot, i;

    ram_addr_t ram_addr, bios_offset, option_rom_offset;

    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;

    int bios_size, isa_bios_size, oprom_area_size;

    PCIBus *pci_bus;

    int piix3_devfn = -1;

    CPUState *env;

    qemu_irq *cpu_irq;

    qemu_irq *i8259;

    int index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    int using_vga = cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled;



    if (ram_size >= 0xe0000000 ) {

        above_4g_mem_size = ram_size - 0xe0000000;

        below_4g_mem_size = 0xe0000000;

    } else {

        below_4g_mem_size = ram_size;

    }



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL) {

#ifdef TARGET_X86_64

        cpu_model = "qemu64";

#else

        cpu_model = "qemu32";

#endif

    }

    

    for(i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, "Unable to find x86 CPU definition\n");

            exit(1);

        }

        if ((env->cpuid_features & CPUID_APIC) || smp_cpus > 1) {

            env->cpuid_apic_id = env->cpu_index;

            apic_init(env);

        }

        qemu_register_reset(main_cpu_reset, 0, env);

    }



    vmport_init();



    /* allocate RAM */

    ram_addr = qemu_ram_alloc(0xa0000);

    cpu_register_physical_memory(0, 0xa0000, ram_addr);



    /* Allocate, even though we won't register, so we don't break the

     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),

     * and some bios areas, which will be registered later

     */

    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);

    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);

    cpu_register_physical_memory(0x100000,

                 below_4g_mem_size - 0x100000,

                 ram_addr);



    /* above 4giga memory allocation */

    if (above_4g_mem_size > 0) {

#if TARGET_PHYS_ADDR_BITS == 32

        hw_error("To much RAM for 32-bit physical address");

#else

        ram_addr = qemu_ram_alloc(above_4g_mem_size);

        cpu_register_physical_memory(0x100000000ULL,

                                     above_4g_mem_size,

                                     ram_addr);

#endif

    }





    /* BIOS load */

    if (bios_name == NULL)

        bios_name = BIOS_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (filename) {

        bios_size = get_image_size(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size <= 0 ||

        (bios_size % 65536) != 0) {

        goto bios_error;

    }

    bios_offset = qemu_ram_alloc(bios_size);

    ret = load_image(filename, qemu_get_ram_ptr(bios_offset));

    if (ret != bios_size) {

    bios_error:

        fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", bios_name);

        exit(1);

    }

    if (filename) {

        qemu_free(filename);

    }

    /* map the last 128KB of the BIOS in ISA space */

    isa_bios_size = bios_size;

    if (isa_bios_size > (128 * 1024))

        isa_bios_size = 128 * 1024;

    cpu_register_physical_memory(0x100000 - isa_bios_size,

                                 isa_bios_size,

                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);







    option_rom_offset = qemu_ram_alloc(0x20000);

    oprom_area_size = 0;

    cpu_register_physical_memory(0xc0000, 0x20000, option_rom_offset);



    if (using_vga) {

        const char *vgabios_filename;

        /* VGA BIOS load */

        if (cirrus_vga_enabled) {

            vgabios_filename = VGABIOS_CIRRUS_FILENAME;

        } else {

            vgabios_filename = VGABIOS_FILENAME;

        }

        oprom_area_size = load_option_rom(vgabios_filename, 0xc0000, 0xe0000);

    }

    /* Although video roms can grow larger than 0x8000, the area between

     * 0xc0000 - 0xc8000 is reserved for them. It means we won't be looking

     * for any other kind of option rom inside this area */

    if (oprom_area_size < 0x8000)

        oprom_area_size = 0x8000;



    if (linux_boot) {

        load_linux(0xc0000 + oprom_area_size,

                   kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);

        oprom_area_size += 2048;

    }



    for (i = 0; i < nb_option_roms; i++) {

        oprom_area_size += load_option_rom(option_rom[i],

                                           0xc0000 + oprom_area_size, 0xe0000);

    }



    /* map all the bios at the top of memory */

    cpu_register_physical_memory((uint32_t)(-bios_size),

                                 bios_size, bios_offset | IO_MEM_ROM);



    bochs_bios_init();



    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);

    i8259 = i8259_init(cpu_irq[0]);

    ferr_irq = i8259[13];



    if (pci_enabled) {

        pci_bus = i440fx_init(&i440fx_state, i8259);

        piix3_devfn = piix3_init(pci_bus, -1);

    } else {

        pci_bus = NULL;

    }



    /* init basic PC hardware */

    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);



    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);



    if (cirrus_vga_enabled) {

        if (pci_enabled) {

            pci_cirrus_vga_init(pci_bus);

        } else {

            isa_cirrus_vga_init();

        }

    } else if (vmsvga_enabled) {

        if (pci_enabled)

            pci_vmsvga_init(pci_bus);

        else

            fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);

    } else if (std_vga_enabled) {

        if (pci_enabled) {

            pci_vga_init(pci_bus, 0, 0);

        } else {

            isa_vga_init();

        }

    }



    rtc_state = rtc_init(0x70, i8259[8], 2000);



    qemu_register_boot_set(pc_boot_set, rtc_state);



    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);

    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);



    if (pci_enabled) {

        ioapic = ioapic_init();

    }

    pit = pit_init(0x40, i8259[0]);

    pcspk_init(pit);

    if (!no_hpet) {

        hpet_init(i8259);

    }

    if (pci_enabled) {

        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);

    }



    for(i = 0; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,

                        serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(parallel_io[i], i8259[parallel_irq[i]],

                          parallel_hds[i]);

        }

    }



    watchdog_pc_init(pci_bus);



    for(i = 0; i < nb_nics; i++) {

        NICInfo *nd = &nd_table[i];



        if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))

            pc_init_ne2k_isa(nd, i8259);

        else

            pci_nic_init(pci_bus, nd, -1, "ne2k_pci");

    }



    qemu_system_hot_add_init();



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, "qemu: too many IDE bus\n");

        exit(1);

    }



    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

	if (index != -1)

	    hd[i] = drives_table[index].bdrv;

	else

	    hd[i] = NULL;

    }



    if (pci_enabled) {

        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);

    } else {

        for(i = 0; i < MAX_IDE_BUS; i++) {

            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],

	                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);

        }

    }



    i8042_init(i8259[1], i8259[12], 0x60);

    DMA_init(0);

#ifdef HAS_AUDIO

    audio_init(pci_enabled ? pci_bus : NULL, i8259);

#endif



    for(i = 0; i < MAX_FD; i++) {

        index = drive_get_index(IF_FLOPPY, 0, i);

	if (index != -1)

	    fd[i] = drives_table[index].bdrv;

	else

	    fd[i] = NULL;

    }

    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);



    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);



    if (pci_enabled && usb_enabled) {

        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);

    }



    if (pci_enabled && acpi_enabled) {

        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */

        i2c_bus *smbus;



        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);

        for (i = 0; i < 8; i++) {

            DeviceState *eeprom;

            eeprom = qdev_create((BusState *)smbus, "smbus-eeprom");

            qdev_set_prop_int(eeprom, "address", 0x50 + i);

            qdev_set_prop_ptr(eeprom, "data", eeprom_buf + (i * 256));

            qdev_init(eeprom);

        }

    }



    if (i440fx_state) {

        i440fx_init_memory_mappings(i440fx_state);

    }



    if (pci_enabled) {

	int max_bus;

        int bus;



        max_bus = drive_get_max_bus(IF_SCSI);

	for (bus = 0; bus <= max_bus; bus++) {

            pci_create_simple(pci_bus, -1, "lsi53c895a");

        }

    }



    /* Add virtio block devices */

    if (pci_enabled) {

        int index;

        int unit_id = 0;



        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {

            pci_create_simple(pci_bus, -1, "virtio-blk-pci");

            unit_id++;

        }

    }



    /* Add virtio balloon device */

    if (pci_enabled && !no_virtio_balloon) {

        pci_create_simple(pci_bus, -1, "virtio-balloon-pci");

    }



    /* Add virtio console devices */

    if (pci_enabled) {

        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {

            if (virtcon_hds[i]) {

                pci_create_simple(pci_bus, -1, "virtio-console-pci");

            }

        }

    }

}
 and probability:0.2
code:static ssize_t v9fs_synth_lgetxattr(FsContext *ctx, V9fsPath *path,

                                    const char *name, void *value, size_t size)

{

    errno = ENOTSUP;

    return -1;

}
 and probability:0.0
code:static void aw_emac_cleanup(NetClientState *nc)

{

    AwEmacState *s = qemu_get_nic_opaque(nc);



    s->nic = NULL;

}
 and probability:0.2
code:static void virtio_net_set_features(VirtIODevice *vdev, uint32_t features)

{

    VirtIONet *n = VIRTIO_NET(vdev);

    int i;



    virtio_net_set_multiqueue(n, !!(features & (1 << VIRTIO_NET_F_MQ)),

                              !!(features & (1 << VIRTIO_NET_F_CTRL_VQ)));



    virtio_net_set_mrg_rx_bufs(n, !!(features & (1 << VIRTIO_NET_F_MRG_RXBUF)));



    if (n->has_vnet_hdr) {

        tap_set_offload(qemu_get_subqueue(n->nic, 0)->peer,

                        (features >> VIRTIO_NET_F_GUEST_CSUM) & 1,

                        (features >> VIRTIO_NET_F_GUEST_TSO4) & 1,

                        (features >> VIRTIO_NET_F_GUEST_TSO6) & 1,

                        (features >> VIRTIO_NET_F_GUEST_ECN)  & 1,

                        (features >> VIRTIO_NET_F_GUEST_UFO)  & 1);

    }



    for (i = 0;  i < n->max_queues; i++) {

        NetClientState *nc = qemu_get_subqueue(n->nic, i);



        if (!nc->peer || nc->peer->info->type != NET_CLIENT_OPTIONS_KIND_TAP) {

            continue;

        }

        if (!tap_get_vhost_net(nc->peer)) {

            continue;

        }

        vhost_net_ack_features(tap_get_vhost_net(nc->peer), features);

    }

}
 and probability:0.2692307692307692
code:void qemu_del_nic(NICState *nic)

{

    int i, queues = nic->conf->queues;



    /* If this is a peer NIC and peer has already been deleted, free it now. */

    if (nic->peer_deleted) {

        for (i = 0; i < queues; i++) {

            qemu_free_net_client(qemu_get_subqueue(nic, i)->peer);

        }

    }



    for (i = queues - 1; i >= 0; i--) {

        NetClientState *nc = qemu_get_subqueue(nic, i);



        qemu_cleanup_net_client(nc);

        qemu_free_net_client(nc);

    }

}
 and probability:0.3333333333333333
code:static int vfio_initfn(PCIDevice *pdev)

{

    VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);

    VFIODevice *vbasedev_iter;

    VFIOGroup *group;

    char path[PATH_MAX], iommu_group_path[PATH_MAX], *group_name;

    ssize_t len;

    struct stat st;

    int groupid;

    int ret;



    /* Check that the host device exists */

    snprintf(path, sizeof(path),

             "/sys/bus/pci/devices/%04x:%02x:%02x.%01x/",

             vdev->host.domain, vdev->host.bus, vdev->host.slot,

             vdev->host.function);

    if (stat(path, &st) < 0) {

        error_report("vfio: error: no such host device: %s", path);

        return -errno;

    }



    vdev->vbasedev.ops = &vfio_pci_ops;



    vdev->vbasedev.type = VFIO_DEVICE_TYPE_PCI;

    vdev->vbasedev.name = g_strdup_printf("%04x:%02x:%02x.%01x",

                                          vdev->host.domain, vdev->host.bus,

                                          vdev->host.slot, vdev->host.function);



    strncat(path, "iommu_group", sizeof(path) - strlen(path) - 1);



    len = readlink(path, iommu_group_path, sizeof(path));

    if (len <= 0 || len >= sizeof(path)) {

        error_report("vfio: error no iommu_group for device");

        return len < 0 ? -errno : -ENAMETOOLONG;

    }



    iommu_group_path[len] = 0;

    group_name = basename(iommu_group_path);



    if (sscanf(group_name, "%d", &groupid) != 1) {

        error_report("vfio: error reading %s: %m", path);

        return -errno;

    }



    trace_vfio_initfn(vdev->vbasedev.name, groupid);



    group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev));

    if (!group) {

        error_report("vfio: failed to get group %d", groupid);

        return -ENOENT;

    }



    snprintf(path, sizeof(path), "%04x:%02x:%02x.%01x",

            vdev->host.domain, vdev->host.bus, vdev->host.slot,

            vdev->host.function);



    QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {

        if (strcmp(vbasedev_iter->name, vdev->vbasedev.name) == 0) {

            error_report("vfio: error: device %s is already attached", path);

            vfio_put_group(group);

            return -EBUSY;

        }

    }



    ret = vfio_get_device(group, path, &vdev->vbasedev);

    if (ret) {

        error_report("vfio: failed to get device %s", path);

        vfio_put_group(group);

        return ret;

    }



    ret = vfio_populate_device(vdev);

    if (ret) {

        return ret;

    }



    /* Get a copy of config space */

    ret = pread(vdev->vbasedev.fd, vdev->pdev.config,

                MIN(pci_config_size(&vdev->pdev), vdev->config_size),

                vdev->config_offset);

    if (ret < (int)MIN(pci_config_size(&vdev->pdev), vdev->config_size)) {

        ret = ret < 0 ? -errno : -EFAULT;

        error_report("vfio: Failed to read device config space");

        return ret;

    }



    /* vfio emulates a lot for us, but some bits need extra love */

    vdev->emulated_config_bits = g_malloc0(vdev->config_size);



    /* QEMU can choose to expose the ROM or not */

    memset(vdev->emulated_config_bits + PCI_ROM_ADDRESS, 0xff, 4);



    /*

     * The PCI spec reserves vendor ID 0xffff as an invalid value.  The

     * device ID is managed by the vendor and need only be a 16-bit value.

     * Allow any 16-bit value for subsystem so they can be hidden or changed.

     */

    if (vdev->vendor_id != PCI_ANY_ID) {

        if (vdev->vendor_id >= 0xffff) {

            error_report("vfio: Invalid PCI vendor ID provided");

            return -EINVAL;

        }

        vfio_add_emulated_word(vdev, PCI_VENDOR_ID, vdev->vendor_id, ~0);

        trace_vfio_pci_emulated_vendor_id(vdev->vbasedev.name, vdev->vendor_id);

    } else {

        vdev->vendor_id = pci_get_word(pdev->config + PCI_VENDOR_ID);

    }



    if (vdev->device_id != PCI_ANY_ID) {

        if (vdev->device_id > 0xffff) {

            error_report("vfio: Invalid PCI device ID provided");

            return -EINVAL;

        }

        vfio_add_emulated_word(vdev, PCI_DEVICE_ID, vdev->device_id, ~0);

        trace_vfio_pci_emulated_device_id(vdev->vbasedev.name, vdev->device_id);

    } else {

        vdev->device_id = pci_get_word(pdev->config + PCI_DEVICE_ID);

    }



    if (vdev->sub_vendor_id != PCI_ANY_ID) {

        if (vdev->sub_vendor_id > 0xffff) {

            error_report("vfio: Invalid PCI subsystem vendor ID provided");

            return -EINVAL;

        }

        vfio_add_emulated_word(vdev, PCI_SUBSYSTEM_VENDOR_ID,

                               vdev->sub_vendor_id, ~0);

        trace_vfio_pci_emulated_sub_vendor_id(vdev->vbasedev.name,

                                              vdev->sub_vendor_id);

    }



    if (vdev->sub_device_id != PCI_ANY_ID) {

        if (vdev->sub_device_id > 0xffff) {

            error_report("vfio: Invalid PCI subsystem device ID provided");

            return -EINVAL;

        }

        vfio_add_emulated_word(vdev, PCI_SUBSYSTEM_ID, vdev->sub_device_id, ~0);

        trace_vfio_pci_emulated_sub_device_id(vdev->vbasedev.name,

                                              vdev->sub_device_id);

    }



    /* QEMU can change multi-function devices to single function, or reverse */

    vdev->emulated_config_bits[PCI_HEADER_TYPE] =

                                              PCI_HEADER_TYPE_MULTI_FUNCTION;



    /* Restore or clear multifunction, this is always controlled by QEMU */

    if (vdev->pdev.cap_present & QEMU_PCI_CAP_MULTIFUNCTION) {

        vdev->pdev.config[PCI_HEADER_TYPE] |= PCI_HEADER_TYPE_MULTI_FUNCTION;

    } else {

        vdev->pdev.config[PCI_HEADER_TYPE] &= ~PCI_HEADER_TYPE_MULTI_FUNCTION;

    }



    /*

     * Clear host resource mapping info.  If we choose not to register a

     * BAR, such as might be the case with the option ROM, we can get

     * confusing, unwritable, residual addresses from the host here.

     */

    memset(&vdev->pdev.config[PCI_BASE_ADDRESS_0], 0, 24);

    memset(&vdev->pdev.config[PCI_ROM_ADDRESS], 0, 4);



    vfio_pci_size_rom(vdev);



    ret = vfio_msix_early_setup(vdev);

    if (ret) {

        return ret;

    }



    vfio_map_bars(vdev);



    ret = vfio_add_capabilities(vdev);

    if (ret) {

        goto out_teardown;

    }



    /* QEMU emulates all of MSI & MSIX */

    if (pdev->cap_present & QEMU_PCI_CAP_MSIX) {

        memset(vdev->emulated_config_bits + pdev->msix_cap, 0xff,

               MSIX_CAP_LENGTH);

    }



    if (pdev->cap_present & QEMU_PCI_CAP_MSI) {

        memset(vdev->emulated_config_bits + pdev->msi_cap, 0xff,

               vdev->msi_cap_size);

    }



    if (vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1)) {

        vdev->intx.mmap_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL,

                                                  vfio_intx_mmap_enable, vdev);

        pci_device_set_intx_routing_notifier(&vdev->pdev, vfio_intx_update);

        ret = vfio_intx_enable(vdev);

        if (ret) {

            goto out_teardown;

        }

    }



    vfio_register_err_notifier(vdev);

    vfio_register_req_notifier(vdev);

    vfio_setup_resetfn_quirk(vdev);



    return 0;



out_teardown:

    pci_device_set_intx_routing_notifier(&vdev->pdev, NULL);

    vfio_teardown_msi(vdev);

    vfio_unregister_bars(vdev);

    return ret;

}
 and probability:0.3236994219653179
code:static void absolute_mouse_grab(void)

{

    int mouse_x, mouse_y;



    if (SDL_GetAppState() & SDL_APPINPUTFOCUS) {

        SDL_GetMouseState(&mouse_x, &mouse_y);

        if (mouse_x > 0 && mouse_x < real_screen->w - 1 &&

            mouse_y > 0 && mouse_y < real_screen->h - 1) {

            sdl_grab_start();

        }

    }

}
 and probability:0.18181818181818182
code:int socket_dgram(SocketAddress *remote, SocketAddress *local, Error **errp)

{

    int fd;



    switch (remote->type) {

    case SOCKET_ADDRESS_KIND_INET:

        fd = inet_dgram_saddr(remote->u.inet, local ? local->u.inet : NULL, errp);

        break;



    default:

        error_setg(errp, "socket type unsupported for datagram");

        fd = -1;

    }

    return fd;

}
 and probability:0.15384615384615385
code:static int update_wrap_reference(AVFormatContext *s, AVStream *st, int stream_index)

{

    if (s->correct_ts_overflow && st->pts_wrap_bits < 63 &&

        st->pts_wrap_reference == AV_NOPTS_VALUE && st->first_dts != AV_NOPTS_VALUE) {

        int i;



        // reference time stamp should be 60 s before first time stamp

        int64_t pts_wrap_reference = st->first_dts - av_rescale(60, st->time_base.den, st->time_base.num);

        // if first time stamp is not more than 1/8 and 60s before the wrap point, subtract rather than add wrap offset

        int pts_wrap_behavior = (st->first_dts < (1LL<<st->pts_wrap_bits) - (1LL<<st->pts_wrap_bits-3)) ||

            (st->first_dts < (1LL<<st->pts_wrap_bits) - av_rescale(60, st->time_base.den, st->time_base.num)) ?

            AV_PTS_WRAP_ADD_OFFSET : AV_PTS_WRAP_SUB_OFFSET;



        AVProgram *first_program = av_find_program_from_stream(s, NULL, stream_index);



        if (!first_program) {

            int default_stream_index = av_find_default_stream_index(s);

            if (s->streams[default_stream_index]->pts_wrap_reference == AV_NOPTS_VALUE) {

                for (i=0; i<s->nb_streams; i++) {

                    s->streams[i]->pts_wrap_reference = pts_wrap_reference;

                    s->streams[i]->pts_wrap_behavior = pts_wrap_behavior;

                }

            }

            else {

                st->pts_wrap_reference = s->streams[default_stream_index]->pts_wrap_reference;

                st->pts_wrap_behavior = s->streams[default_stream_index]->pts_wrap_behavior;

            }

        }

        else {

            AVProgram *program = first_program;

            while (program) {

                if (program->pts_wrap_reference != AV_NOPTS_VALUE) {

                    pts_wrap_reference = program->pts_wrap_reference;

                    pts_wrap_behavior = program->pts_wrap_behavior;

                    break;

                }

                program = av_find_program_from_stream(s, program, stream_index);

            }



            // update every program with differing pts_wrap_reference

            program = first_program;

            while(program) {

                if (program->pts_wrap_reference != pts_wrap_reference) {

                    for (i=0; i<program->nb_stream_indexes; i++) {

                        s->streams[program->stream_index[i]]->pts_wrap_reference = pts_wrap_reference;

                        s->streams[program->stream_index[i]]->pts_wrap_behavior = pts_wrap_behavior;

                    }



                    program->pts_wrap_reference = pts_wrap_reference;

                    program->pts_wrap_behavior = pts_wrap_behavior;

                }

                program = av_find_program_from_stream(s, program, stream_index);

            }

        }

        return 1;

    }

    return 0;

}
 and probability:0.37735849056603776
code:uint64_t HELPER(diag)(CPUS390XState *env, uint32_t num, uint64_t mem,

                      uint64_t code)

{

    uint64_t r;



    switch (num) {

    case 0x500:

        /* KVM hypercall */

        r = s390_virtio_hypercall(env);

        break;

    case 0x44:

        /* yield */

        r = 0;

        break;

    case 0x308:

        /* ipl */

        r = 0;

        break;

    default:

        r = -1;

        break;

    }



    if (r) {

        program_interrupt(env, PGM_OPERATION, ILEN_LATER_INC);

    }



    return r;

}
 and probability:0.0
code:static uint64_t get_cluster_offset(BlockDriverState *bs,

                                    VmdkExtent *extent,

                                    VmdkMetaData *m_data,

                                    uint64_t offset, int allocate)

{

    unsigned int l1_index, l2_offset, l2_index;

    int min_index, i, j;

    uint32_t min_count, *l2_table, tmp = 0;

    uint64_t cluster_offset;



    if (m_data)

        m_data->valid = 0;



    l1_index = (offset >> 9) / extent->l1_entry_sectors;

    if (l1_index >= extent->l1_size) {

        return 0;

    }

    l2_offset = extent->l1_table[l1_index];

    if (!l2_offset) {

        return 0;

    }

    for (i = 0; i < L2_CACHE_SIZE; i++) {

        if (l2_offset == extent->l2_cache_offsets[i]) {

            /* increment the hit count */

            if (++extent->l2_cache_counts[i] == 0xffffffff) {

                for (j = 0; j < L2_CACHE_SIZE; j++) {

                    extent->l2_cache_counts[j] >>= 1;

                }

            }

            l2_table = extent->l2_cache + (i * extent->l2_size);

            goto found;

        }

    }

    /* not found: load a new entry in the least used one */

    min_index = 0;

    min_count = 0xffffffff;

    for (i = 0; i < L2_CACHE_SIZE; i++) {

        if (extent->l2_cache_counts[i] < min_count) {

            min_count = extent->l2_cache_counts[i];

            min_index = i;

        }

    }

    l2_table = extent->l2_cache + (min_index * extent->l2_size);

    if (bdrv_pread(

                extent->file,

                (int64_t)l2_offset * 512,

                l2_table,

                extent->l2_size * sizeof(uint32_t)

            ) != extent->l2_size * sizeof(uint32_t)) {

        return 0;

    }



    extent->l2_cache_offsets[min_index] = l2_offset;

    extent->l2_cache_counts[min_index] = 1;

 found:

    l2_index = ((offset >> 9) / extent->cluster_sectors) % extent->l2_size;

    cluster_offset = le32_to_cpu(l2_table[l2_index]);



    if (!cluster_offset) {

        if (!allocate)

            return 0;



        // Avoid the L2 tables update for the images that have snapshots.

        cluster_offset = bdrv_getlength(extent->file);

        bdrv_truncate(

            extent->file,

            cluster_offset + (extent->cluster_sectors << 9)

        );



        cluster_offset >>= 9;

        tmp = cpu_to_le32(cluster_offset);

        l2_table[l2_index] = tmp;



        /* First of all we write grain itself, to avoid race condition

         * that may to corrupt the image.

         * This problem may occur because of insufficient space on host disk

         * or inappropriate VM shutdown.

         */

        if (get_whole_cluster(

                bs, extent, cluster_offset, offset, allocate) == -1)

            return 0;



        if (m_data) {

            m_data->offset = tmp;

            m_data->l1_index = l1_index;

            m_data->l2_index = l2_index;

            m_data->l2_offset = l2_offset;

            m_data->valid = 1;

        }

    }

    cluster_offset <<= 9;

    return cluster_offset;

}
 and probability:0.36470588235294116
code:void qemu_set_fd_handler(int fd,

                         IOHandler *fd_read,

                         IOHandler *fd_write,

                         void *opaque)

{

    iohandler_init();

    aio_set_fd_handler(iohandler_ctx, fd, false,

                       fd_read, fd_write, NULL, opaque);

}
 and probability:0.0
code:static MemTxResult nvic_sysreg_write(void *opaque, hwaddr addr,

                                     uint64_t value, unsigned size,

                                     MemTxAttrs attrs)

{

    NVICState *s = (NVICState *)opaque;

    uint32_t offset = addr;

    unsigned i, startvec, end;

    unsigned setval = 0;



    trace_nvic_sysreg_write(addr, value, size);



    if (attrs.user && !nvic_user_access_ok(s, addr)) {

        /* Generate BusFault for unprivileged accesses */

        return MEMTX_ERROR;

    }



    switch (offset) {

    case 0x100 ... 0x13f: /* NVIC Set enable */

        offset += 0x80;

        setval = 1;

        /* fall through */

    case 0x180 ... 0x1bf: /* NVIC Clear enable */

        startvec = 8 * (offset - 0x180) + NVIC_FIRST_IRQ;



        for (i = 0, end = size * 8; i < end && startvec + i < s->num_irq; i++) {

            if (value & (1 << i)) {

                s->vectors[startvec + i].enabled = setval;

            }

        }

        nvic_irq_update(s);

        return MEMTX_OK;

    case 0x200 ... 0x23f: /* NVIC Set pend */

        /* the special logic in armv7m_nvic_set_pending()

         * is not needed since IRQs are never escalated

         */

        offset += 0x80;

        setval = 1;

        /* fall through */

    case 0x280 ... 0x2bf: /* NVIC Clear pend */

        startvec = 8 * (offset - 0x280) + NVIC_FIRST_IRQ; /* vector # */



        for (i = 0, end = size * 8; i < end && startvec + i < s->num_irq; i++) {

            if (value & (1 << i)) {

                s->vectors[startvec + i].pending = setval;

            }

        }

        nvic_irq_update(s);

        return MEMTX_OK;

    case 0x300 ... 0x33f: /* NVIC Active */

        return MEMTX_OK; /* R/O */

    case 0x400 ... 0x5ef: /* NVIC Priority */

        startvec = 8 * (offset - 0x400) + NVIC_FIRST_IRQ; /* vector # */



        for (i = 0; i < size && startvec + i < s->num_irq; i++) {

            set_prio(s, startvec + i, (value >> (i * 8)) & 0xff);

        }

        nvic_irq_update(s);

        return MEMTX_OK;

    case 0xd18 ... 0xd23: /* System Handler Priority.  */

        for (i = 0; i < size; i++) {

            unsigned hdlidx = (offset - 0xd14) + i;

            set_prio(s, hdlidx, (value >> (i * 8)) & 0xff);

        }

        nvic_irq_update(s);

        return MEMTX_OK;

    }

    if (size == 4) {

        nvic_writel(s, offset, value);

        return MEMTX_OK;

    }

    qemu_log_mask(LOG_GUEST_ERROR,

                  "NVIC: Bad write of size %d at offset 0x%x\n", size, offset);

    /* This is UNPREDICTABLE; treat as RAZ/WI */

    return MEMTX_OK;

}
 and probability:0.2028985507246377
code:static void phys_page_set_level(PhysPageEntry *lp, hwaddr *index,

                                hwaddr *nb, uint16_t leaf,

                                int level)

{

    PhysPageEntry *p;

    int i;

    hwaddr step = (hwaddr)1 << (level * P_L2_BITS);



    if (lp->skip && lp->ptr == PHYS_MAP_NODE_NIL) {

        lp->ptr = phys_map_node_alloc();

        p = next_map.nodes[lp->ptr];

        if (level == 0) {

            for (i = 0; i < P_L2_SIZE; i++) {

                p[i].skip = 0;

                p[i].ptr = PHYS_SECTION_UNASSIGNED;

            }

        }

    } else {

        p = next_map.nodes[lp->ptr];

    }

    lp = &p[(*index >> (level * P_L2_BITS)) & (P_L2_SIZE - 1)];



    while (*nb && lp < &p[P_L2_SIZE]) {

        if ((*index & (step - 1)) == 0 && *nb >= step) {

            lp->skip = 0;

            lp->ptr = leaf;

            *index += step;

            *nb -= step;

        } else {

            phys_page_set_level(lp, index, nb, leaf, level - 1);

        }

        ++lp;

    }

}
 and probability:0.53125
code:static void map_page(uint8_t **ptr, uint64_t addr, uint32_t wanted)

{

    target_phys_addr_t len = wanted;



    if (*ptr) {

        cpu_physical_memory_unmap(*ptr, len, 1, len);

    }



    *ptr = cpu_physical_memory_map(addr, &len, 1);

    if (len < wanted) {

        cpu_physical_memory_unmap(*ptr, len, 1, len);

        *ptr = NULL;

    }

}
 and probability:0.4166666666666667
code:static VmdkExtent *vmdk_add_extent(BlockDriverState *bs,

                           BlockDriverState *file, bool flat, int64_t sectors,

                           int64_t l1_offset, int64_t l1_backup_offset,

                           uint32_t l1_size,

                           int l2_size, unsigned int cluster_sectors)

{

    VmdkExtent *extent;

    BDRVVmdkState *s = bs->opaque;



    s->extents = g_realloc(s->extents,

                              (s->num_extents + 1) * sizeof(VmdkExtent));

    extent = &s->extents[s->num_extents];

    s->num_extents++;



    memset(extent, 0, sizeof(VmdkExtent));

    extent->file = file;

    extent->flat = flat;

    extent->sectors = sectors;

    extent->l1_table_offset = l1_offset;

    extent->l1_backup_table_offset = l1_backup_offset;

    extent->l1_size = l1_size;

    extent->l1_entry_sectors = l2_size * cluster_sectors;

    extent->l2_size = l2_size;

    extent->cluster_sectors = cluster_sectors;



    if (s->num_extents > 1) {

        extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;

    } else {

        extent->end_sector = extent->sectors;

    }

    bs->total_sectors = extent->end_sector;

    return extent;

}
 and probability:0.6
code:static void ppc_heathrow_init (int ram_size, int vga_ram_size,

                               const char *boot_device, DisplayState *ds,

                               const char **fd_filename, int snapshot,

                               const char *kernel_filename,

                               const char *kernel_cmdline,

                               const char *initrd_filename,

                               const char *cpu_model)

{

    CPUState *env = NULL, *envs[MAX_CPUS];

    char buf[1024];

    qemu_irq *pic, **heathrow_irqs;

    nvram_t nvram;

    m48t59_t *m48t59;

    int linux_boot, i;

    unsigned long bios_offset, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;

    PCIBus *pci_bus;

    MacIONVRAMState *nvr;

    int vga_bios_size, bios_size;

    qemu_irq *dummy_irq;

    int pic_mem_index, nvram_mem_index, dbdma_mem_index, cuda_mem_index;

    int ppc_boot_device = boot_device[0];



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

        cpu_model = "default";

    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, "Unable to find PowerPC CPU definition\n");

            exit(1);

        }

        /* Set time-base frequency to 100 Mhz */

        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);

        env->osi_call = vga_osi_call;

        qemu_register_reset(&cpu_ppc_reset, env);

        register_savevm("cpu", 0, 3, cpu_save, cpu_load, env);

        envs[i] = env;

    }

    if (env->nip < 0xFFF80000) {

        /* Special test for PowerPC 601:

         * the boot vector is at 0xFFF00100, then we need a 1MB BIOS.

         * But the NVRAM is located at 0xFFF04000...

         */

        cpu_abort(env, "G3BW Mac hardware can not handle 1 MB BIOS\n");

    }



    /* allocate RAM */

    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);



    /* allocate and load BIOS */

    bios_offset = ram_size + vga_ram_size;

    if (bios_name == NULL)

        bios_name = BIOS_FILENAME;

    snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name);

    bios_size = load_image(buf, phys_ram_base + bios_offset);

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        cpu_abort(env, "qemu: could not load PowerPC bios '%s'\n", buf);

        exit(1);

    }

    bios_size = (bios_size + 0xfff) & ~0xfff;

    if (bios_size > 0x00080000) {

        /* As the NVRAM is located at 0xFFF04000, we cannot use 1 MB BIOSes */

        cpu_abort(env, "G3BW Mac hardware can not handle 1 MB BIOS\n");

    }

    cpu_register_physical_memory((uint32_t)(-bios_size),

                                 bios_size, bios_offset | IO_MEM_ROM);



    /* allocate and load VGA BIOS */

    vga_bios_offset = bios_offset + bios_size;

    snprintf(buf, sizeof(buf), "%s/%s", bios_dir, VGABIOS_FILENAME);

    vga_bios_size = load_image(buf, phys_ram_base + vga_bios_offset + 8);

    if (vga_bios_size < 0) {

        /* if no bios is present, we can still work */

        fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n", buf);

        vga_bios_size = 0;

    } else {

        /* set a specific header (XXX: find real Apple format for NDRV

           drivers) */

        phys_ram_base[vga_bios_offset] = 'N';

        phys_ram_base[vga_bios_offset + 1] = 'D';

        phys_ram_base[vga_bios_offset + 2] = 'R';

        phys_ram_base[vga_bios_offset + 3] = 'V';

        cpu_to_be32w((uint32_t *)(phys_ram_base + vga_bios_offset + 4),

                     vga_bios_size);

        vga_bios_size += 8;

    }

    vga_bios_size = (vga_bios_size + 0xfff) & ~0xfff;



    if (linux_boot) {

        kernel_base = KERNEL_LOAD_ADDR;

        /* now we can load the kernel */

        kernel_size = load_image(kernel_filename, phys_ram_base + kernel_base);

        if (kernel_size < 0) {

            cpu_abort(env, "qemu: could not load kernel '%s'\n",

                      kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image(initrd_filename,

                                     phys_ram_base + initrd_base);

            if (initrd_size < 0) {

                cpu_abort(env, "qemu: could not load initial ram disk '%s'\n",

                          initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

    }



    isa_mem_base = 0x80000000;

    

    /* Register 2 MB of ISA IO space */

    isa_mmio_init(0xfe000000, 0x00200000);



    /* XXX: we register only 1 output pin for heathrow PIC */

    heathrow_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));

    heathrow_irqs[0] =

        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * 1);

    /* Connect the heathrow PIC outputs to the 6xx bus */

    for (i = 0; i < smp_cpus; i++) {

        switch (PPC_INPUT(env)) {

        case PPC_FLAGS_INPUT_6xx:

            heathrow_irqs[i] = heathrow_irqs[0] + (i * 1);

            heathrow_irqs[i][0] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            break;

        default:

            cpu_abort(env, "Bus model not supported on OldWorld Mac machine\n");

            exit(1);

        }

    }



    /* init basic PC hardware */

    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {

        cpu_abort(env, "Only 6xx bus is supported on heathrow machine\n");

        exit(1);

    }

    pic = heathrow_pic_init(&pic_mem_index, 1, heathrow_irqs);

    pci_bus = pci_grackle_init(0xfec00000, pic);

    pci_vga_init(pci_bus, ds, phys_ram_base + ram_size,

                 ram_size, vga_ram_size,

                 vga_bios_offset, vga_bios_size);

    

    /* XXX: suppress that */

    dummy_irq = i8259_init(NULL);



    /* XXX: use Mac Serial port */

    serial_init(0x3f8, dummy_irq[4], serial_hds[0]);

    

    for(i = 0; i < nb_nics; i++) {

        if (!nd_table[i].model)

            nd_table[i].model = "ne2k_pci";

        pci_nic_init(pci_bus, &nd_table[i], -1);

    }

    

    pci_cmd646_ide_init(pci_bus, &bs_table[0], 0);



    /* cuda also initialize ADB */

    cuda_init(&cuda_mem_index, pic[0x12]);



    adb_kbd_init(&adb_bus);

    adb_mouse_init(&adb_bus);

    

    nvr = macio_nvram_init(&nvram_mem_index, 0x2000);

    pmac_format_nvram_partition(nvr, 0x2000);



    dbdma_init(&dbdma_mem_index);

    

    macio_init(pci_bus, 0x0017, 1, pic_mem_index, dbdma_mem_index,

               cuda_mem_index, nvr, 0, NULL);



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, 3, -1);

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    m48t59 = m48t59_init(dummy_irq[8], 0xFFF04000, 0x0074, NVRAM_SIZE, 59);

    nvram.opaque = m48t59;

    nvram.read_fn = &m48t59_read;

    nvram.write_fn = &m48t59_write;

    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, "HEATHROW", ram_size,

                         ppc_boot_device, kernel_base, kernel_size,

                         kernel_cmdline,

                         initrd_base, initrd_size,

                         /* XXX: need an option to load a NVRAM image */

                         0,

                         graphic_width, graphic_height, graphic_depth);

    /* No PCI init: the BIOS will do it */



    /* Special port to get debug messages from Open-Firmware */

    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);

}
 and probability:0.1956521739130435
code:static void musicpal_gpio_write(void *opaque, target_phys_addr_t offset,

                                uint64_t value, unsigned size)

{

    musicpal_gpio_state *s = opaque;

    switch (offset) {

    case MP_GPIO_OE_HI: /* used for LCD brightness control */

        s->lcd_brightness = (s->lcd_brightness & MP_GPIO_LCD_BRIGHTNESS) |

                         (value & MP_OE_LCD_BRIGHTNESS);

        musicpal_gpio_brightness_update(s);

        break;



    case MP_GPIO_OUT_LO:

        s->out_state = (s->out_state & 0xFFFF0000) | (value & 0xFFFF);

        break;

    case MP_GPIO_OUT_HI:

        s->out_state = (s->out_state & 0xFFFF) | (value << 16);

        s->lcd_brightness = (s->lcd_brightness & 0xFFFF) |

                            (s->out_state & MP_GPIO_LCD_BRIGHTNESS);

        musicpal_gpio_brightness_update(s);

        qemu_set_irq(s->out[3], (s->out_state >> MP_GPIO_I2C_DATA_BIT) & 1);

        qemu_set_irq(s->out[4], (s->out_state >> MP_GPIO_I2C_CLOCK_BIT) & 1);

        break;



    case MP_GPIO_IER_LO:

        s->ier = (s->ier & 0xFFFF0000) | (value & 0xFFFF);

        break;

    case MP_GPIO_IER_HI:

        s->ier = (s->ier & 0xFFFF) | (value << 16);

        break;



    case MP_GPIO_IMR_LO:

        s->imr = (s->imr & 0xFFFF0000) | (value & 0xFFFF);

        break;

    case MP_GPIO_IMR_HI:

        s->imr = (s->imr & 0xFFFF) | (value << 16);

        break;

    }

}
 and probability:0.3142857142857143
code:static inline void scale_mv(AVSContext *h, int *d_x, int *d_y,

                            cavs_vector *src, int distp)

{

    int den = h->scale_den[src->ref];



    *d_x = (src->x * distp * den + 256 + (src->x >> 31)) >> 9;

    *d_y = (src->y * distp * den + 256 + (src->y >> 31)) >> 9;

}
 and probability:0.42857142857142855
code:static int usb_wacom_handle_data(USBDevice *dev, USBPacket *p)

{

    USBWacomState *s = (USBWacomState *) dev;

    uint8_t buf[p->iov.size];

    int ret = 0;



    switch (p->pid) {

    case USB_TOKEN_IN:

        if (p->devep == 1) {

            if (!(s->changed || s->idle))

                return USB_RET_NAK;

            s->changed = 0;

            if (s->mode == WACOM_MODE_HID)

                ret = usb_mouse_poll(s, buf, p->iov.size);

            else if (s->mode == WACOM_MODE_WACOM)

                ret = usb_wacom_poll(s, buf, p->iov.size);

            usb_packet_copy(p, buf, ret);

            break;

        }

        /* Fall through.  */

    case USB_TOKEN_OUT:

    default:

        ret = USB_RET_STALL;

        break;

    }

    return ret;

}
 and probability:0.34615384615384615
code:RGB_FUNCTIONS(rgb565)



#undef RGB_IN

#undef RGB_OUT

#undef BPP



/* bgr24 handling */



#define RGB_IN(r, g, b, s)\

{\

    b = (s)[0];\

    g = (s)[1];\

    r = (s)[2];\

}



#define RGB_OUT(d, r, g, b)\

{\

    (d)[0] = b;\

    (d)[1] = g;\

    (d)[2] = r;\

}



#define BPP 3



RGB_FUNCTIONS(bgr24)



#undef RGB_IN

#undef RGB_OUT

#undef BPP



/* rgb24 handling */



#define RGB_IN(r, g, b, s)\

{\

    r = (s)[0];\

    g = (s)[1];\

    b = (s)[2];\

}



#define RGB_OUT(d, r, g, b)\

{\

    (d)[0] = r;\

    (d)[1] = g;\

    (d)[2] = b;\

}



#define BPP 3



RGB_FUNCTIONS(rgb24)



static void yuv444p_to_rgb24(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    uint8_t *y1_ptr, *cb_ptr, *cr_ptr, *d, *d1;

    int w, y, cb, cr, r_add, g_add, b_add;

    uint8_t *cm = cropTbl + MAX_NEG_CROP;

    unsigned int r, g, b;



    d = dst->data[0];

    y1_ptr = src->data[0];

    cb_ptr = src->data[1];

    cr_ptr = src->data[2];

    for(;height > 0; height --) {

        d1 = d;

        for(w = width; w > 0; w--) {

            YUV_TO_RGB1_CCIR(cb_ptr[0], cr_ptr[0]);



            YUV_TO_RGB2_CCIR(r, g, b, y1_ptr[0]);

            RGB_OUT(d1, r, g, b);

            d1 += BPP;



            y1_ptr++;

            cb_ptr++;

            cr_ptr++;

        }

        d += dst->linesize[0];

        y1_ptr += src->linesize[0] - width;

        cb_ptr += src->linesize[1] - width;

        cr_ptr += src->linesize[2] - width;

    }

}
 and probability:0.4461538461538462
code:int ff_af_queue_add(AudioFrameQueue *afq, const AVFrame *f)

{

    AudioFrame *new_frame;

    AudioFrame *queue_end = afq->frame_queue;



    /* find the end of the queue */

    while (queue_end && queue_end->next)

        queue_end = queue_end->next;



    /* allocate new frame queue entry */

    if (!(new_frame = av_malloc(sizeof(*new_frame))))

        return AVERROR(ENOMEM);



    /* get frame parameters */

    new_frame->next = NULL;

    new_frame->duration = f->nb_samples;

    if (f->pts != AV_NOPTS_VALUE) {

        new_frame->pts = av_rescale_q(f->pts,

                                      afq->avctx->time_base,

                                      (AVRational){ 1, afq->avctx->sample_rate });

        afq->next_pts = new_frame->pts + new_frame->duration;

    } else {

        new_frame->pts = AV_NOPTS_VALUE;

        afq->next_pts  = AV_NOPTS_VALUE;

    }



    /* add new frame to the end of the queue */

    if (!queue_end)

        afq->frame_queue = new_frame;

    else

        queue_end->next = new_frame;



    /* add frame sample count */

    afq->remaining_samples += f->nb_samples;



#ifdef DEBUG

    ff_af_queue_log_state(afq);

#endif



    return 0;

}
 and probability:0.47058823529411764
code:yuv2mono_1_c_template(SwsContext *c, const int16_t *buf0,

                      const int16_t *ubuf[2], const int16_t *vbuf[2],

                      const int16_t *abuf0, uint8_t *dest, int dstW,

                      int uvalpha, int y, enum AVPixelFormat target)

{

    const uint8_t * const d128 = dither_8x8_220[y & 7];

    int i;



    if (c->flags & SWS_ERROR_DIFFUSION) {

        int err = 0;

        int acc = 0;

        for (i = 0; i < dstW; i +=2) {

            int Y;



            Y = ((buf0[i + 0] + 64) >> 7);

            Y += (7*err + 1*c->dither_error[0][i] + 5*c->dither_error[0][i+1] + 3*c->dither_error[0][i+2] + 8 - 256)>>4;

            c->dither_error[0][i] = err;

            acc = 2*acc + (Y >= 128);

            Y -= 220*(acc&1);



            err = ((buf0[i + 1] + 64) >> 7);

            err += (7*Y + 1*c->dither_error[0][i+1] + 5*c->dither_error[0][i+2] + 3*c->dither_error[0][i+3] + 8 - 256)>>4;

            c->dither_error[0][i+1] = Y;

            acc = 2*acc + (err >= 128);

            err -= 220*(acc&1);



            if ((i & 7) == 6)

                output_pixel(*dest++, acc);

        }

        c->dither_error[0][i] = err;

    } else {

    for (i = 0; i < dstW; i += 8) {

        int acc = 0;

        accumulate_bit(acc, ((buf0[i + 0] + 64) >> 7) + d128[0]);

        accumulate_bit(acc, ((buf0[i + 1] + 64) >> 7) + d128[1]);

        accumulate_bit(acc, ((buf0[i + 2] + 64) >> 7) + d128[2]);

        accumulate_bit(acc, ((buf0[i + 3] + 64) >> 7) + d128[3]);

        accumulate_bit(acc, ((buf0[i + 4] + 64) >> 7) + d128[4]);

        accumulate_bit(acc, ((buf0[i + 5] + 64) >> 7) + d128[5]);

        accumulate_bit(acc, ((buf0[i + 6] + 64) >> 7) + d128[6]);

        accumulate_bit(acc, ((buf0[i + 7] + 64) >> 7) + d128[7]);



        output_pixel(*dest++, acc);

    }

    }

}
 and probability:0.6829268292682927
code:static sPAPREventLogEntry *rtas_event_log_dequeue(uint32_t event_mask,

                                                  bool exception)

{

    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());

    sPAPREventLogEntry *entry = NULL;



    /* we only queue EPOW events atm. */

    if ((event_mask & EVENT_MASK_EPOW) == 0) {

        return NULL;

    }



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        if (entry->exception != exception) {

            continue;

        }



        /* EPOW and hotplug events are surfaced in the same manner */

        if (entry->log_type == RTAS_LOG_TYPE_EPOW ||

            entry->log_type == RTAS_LOG_TYPE_HOTPLUG) {

            break;

        }

    }



    if (entry) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

    }



    return entry;

}
 and probability:0.20833333333333334
code:static int spapr_check_htab_fd(sPAPRMachineState *spapr)

{

    int rc = 0;



    if (spapr->htab_fd_stale) {

        close(spapr->htab_fd);

        spapr->htab_fd = kvmppc_get_htab_fd(false);

        if (spapr->htab_fd < 0) {

            error_report("Unable to open fd for reading hash table from KVM: "

                         "%s", strerror(errno));

            rc = -1;

        }

        spapr->htab_fd_stale = false;

    }



    return rc;

}
 and probability:0.3333333333333333
code:static int coroutine_fn raw_co_pwritev(BlockDriverState *bs, uint64_t offset,

                                       uint64_t bytes, QEMUIOVector *qiov,

                                       int flags)

{

    BDRVRawState *s = bs->opaque;

    void *buf = NULL;

    BlockDriver *drv;

    QEMUIOVector local_qiov;

    int ret;



    if (s->has_size && (offset > s->size || bytes > (s->size - offset))) {

        /* There's not enough space for the data. Don't write anything and just

         * fail to prevent leaking out of the size specified in options. */

        return -ENOSPC;

    }



    if (offset > UINT64_MAX - s->offset) {

        ret = -EINVAL;

        goto fail;

    }



    if (bs->probed && offset < BLOCK_PROBE_BUF_SIZE && bytes) {

        /* Handling partial writes would be a pain - so we just

         * require that guests have 512-byte request alignment if

         * probing occurred */

        QEMU_BUILD_BUG_ON(BLOCK_PROBE_BUF_SIZE != 512);

        QEMU_BUILD_BUG_ON(BDRV_SECTOR_SIZE != 512);

        assert(offset == 0 && bytes >= BLOCK_PROBE_BUF_SIZE);



        buf = qemu_try_blockalign(bs->file->bs, 512);

        if (!buf) {

            ret = -ENOMEM;

            goto fail;

        }



        ret = qemu_iovec_to_buf(qiov, 0, buf, 512);

        if (ret != 512) {

            ret = -EINVAL;

            goto fail;

        }



        drv = bdrv_probe_all(buf, 512, NULL);

        if (drv != bs->drv) {

            ret = -EPERM;

            goto fail;

        }



        /* Use the checked buffer, a malicious guest might be overwriting its

         * original buffer in the background. */

        qemu_iovec_init(&local_qiov, qiov->niov + 1);

        qemu_iovec_add(&local_qiov, buf, 512);

        qemu_iovec_concat(&local_qiov, qiov, 512, qiov->size - 512);

        qiov = &local_qiov;

    }



    offset += s->offset;



    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);

    ret = bdrv_co_pwritev(bs->file, offset, bytes, qiov, flags);



fail:

    if (qiov == &local_qiov) {

        qemu_iovec_destroy(&local_qiov);

    }

    qemu_vfree(buf);

    return ret;

}
 and probability:0.19298245614035087
code:void *qemu_ram_ptr_length(target_phys_addr_t addr, target_phys_addr_t *size)

{

    if (xen_enabled()) {

        return xen_map_cache(addr, *size, 1);

    } else {

        RAMBlock *block;



        QLIST_FOREACH(block, &ram_list.blocks, next) {

            if (addr - block->offset < block->length) {

                if (addr - block->offset + *size > block->length)

                    *size = block->length - addr + block->offset;

                return block->host + (addr - block->offset);

            }

        }



        fprintf(stderr, "Bad ram offset %" PRIx64 "\n", (uint64_t)addr);

        abort();



        *size = 0;

        return NULL;

    }

}
 and probability:0.3157894736842105
code:static void *qemu_dummy_cpu_thread_fn(void *arg)

{

#ifdef _WIN32

    fprintf(stderr, "qtest is not supported under Windows\n");

    exit(1);

#else

    CPUState *cpu = arg;

    sigset_t waitset;

    int r;



    qemu_mutex_lock_iothread();

    qemu_thread_get_self(cpu->thread);

    cpu->thread_id = qemu_get_thread_id();

    cpu->exception_index = -1;

    cpu->can_do_io = 1;



    sigemptyset(&waitset);

    sigaddset(&waitset, SIG_IPI);



    /* signal CPU creation */

    cpu->created = true;

    qemu_cond_signal(&qemu_cpu_cond);



    current_cpu = cpu;

    while (1) {

        current_cpu = NULL;

        qemu_mutex_unlock_iothread();

        do {

            int sig;

            r = sigwait(&waitset, &sig);

        } while (r == -1 && (errno == EAGAIN || errno == EINTR));

        if (r == -1) {

            perror("sigwait");

            exit(1);

        }

        qemu_mutex_lock_iothread();

        current_cpu = cpu;

        qemu_wait_io_event_common(cpu);

    }



    return NULL;

#endif

}
 and probability:0.13157894736842105
code:static void acpi_get_hotplug_info(AcpiMiscInfo *misc)

{

    int i;

    PCIBus *bus = find_i440fx();



    if (!bus) {

        /* Only PIIX supports ACPI hotplug */

        memset(misc->slot_hotplug_enable, 0, sizeof misc->slot_hotplug_enable);

        return;

    }



    memset(misc->slot_hotplug_enable, 0xff,

           DIV_ROUND_UP(PCI_SLOT_MAX, BITS_PER_BYTE));



    for (i = 0; i < ARRAY_SIZE(bus->devices); ++i) {

        PCIDeviceClass *pc;

        PCIDevice *pdev = bus->devices[i];



        if (!pdev) {

            continue;

        }



        pc = PCI_DEVICE_GET_CLASS(pdev);



        if (pc->no_hotplug) {

            int slot = PCI_SLOT(i);



            clear_bit(slot, misc->slot_hotplug_enable);

        }

    }

}
 and probability:0.25
code:static int spapr_fixup_cpu_dt(void *fdt, sPAPRMachineState *spapr)

{

    int ret = 0, offset, cpus_offset;

    CPUState *cs;

    char cpu_model[32];

    int smt = kvmppc_smt_threads();

    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};



    CPU_FOREACH(cs) {

        PowerPCCPU *cpu = POWERPC_CPU(cs);

        DeviceClass *dc = DEVICE_GET_CLASS(cs);

        int index = spapr_vcpu_id(cpu);

        int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));



        if ((index % smt) != 0) {

            continue;

        }



        snprintf(cpu_model, 32, "%s@%x", dc->fw_name, index);



        cpus_offset = fdt_path_offset(fdt, "/cpus");

        if (cpus_offset < 0) {

            cpus_offset = fdt_add_subnode(fdt, 0, "cpus");

            if (cpus_offset < 0) {

                return cpus_offset;

            }

        }

        offset = fdt_subnode_offset(fdt, cpus_offset, cpu_model);

        if (offset < 0) {

            offset = fdt_add_subnode(fdt, cpus_offset, cpu_model);

            if (offset < 0) {

                return offset;

            }

        }



        ret = fdt_setprop(fdt, offset, "ibm,pft-size",

                          pft_size_prop, sizeof(pft_size_prop));

        if (ret < 0) {

            return ret;

        }



        if (nb_numa_nodes > 1) {

            ret = spapr_fixup_cpu_numa_dt(fdt, offset, cpu);

            if (ret < 0) {

                return ret;

            }

        }



        ret = spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt);

        if (ret < 0) {

            return ret;

        }



        spapr_populate_pa_features(cpu, fdt, offset,

                                         spapr->cas_legacy_guest_workaround);

    }

    return ret;

}
 and probability:0.08
code:void subch_device_save(SubchDev *s, QEMUFile *f)

{

    int i;



    qemu_put_byte(f, s->cssid);

    qemu_put_byte(f, s->ssid);

    qemu_put_be16(f, s->schid);

    qemu_put_be16(f, s->devno);

    qemu_put_byte(f, s->thinint_active);

    /* SCHIB */

    /*     PMCW */

    qemu_put_be32(f, s->curr_status.pmcw.intparm);

    qemu_put_be16(f, s->curr_status.pmcw.flags);

    qemu_put_be16(f, s->curr_status.pmcw.devno);

    qemu_put_byte(f, s->curr_status.pmcw.lpm);

    qemu_put_byte(f, s->curr_status.pmcw.pnom);

    qemu_put_byte(f, s->curr_status.pmcw.lpum);

    qemu_put_byte(f, s->curr_status.pmcw.pim);

    qemu_put_be16(f, s->curr_status.pmcw.mbi);

    qemu_put_byte(f, s->curr_status.pmcw.pom);

    qemu_put_byte(f, s->curr_status.pmcw.pam);

    qemu_put_buffer(f, s->curr_status.pmcw.chpid, 8);

    qemu_put_be32(f, s->curr_status.pmcw.chars);

    /*     SCSW */

    qemu_put_be16(f, s->curr_status.scsw.flags);

    qemu_put_be16(f, s->curr_status.scsw.ctrl);

    qemu_put_be32(f, s->curr_status.scsw.cpa);

    qemu_put_byte(f, s->curr_status.scsw.dstat);

    qemu_put_byte(f, s->curr_status.scsw.cstat);

    qemu_put_be16(f, s->curr_status.scsw.count);

    qemu_put_be64(f, s->curr_status.mba);

    qemu_put_buffer(f, s->curr_status.mda, 4);

    /* end SCHIB */

    qemu_put_buffer(f, s->sense_data, 32);

    qemu_put_be64(f, s->channel_prog);

    /* last cmd */

    qemu_put_byte(f, s->last_cmd.cmd_code);

    qemu_put_byte(f, s->last_cmd.flags);

    qemu_put_be16(f, s->last_cmd.count);

    qemu_put_be32(f, s->last_cmd.cda);

    qemu_put_byte(f, s->last_cmd_valid);

    qemu_put_byte(f, s->id.reserved);

    qemu_put_be16(f, s->id.cu_type);

    qemu_put_byte(f, s->id.cu_model);

    qemu_put_be16(f, s->id.dev_type);

    qemu_put_byte(f, s->id.dev_model);

    qemu_put_byte(f, s->id.unused);

    for (i = 0; i < ARRAY_SIZE(s->id.ciw); i++) {

        qemu_put_byte(f, s->id.ciw[i].type);

        qemu_put_byte(f, s->id.ciw[i].command);

        qemu_put_be16(f, s->id.ciw[i].count);

    }

    qemu_put_byte(f, s->ccw_fmt_1);

    qemu_put_byte(f, s->ccw_no_data_cnt);

}
 and probability:0.8148148148148148
code:static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,

                                               VirtQueue *vq,

                                               EventNotifierHandler *handler,

                                               int n)

{

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    VirtIOSCSIVring *r;

    int rc;



    /* Set up virtqueue notify */

    rc = k->set_host_notifier(qbus->parent, n, true);

    if (rc != 0) {

        fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n",

                rc);

        s->dataplane_fenced = true;

        return NULL;

    }



    r = g_new(VirtIOSCSIVring, 1);

    r->host_notifier = *virtio_queue_get_host_notifier(vq);

    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);

    aio_set_event_notifier(s->ctx, &r->host_notifier, false,

                           handler);



    r->parent = s;



    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {

        fprintf(stderr, "virtio-scsi: VRing setup failed\n");

        goto fail_vring;

    }

    return r;



fail_vring:

    aio_set_event_notifier(s->ctx, &r->host_notifier, false,

                           NULL);

    k->set_host_notifier(qbus->parent, n, false);

    g_free(r);

    return NULL;

}
 and probability:0.2571428571428571
code:static void do_change_block(const char *device, const char *filename, const char *fmt)

{

    BlockDriverState *bs;

    BlockDriver *drv = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        term_printf("device not found\n");

        return;

    }

    if (fmt) {

        drv = bdrv_find_format(fmt);

        if (!drv) {

            term_printf("invalid format %s\n", fmt);

            return;

        }

    }

    if (eject_device(bs, 0) < 0)

        return;

    bdrv_open2(bs, filename, 0, drv);

    qemu_key_check(bs, filename);

}
 and probability:0.0
code:static void add_flagname_to_bitmaps(const char *flagname, uint32_t *features,

                                    uint32_t *ext_features,

                                    uint32_t *ext2_features,

                                    uint32_t *ext3_features,

                                    uint32_t *kvm_features,

                                    uint32_t *svm_features)

{

    if (!lookup_feature(features, flagname, NULL, feature_name) &&

        !lookup_feature(ext_features, flagname, NULL, ext_feature_name) &&

        !lookup_feature(ext2_features, flagname, NULL, ext2_feature_name) &&

        !lookup_feature(ext3_features, flagname, NULL, ext3_feature_name) &&

        !lookup_feature(kvm_features, flagname, NULL, kvm_feature_name) &&

        !lookup_feature(svm_features, flagname, NULL, svm_feature_name))

            fprintf(stderr, "CPU feature %s not found\n", flagname);

}
 and probability:0.0
code:static void test_machine(const void *data)

{

    const testdef_t *test = data;

    char tmpname[] = "/tmp/qtest-boot-serial-XXXXXX";

    int fd;



    fd = mkstemp(tmpname);

    g_assert(fd != -1);



    /*

     * Make sure that this test uses tcg if available: It is used as a

     * fast-enough smoketest for that.

     */

    global_qtest = qtest_startf("-M %s,accel=tcg:kvm "

                                "-chardev file,id=serial0,path=%s "

                                "-no-shutdown -serial chardev:serial0 %s",

                                test->machine, tmpname, test->extra);

    unlink(tmpname);



    check_guest_output(test, fd);

    qtest_quit(global_qtest);



    close(fd);

}
 and probability:0.05
code:START_TEST(qstring_from_substr_test)

{

    QString *qs;



    qs = qstring_from_substr("virtualization", 3, 9);

    fail_unless(qs != NULL);

    fail_unless(strcmp(qstring_get_str(qs), "tualiza") == 0);



    QDECREF(qs);

}
 and probability:0.0
code:void qdev_prop_set_ptr(DeviceState *dev, const char *name, void *value)

{

    qdev_prop_set(dev, name, &value, PROP_TYPE_PTR);

}
 and probability:0.0
code:static void do_fp_ld(DisasContext *s, int destidx, TCGv_i64 tcg_addr, int size)

{

    /* This always zero-extends and writes to a full 128 bit wide vector */

    TCGv_i64 tmplo = tcg_temp_new_i64();

    TCGv_i64 tmphi;



    if (size < 4) {

        TCGMemOp memop = MO_TE + size;

        tmphi = tcg_const_i64(0);

        tcg_gen_qemu_ld_i64(tmplo, tcg_addr, get_mem_index(s), memop);

    } else {

        TCGv_i64 tcg_hiaddr;

        tmphi = tcg_temp_new_i64();

        tcg_hiaddr = tcg_temp_new_i64();



        tcg_gen_qemu_ld_i64(tmplo, tcg_addr, get_mem_index(s), MO_TEQ);

        tcg_gen_addi_i64(tcg_hiaddr, tcg_addr, 8);

        tcg_gen_qemu_ld_i64(tmphi, tcg_hiaddr, get_mem_index(s), MO_TEQ);

        tcg_temp_free_i64(tcg_hiaddr);

    }



    tcg_gen_st_i64(tmplo, cpu_env, fp_reg_offset(destidx, MO_64));

    tcg_gen_st_i64(tmphi, cpu_env, fp_reg_hi_offset(destidx));



    tcg_temp_free_i64(tmplo);

    tcg_temp_free_i64(tmphi);

}
 and probability:0.043478260869565216
code:static inline void gen_op_eval_fbne(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_or_tl(dst, dst, cpu_tmp0);

}
 and probability:0.0
code:av_cold int ff_alsa_open(AVFormatContext *ctx, snd_pcm_stream_t mode,

                         unsigned int *sample_rate,

                         int channels, enum CodecID *codec_id)

{

    AlsaData *s = ctx->priv_data;

    const char *audio_device;

    int res, flags = 0;

    snd_pcm_format_t format;

    snd_pcm_t *h;

    snd_pcm_hw_params_t *hw_params;

    snd_pcm_uframes_t buffer_size, period_size;

    int64_t layout = ctx->streams[0]->codec->channel_layout;



    if (ctx->filename[0] == 0) audio_device = "default";

    else                       audio_device = ctx->filename;



    if (*codec_id == CODEC_ID_NONE)

        *codec_id = DEFAULT_CODEC_ID;

    format = codec_id_to_pcm_format(*codec_id);

    if (format == SND_PCM_FORMAT_UNKNOWN) {

        av_log(ctx, AV_LOG_ERROR, "sample format 0x%04x is not supported\n", *codec_id);

        return AVERROR(ENOSYS);

    }

    s->frame_size = av_get_bits_per_sample(*codec_id) / 8 * channels;



    if (ctx->flags & AVFMT_FLAG_NONBLOCK) {

        flags = SND_PCM_NONBLOCK;

    }

    res = snd_pcm_open(&h, audio_device, mode, flags);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot open audio device %s (%s)\n",

               audio_device, snd_strerror(res));

        return AVERROR(EIO);

    }



    res = snd_pcm_hw_params_malloc(&hw_params);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot allocate hardware parameter structure (%s)\n",

               snd_strerror(res));

        goto fail1;

    }



    res = snd_pcm_hw_params_any(h, hw_params);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot initialize hardware parameter structure (%s)\n",

               snd_strerror(res));

        goto fail;

    }



    res = snd_pcm_hw_params_set_access(h, hw_params, SND_PCM_ACCESS_RW_INTERLEAVED);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set access type (%s)\n",

               snd_strerror(res));

        goto fail;

    }



    res = snd_pcm_hw_params_set_format(h, hw_params, format);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set sample format 0x%04x %d (%s)\n",

               *codec_id, format, snd_strerror(res));

        goto fail;

    }



    res = snd_pcm_hw_params_set_rate_near(h, hw_params, sample_rate, 0);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set sample rate (%s)\n",

               snd_strerror(res));

        goto fail;

    }



    res = snd_pcm_hw_params_set_channels(h, hw_params, channels);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set channel count to %d (%s)\n",

               channels, snd_strerror(res));

        goto fail;

    }



    snd_pcm_hw_params_get_buffer_size_max(hw_params, &buffer_size);

    buffer_size = FFMIN(buffer_size, ALSA_BUFFER_SIZE_MAX);

    /* TODO: maybe use ctx->max_picture_buffer somehow */

    res = snd_pcm_hw_params_set_buffer_size_near(h, hw_params, &buffer_size);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set ALSA buffer size (%s)\n",

               snd_strerror(res));

        goto fail;

    }



    snd_pcm_hw_params_get_period_size_min(hw_params, &period_size, NULL);

    if (!period_size)

        period_size = buffer_size / 4;

    res = snd_pcm_hw_params_set_period_size_near(h, hw_params, &period_size, NULL);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set ALSA period size (%s)\n",

               snd_strerror(res));

        goto fail;

    }

    s->period_size = period_size;



    res = snd_pcm_hw_params(h, hw_params);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, "cannot set parameters (%s)\n",

               snd_strerror(res));

        goto fail;

    }



    snd_pcm_hw_params_free(hw_params);



    if (channels > 2 && layout) {

        if (find_reorder_func(s, *codec_id, layout, mode == SND_PCM_STREAM_PLAYBACK) < 0) {

            char name[128];

            av_get_channel_layout_string(name, sizeof(name), channels, layout);

            av_log(ctx, AV_LOG_WARNING, "ALSA channel layout unknown or unimplemented for %s %s.\n",

                   name, mode == SND_PCM_STREAM_PLAYBACK ? "playback" : "capture");

        }

        if (s->reorder_func) {

            s->reorder_buf_size = buffer_size;

            s->reorder_buf = av_malloc(s->reorder_buf_size * s->frame_size);

            if (!s->reorder_buf)

                goto fail1;

        }

    }



    s->h = h;

    return 0;



fail:

    snd_pcm_hw_params_free(hw_params);

fail1:

    snd_pcm_close(h);

    return AVERROR(EIO);

}
 and probability:0.16521739130434782
code:bool kvm_arch_stop_on_emulation_error(CPUState *env)

{

      return !(env->cr[0] & CR0_PE_MASK) ||

              ((env->segs[R_CS].selector  & 3) != 3);

}
 and probability:0.4
code:static ssize_t block_crypto_write_func(QCryptoBlock *block,

                                       size_t offset,

                                       const uint8_t *buf,

                                       size_t buflen,

                                       Error **errp,

                                       void *opaque)

{

    struct BlockCryptoCreateData *data = opaque;

    ssize_t ret;



    ret = blk_pwrite(data->blk, offset, buf, buflen, 0);

    if (ret < 0) {

        error_setg_errno(errp, -ret, "Could not write encryption header");

        return ret;

    }

    return ret;

}
 and probability:0.0625
code:static int bdrv_check_perm(BlockDriverState *bs, uint64_t cumulative_perms,

                           uint64_t cumulative_shared_perms, Error **errp)

{

    BlockDriver *drv = bs->drv;

    BdrvChild *c;

    int ret;



    /* Write permissions never work with read-only images */

    if ((cumulative_perms & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)) &&

        bdrv_is_read_only(bs))

    {

        error_setg(errp, "Block node is read-only");

        return -EPERM;

    }



    /* Check this node */

    if (!drv) {

        return 0;

    }



    if (drv->bdrv_check_perm) {

        return drv->bdrv_check_perm(bs, cumulative_perms,

                                    cumulative_shared_perms, errp);

    }



    /* Drivers that never have children can omit .bdrv_child_perm() */

    if (!drv->bdrv_child_perm) {

        assert(QLIST_EMPTY(&bs->children));

        return 0;

    }



    /* Check all children */

    QLIST_FOREACH(c, &bs->children, next) {

        uint64_t cur_perm, cur_shared;

        drv->bdrv_child_perm(bs, c, c->role,

                             cumulative_perms, cumulative_shared_perms,

                             &cur_perm, &cur_shared);

        ret = bdrv_child_check_perm(c, cur_perm, cur_shared, errp);

        if (ret < 0) {

            return ret;

        }

    }



    return 0;

}
 and probability:0.1794871794871795
code:static void test_qemu_strtosz_simple(void)

{

    const char *str;

    char *endptr = NULL;

    int64_t res;



    str = "0";

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str + 1);



    str = "12345";

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 12345);

    g_assert(endptr == str + 5);



    res = qemu_strtosz(str, NULL);

    g_assert_cmpint(res, ==, 12345);



    /* Note: precision is 53 bits since we're parsing with strtod() */



    str = "9007199254740991"; /* 2^53-1 */

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0x1fffffffffffff);

    g_assert(endptr == str + 16);



    str = "9007199254740992"; /* 2^53 */

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0x20000000000000);

    g_assert(endptr == str + 16);



    str = "9007199254740993"; /* 2^53+1 */

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0x20000000000000); /* rounded to 53 bits */

    g_assert(endptr == str + 16);



    str = "9223372036854774784"; /* 0x7ffffffffffffc00 (53 msbs set) */

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0x7ffffffffffffc00);

    g_assert(endptr == str + 19);



    str = "9223372036854775295"; /* 0x7ffffffffffffdff */

    res = qemu_strtosz(str, &endptr);

    g_assert_cmpint(res, ==, 0x7ffffffffffffc00); /* rounded to 53 bits */

    g_assert(endptr == str + 19);



    /* 0x7ffffffffffffe00..0x7fffffffffffffff get rounded to

     * 0x8000000000000000, thus -ERANGE; see test_qemu_strtosz_erange() */

}
 and probability:0.1794871794871795
code:void vring_teardown(Vring *vring)

{

    hostmem_finalize(&vring->hostmem);

}
 and probability:0.25
code:static uint16_t nvme_rw(NvmeCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd,

    NvmeRequest *req)

{

    NvmeRwCmd *rw = (NvmeRwCmd *)cmd;

    uint32_t nlb  = le32_to_cpu(rw->nlb) + 1;

    uint64_t slba = le64_to_cpu(rw->slba);

    uint64_t prp1 = le64_to_cpu(rw->prp1);

    uint64_t prp2 = le64_to_cpu(rw->prp2);



    uint8_t lba_index  = NVME_ID_NS_FLBAS_INDEX(ns->id_ns.flbas);

    uint8_t data_shift = ns->id_ns.lbaf[lba_index].ds;

    uint64_t data_size = nlb << data_shift;

    uint64_t aio_slba  = slba << (data_shift - BDRV_SECTOR_BITS);

    int is_write = rw->opcode == NVME_CMD_WRITE ? 1 : 0;



    if ((slba + nlb) > ns->id_ns.nsze) {

        return NVME_LBA_RANGE | NVME_DNR;

    }

    if (nvme_map_prp(&req->qsg, prp1, prp2, data_size, n)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    assert((nlb << data_shift) == req->qsg.size);



    dma_acct_start(n->conf.bs, &req->acct, &req->qsg, is_write ?

        BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);

    req->aiocb = is_write ?

        dma_bdrv_write(n->conf.bs, &req->qsg, aio_slba, nvme_rw_cb, req) :

        dma_bdrv_read(n->conf.bs, &req->qsg, aio_slba, nvme_rw_cb, req);



    return NVME_NO_COMPLETE;

}
 and probability:0.5555555555555556
code:static int decode_block_progressive(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,

                                    int ac_index, int16_t *quant_matrix,

                                    int ss, int se, int Al, int *EOBRUN)

{

    int code, i, j, level, val, run;



    if(*EOBRUN){

        (*EOBRUN)--;

        return 0;

    }

    {OPEN_READER(re, &s->gb)

    for(i=ss;;i++) {

        UPDATE_CACHE(re, &s->gb);

        GET_VLC(code, re, &s->gb, s->vlcs[1][ac_index].table, 9, 2)

        /* Progressive JPEG use AC coeffs from zero and this decoder sets offset 16 by default */

        code -= 16;

        run = ((unsigned) code) >> 4;

        code &= 0xF;

        if(code) {

            i += run;

            if(code > MIN_CACHE_BITS - 16){

                UPDATE_CACHE(re, &s->gb)

            }

            {

                int cache=GET_CACHE(re,&s->gb);

                int sign=(~cache)>>31;

                level = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;

            }



            LAST_SKIP_BITS(re, &s->gb, code)



            if (i >= se) {

                if(i == se){

                    j = s->scantable.permutated[se];

                    block[j] = level * quant_matrix[j] << Al;

                    break;

                }

                av_log(s->avctx, AV_LOG_ERROR, "error count: %d\n", i);

                return -1;

            }

            j = s->scantable.permutated[i];

            block[j] = level * quant_matrix[j] << Al;

        }else{

            if(run == 0xF){// ZRL - skip 15 coefficients

                i += 15;

            }else{

                val = (1 << run);

                if(run){

                    UPDATE_CACHE(re, &s->gb);

                    val += NEG_USR32(GET_CACHE(re, &s->gb), run);

                    LAST_SKIP_BITS(re, &s->gb, run);

                }

                *EOBRUN = val - 1;

                break;

            }

        }

    }

    CLOSE_READER(re, &s->gb)}

    if(i > *last_nnz)

        *last_nnz = i;

    return 0;

}
 and probability:0.423728813559322
code:static int dca_subframe_header(DCAContext *s, int base_channel, int block_index)

{

    /* Primary audio coding side information */

    int j, k;



    if (get_bits_left(&s->gb) < 0)

        return AVERROR_INVALIDDATA;



    if (!base_channel) {

        s->subsubframes[s->current_subframe]    = get_bits(&s->gb, 2) + 1;

        s->partial_samples[s->current_subframe] = get_bits(&s->gb, 3);

    }



    for (j = base_channel; j < s->prim_channels; j++) {

        for (k = 0; k < s->subband_activity[j]; k++)

            s->prediction_mode[j][k] = get_bits(&s->gb, 1);

    }



    /* Get prediction codebook */

    for (j = base_channel; j < s->prim_channels; j++) {

        for (k = 0; k < s->subband_activity[j]; k++) {

            if (s->prediction_mode[j][k] > 0) {

                /* (Prediction coefficient VQ address) */

                s->prediction_vq[j][k] = get_bits(&s->gb, 12);

            }

        }

    }



    /* Bit allocation index */

    for (j = base_channel; j < s->prim_channels; j++) {

        for (k = 0; k < s->vq_start_subband[j]; k++) {

            if (s->bitalloc_huffman[j] == 6)

                s->bitalloc[j][k] = get_bits(&s->gb, 5);

            else if (s->bitalloc_huffman[j] == 5)

                s->bitalloc[j][k] = get_bits(&s->gb, 4);

            else if (s->bitalloc_huffman[j] == 7) {

                av_log(s->avctx, AV_LOG_ERROR,

                       "Invalid bit allocation index\n");

                return AVERROR_INVALIDDATA;

            } else {

                s->bitalloc[j][k] =

                    get_bitalloc(&s->gb, &dca_bitalloc_index, s->bitalloc_huffman[j]);

            }



            if (s->bitalloc[j][k] > 26) {

                // av_log(s->avctx, AV_LOG_DEBUG, "bitalloc index [%i][%i] too big (%i)\n",

                //        j, k, s->bitalloc[j][k]);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    /* Transition mode */

    for (j = base_channel; j < s->prim_channels; j++) {

        for (k = 0; k < s->subband_activity[j]; k++) {

            s->transition_mode[j][k] = 0;

            if (s->subsubframes[s->current_subframe] > 1 &&

                k < s->vq_start_subband[j] && s->bitalloc[j][k] > 0) {

                s->transition_mode[j][k] =

                    get_bitalloc(&s->gb, &dca_tmode, s->transient_huffman[j]);

            }

        }

    }



    if (get_bits_left(&s->gb) < 0)

        return AVERROR_INVALIDDATA;



    for (j = base_channel; j < s->prim_channels; j++) {

        const uint32_t *scale_table;

        int scale_sum;



        memset(s->scale_factor[j], 0,

               s->subband_activity[j] * sizeof(s->scale_factor[0][0][0]) * 2);



        if (s->scalefactor_huffman[j] == 6)

            scale_table = scale_factor_quant7;

        else

            scale_table = scale_factor_quant6;



        /* When huffman coded, only the difference is encoded */

        scale_sum = 0;



        for (k = 0; k < s->subband_activity[j]; k++) {

            if (k >= s->vq_start_subband[j] || s->bitalloc[j][k] > 0) {

                scale_sum = get_scale(&s->gb, s->scalefactor_huffman[j], scale_sum);

                s->scale_factor[j][k][0] = scale_table[scale_sum];

            }



            if (k < s->vq_start_subband[j] && s->transition_mode[j][k]) {

                /* Get second scale factor */

                scale_sum = get_scale(&s->gb, s->scalefactor_huffman[j], scale_sum);

                s->scale_factor[j][k][1] = scale_table[scale_sum];

            }

        }

    }



    /* Joint subband scale factor codebook select */

    for (j = base_channel; j < s->prim_channels; j++) {

        /* Transmitted only if joint subband coding enabled */

        if (s->joint_intensity[j] > 0)

            s->joint_huff[j] = get_bits(&s->gb, 3);

    }



    if (get_bits_left(&s->gb) < 0)

        return AVERROR_INVALIDDATA;



    /* Scale factors for joint subband coding */

    for (j = base_channel; j < s->prim_channels; j++) {

        int source_channel;



        /* Transmitted only if joint subband coding enabled */

        if (s->joint_intensity[j] > 0) {

            int scale = 0;

            source_channel = s->joint_intensity[j] - 1;



            /* When huffman coded, only the difference is encoded

             * (is this valid as well for joint scales ???) */



            for (k = s->subband_activity[j]; k < s->subband_activity[source_channel]; k++) {

                scale = get_scale(&s->gb, s->joint_huff[j], 0);

                scale += 64;    /* bias */

                s->joint_scale_factor[j][k] = scale;    /*joint_scale_table[scale]; */

            }



            if (!(s->debug_flag & 0x02)) {

                av_log(s->avctx, AV_LOG_DEBUG,

                       "Joint stereo coding not supported\n");

                s->debug_flag |= 0x02;

            }

        }

    }



    /* Stereo downmix coefficients */

    if (!base_channel && s->prim_channels > 2) {

        if (s->downmix) {

            for (j = base_channel; j < s->prim_channels; j++) {

                s->downmix_coef[j][0] = get_bits(&s->gb, 7);

                s->downmix_coef[j][1] = get_bits(&s->gb, 7);

            }

        } else {

            int am = s->amode & DCA_CHANNEL_MASK;

            for (j = base_channel; j < s->prim_channels; j++) {

                s->downmix_coef[j][0] = dca_default_coeffs[am][j][0];

                s->downmix_coef[j][1] = dca_default_coeffs[am][j][1];

            }

        }

    }



    /* Dynamic range coefficient */

    if (!base_channel && s->dynrange)

        s->dynrange_coef = get_bits(&s->gb, 8);



    /* Side information CRC check word */

    if (s->crc_present) {

        get_bits(&s->gb, 16);

    }



    /*

     * Primary audio data arrays

     */



    /* VQ encoded high frequency subbands */

    for (j = base_channel; j < s->prim_channels; j++)

        for (k = s->vq_start_subband[j]; k < s->subband_activity[j]; k++)

            /* 1 vector -> 32 samples */

            s->high_freq_vq[j][k] = get_bits(&s->gb, 10);



    /* Low frequency effect data */

    if (!base_channel && s->lfe) {

        /* LFE samples */

        int lfe_samples = 2 * s->lfe * (4 + block_index);

        int lfe_end_sample = 2 * s->lfe * (4 + block_index + s->subsubframes[s->current_subframe]);

        float lfe_scale;



        for (j = lfe_samples; j < lfe_end_sample; j++) {

            /* Signed 8 bits int */

            s->lfe_data[j] = get_sbits(&s->gb, 8);

        }



        /* Scale factor index */

        s->lfe_scale_factor = scale_factor_quant7[get_bits(&s->gb, 8)];



        /* Quantization step size * scale factor */

        lfe_scale = 0.035 * s->lfe_scale_factor;



        for (j = lfe_samples; j < lfe_end_sample; j++)

            s->lfe_data[j] *= lfe_scale;

    }



#ifdef TRACE

    av_log(s->avctx, AV_LOG_DEBUG, "subsubframes: %i\n",

           s->subsubframes[s->current_subframe]);

    av_log(s->avctx, AV_LOG_DEBUG, "partial samples: %i\n",

           s->partial_samples[s->current_subframe]);



    for (j = base_channel; j < s->prim_channels; j++) {

        av_log(s->avctx, AV_LOG_DEBUG, "prediction mode:");

        for (k = 0; k < s->subband_activity[j]; k++)

            av_log(s->avctx, AV_LOG_DEBUG, " %i", s->prediction_mode[j][k]);

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

    for (j = base_channel; j < s->prim_channels; j++) {

        for (k = 0; k < s->subband_activity[j]; k++)

            av_log(s->avctx, AV_LOG_DEBUG,

                   "prediction coefs: %f, %f, %f, %f\n",

                   (float) adpcm_vb[s->prediction_vq[j][k]][0] / 8192,

                   (float) adpcm_vb[s->prediction_vq[j][k]][1] / 8192,

                   (float) adpcm_vb[s->prediction_vq[j][k]][2] / 8192,

                   (float) adpcm_vb[s->prediction_vq[j][k]][3] / 8192);

    }

    for (j = base_channel; j < s->prim_channels; j++) {

        av_log(s->avctx, AV_LOG_DEBUG, "bitalloc index: ");

        for (k = 0; k < s->vq_start_subband[j]; k++)

            av_log(s->avctx, AV_LOG_DEBUG, "%2.2i ", s->bitalloc[j][k]);

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

    for (j = base_channel; j < s->prim_channels; j++) {

        av_log(s->avctx, AV_LOG_DEBUG, "Transition mode:");

        for (k = 0; k < s->subband_activity[j]; k++)

            av_log(s->avctx, AV_LOG_DEBUG, " %i", s->transition_mode[j][k]);

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

    for (j = base_channel; j < s->prim_channels; j++) {

        av_log(s->avctx, AV_LOG_DEBUG, "Scale factor:");

        for (k = 0; k < s->subband_activity[j]; k++) {

            if (k >= s->vq_start_subband[j] || s->bitalloc[j][k] > 0)

                av_log(s->avctx, AV_LOG_DEBUG, " %i", s->scale_factor[j][k][0]);

            if (k < s->vq_start_subband[j] && s->transition_mode[j][k])

                av_log(s->avctx, AV_LOG_DEBUG, " %i(t)", s->scale_factor[j][k][1]);

        }

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

    for (j = base_channel; j < s->prim_channels; j++) {

        if (s->joint_intensity[j] > 0) {

            int source_channel = s->joint_intensity[j] - 1;

            av_log(s->avctx, AV_LOG_DEBUG, "Joint scale factor index:\n");

            for (k = s->subband_activity[j]; k < s->subband_activity[source_channel]; k++)

                av_log(s->avctx, AV_LOG_DEBUG, " %i", s->joint_scale_factor[j][k]);

            av_log(s->avctx, AV_LOG_DEBUG, "\n");

        }

    }

    if (!base_channel && s->prim_channels > 2 && s->downmix) {

        av_log(s->avctx, AV_LOG_DEBUG, "Downmix coeffs:\n");

        for (j = 0; j < s->prim_channels; j++) {

            av_log(s->avctx, AV_LOG_DEBUG, "Channel 0, %d = %f\n", j,

                   dca_downmix_coeffs[s->downmix_coef[j][0]]);

            av_log(s->avctx, AV_LOG_DEBUG, "Channel 1, %d = %f\n", j,

                   dca_downmix_coeffs[s->downmix_coef[j][1]]);

        }

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

    for (j = base_channel; j < s->prim_channels; j++)

        for (k = s->vq_start_subband[j]; k < s->subband_activity[j]; k++)

            av_log(s->avctx, AV_LOG_DEBUG, "VQ index: %i\n", s->high_freq_vq[j][k]);

    if (!base_channel && s->lfe) {

        int lfe_samples = 2 * s->lfe * (4 + block_index);

        int lfe_end_sample = 2 * s->lfe * (4 + block_index + s->subsubframes[s->current_subframe]);



        av_log(s->avctx, AV_LOG_DEBUG, "LFE samples:\n");

        for (j = lfe_samples; j < lfe_end_sample; j++)

            av_log(s->avctx, AV_LOG_DEBUG, " %f", s->lfe_data[j]);

        av_log(s->avctx, AV_LOG_DEBUG, "\n");

    }

#endif



    return 0;

}
 and probability:0.5948275862068966
code:static int vc1_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    VC1Context *v = avctx->priv_data;

    MpegEncContext *s = &v->s;

    AVFrame *pict = data;

    uint8_t *buf2 = NULL;

    const uint8_t *buf_start = buf;



    /* no supplementary picture */

    if (buf_size == 0) {

        /* special case for last picture */

        if (s->low_delay==0 && s->next_picture_ptr) {

            *pict= *(AVFrame*)s->next_picture_ptr;

            s->next_picture_ptr= NULL;



            *data_size = sizeof(AVFrame);

        }



        return 0;

    }



    /* We need to set current_picture_ptr before reading the header,

     * otherwise we cannot store anything in there. */

    if(s->current_picture_ptr==NULL || s->current_picture_ptr->data[0]){

        int i= ff_find_unused_picture(s, 0);

        s->current_picture_ptr= &s->picture[i];

    }



    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){

        if (v->profile < PROFILE_ADVANCED)

            avctx->pix_fmt = PIX_FMT_VDPAU_WMV3;

        else

            avctx->pix_fmt = PIX_FMT_VDPAU_VC1;

    }



    //for advanced profile we may need to parse and unescape data

    if (avctx->codec_id == CODEC_ID_VC1) {

        int buf_size2 = 0;

        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);



        if(IS_MARKER(AV_RB32(buf))){ /* frame starts with marker and needs to be parsed */

            const uint8_t *start, *end, *next;

            int size;



            next = buf;

            for(start = buf, end = buf + buf_size; next < end; start = next){

                next = find_next_marker(start + 4, end);

                size = next - start - 4;

                if(size <= 0) continue;

                switch(AV_RB32(start)){

                case VC1_CODE_FRAME:

                    if (avctx->hwaccel ||

                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                        buf_start = start;

                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);

                    break;

                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */

                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);

                    init_get_bits(&s->gb, buf2, buf_size2*8);

                    vc1_decode_entry_point(avctx, v, &s->gb);

                    break;

                case VC1_CODE_SLICE:

                    av_log(avctx, AV_LOG_ERROR, "Sliced decoding is not implemented (yet)\n");

                    av_free(buf2);

                    return -1;

                }

            }

        }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ /* WVC1 interlaced stores both fields divided by marker */

            const uint8_t *divider;



            divider = find_next_marker(buf, buf + buf_size);

            if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){

                av_log(avctx, AV_LOG_ERROR, "Error in WVC1 interlaced frame\n");

                av_free(buf2);

                return -1;

            }



            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);

            // TODO

            av_free(buf2);return -1;

        }else{

            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);

        }

        init_get_bits(&s->gb, buf2, buf_size2*8);

    } else

        init_get_bits(&s->gb, buf, buf_size*8);

    // do parse frame header

    if(v->profile < PROFILE_ADVANCED) {

        if(vc1_parse_frame_header(v, &s->gb) == -1) {

            av_free(buf2);

            return -1;

        }

    } else {

        if(vc1_parse_frame_header_adv(v, &s->gb) == -1) {

            av_free(buf2);

            return -1;

        }

    }



    if(s->pict_type != FF_I_TYPE && !v->res_rtm_flag){

        av_free(buf2);

        return -1;

    }



    // for hurry_up==5

    s->current_picture.pict_type= s->pict_type;

    s->current_picture.key_frame= s->pict_type == FF_I_TYPE;



    /* skip B-frames if we don't have reference frames */

    if(s->last_picture_ptr==NULL && (s->pict_type==FF_B_TYPE || s->dropable)){

        av_free(buf2);

        return -1;//buf_size;

    }

    /* skip b frames if we are in a hurry */

    if(avctx->hurry_up && s->pict_type==FF_B_TYPE) return -1;//buf_size;

    if(   (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==FF_B_TYPE)

       || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=FF_I_TYPE)

       ||  avctx->skip_frame >= AVDISCARD_ALL) {

        av_free(buf2);

        return buf_size;

    }

    /* skip everything if we are in a hurry>=5 */

    if(avctx->hurry_up>=5) {

        av_free(buf2);

        return -1;//buf_size;

    }



    if(s->next_p_frame_damaged){

        if(s->pict_type==FF_B_TYPE)

            return buf_size;

        else

            s->next_p_frame_damaged=0;

    }



    if(MPV_frame_start(s, avctx) < 0) {

        av_free(buf2);

        return -1;

    }



    s->me.qpel_put= s->dsp.put_qpel_pixels_tab;

    s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab;



    if ((CONFIG_VC1_VDPAU_DECODER || CONFIG_WMV3_VDPAU_DECODER)

        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);

    else if (avctx->hwaccel) {

        if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0)

            return -1;

        if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)

            return -1;

        if (avctx->hwaccel->end_frame(avctx) < 0)

            return -1;

    } else {

        ff_er_frame_start(s);



        v->bits = buf_size * 8;

        vc1_decode_blocks(v);

//av_log(s->avctx, AV_LOG_INFO, "Consumed %i/%i bits\n", get_bits_count(&s->gb), buf_size*8);

//  if(get_bits_count(&s->gb) > buf_size * 8)

//      return -1;

        ff_er_frame_end(s);

    }



    MPV_frame_end(s);



assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);

assert(s->current_picture.pict_type == s->pict_type);

    if (s->pict_type == FF_B_TYPE || s->low_delay) {

        *pict= *(AVFrame*)s->current_picture_ptr;

    } else if (s->last_picture_ptr != NULL) {

        *pict= *(AVFrame*)s->last_picture_ptr;

    }



    if(s->last_picture_ptr || s->low_delay){

        *data_size = sizeof(AVFrame);

        ff_print_debug_info(s, pict);

    }



    av_free(buf2);

    return buf_size;

}
 and probability:0.38650306748466257
code:static void ff_h264_idct_add8_mmx2(uint8_t **dest, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){

    int i;

    for(i=16; i<16+8; i++){

        if(nnzc[ scan8[i] ])

            ff_h264_idct_add_mmx    (dest[(i&4)>>2] + block_offset[i], block + i*16, stride);

        else if(block[i*16])

            ff_h264_idct_dc_add_mmx2(dest[(i&4)>>2] + block_offset[i], block + i*16, stride);

    }

}
 and probability:0.6666666666666666
code:int ff_isom_write_avcc(AVIOContext *pb, const uint8_t *data, int len)

{

    if (len > 6) {

        /* check for h264 start code */

        if (AV_RB32(data) == 0x00000001 ||

            AV_RB24(data) == 0x000001) {

            uint8_t *buf=NULL, *end, *start;

            uint32_t sps_size=0, pps_size=0;

            uint8_t *sps=0, *pps=0;



            int ret = ff_avc_parse_nal_units_buf(data, &buf, &len);

            if (ret < 0)

                return ret;

            start = buf;

            end = buf + len;



            /* look for sps and pps */

            while (buf < end) {

                unsigned int size;

                uint8_t nal_type;

                size = AV_RB32(buf);

                nal_type = buf[4] & 0x1f;

                if (nal_type == 7) { /* SPS */

                    sps = buf + 4;

                    sps_size = size;

                } else if (nal_type == 8) { /* PPS */

                    pps = buf + 4;

                    pps_size = size;

                }

                buf += size + 4;

            }

            assert(sps);

            assert(pps);



            avio_w8(pb, 1); /* version */

            avio_w8(pb, sps[1]); /* profile */

            avio_w8(pb, sps[2]); /* profile compat */

            avio_w8(pb, sps[3]); /* level */

            avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */

            avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */



            avio_wb16(pb, sps_size);

            avio_write(pb, sps, sps_size);

            avio_w8(pb, 1); /* number of pps */

            avio_wb16(pb, pps_size);

            avio_write(pb, pps, pps_size);

            av_free(start);

        } else {

            avio_write(pb, data, len);

        }

    }

    return 0;

}
 and probability:0.16326530612244897
code:static void uninit(struct vf_instance *vf)

{

    free(vf->priv);

}
 and probability:0.25
code:static ExitStatus trans_fop_dew_0c(DisasContext *ctx, uint32_t insn,

                                   const DisasInsn *di)

{

    unsigned rt = extract32(insn, 0, 5);

    unsigned ra = extract32(insn, 21, 5);

    return do_fop_dew(ctx, rt, ra, di->f_dew);

}
 and probability:0.14285714285714285
code:static void test_dispatch_cmd_io(void)

{

    QDict *req = qdict_new();

    QDict *args = qdict_new();

    QDict *args3 = qdict_new();

    QDict *ud1a = qdict_new();

    QDict *ud1b = qdict_new();

    QDict *ret, *ret_dict, *ret_dict_dict, *ret_dict_dict_userdef;

    QDict *ret_dict_dict2, *ret_dict_dict2_userdef;

    QInt *ret3;



    qdict_put_obj(ud1a, "integer", QOBJECT(qint_from_int(42)));

    qdict_put_obj(ud1a, "string", QOBJECT(qstring_from_str("hello")));

    qdict_put_obj(ud1b, "integer", QOBJECT(qint_from_int(422)));

    qdict_put_obj(ud1b, "string", QOBJECT(qstring_from_str("hello2")));

    qdict_put_obj(args, "ud1a", QOBJECT(ud1a));

    qdict_put_obj(args, "ud1b", QOBJECT(ud1b));

    qdict_put_obj(req, "arguments", QOBJECT(args));

    qdict_put_obj(req, "execute", QOBJECT(qstring_from_str("user_def_cmd2")));



    ret = qobject_to_qdict(test_qmp_dispatch(req));



    assert(!strcmp(qdict_get_str(ret, "string"), "blah1"));

    ret_dict = qdict_get_qdict(ret, "dict");

    assert(!strcmp(qdict_get_str(ret_dict, "string"), "blah2"));

    ret_dict_dict = qdict_get_qdict(ret_dict, "dict");

    ret_dict_dict_userdef = qdict_get_qdict(ret_dict_dict, "userdef");

    assert(qdict_get_int(ret_dict_dict_userdef, "integer") == 42);

    assert(!strcmp(qdict_get_str(ret_dict_dict_userdef, "string"), "hello"));

    assert(!strcmp(qdict_get_str(ret_dict_dict, "string"), "blah3"));

    ret_dict_dict2 = qdict_get_qdict(ret_dict, "dict2");

    ret_dict_dict2_userdef = qdict_get_qdict(ret_dict_dict2, "userdef");

    assert(qdict_get_int(ret_dict_dict2_userdef, "integer") == 422);

    assert(!strcmp(qdict_get_str(ret_dict_dict2_userdef, "string"), "hello2"));

    assert(!strcmp(qdict_get_str(ret_dict_dict2, "string"), "blah4"));

    QDECREF(ret);



    qdict_put(args3, "a", qint_from_int(66));

    qdict_put(req, "arguments", args3);

    qdict_put(req, "execute", qstring_from_str("user_def_cmd3"));



    ret3 = qobject_to_qint(test_qmp_dispatch(req));

    assert(qint_get_int(ret3) == 66);

    QDECREF(ret);



    QDECREF(req);

}
 and probability:0.0
code:int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,

                                 int nb_sectors)

{

    BdrvTrackedRequest req;

    int max_discard, ret;



    if (!bs->drv) {

        return -ENOMEDIUM;

    }



    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    } else if (bs->read_only) {

        return -EPERM;

    }

    assert(!(bs->open_flags & BDRV_O_INACTIVE));



    /* Do nothing if disabled.  */

    if (!(bs->open_flags & BDRV_O_UNMAP)) {

        return 0;

    }



    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {

        return 0;

    }



    tracked_request_begin(&req, bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, BDRV_TRACKED_DISCARD);



    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, &req);

    if (ret < 0) {

        goto out;

    }



    max_discard = MIN_NON_ZERO(bs->bl.max_pdiscard >> BDRV_SECTOR_BITS,

                               BDRV_REQUEST_MAX_SECTORS);

    while (nb_sectors > 0) {

        int ret;

        int num = nb_sectors;

        int discard_alignment = bs->bl.pdiscard_alignment >> BDRV_SECTOR_BITS;



        /* align request */

        if (discard_alignment &&

            num >= discard_alignment &&

            sector_num % discard_alignment) {

            if (num > discard_alignment) {

                num = discard_alignment;

            }

            num -= sector_num % discard_alignment;

        }



        /* limit request size */

        if (num > max_discard) {

            num = max_discard;

        }



        if (bs->drv->bdrv_co_discard) {

            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);

        } else {

            BlockAIOCB *acb;

            CoroutineIOCompletion co = {

                .coroutine = qemu_coroutine_self(),

            };



            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,

                                            bdrv_co_io_em_complete, &co);

            if (acb == NULL) {

                ret = -EIO;

                goto out;

            } else {

                qemu_coroutine_yield();

                ret = co.ret;

            }

        }

        if (ret && ret != -ENOTSUP) {

            goto out;

        }



        sector_num += num;

        nb_sectors -= num;

    }

    ret = 0;

out:


    bdrv_set_dirty(bs, req.offset >> BDRV_SECTOR_BITS,

                   req.bytes >> BDRV_SECTOR_BITS);

    tracked_request_end(&req);

    return ret;

} and probability:0.19480519480519481
code:static CCW1 copy_ccw_from_guest(hwaddr addr, bool fmt1)

{

    CCW0 tmp0;

    CCW1 tmp1;

    CCW1 ret;



    if (fmt1) {

        cpu_physical_memory_read(addr, &tmp1, sizeof(tmp1));

        ret.cmd_code = tmp1.cmd_code;

        ret.flags = tmp1.flags;

        ret.count = be16_to_cpu(tmp1.count);

        ret.cda = be32_to_cpu(tmp1.cda);

    } else {

        cpu_physical_memory_read(addr, &tmp0, sizeof(tmp0));

        ret.cmd_code = tmp0.cmd_code;

        ret.flags = tmp0.flags;

        ret.count = be16_to_cpu(tmp0.count);

        ret.cda = be16_to_cpu(tmp0.cda1) | (tmp0.cda0 << 16);

        if ((ret.cmd_code & 0x0f) == CCW_CMD_TIC) {

            ret.cmd_code &= 0x0f;

        }

    }

    return ret;

}
 and probability:0.0
code:static int tosa_dac_init(I2CSlave *i2c)

{

    /* Nothing to do.  */

    return 0;

}
 and probability:0.0
code:CharDriverState *qemu_chr_open_eventfd(int eventfd)

{

    CharDriverState *chr = qemu_chr_open_fd(eventfd, eventfd);



    if (chr) {

        chr->avail_connections = 1;

    }



    return chr;

}
 and probability:0.125
code:static CharDriverState *qmp_chardev_open_socket(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    CharDriverState *chr;

    TCPCharDriver *s;

    ChardevSocket *sock = backend->u.socket;

    SocketAddress *addr = sock->addr;

    bool do_nodelay     = sock->has_nodelay ? sock->nodelay : false;

    bool is_listen      = sock->has_server  ? sock->server  : true;

    bool is_telnet      = sock->has_telnet  ? sock->telnet  : false;

    bool is_waitconnect = sock->has_wait    ? sock->wait    : false;

    int64_t reconnect   = sock->has_reconnect ? sock->reconnect : 0;

    ChardevCommon *common = qapi_ChardevSocket_base(sock);

    QIOChannelSocket *sioc = NULL;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    s = g_new0(TCPCharDriver, 1);



    s->is_unix = addr->type == SOCKET_ADDRESS_KIND_UNIX;

    s->is_listen = is_listen;

    s->is_telnet = is_telnet;

    s->do_nodelay = do_nodelay;

    if (sock->tls_creds) {

        Object *creds;

        creds = object_resolve_path_component(

            object_get_objects_root(), sock->tls_creds);

        if (!creds) {

            error_setg(errp, "No TLS credentials with id '%s'",

                       sock->tls_creds);

            goto error;

        }

        s->tls_creds = (QCryptoTLSCreds *)

            object_dynamic_cast(creds,

                                TYPE_QCRYPTO_TLS_CREDS);

        if (!s->tls_creds) {

            error_setg(errp, "Object with id '%s' is not TLS credentials",

                       sock->tls_creds);

            goto error;

        }

        object_ref(OBJECT(s->tls_creds));

        if (is_listen) {

            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_SERVER) {

                error_setg(errp, "%s",

                           "Expected TLS credentials for server endpoint");

                goto error;

            }

        } else {

            if (s->tls_creds->endpoint != QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT) {

                error_setg(errp, "%s",

                           "Expected TLS credentials for client endpoint");

                goto error;

            }

        }

    }



    qapi_copy_SocketAddress(&s->addr, sock->addr);



    chr->opaque = s;

    chr->chr_write = tcp_chr_write;

    chr->chr_sync_read = tcp_chr_sync_read;

    chr->chr_close = tcp_chr_close;

    chr->get_msgfds = tcp_get_msgfds;

    chr->set_msgfds = tcp_set_msgfds;

    chr->chr_add_client = tcp_chr_add_client;

    chr->chr_add_watch = tcp_chr_add_watch;

    chr->chr_update_read_handler = tcp_chr_update_read_handler;

    /* be isn't opened until we get a connection */

    chr->explicit_be_open = true;



    chr->filename = SocketAddress_to_str("disconnected:",

                                         addr, is_listen, is_telnet);



    if (is_listen) {

        if (is_telnet) {

            s->do_telnetopt = 1;

        }

    } else if (reconnect > 0) {

        s->reconnect_time = reconnect;

    }



    sioc = qio_channel_socket_new();

    if (s->reconnect_time) {

        qio_channel_socket_connect_async(sioc, s->addr,

                                         qemu_chr_socket_connected,

                                         chr, NULL);

    } else if (s->is_listen) {

        if (qio_channel_socket_listen_sync(sioc, s->addr, errp) < 0) {

            goto error;

        }

        s->listen_ioc = sioc;

        if (is_waitconnect) {

            fprintf(stderr, "QEMU waiting for connection on: %s\n",

                    chr->filename);

            tcp_chr_accept(QIO_CHANNEL(s->listen_ioc), G_IO_IN, chr);

        }

        qio_channel_set_blocking(QIO_CHANNEL(s->listen_ioc), false, NULL);

        if (!s->ioc) {

            s->listen_tag = qio_channel_add_watch(

                QIO_CHANNEL(s->listen_ioc), G_IO_IN, tcp_chr_accept, chr, NULL);

        }

    } else {

        if (qio_channel_socket_connect_sync(sioc, s->addr, errp) < 0) {

            goto error;

        }

        tcp_chr_new_client(chr, sioc);

        object_unref(OBJECT(sioc));

    }



    return chr;



 error:

    if (sioc) {

        object_unref(OBJECT(sioc));

    }

    if (s->tls_creds) {

        object_unref(OBJECT(s->tls_creds));

    }

    g_free(s);

    qemu_chr_free_common(chr);

    return NULL;

}
 and probability:0.41025641025641024
code:uint64_t ldq_le_phys(target_phys_addr_t addr)

{

    return ldq_phys_internal(addr, DEVICE_LITTLE_ENDIAN);

}
 and probability:0.0
code:static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    MpegEncContext *s = avctx->priv_data;

    AVFrame *pict = data;

    int i, ret;

    int slice_count;

    const uint8_t *slices_hdr = NULL;



    av_dlog(avctx, "*****frame %d size=%d\n", avctx->frame_number, buf_size);



    /* no supplementary picture */

    if (buf_size == 0) {

        return 0;

    }



    if (!avctx->slice_count) {

        slice_count = (*buf++) + 1;

        buf_size--;



        if (!slice_count || buf_size <= 8 * slice_count) {

            av_log(avctx, AV_LOG_ERROR, "Invalid slice count: %d.\n",

                   slice_count);

            return AVERROR_INVALIDDATA;

        }



        slices_hdr = buf + 4;

        buf       += 8 * slice_count;

        buf_size  -= 8 * slice_count;

    } else

        slice_count = avctx->slice_count;



    for (i = 0; i < slice_count; i++) {

        unsigned offset = get_slice_offset(avctx, slices_hdr, i);

        int size, size2;



        if (offset >= buf_size)

            return AVERROR_INVALIDDATA;



        if (i + 1 == slice_count)

            size = buf_size - offset;

        else

            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;



        if (i + 2 >= slice_count)

            size2 = buf_size - offset;

        else

            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;



        if (size <= 0 || size2 <= 0 ||

            offset + FFMAX(size, size2) > buf_size)

            return AVERROR_INVALIDDATA;



        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)

            return ret;



        if (ret > 8 * size)

            i++;

    }



    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {

        ff_er_frame_end(&s->er);

        ff_mpv_frame_end(s);



        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            if ((ret = av_frame_ref(pict, s->current_picture_ptr->f)) < 0)

                return ret;

            ff_print_debug_info(s, s->current_picture_ptr);

        } else if (s->last_picture_ptr != NULL) {

            if ((ret = av_frame_ref(pict, s->last_picture_ptr->f)) < 0)

                return ret;

            ff_print_debug_info(s, s->last_picture_ptr);

        }



        if (s->last_picture_ptr || s->low_delay) {

            *got_frame = 1;

        }



        // so we can detect if frame_end was not called (find some nicer solution...)

        s->current_picture_ptr = NULL;

    }



    return avpkt->size;

}
 and probability:0.5072463768115942
code:void xen_config_cleanup(void)

{

    struct xs_dirs *d;



    TAILQ_FOREACH(d, &xs_cleanup, list) {

	xs_rm(xenstore, 0, d->xs_dir);

    }

}
 and probability:0.14285714285714285
code:uint64_t helper_frsqrte(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;



    farg.ll = arg;



    if (unlikely(float64_is_neg(farg.d) && !float64_is_zero(farg.d))) {

        /* Reciprocal square root of a negative nonzero number */

        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSQRT, 1);

    } else {

        if (unlikely(float64_is_signaling_nan(farg.d))) {

            /* sNaN reciprocal square root */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);

        }

        farg.d = float64_sqrt(farg.d, &env->fp_status);

        farg.d = float64_div(float64_one, farg.d, &env->fp_status);

    }

    return farg.ll;

}
 and probability:0.11764705882352941
code:static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,

                                    uint64_t value, unsigned size,

                                    MemTxAttrs attrs)

{

    int ret = 0;

    MSIMessage from = {}, to = {};



    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;

    from.data = (uint32_t) value;



    ret = vtd_interrupt_remap_msi(opaque, &from, &to);

    if (ret) {

        /* TODO: report error */

        VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64

                    " data 0x%"PRIx32, from.address, from.data);

        /* Drop this interrupt */

        return MEMTX_ERROR;

    }



    VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32

                " for device sid 0x%04x",

                to.address, to.data, sid);



    if (dma_memory_write(&address_space_memory, to.address,

                         &to.data, size)) {

        VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64

                    " value 0x%"PRIx32, to.address, to.data);

    }



    return MEMTX_OK;

}
 and probability:0.038461538461538464
code:static int vmdk_read_extent(VmdkExtent *extent, int64_t cluster_offset,

                            int64_t offset_in_cluster, QEMUIOVector *qiov,

                            int bytes)

{

    int ret;

    int cluster_bytes, buf_bytes;

    uint8_t *cluster_buf, *compressed_data;

    uint8_t *uncomp_buf;

    uint32_t data_len;

    VmdkGrainMarker *marker;

    uLongf buf_len;





    if (!extent->compressed) {

        ret = bdrv_co_preadv(extent->file->bs,

                             cluster_offset + offset_in_cluster, bytes,

                             qiov, 0);

        if (ret < 0) {

            return ret;

        }

        return 0;

    }

    cluster_bytes = extent->cluster_sectors * 512;

    /* Read two clusters in case GrainMarker + compressed data > one cluster */

    buf_bytes = cluster_bytes * 2;

    cluster_buf = g_malloc(buf_bytes);

    uncomp_buf = g_malloc(cluster_bytes);

    ret = bdrv_pread(extent->file,

                cluster_offset,

                cluster_buf, buf_bytes);

    if (ret < 0) {

        goto out;

    }

    compressed_data = cluster_buf;

    buf_len = cluster_bytes;

    data_len = cluster_bytes;

    if (extent->has_marker) {

        marker = (VmdkGrainMarker *)cluster_buf;

        compressed_data = marker->data;

        data_len = le32_to_cpu(marker->size);

    }

    if (!data_len || data_len > buf_bytes) {

        ret = -EINVAL;

        goto out;

    }

    ret = uncompress(uncomp_buf, &buf_len, compressed_data, data_len);

    if (ret != Z_OK) {

        ret = -EINVAL;

        goto out;



    }

    if (offset_in_cluster < 0 ||

            offset_in_cluster + bytes > buf_len) {

        ret = -EINVAL;

        goto out;

    }

    qemu_iovec_from_buf(qiov, 0, uncomp_buf + offset_in_cluster, bytes);

    ret = 0;



 out:

    g_free(uncomp_buf);

    g_free(cluster_buf);

    return ret;

}
 and probability:0.18333333333333332
code:static void parser_context_free(JSONParserContext *ctxt)

{

    if (ctxt) {

        while (!g_queue_is_empty(ctxt->buf)) {

            parser_context_pop_token(ctxt);

        }

        qobject_decref(ctxt->current);

        g_queue_free(ctxt->buf);

        g_free(ctxt);

    }

}
 and probability:0.2727272727272727
code:int page_check_range(target_ulong start, target_ulong len, int flags)

{

    PageDesc *p;

    target_ulong end;

    target_ulong addr;



    if (start + len < start)

        /* we've wrapped around */

        return -1;



    end = TARGET_PAGE_ALIGN(start+len); /* must do before we loose bits in the next step */

    start = start & TARGET_PAGE_MASK;



    for(addr = start; addr < end; addr += TARGET_PAGE_SIZE) {

        p = page_find(addr >> TARGET_PAGE_BITS);

        if( !p )

            return -1;

        if( !(p->flags & PAGE_VALID) )

            return -1;



        if ((flags & PAGE_READ) && !(p->flags & PAGE_READ))

            return -1;

        if (flags & PAGE_WRITE) {

            if (!(p->flags & PAGE_WRITE_ORG))

                return -1;

            /* unprotect the page if it was put read-only because it

               contains translated code */

            if (!(p->flags & PAGE_WRITE)) {

                if (!page_unprotect(addr, 0, NULL))

                    return -1;

            }

            return 0;

        }

    }

    return 0;

}
 and probability:0.21875
code:processed(OptsVisitor *ov, const char *name)

{

    if (ov->repeated_opts == NULL) {

        g_hash_table_remove(ov->unprocessed_opts, name);

    }

}
 and probability:0.5
code:minimac2_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    MilkymistMinimac2State *s = opaque;

    uint32_t r = 0;



    addr >>= 2;

    switch (addr) {

    case R_SETUP:

    case R_MDIO:

    case R_STATE0:

    case R_COUNT0:

    case R_STATE1:

    case R_COUNT1:

    case R_TXCOUNT:

        r = s->regs[addr];

        break;



    default:

        error_report("milkymist_minimac2: read access to unknown register 0x"

                TARGET_FMT_plx, addr << 2);

        break;

    }



    trace_milkymist_minimac2_memory_read(addr << 2, r);



    return r;

}
 and probability:0.08695652173913043
code:static inline void float_to_int (float * _f, int16_t * s16, int samples)

{

    int32_t * f = (int32_t *) _f;       // XXX assumes IEEE float format

    int i;



    for (i = 0; i < samples; i++) {

        s16[i] = blah (f[i]);

    }

}
 and probability:0.25
code:void kvm_arm_register_device(MemoryRegion *mr, uint64_t devid)

{

    KVMDevice *kd;



    if (!kvm_irqchip_in_kernel()) {

        return;

    }



    if (QSLIST_EMPTY(&kvm_devices_head)) {

        memory_listener_register(&devlistener, NULL);

        qemu_add_machine_init_done_notifier(&notify);

    }

    kd = g_new0(KVMDevice, 1);

    kd->mr = mr;

    kd->kda.id = devid;

    kd->kda.addr = -1;

    QSLIST_INSERT_HEAD(&kvm_devices_head, kd, entries);

    memory_region_ref(kd->mr);

}
 and probability:0.23529411764705882
code:X86CPU *cpu_x86_init(const char *cpu_model)

{

    X86CPU *cpu;

    CPUX86State *env;

    static int inited;



    cpu = X86_CPU(object_new(TYPE_X86_CPU));

    env = &cpu->env;

    env->cpu_model_str = cpu_model;



    /* init various static tables used in TCG mode */

    if (tcg_enabled() && !inited) {

        inited = 1;

        optimize_flags_init();

#ifndef CONFIG_USER_ONLY

        prev_debug_excp_handler =

            cpu_set_debug_excp_handler(breakpoint_handler);

#endif

    }

    if (cpu_x86_register(cpu, cpu_model) < 0) {

        object_delete(OBJECT(cpu));

        return NULL;

    }



    x86_cpu_realize(OBJECT(cpu), NULL);



    return cpu;

}
 and probability:0.08333333333333333
code:int raw_get_aio_fd(BlockDriverState *bs)

{

    BDRVRawState *s;



    if (!bs->drv) {

        return -ENOMEDIUM;

    }



    if (bs->drv == bdrv_find_format("raw")) {

        bs = bs->file;

    }



    /* raw-posix has several protocols so just check for raw_aio_readv */

    if (bs->drv->bdrv_aio_readv != raw_aio_readv) {

        return -ENOTSUP;

    }



    s = bs->opaque;

    if (!s->use_aio) {

        return -ENOTSUP;

    }

    return s->fd;

}
 and probability:0.3684210526315789
code:static SocketAddressLegacy *unix_build_address(const char *path)

{

    SocketAddressLegacy *saddr;



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;

    saddr->u.q_unix.data = g_new0(UnixSocketAddress, 1);

    saddr->u.q_unix.data->path = g_strdup(path);



    return saddr;

}
 and probability:0.3333333333333333
code:e1000_mmio_read(void *opaque, hwaddr addr, unsigned size)

{

    E1000State *s = opaque;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](s, index);

    }

    DBGOUT(UNKNOWN, "MMIO unknown read addr=0x%08x\n", index<<2);

    return 0;

}
 and probability:0.2727272727272727
code:void bdrv_img_create(const char *filename, const char *fmt,

                     const char *base_filename, const char *base_fmt,

                     char *options, uint64_t img_size, int flags,

                     Error **errp, bool quiet)

{

    QEMUOptionParameter *param = NULL, *create_options = NULL;

    QEMUOptionParameter *backing_fmt, *backing_file, *size;

    BlockDriverState *bs = NULL;

    BlockDriver *drv, *proto_drv;

    BlockDriver *backing_drv = NULL;

    int ret = 0;



    /* Find driver and parse its options */

    drv = bdrv_find_format(fmt);

    if (!drv) {

        error_setg(errp, "Unknown file format '%s'", fmt);

        return;

    }



    proto_drv = bdrv_find_protocol(filename);

    if (!proto_drv) {

        error_setg(errp, "Unknown protocol '%s'", filename);

        return;

    }



    create_options = append_option_parameters(create_options,

                                              drv->create_options);

    create_options = append_option_parameters(create_options,

                                              proto_drv->create_options);



    /* Create parameter list with default values */

    param = parse_option_parameters("", create_options, param);



    set_option_parameter_int(param, BLOCK_OPT_SIZE, img_size);



    /* Parse -o options */

    if (options) {

        param = parse_option_parameters(options, create_options, param);

        if (param == NULL) {

            error_setg(errp, "Invalid options for file format '%s'.", fmt);

            goto out;

        }

    }



    if (base_filename) {

        if (set_option_parameter(param, BLOCK_OPT_BACKING_FILE,

                                 base_filename)) {

            error_setg(errp, "Backing file not supported for file format '%s'",

                       fmt);

            goto out;

        }

    }



    if (base_fmt) {

        if (set_option_parameter(param, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_setg(errp, "Backing file format not supported for file "

                             "format '%s'", fmt);

            goto out;

        }

    }



    backing_file = get_option_parameter(param, BLOCK_OPT_BACKING_FILE);

    if (backing_file && backing_file->value.s) {

        if (!strcmp(filename, backing_file->value.s)) {

            error_setg(errp, "Error: Trying to create an image with the "

                             "same filename as the backing file");

            goto out;

        }

    }



    backing_fmt = get_option_parameter(param, BLOCK_OPT_BACKING_FMT);

    if (backing_fmt && backing_fmt->value.s) {

        backing_drv = bdrv_find_format(backing_fmt->value.s);

        if (!backing_drv) {

            error_setg(errp, "Unknown backing file format '%s'",

                       backing_fmt->value.s);

            goto out;

        }

    }



    // The size for the image must always be specified, with one exception:

    // If we are using a backing file, we can obtain the size from there

    size = get_option_parameter(param, BLOCK_OPT_SIZE);

    if (size && size->value.n == -1) {

        if (backing_file && backing_file->value.s) {

            uint64_t size;

            char buf[32];

            int back_flags;



            /* backing files always opened read-only */

            back_flags =

                flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING);



            bs = bdrv_new("");



            ret = bdrv_open(bs, backing_file->value.s, NULL, back_flags,

                            backing_drv);

            if (ret < 0) {

                error_setg_errno(errp, -ret, "Could not open '%s'",

                                 backing_file->value.s);

                goto out;

            }

            bdrv_get_geometry(bs, &size);

            size *= 512;



            snprintf(buf, sizeof(buf), "%" PRId64, size);

            set_option_parameter(param, BLOCK_OPT_SIZE, buf);

        } else {

            error_setg(errp, "Image creation needs a size parameter");

            goto out;

        }

    }



    if (!quiet) {

        printf("Formatting '%s', fmt=%s ", filename, fmt);

        print_option_parameters(param);

        puts("");

    }

    ret = bdrv_create(drv, filename, param);

    if (ret < 0) {

        if (ret == -ENOTSUP) {

            error_setg(errp,"Formatting or formatting option not supported for "

                            "file format '%s'", fmt);

        } else if (ret == -EFBIG) {

            error_setg(errp, "The image size is too large for file format '%s'",

                       fmt);

        } else {

            error_setg(errp, "%s: error while creating %s: %s", filename, fmt,

                       strerror(-ret));

        }

    }



out:

    free_option_parameters(create_options);

    free_option_parameters(param);



    if (bs) {

        bdrv_delete(bs);

    }

}
 and probability:0.09836065573770492
code:int nbd_client(int fd)

{

    int ret;

    int serrno;



    TRACE("Doing NBD loop");



    ret = ioctl(fd, NBD_DO_IT);

    if (ret == -1 && errno == EPIPE) {

        /* NBD_DO_IT normally returns EPIPE when someone has disconnected

         * the socket via NBD_DISCONNECT.  We do not want to return 1 in

         * that case.

         */

        ret = 0;

    }

    serrno = errno;



    TRACE("NBD loop returned %d: %s", ret, strerror(serrno));



    TRACE("Clearing NBD queue");

    ioctl(fd, NBD_CLEAR_QUE);



    TRACE("Clearing NBD socket");

    ioctl(fd, NBD_CLEAR_SOCK);



    errno = serrno;

    return ret;

}
 and probability:0.0
code:static void slirp_init_once(void)

{

    static int initialized;

    struct hostent *he;

    char our_name[256];

#ifdef _WIN32

    WSADATA Data;

#endif



    if (initialized) {

        return;

    }

    initialized = 1;



#ifdef _WIN32

    WSAStartup(MAKEWORD(2,0), &Data);

    atexit(winsock_cleanup);

#endif



    loopback_addr.s_addr = htonl(INADDR_LOOPBACK);



    /* FIXME: This address may change during runtime */

    if (gethostname(our_name, sizeof(our_name)) == 0) {

        he = gethostbyname(our_name);

        if (he) {

            our_addr = *(struct in_addr *)he->h_addr;

        }

    }

    if (our_addr.s_addr == 0) {

        our_addr = loopback_addr;

    }



    /* FIXME: This address may change during runtime */

    if (get_dns_addr(&dns_addr) < 0) {

        dns_addr = loopback_addr;

    }

}
 and probability:0.03125
code:BlockDeviceInfoList *qmp_query_named_block_nodes(Error **errp)

{

    return bdrv_named_nodes_list();

}
 and probability:0.0
code:void backup_start(BlockDriverState *bs, BlockDriverState *target,

                  int64_t speed, MirrorSyncMode sync_mode,

                  BdrvDirtyBitmap *sync_bitmap,

                  BlockdevOnError on_source_error,

                  BlockdevOnError on_target_error,

                  BlockCompletionFunc *cb, void *opaque,

                  BlockJobTxn *txn, Error **errp)

{

    int64_t len;

    BlockDriverInfo bdi;

    int ret;



    assert(bs);

    assert(target);

    assert(cb);



    if (bs == target) {

        error_setg(errp, "Source and target cannot be the same");

        return;

    }



    if (!bdrv_is_inserted(bs)) {

        error_setg(errp, "Device is not inserted: %s",

                   bdrv_get_device_name(bs));

        return;

    }



    if (!bdrv_is_inserted(target)) {

        error_setg(errp, "Device is not inserted: %s",

                   bdrv_get_device_name(target));

        return;

    }



    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {

        return;

    }



    if (bdrv_op_is_blocked(target, BLOCK_OP_TYPE_BACKUP_TARGET, errp)) {

        return;

    }



    if (sync_mode == MIRROR_SYNC_MODE_INCREMENTAL) {

        if (!sync_bitmap) {

            error_setg(errp, "must provide a valid bitmap name for "

                             "\"incremental\" sync mode");

            return;

        }



        /* Create a new bitmap, and freeze/disable this one. */

        if (bdrv_dirty_bitmap_create_successor(bs, sync_bitmap, errp) < 0) {

            return;

        }

    } else if (sync_bitmap) {

        error_setg(errp,

                   "a sync_bitmap was provided to backup_run, "

                   "but received an incompatible sync_mode (%s)",

                   MirrorSyncMode_lookup[sync_mode]);

        return;

    }



    len = bdrv_getlength(bs);

    if (len < 0) {

        error_setg_errno(errp, -len, "unable to get length for '%s'",

                         bdrv_get_device_name(bs));

        goto error;

    }



    BackupBlockJob *job = block_job_create(&backup_job_driver, bs, speed,

                                           cb, opaque, errp);

    if (!job) {

        goto error;

    }



    job->on_source_error = on_source_error;

    job->on_target_error = on_target_error;

    job->target = target;

    job->sync_mode = sync_mode;

    job->sync_bitmap = sync_mode == MIRROR_SYNC_MODE_INCREMENTAL ?

                       sync_bitmap : NULL;



    /* If there is no backing file on the target, we cannot rely on COW if our

     * backup cluster size is smaller than the target cluster size. Even for

     * targets with a backing file, try to avoid COW if possible. */

    ret = bdrv_get_info(job->target, &bdi);

    if (ret < 0 && !target->backing) {

        error_setg_errno(errp, -ret,

            "Couldn't determine the cluster size of the target image, "

            "which has no backing file");

        error_append_hint(errp,

            "Aborting, since this may create an unusable destination image\n");

        goto error;

    } else if (ret < 0 && target->backing) {

        /* Not fatal; just trudge on ahead. */

        job->cluster_size = BACKUP_CLUSTER_SIZE_DEFAULT;

    } else {

        job->cluster_size = MAX(BACKUP_CLUSTER_SIZE_DEFAULT, bdi.cluster_size);

    }



    bdrv_op_block_all(target, job->common.blocker);

    job->common.len = len;

    job->common.co = qemu_coroutine_create(backup_run);

    block_job_txn_add_job(txn, &job->common);

    qemu_coroutine_enter(job->common.co, job);

    return;



 error:

    if (sync_bitmap) {

        bdrv_reclaim_dirty_bitmap(bs, sync_bitmap, NULL);

    }

}
 and probability:0.16666666666666666
code:void ppc_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,

                        int flags)

{

#define RGPL  4

#define RFPL  4



    PowerPCCPU *cpu = POWERPC_CPU(cs);

    CPUPPCState *env = &cpu->env;

    int i;



    cpu_fprintf(f, "NIP " TARGET_FMT_lx "   LR " TARGET_FMT_lx " CTR "

                TARGET_FMT_lx " XER " TARGET_FMT_lx " CPU#%d\n",

                env->nip, env->lr, env->ctr, cpu_read_xer(env),

                cs->cpu_index);

    cpu_fprintf(f, "MSR " TARGET_FMT_lx " HID0 " TARGET_FMT_lx "  HF "

                TARGET_FMT_lx " iidx %d didx %d\n",

                env->msr, env->spr[SPR_HID0],

                env->hflags, env->immu_idx, env->dmmu_idx);

#if !defined(NO_TIMER_DUMP)

    cpu_fprintf(f, "TB %08" PRIu32 " %08" PRIu64

#if !defined(CONFIG_USER_ONLY)

                " DECR %08" PRIu32


                "\n",

                cpu_ppc_load_tbu(env), cpu_ppc_load_tbl(env)

#if !defined(CONFIG_USER_ONLY)

                , cpu_ppc_load_decr(env)


                );


    for (i = 0; i < 32; i++) {

        if ((i & (RGPL - 1)) == 0)

            cpu_fprintf(f, "GPR%02d", i);

        cpu_fprintf(f, " %016" PRIx64, ppc_dump_gpr(env, i));

        if ((i & (RGPL - 1)) == (RGPL - 1))

            cpu_fprintf(f, "\n");


    cpu_fprintf(f, "CR ");

    for (i = 0; i < 8; i++)

        cpu_fprintf(f, "%01x", env->crf[i]);

    cpu_fprintf(f, "  [");

    for (i = 0; i < 8; i++) {

        char a = '-';

        if (env->crf[i] & 0x08)

            a = 'L';

        else if (env->crf[i] & 0x04)

            a = 'G';

        else if (env->crf[i] & 0x02)

            a = 'E';

        cpu_fprintf(f, " %c%c", a, env->crf[i] & 0x01 ? 'O' : ' ');


    cpu_fprintf(f, " ]             RES " TARGET_FMT_lx "\n",

                env->reserve_addr);

    for (i = 0; i < 32; i++) {

        if ((i & (RFPL - 1)) == 0)

            cpu_fprintf(f, "FPR%02d", i);

        cpu_fprintf(f, " %016" PRIx64, *((uint64_t *)&env->fpr[i]));

        if ((i & (RFPL - 1)) == (RFPL - 1))

            cpu_fprintf(f, "\n");


    cpu_fprintf(f, "FPSCR " TARGET_FMT_lx "\n", env->fpscr);

#if !defined(CONFIG_USER_ONLY)

    cpu_fprintf(f, " SRR0 " TARGET_FMT_lx "  SRR1 " TARGET_FMT_lx

                   "    PVR " TARGET_FMT_lx " VRSAVE " TARGET_FMT_lx "\n",

                env->spr[SPR_SRR0], env->spr[SPR_SRR1],

                env->spr[SPR_PVR], env->spr[SPR_VRSAVE]);



    cpu_fprintf(f, "SPRG0 " TARGET_FMT_lx " SPRG1 " TARGET_FMT_lx

                   "  SPRG2 " TARGET_FMT_lx "  SPRG3 " TARGET_FMT_lx "\n",

                env->spr[SPR_SPRG0], env->spr[SPR_SPRG1],

                env->spr[SPR_SPRG2], env->spr[SPR_SPRG3]);



    cpu_fprintf(f, "SPRG4 " TARGET_FMT_lx " SPRG5 " TARGET_FMT_lx

                   "  SPRG6 " TARGET_FMT_lx "  SPRG7 " TARGET_FMT_lx "\n",

                env->spr[SPR_SPRG4], env->spr[SPR_SPRG5],

                env->spr[SPR_SPRG6], env->spr[SPR_SPRG7]);










    if (env->excp_model == POWERPC_EXCP_BOOKE) {

        cpu_fprintf(f, "CSRR0 " TARGET_FMT_lx " CSRR1 " TARGET_FMT_lx

                       " MCSRR0 " TARGET_FMT_lx " MCSRR1 " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_CSRR0], env->spr[SPR_BOOKE_CSRR1],

                    env->spr[SPR_BOOKE_MCSRR0], env->spr[SPR_BOOKE_MCSRR1]);



        cpu_fprintf(f, "  TCR " TARGET_FMT_lx "   TSR " TARGET_FMT_lx

                       "    ESR " TARGET_FMT_lx "   DEAR " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_TCR], env->spr[SPR_BOOKE_TSR],

                    env->spr[SPR_BOOKE_ESR], env->spr[SPR_BOOKE_DEAR]);



        cpu_fprintf(f, "  PIR " TARGET_FMT_lx " DECAR " TARGET_FMT_lx

                       "   IVPR " TARGET_FMT_lx "   EPCR " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_PIR], env->spr[SPR_BOOKE_DECAR],

                    env->spr[SPR_BOOKE_IVPR], env->spr[SPR_BOOKE_EPCR]);



        cpu_fprintf(f, " MCSR " TARGET_FMT_lx " SPRG8 " TARGET_FMT_lx

                       "    EPR " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_MCSR], env->spr[SPR_BOOKE_SPRG8],

                    env->spr[SPR_BOOKE_EPR]);



        /* FSL-specific */

        cpu_fprintf(f, " MCAR " TARGET_FMT_lx "  PID1 " TARGET_FMT_lx

                       "   PID2 " TARGET_FMT_lx "    SVR " TARGET_FMT_lx "\n",

                    env->spr[SPR_Exxx_MCAR], env->spr[SPR_BOOKE_PID1],

                    env->spr[SPR_BOOKE_PID2], env->spr[SPR_E500_SVR]);



        /*

         * IVORs are left out as they are large and do not change often --

         * they can be read with "p $ivor0", "p $ivor1", etc.

         */





    if (env->flags & POWERPC_FLAG_CFAR) {

        cpu_fprintf(f, " CFAR " TARGET_FMT_lx"\n", env->cfar);





    switch (env->mmu_model) {

    case POWERPC_MMU_32B:

    case POWERPC_MMU_601:

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:


    case POWERPC_MMU_64B:

    case POWERPC_MMU_2_03:

    case POWERPC_MMU_2_06:

    case POWERPC_MMU_2_06a:

    case POWERPC_MMU_2_07:

    case POWERPC_MMU_2_07a:


        cpu_fprintf(f, " SDR1 " TARGET_FMT_lx "   DAR " TARGET_FMT_lx

                       "  DSISR " TARGET_FMT_lx "\n", env->spr[SPR_SDR1],

                    env->spr[SPR_DAR], env->spr[SPR_DSISR]);

        break;

    case POWERPC_MMU_BOOKE206:

        cpu_fprintf(f, " MAS0 " TARGET_FMT_lx "  MAS1 " TARGET_FMT_lx

                       "   MAS2 " TARGET_FMT_lx "   MAS3 " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_MAS0], env->spr[SPR_BOOKE_MAS1],

                    env->spr[SPR_BOOKE_MAS2], env->spr[SPR_BOOKE_MAS3]);



        cpu_fprintf(f, " MAS4 " TARGET_FMT_lx "  MAS6 " TARGET_FMT_lx

                       "   MAS7 " TARGET_FMT_lx "    PID " TARGET_FMT_lx "\n",

                    env->spr[SPR_BOOKE_MAS4], env->spr[SPR_BOOKE_MAS6],

                    env->spr[SPR_BOOKE_MAS7], env->spr[SPR_BOOKE_PID]);



        cpu_fprintf(f, "MMUCFG " TARGET_FMT_lx " TLB0CFG " TARGET_FMT_lx

                       " TLB1CFG " TARGET_FMT_lx "\n",

                    env->spr[SPR_MMUCFG], env->spr[SPR_BOOKE_TLB0CFG],

                    env->spr[SPR_BOOKE_TLB1CFG]);

        break;

    default:

        break;





#undef RGPL

#undef RFPL
 and probability:0.3858267716535433
code:void uninit_opts(void)

{

    int i;

    for (i = 0; i < AVMEDIA_TYPE_NB; i++)

        av_freep(&avcodec_opts[i]);

    av_freep(&avformat_opts->key);

    av_freep(&avformat_opts);

#if CONFIG_SWSCALE

    av_freep(&sws_opts);

#endif



} and probability:0.2727272727272727
code:static USBDevice *usb_braille_init(USBBus *bus, const char *unused)

{

    USBDevice *dev;

    CharDriverState *cdrv;



    cdrv = qemu_chr_new("braille", "braille", NULL);

    if (!cdrv)

        return NULL;



    dev = usb_create(bus, "usb-braille");

    qdev_prop_set_chr(&dev->qdev, "chardev", cdrv);

    qdev_init_nofail(&dev->qdev);



    return dev;

}
 and probability:0.16666666666666666
code:void qdev_free(DeviceState *dev)

{

    BusState *bus;




    if (dev->state == DEV_STATE_INITIALIZED) {

        while (dev->num_child_bus) {

            bus = QLIST_FIRST(&dev->child_bus);

            qbus_free(bus);

        }

        if (dev->info->vmsd)

            vmstate_unregister(dev->info->vmsd, dev);

        if (dev->info->exit)

            dev->info->exit(dev);

        if (dev->opts)

            qemu_opts_del(dev->opts);

    }

    qemu_unregister_reset(qdev_reset, dev);

    QLIST_REMOVE(dev, sibling);

    for (prop = dev->info->props; prop && prop->name; prop++) {

        if (prop->info->free) {

            prop->info->free(dev, prop);

        }

    }

    qemu_free(dev);

} and probability:0.5
code:static inline void RENAME(rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size)

{

	const uint8_t *s = src;

	const uint8_t *end;

#ifdef HAVE_MMX

	const uint8_t *mm_end;

#endif

	uint16_t *d = (uint16_t *)dst;

	end = s + src_size;

#ifdef HAVE_MMX

	__asm __volatile(PREFETCH"	%0"::"m"(*src):"memory");

	__asm __volatile(

	    "movq	%0, %%mm7\n\t"

	    "movq	%1, %%mm6\n\t"

	    ::"m"(red_16mask),"m"(green_16mask));

	mm_end = end - 15;

	while(s < mm_end)

	{

	    __asm __volatile(

		PREFETCH" 32%1\n\t"

		"movd	%1, %%mm0\n\t"

		"movd	3%1, %%mm3\n\t"

		"punpckldq 6%1, %%mm0\n\t"

		"punpckldq 9%1, %%mm3\n\t"

		"movq	%%mm0, %%mm1\n\t"

		"movq	%%mm0, %%mm2\n\t"

		"movq	%%mm3, %%mm4\n\t"

		"movq	%%mm3, %%mm5\n\t"

		"psllq	$8, %%mm0\n\t"

		"psllq	$8, %%mm3\n\t"

		"pand	%%mm7, %%mm0\n\t"

		"pand	%%mm7, %%mm3\n\t"

		"psrlq	$5, %%mm1\n\t"

		"psrlq	$5, %%mm4\n\t"

		"pand	%%mm6, %%mm1\n\t"

		"pand	%%mm6, %%mm4\n\t"

		"psrlq	$19, %%mm2\n\t"

		"psrlq	$19, %%mm5\n\t"

		"pand	%2, %%mm2\n\t"

		"pand	%2, %%mm5\n\t"

		"por	%%mm1, %%mm0\n\t"

		"por	%%mm4, %%mm3\n\t"

		"por	%%mm2, %%mm0\n\t"

		"por	%%mm5, %%mm3\n\t"

		"psllq	$16, %%mm3\n\t"

		"por	%%mm3, %%mm0\n\t"

		MOVNTQ"	%%mm0, %0\n\t"

		:"=m"(*d):"m"(*s),"m"(blue_16mask):"memory");

		d += 4;

		s += 12;

	}

	__asm __volatile(SFENCE:::"memory");

	__asm __volatile(EMMS:::"memory");

#endif

	while(s < end)

	{

		const int r= *s++;

		const int g= *s++;

		const int b= *s++;

		*d++ = (b>>3) | ((g&0xFC)<<3) | ((r&0xF8)<<8);

	}

}
 and probability:0.12903225806451613
code:static inline void RENAME(rgb16tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)

{

    const uint16_t *end;

#if COMPILE_TEMPLATE_MMX

    const uint16_t *mm_end;

#endif

    uint8_t *d = (uint8_t *)dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(PREFETCH"    %0"::"m"(*s):"memory");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH"    32%1           \n\t"

            "movq          %1, %%mm0    \n\t"

            "movq          %1, %%mm1    \n\t"

            "movq          %1, %%mm2    \n\t"

            "pand          %2, %%mm0    \n\t"

            "pand          %3, %%mm1    \n\t"

            "pand          %4, %%mm2    \n\t"

            "psllq         $3, %%mm0    \n\t"

            "psrlq         $3, %%mm1    \n\t"

            "psrlq         $8, %%mm2    \n\t"

            "movq       %%mm0, %%mm3    \n\t"

            "movq       %%mm1, %%mm4    \n\t"

            "movq       %%mm2, %%mm5    \n\t"

            "punpcklwd     %5, %%mm0    \n\t"

            "punpcklwd     %5, %%mm1    \n\t"

            "punpcklwd     %5, %%mm2    \n\t"

            "punpckhwd     %5, %%mm3    \n\t"

            "punpckhwd     %5, %%mm4    \n\t"

            "punpckhwd     %5, %%mm5    \n\t"

            "psllq         $8, %%mm1    \n\t"

            "psllq        $16, %%mm2    \n\t"

            "por        %%mm1, %%mm0    \n\t"

            "por        %%mm2, %%mm0    \n\t"

            "psllq         $8, %%mm4    \n\t"

            "psllq        $16, %%mm5    \n\t"

            "por        %%mm4, %%mm3    \n\t"

            "por        %%mm5, %%mm3    \n\t"



            "movq       %%mm0, %%mm6    \n\t"

            "movq       %%mm3, %%mm7    \n\t"



            "movq         8%1, %%mm0    \n\t"

            "movq         8%1, %%mm1    \n\t"

            "movq         8%1, %%mm2    \n\t"

            "pand          %2, %%mm0    \n\t"

            "pand          %3, %%mm1    \n\t"

            "pand          %4, %%mm2    \n\t"

            "psllq         $3, %%mm0    \n\t"

            "psrlq         $3, %%mm1    \n\t"

            "psrlq         $8, %%mm2    \n\t"

            "movq       %%mm0, %%mm3    \n\t"

            "movq       %%mm1, %%mm4    \n\t"

            "movq       %%mm2, %%mm5    \n\t"

            "punpcklwd     %5, %%mm0    \n\t"

            "punpcklwd     %5, %%mm1    \n\t"

            "punpcklwd     %5, %%mm2    \n\t"

            "punpckhwd     %5, %%mm3    \n\t"

            "punpckhwd     %5, %%mm4    \n\t"

            "punpckhwd     %5, %%mm5    \n\t"

            "psllq         $8, %%mm1    \n\t"

            "psllq        $16, %%mm2    \n\t"

            "por        %%mm1, %%mm0    \n\t"

            "por        %%mm2, %%mm0    \n\t"

            "psllq         $8, %%mm4    \n\t"

            "psllq        $16, %%mm5    \n\t"

            "por        %%mm4, %%mm3    \n\t"

            "por        %%mm5, %%mm3    \n\t"

            :"=m"(*d)

            :"m"(*s),"m"(mask16b),"m"(mask16g),"m"(mask16r),"m"(mmx_null)

            :"memory");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            "movq       %%mm0, %%mm4    \n\t"

            "movq       %%mm3, %%mm5    \n\t"

            "movq       %%mm6, %%mm0    \n\t"

            "movq       %%mm7, %%mm1    \n\t"



            "movq       %%mm4, %%mm6    \n\t"

            "movq       %%mm5, %%mm7    \n\t"

            "movq       %%mm0, %%mm2    \n\t"

            "movq       %%mm1, %%mm3    \n\t"



            STORE_BGR24_MMX



            :"=m"(*d)

            :"m"(*s)

            :"memory");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::"memory");

    __asm__ volatile(EMMS:::"memory");

#endif

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x7E0)>>3;

        *d++ = (bgr&0xF800)>>8;

    }

}
 and probability:0.1
code:static int teletext_close_decoder(AVCodecContext *avctx)

{

    TeletextContext *ctx = avctx->priv_data;



    av_dlog(avctx, "lines_total=%u\n", ctx->lines_processed);

    while (ctx->nb_pages)

        subtitle_rect_free(&ctx->pages[--ctx->nb_pages].sub_rect);

    av_freep(&ctx->pages);



    vbi_dvb_demux_delete(ctx->dx);

    vbi_decoder_delete(ctx->vbi);

    ctx->dx = NULL;

    ctx->vbi = NULL;

    ctx->pts = AV_NOPTS_VALUE;

    return 0;

}
 and probability:0.7142857142857143
code:static av_always_inline void predict(PredictorState *ps, int *coef,

                                     int output_enable)

{

    const SoftFloat a     = { 1023410176, 0 };  // 61.0 / 64

    const SoftFloat alpha = {  973078528, 0 };  // 29.0 / 32

    SoftFloat e0, e1;

    SoftFloat pv;

    SoftFloat k1, k2;

    SoftFloat   r0 = ps->r0,     r1 = ps->r1;

    SoftFloat cor0 = ps->cor0, cor1 = ps->cor1;

    SoftFloat var0 = ps->var0, var1 = ps->var1;

    SoftFloat tmp;



    if (var0.exp > 1 || (var0.exp == 1 && var0.mant > 0x20000000)) {

        k1 = av_mul_sf(cor0, flt16_even(av_div_sf(a, var0)));

    }

    else {

        k1.mant = 0;

        k1.exp = 0;

    }



    if (var1.exp > 1 || (var1.exp == 1 && var1.mant > 0x20000000)) {

        k2 = av_mul_sf(cor1, flt16_even(av_div_sf(a, var1)));

    }

    else {

        k2.mant = 0;

        k2.exp = 0;

    }



    tmp = av_mul_sf(k1, r0);

    pv = flt16_round(av_add_sf(tmp, av_mul_sf(k2, r1)));

    if (output_enable) {

        int shift = 28 - pv.exp;



        if (shift < 31)

            *coef += (pv.mant + (1 << (shift - 1))) >> shift;

    }



    e0 = av_int2sf(*coef, 2);

    e1 = av_sub_sf(e0, tmp);



    ps->cor1 = flt16_trunc(av_add_sf(av_mul_sf(alpha, cor1), av_mul_sf(r1, e1)));

    tmp = av_add_sf(av_mul_sf(r1, r1), av_mul_sf(e1, e1));

    tmp.exp--;

    ps->var1 = flt16_trunc(av_add_sf(av_mul_sf(alpha, var1), tmp));

    ps->cor0 = flt16_trunc(av_add_sf(av_mul_sf(alpha, cor0), av_mul_sf(r0, e0)));

    tmp = av_add_sf(av_mul_sf(r0, r0), av_mul_sf(e0, e0));

    tmp.exp--;

    ps->var0 = flt16_trunc(av_add_sf(av_mul_sf(alpha, var0), tmp));



    ps->r1 = flt16_trunc(av_mul_sf(a, av_sub_sf(r0, av_mul_sf(k1, e0))));

    ps->r0 = flt16_trunc(av_mul_sf(a, e0));

}
 and probability:0.30434782608695654
code:static OSStatus ffat_decode_callback(AudioConverterRef converter, UInt32 *nb_packets,

                                     AudioBufferList *data,

                                     AudioStreamPacketDescription **packets,

                                     void *inctx)

{

    AVCodecContext *avctx = inctx;

    ATDecodeContext *at = avctx->priv_data;



    if (at->eof) {

        *nb_packets = 0;

        if (packets) {

            *packets = &at->pkt_desc;

            at->pkt_desc.mDataByteSize = 0;

        }

        return 0;

    }




    av_packet_move_ref(&at->in_pkt, &at->new_in_pkt);

    at->new_in_pkt.data = 0;

    at->new_in_pkt.size = 0;



    if (!at->in_pkt.data) {

        *nb_packets = 0;

        return 1;

    }



    data->mNumberBuffers              = 1;

    data->mBuffers[0].mNumberChannels = 0;

    data->mBuffers[0].mDataByteSize   = at->in_pkt.size;

    data->mBuffers[0].mData           = at->in_pkt.data;

    *nb_packets = 1;



    if (packets) {

        *packets = &at->pkt_desc;

        at->pkt_desc.mDataByteSize = at->in_pkt.size;

    }



    return 0;

} and probability:0.5151515151515151
code:static int sse8_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)

{

    int i;

    int s;

    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);

    const vector unsigned char permclear = (vector unsigned char){255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0};

    vector unsigned char perm1 = vec_lvsl(0, pix1);

    vector unsigned char perm2 = vec_lvsl(0, pix2);

    vector unsigned char t1, t2, t3,t4, t5;

    vector unsigned int sum;

    vector signed int sumsqr;



    sum = (vector unsigned int)vec_splat_u32(0);



    for (i = 0; i < h; i++) {

        /* Read potentially unaligned pixels into t1 and t2

           Since we're reading 16 pixels, and actually only want 8,

           mask out the last 8 pixels. The 0s don't change the sum. */

        vector unsigned char pix1l = vec_ld( 0, pix1);

        vector unsigned char pix1r = vec_ld(15, pix1);

        vector unsigned char pix2l = vec_ld( 0, pix2);

        vector unsigned char pix2r = vec_ld(15, pix2);

        t1 = vec_and(vec_perm(pix1l, pix1r, perm1), permclear);

        t2 = vec_and(vec_perm(pix2l, pix2r, perm2), permclear);



        /* Since we want to use unsigned chars, we can take advantage

           of the fact that abs(a-b)^2 = (a-b)^2. */



        /* Calculate abs differences vector */

        t3 = vec_max(t1, t2);

        t4 = vec_min(t1, t2);

        t5 = vec_sub(t3, t4);



        /* Square the values and add them to our sum */

        sum = vec_msum(t5, t5, sum);



        pix1 += line_size;

        pix2 += line_size;

    }



    /* Sum up the four partial sums, and put the result into s */

    sumsqr = vec_sums((vector signed int) sum, (vector signed int) zero);

    sumsqr = vec_splat(sumsqr, 3);

    vec_ste(sumsqr, 0, &s);



    return s;

}
 and probability:0.07692307692307693
code:av_cold void ff_vp8dsp_init_ppc(VP8DSPContext *c)

{

#if HAVE_ALTIVEC

    if (!(av_get_cpu_flags() & AV_CPU_FLAG_ALTIVEC))

        return;



    c->put_vp8_epel_pixels_tab[0][0][0] = put_vp8_pixels16_altivec;

    c->put_vp8_epel_pixels_tab[0][0][2] = put_vp8_epel16_h6_altivec;

    c->put_vp8_epel_pixels_tab[0][2][0] = put_vp8_epel16_v6_altivec;

    c->put_vp8_epel_pixels_tab[0][2][2] = put_vp8_epel16_h6v6_altivec;



    c->put_vp8_epel_pixels_tab[1][0][2] = put_vp8_epel8_h6_altivec;

    c->put_vp8_epel_pixels_tab[1][2][0] = put_vp8_epel8_v6_altivec;

    c->put_vp8_epel_pixels_tab[1][0][1] = put_vp8_epel8_h4_altivec;

    c->put_vp8_epel_pixels_tab[1][1][0] = put_vp8_epel8_v4_altivec;



    c->put_vp8_epel_pixels_tab[1][2][2] = put_vp8_epel8_h6v6_altivec;

    c->put_vp8_epel_pixels_tab[1][1][1] = put_vp8_epel8_h4v4_altivec;

    c->put_vp8_epel_pixels_tab[1][1][2] = put_vp8_epel8_h6v4_altivec;

    c->put_vp8_epel_pixels_tab[1][2][1] = put_vp8_epel8_h4v6_altivec;



    c->put_vp8_epel_pixels_tab[2][0][2] = put_vp8_epel4_h6_altivec;

    c->put_vp8_epel_pixels_tab[2][2][0] = put_vp8_epel4_v6_altivec;

    c->put_vp8_epel_pixels_tab[2][0][1] = put_vp8_epel4_h4_altivec;

    c->put_vp8_epel_pixels_tab[2][1][0] = put_vp8_epel4_v4_altivec;



    c->put_vp8_epel_pixels_tab[2][2][2] = put_vp8_epel4_h6v6_altivec;

    c->put_vp8_epel_pixels_tab[2][1][1] = put_vp8_epel4_h4v4_altivec;

    c->put_vp8_epel_pixels_tab[2][1][2] = put_vp8_epel4_h6v4_altivec;

    c->put_vp8_epel_pixels_tab[2][2][1] = put_vp8_epel4_h4v6_altivec;

#endif /* HAVE_ALTIVEC */

}
 and probability:0.7407407407407407
code:static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    Error *local_err = NULL;

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    DPRINTF("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " "

            "is_snapshot %d\n", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report("You can't create a snapshot of a snapshot VDI, "

                     "%s (%" PRIu32 ").", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    DPRINTF("%s %s\n", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s, &local_err);

    if (fd < 0) {

        error_report("%s", error_get_pretty(local_err));;

        error_free(local_err);

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_flags);

    if (ret < 0) {

        error_report("failed to write snapshot's inode.");

        goto cleanup;

    }



    ret = do_sd_create(s, &new_vid, 1, &local_err);

    if (ret < 0) {

        error_report("%s", error_get_pretty(local_err));;

        error_free(local_err);

        error_report("failed to create inode for snapshot. %s",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_flags);



    if (ret < 0) {

        error_report("failed to read new inode info. %s", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    DPRINTF("s->inode: name %s snap_id %x oid %x\n",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
 and probability:0.2459016393442623
code:static int probe(AVProbeData *p)

{

    unsigned i, frames, checked = 0;



    if (p->buf_size < 22 || AV_RL16(p->buf) || AV_RL16(p->buf + 2) != 1)

        return 0;

    frames = AV_RL16(p->buf + 4);

    if (!frames)

        return 0;

    for (i = 0; i < frames && i * 16 + 22 <= p->buf_size; i++) {

        unsigned offset;

        if (AV_RL16(p->buf + 10 + i * 16) & ~1)

            return FFMIN(i, AVPROBE_SCORE_MAX / 4);

        if (p->buf[13 + i * 16])

            return FFMIN(i, AVPROBE_SCORE_MAX / 4);

        if (AV_RL32(p->buf + 14 + i * 16) < 40)

            return FFMIN(i, AVPROBE_SCORE_MAX / 4);

        offset = AV_RL32(p->buf + 18 + i * 16);

        if (offset < 22)

            return FFMIN(i, AVPROBE_SCORE_MAX / 4);

        if (offset + 8 > p->buf_size)

            continue;

        if (p->buf[offset] != 40 && AV_RB64(p->buf + offset) != PNGSIG)

            return FFMIN(i, AVPROBE_SCORE_MAX / 4);

        checked++;

    }



    if (checked < frames)

        return AVPROBE_SCORE_MAX / 4 + FFMIN(checked, 1);

    return AVPROBE_SCORE_MAX / 2 + 1;

}
 and probability:0.5862068965517241
code:int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)

{

    inc_tb = av_mul_q(inc_tb, (AVRational) {inc, 1});



    if (av_cmp_q(inc_tb, ts_tb) < 0) {

        //increase step is too small for even 1 step to be representable

        return ts;

    } else {

        int64_t old = av_rescale_q(ts, ts_tb, inc_tb);

        int64_t old_ts = av_rescale_q(old, inc_tb, ts_tb);

        return av_rescale_q(old + 1, inc_tb, ts_tb) + (ts - old_ts);

    }

}
 and probability:0.08333333333333333
code:void ff_put_h264_qpel8_mc11_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2, src - (stride * 2), stride, dst, stride, 8);

}
 and probability:0.2
code:static av_noinline void FUNC(hl_decode_mb_444)(const H264Context *h, H264SliceContext *sl)

{

    const int mb_x    = sl->mb_x;

    const int mb_y    = sl->mb_y;

    const int mb_xy   = sl->mb_xy;

    const int mb_type = h->cur_pic.mb_type[mb_xy];

    uint8_t *dest[3];

    int linesize;

    int i, j, p;

    const int *block_offset = &h->block_offset[0];

    const int transform_bypass = !SIMPLE && (sl->qscale == 0 && h->sps.transform_bypass);

    const int plane_count      = (SIMPLE || !CONFIG_GRAY || !(h->flags & AV_CODEC_FLAG_GRAY)) ? 3 : 1;



    for (p = 0; p < plane_count; p++) {

        dest[p] = h->cur_pic.f->data[p] +

                  ((mb_x << PIXEL_SHIFT) + mb_y * sl->linesize) * 16;

        h->vdsp.prefetch(dest[p] + (sl->mb_x & 3) * 4 * sl->linesize + (64 << PIXEL_SHIFT),

                         sl->linesize, 4);

    }



    h->list_counts[mb_xy] = sl->list_count;



    if (!SIMPLE && MB_FIELD(sl)) {

        linesize     = sl->mb_linesize = sl->mb_uvlinesize = sl->linesize * 2;

        block_offset = &h->block_offset[48];

        if (mb_y & 1) // FIXME move out of this function?

            for (p = 0; p < 3; p++)

                dest[p] -= sl->linesize * 15;

        if (FRAME_MBAFF(h)) {

            int list;

            for (list = 0; list < sl->list_count; list++) {

                if (!USES_LIST(mb_type, list))

                    continue;

                if (IS_16X16(mb_type)) {

                    int8_t *ref = &sl->ref_cache[list][scan8[0]];

                    fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (sl->mb_y & 1), 1);

                } else {

                    for (i = 0; i < 16; i += 4) {

                        int ref = sl->ref_cache[list][scan8[i]];

                        if (ref >= 0)

                            fill_rectangle(&sl->ref_cache[list][scan8[i]], 2, 2,

                                           8, (16 + ref) ^ (sl->mb_y & 1), 1);

                    }

                }

            }

        }

    } else {

        linesize = sl->mb_linesize = sl->mb_uvlinesize = sl->linesize;

    }



    if (!SIMPLE && IS_INTRA_PCM(mb_type)) {

        if (PIXEL_SHIFT) {

            const int bit_depth = h->sps.bit_depth_luma;

            GetBitContext gb;

            init_get_bits(&gb, sl->intra_pcm_ptr, 768 * bit_depth);



            for (p = 0; p < plane_count; p++)

                for (i = 0; i < 16; i++) {

                    uint16_t *tmp = (uint16_t *)(dest[p] + i * linesize);

                    for (j = 0; j < 16; j++)

                        tmp[j] = get_bits(&gb, bit_depth);

                }

        } else {

            for (p = 0; p < plane_count; p++)

                for (i = 0; i < 16; i++)

                    memcpy(dest[p] + i * linesize,

                           sl->intra_pcm_ptr + p * 256 + i * 16, 16);

        }

    } else {

        if (IS_INTRA(mb_type)) {

            if (sl->deblocking_filter)

                xchg_mb_border(h, sl, dest[0], dest[1], dest[2], linesize,

                               linesize, 1, 1, SIMPLE, PIXEL_SHIFT);



            for (p = 0; p < plane_count; p++)

                hl_decode_mb_predict_luma(h, sl, mb_type, SIMPLE,

                                          transform_bypass, PIXEL_SHIFT,

                                          block_offset, linesize, dest[p], p);



            if (sl->deblocking_filter)

                xchg_mb_border(h, sl, dest[0], dest[1], dest[2], linesize,

                               linesize, 0, 1, SIMPLE, PIXEL_SHIFT);

        } else {

            FUNC(hl_motion_444)(h, sl, dest[0], dest[1], dest[2],

                      h->qpel_put, h->h264chroma.put_h264_chroma_pixels_tab,

                      h->qpel_avg, h->h264chroma.avg_h264_chroma_pixels_tab,

                      h->h264dsp.weight_h264_pixels_tab,

                      h->h264dsp.biweight_h264_pixels_tab);

        }



        for (p = 0; p < plane_count; p++)

            hl_decode_mb_idct_luma(h, sl, mb_type, SIMPLE, transform_bypass,

                                   PIXEL_SHIFT, block_offset, linesize,

                                   dest[p], p);

    }

}
 and probability:0.5568181818181818
code:static int parse_times(void *log_ctx, int64_t **times, int *nb_times,

                       const char *times_str)

{

    char *p;

    int i, ret = 0;

    char *times_str1 = av_strdup(times_str);

    char *saveptr = NULL;



    if (!times_str1)

        return AVERROR(ENOMEM);



#define FAIL(err) ret = err; goto end



    *nb_times = 1;

    for (p = times_str1; *p; p++)

        if (*p == ',')

            (*nb_times)++;



    *times = av_malloc(sizeof(**times) * *nb_times);

    if (!*times) {

        av_log(log_ctx, AV_LOG_ERROR, "Could not allocate forced times array\n");

        FAIL(AVERROR(ENOMEM));

    }



    p = times_str1;

    for (i = 0; i < *nb_times; i++) {

        int64_t t;

        char *tstr = av_strtok(p, ",", &saveptr);

        av_assert0(tstr);

        p = NULL;



        ret = av_parse_time(&t, tstr, 1);

        if (ret < 0) {

            av_log(log_ctx, AV_LOG_ERROR,

                   "Invalid time duration specification in %s\n", p);

            FAIL(AVERROR(EINVAL));

        }

        (*times)[i] = t;



        /* check on monotonicity */

        if (i && (*times)[i-1] > (*times)[i]) {

            av_log(log_ctx, AV_LOG_ERROR,

                   "Specified time %f is greater than the following time %f\n",

                   (float)((*times)[i])/1000000, (float)((*times)[i-1])/1000000);

            FAIL(AVERROR(EINVAL));

        }

    }



end:

    av_free(times_str1);

    return ret;

}
 and probability:0.22727272727272727
code:static void floor_fit(venc_context_t * venc, floor_t * fc, float * coeffs, int * posts, int samples) {

    int range = 255 / fc->multiplier + 1;

    int i;

    for (i = 0; i < fc->values; i++) {

        int position = fc->list[fc->list[i].sort].x;

        int begin = fc->list[fc->list[FFMAX(i-1, 0)].sort].x;

        int end   = fc->list[fc->list[FFMIN(i+1, fc->values - 1)].sort].x;

        int j;

        float average = 0;

        begin = (position + begin) / 2;

        end   = (position + end  ) / 2;



        assert(end <= samples);

        for (j = begin; j < end; j++) average += fabs(coeffs[j]);

        average /= end - begin;

        average /= 32; // MAGIC!

        for (j = 0; j < range; j++) if (floor1_inverse_db_table[j * fc->multiplier] > average) break;

        posts[fc->list[i].sort] = j;

    }

}
 and probability:0.631578947368421
code:static void gen_spr_power8_fscr(CPUPPCState *env)

{

    spr_register_kvm(env, SPR_FSCR, "FSCR",

                     SPR_NOACCESS, SPR_NOACCESS,

                     &spr_read_generic, &spr_write_generic,

                     KVM_REG_PPC_FSCR, 0x00000000);

}
 and probability:0.0
code:static int pcm_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCMDecode *s = avctx->priv_data;

    int sample_size, c, n, i;

    short *samples;

    const uint8_t *src, *src8, *src2[MAX_CHANNELS];

    uint8_t *dstu8;

    int16_t *dst_int16_t;

    int32_t *dst_int32_t;

    int64_t *dst_int64_t;

    uint16_t *dst_uint16_t;

    uint32_t *dst_uint32_t;



    samples = data;

    src = buf;



    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {

        av_log(avctx, AV_LOG_ERROR, "invalid sample_fmt\n");

        return -1;

    }



    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){

        av_log(avctx, AV_LOG_ERROR, "PCM channels out of bounds\n");

        return -1;

    }



    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;



    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */

    if (CODEC_ID_PCM_DVD == avctx->codec_id)

        /* 2 samples are interleaved per block in PCM_DVD */

        sample_size = avctx->bits_per_coded_sample * 2 / 8;

    else if (avctx->codec_id == CODEC_ID_PCM_LXF)

        /* we process 40-bit blocks per channel for LXF */

        sample_size = 5;



    if (sample_size == 0) {

        av_log(avctx, AV_LOG_ERROR, "Invalid sample_size\n");

        return AVERROR(EINVAL);

    }



    n = avctx->channels * sample_size;



    if(n && buf_size % n){

        if (buf_size < n) {

            av_log(avctx, AV_LOG_ERROR, "invalid PCM packet\n");

            return -1;

        }else

            buf_size -= buf_size % n;

    }



    buf_size= FFMIN(buf_size, *data_size/2);

    *data_size=0;



    n = buf_size/sample_size;



    switch(avctx->codec->id) {

    case CODEC_ID_PCM_U32LE:

        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)

        break;

    case CODEC_ID_PCM_U32BE:

        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)

        break;

    case CODEC_ID_PCM_S24LE:

        DECODE(int32_t, le24, src, samples, n, 8, 0)

        break;

    case CODEC_ID_PCM_S24BE:

        DECODE(int32_t, be24, src, samples, n, 8, 0)

        break;

    case CODEC_ID_PCM_U24LE:

        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)

        break;

    case CODEC_ID_PCM_U24BE:

        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)

        break;

    case CODEC_ID_PCM_S24DAUD:

        for(;n>0;n--) {

          uint32_t v = bytestream_get_be24(&src);

          v >>= 4; // sync flags are here

          *samples++ = av_reverse[(v >> 8) & 0xff] +

                       (av_reverse[v & 0xff] << 8);

        }

        break;

    case CODEC_ID_PCM_S16LE_PLANAR:

        n /= avctx->channels;

        for(c=0;c<avctx->channels;c++)

            src2[c] = &src[c*n*2];

        for(;n>0;n--)

            for(c=0;c<avctx->channels;c++)

                *samples++ = bytestream_get_le16(&src2[c]);

        src = src2[avctx->channels-1];

        break;

    case CODEC_ID_PCM_U16LE:

        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)

        break;

    case CODEC_ID_PCM_U16BE:

        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)

        break;

    case CODEC_ID_PCM_S8:

        dstu8= (uint8_t*)samples;

        for(;n>0;n--) {

            *dstu8++ = *src++ + 128;

        }

        samples= (short*)dstu8;

        break;

#if HAVE_BIGENDIAN

    case CODEC_ID_PCM_F64LE:

        DECODE(int64_t, le64, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S32LE:

    case CODEC_ID_PCM_F32LE:

        DECODE(int32_t, le32, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S16LE:

        DECODE(int16_t, le16, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F64BE:

    case CODEC_ID_PCM_F32BE:

    case CODEC_ID_PCM_S32BE:

    case CODEC_ID_PCM_S16BE:

#else

    case CODEC_ID_PCM_F64BE:

        DECODE(int64_t, be64, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F32BE:

    case CODEC_ID_PCM_S32BE:

        DECODE(int32_t, be32, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_S16BE:

        DECODE(int16_t, be16, src, samples, n, 0, 0)

        break;

    case CODEC_ID_PCM_F64LE:

    case CODEC_ID_PCM_F32LE:

    case CODEC_ID_PCM_S32LE:

    case CODEC_ID_PCM_S16LE:

#endif /* HAVE_BIGENDIAN */

    case CODEC_ID_PCM_U8:

        memcpy(samples, src, n*sample_size);

        src += n*sample_size;

        samples = (short*)((uint8_t*)data + n*sample_size);

        break;

    case CODEC_ID_PCM_ZORK:

        for(;n>0;n--) {

            int x= *src++;

            if(x&128) x-= 128;

            else      x = -x;

            *samples++ = x << 8;

        }

        break;

    case CODEC_ID_PCM_ALAW:

    case CODEC_ID_PCM_MULAW:

        for(;n>0;n--) {

            *samples++ = s->table[*src++];

        }

        break;

    case CODEC_ID_PCM_DVD:

        dst_int32_t = data;

        n /= avctx->channels;

        switch (avctx->bits_per_coded_sample) {

        case 20:

            while (n--) {

                c = avctx->channels;

                src8 = src + 4*c;

                while (c--) {

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);

                }

                src = src8;

            }

            break;

        case 24:

            while (n--) {

                c = avctx->channels;

                src8 = src + 4*c;

                while (c--) {

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);

                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);

                }

                src = src8;

            }

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, "PCM DVD unsupported sample depth\n");

            return -1;

        }

        samples = (short *) dst_int32_t;

        break;

    case CODEC_ID_PCM_LXF:

        dst_int32_t = data;

        n /= avctx->channels;

        //unpack and de-planerize

        for (i = 0; i < n; i++) {

            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {

                //extract low 20 bits and expand to 32 bits

                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |

                                 ((src8[2] & 0xF) << 8) | src8[1];

            }



            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {

                //extract high 20 bits and expand to 32 bits

                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |

                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);

            }

        }

        src += n * avctx->channels * 5;

        samples = (short *) dst_int32_t;

        break;

    default:

        return -1;

    }

    *data_size = (uint8_t *)samples - (uint8_t *)data;

    return src - buf;

}
 and probability:0.3024390243902439
code:int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,

                             int *got_sub_ptr,

                             AVPacket *avpkt)

{

    int i, ret = 0;



    if (!avpkt->data && avpkt->size) {

        av_log(avctx, AV_LOG_ERROR, "invalid packet: NULL data, size != 0\n");

        return AVERROR(EINVAL);

    }

    if (!avctx->codec)

        return AVERROR(EINVAL);

    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {

        av_log(avctx, AV_LOG_ERROR, "Invalid media type for subtitles\n");

        return AVERROR(EINVAL);

    }



    *got_sub_ptr = 0;

    get_subtitle_defaults(sub);



    if ((avctx->codec->capabilities & AV_CODEC_CAP_DELAY) || avpkt->size) {

        AVPacket pkt_recoded;

        AVPacket tmp = *avpkt;

        int did_split = av_packet_split_side_data(&tmp);

        //apply_param_change(avctx, &tmp);



        if (did_split) {

            /* FFMIN() prevents overflow in case the packet wasn't allocated with

             * proper padding.

             * If the side data is smaller than the buffer padding size, the

             * remaining bytes should have already been filled with zeros by the

             * original packet allocation anyway. */

            memset(tmp.data + tmp.size, 0,

                   FFMIN(avpkt->size - tmp.size, AV_INPUT_BUFFER_PADDING_SIZE));

        }



        pkt_recoded = tmp;

        ret = recode_subtitle(avctx, &pkt_recoded, &tmp);

        if (ret < 0) {

            *got_sub_ptr = 0;

        } else {

            avctx->internal->pkt = &pkt_recoded;



            if (avctx->pkt_timebase.den && avpkt->pts != AV_NOPTS_VALUE)

                sub->pts = av_rescale_q(avpkt->pts,

                                        avctx->pkt_timebase, AV_TIME_BASE_Q);

            ret = avctx->codec->decode(avctx, sub, got_sub_ptr, &pkt_recoded);

            av_assert1((ret >= 0) >= !!*got_sub_ptr &&

                       !!*got_sub_ptr >= !!sub->num_rects);



            if (sub->num_rects && !sub->end_display_time && avpkt->duration &&

                avctx->pkt_timebase.num) {

                AVRational ms = { 1, 1000 };

                sub->end_display_time = av_rescale_q(avpkt->duration,

                                                     avctx->pkt_timebase, ms);

            }



            for (i = 0; i < sub->num_rects; i++) {

                if (sub->rects[i]->ass && !utf8_check(sub->rects[i]->ass)) {

                    av_log(avctx, AV_LOG_ERROR,

                           "Invalid UTF-8 in decoded subtitles text; "

                           "maybe missing -sub_charenc option\n");

                    avsubtitle_free(sub);

                    return AVERROR_INVALIDDATA;

                }

            }



            if (tmp.data != pkt_recoded.data) { // did we recode?

                /* prevent from destroying side data from original packet */

                pkt_recoded.side_data = NULL;

                pkt_recoded.side_data_elems = 0;



                av_packet_unref(&pkt_recoded);

            }

            if (avctx->codec_descriptor->props & AV_CODEC_PROP_BITMAP_SUB)

                sub->format = 0;

            else if (avctx->codec_descriptor->props & AV_CODEC_PROP_TEXT_SUB)

                sub->format = 1;

            avctx->internal->pkt = NULL;

        }



        if (did_split) {

            av_packet_free_side_data(&tmp);

            if(ret == tmp.size)

                ret = avpkt->size;

        }



        if (*got_sub_ptr)

            avctx->frame_number++;

    }



    return ret;

}
 and probability:0.375
code:static int flv_write_packet(AVFormatContext *s, int stream_index,

                            const uint8_t *buf, int size, int64_t timestamp)

{

    ByteIOContext *pb = &s->pb;

    AVCodecContext *enc = &s->streams[stream_index]->codec;

    FLVContext *flv = s->priv_data;



    if (enc->codec_type == CODEC_TYPE_VIDEO) {

        FLVFrame *frame = av_malloc(sizeof(FLVFrame));

        frame->next = 0;

        frame->type = 9;

        frame->flags = 2; // choose h263

        frame->flags |= enc->coded_frame->key_frame ? 0x10 : 0x20; // add keyframe indicator

        frame->timestamp = timestamp;

        //frame->timestamp = ( ( flv->frameCount * (int64_t)FRAME_RATE_BASE * (int64_t)1000 ) / (int64_t)enc->frame_rate );

        //printf("%08x %f %f\n",frame->timestamp,(double)enc->frame_rate/(double)FRAME_RATE_BASE,1000*(double)FRAME_RATE_BASE/(double)enc->frame_rate);

        frame->size = size;

        frame->data = av_malloc(size);

        memcpy(frame->data,buf,size);

        flv->hasVideo = 1;



        InsertSorted(flv,frame);



        flv->frameCount ++;

    }

    else if (enc->codec_type == CODEC_TYPE_AUDIO) {

#ifdef CONFIG_MP3LAME

        if (enc->codec_id == CODEC_ID_MP3 ) {

            int c=0;

            for (;c<size;c++) {

                flv->audioFifo[(flv->audioOutPos+c)%AUDIO_FIFO_SIZE] = buf[c];

            }

            flv->audioSize += size;

            flv->audioOutPos += size;

            flv->audioOutPos %= AUDIO_FIFO_SIZE;



            if ( flv->initDelay == -1 ) {

                flv->initDelay = timestamp;

            }



            if ( flv->audioTime == -1 ) {

                flv->audioTime = timestamp;

//                flv->audioTime = ( ( ( flv->sampleCount - enc->delay ) * 8000 ) / flv->audioRate ) - flv->initDelay - 250;

//                if ( flv->audioTime < 0 ) {

//                    flv->audioTime = 0;

//                }

            }

        }

        for ( ; flv->audioSize >= 4 ; ) {



            int mp3FrameSize = 0;

            int mp3SampleRate = 0;

            int mp3IsMono = 0;

            int mp3SamplesPerFrame = 0;



            if ( mp3info(&flv->audioFifo[flv->audioInPos],&mp3FrameSize,&mp3SamplesPerFrame,&mp3SampleRate,&mp3IsMono) ) {

                if ( flv->audioSize >= mp3FrameSize ) {



                    int soundFormat = 0x22;

                    int c=0;

                    FLVFrame *frame = av_malloc(sizeof(FLVFrame));



                    flv->audioRate = mp3SampleRate;



                    switch (mp3SampleRate) {

                        case    44100:

                            soundFormat |= 0x0C;

                            break;

                        case    22050:

                            soundFormat |= 0x08;

                            break;

                        case    11025:

                            soundFormat |= 0x04;

                            break;

                    }



                    if ( !mp3IsMono ) {

                        soundFormat |= 0x01;

                    }



                    frame->next = 0;

                    frame->type = 8;

                    frame->flags = soundFormat;

                    frame->timestamp = flv->audioTime;

                    frame->size = mp3FrameSize;

                    frame->data = av_malloc(mp3FrameSize);



                    for (;c<mp3FrameSize;c++) {

                        frame->data[c] = flv->audioFifo[(flv->audioInPos+c)%AUDIO_FIFO_SIZE];

                    }



                    flv->audioInPos += mp3FrameSize;

                    flv->audioSize -= mp3FrameSize;

                    flv->audioInPos %= AUDIO_FIFO_SIZE;

                    flv->sampleCount += mp3SamplesPerFrame;



                    // Reset audio for next round

                    flv->audioTime = -1;

                    // We got audio! Make sure we set this to the global flags on closure

                    flv->hasAudio = 1;



                    InsertSorted(flv,frame);

                }

                break;

            }

            flv->audioInPos ++;

            flv->audioSize --;

            flv->audioInPos %= AUDIO_FIFO_SIZE;

            // no audio in here!

            flv->audioTime = -1;

        }

#endif

    }

    Dump(flv,pb,128);

    put_flush_packet(pb);

    return 0;

}
 and probability:0.46534653465346537
code:void ahci_init(AHCIState *s, DeviceState *qdev, DMAContext *dma, int ports)

{

    qemu_irq *irqs;

    int i;



    s->dma = dma;

    s->ports = ports;

    s->dev = g_malloc0(sizeof(AHCIDevice) * ports);

    ahci_reg_init(s);

    /* XXX BAR size should be 1k, but that breaks, so bump it to 4k for now */

    memory_region_init_io(&s->mem, &ahci_mem_ops, s, "ahci", AHCI_MEM_BAR_SIZE);

    memory_region_init_io(&s->idp, &ahci_idp_ops, s, "ahci-idp", 32);



    irqs = qemu_allocate_irqs(ahci_irq_set, s, s->ports);



    for (i = 0; i < s->ports; i++) {

        AHCIDevice *ad = &s->dev[i];



        ide_bus_new(&ad->port, qdev, i);

        ide_init2(&ad->port, irqs[i]);



        ad->hba = s;

        ad->port_no = i;

        ad->port.dma = &ad->dma;

        ad->port.dma->ops = &ahci_dma_ops;

        ad->port_regs.cmd = PORT_CMD_SPIN_UP | PORT_CMD_POWER_ON;

    }

}
 and probability:0.6521739130434783
code:static void put_psr(target_ulong val)

{

    env->psr = val & PSR_ICC;

    env->psref = (val & PSR_EF)? 1 : 0;

    env->psrpil = (val & PSR_PIL) >> 8;

#if ((!defined (TARGET_SPARC64)) && !defined(CONFIG_USER_ONLY))

    cpu_check_irqs(env);

#endif

    env->psrs = (val & PSR_S)? 1 : 0;

    env->psrps = (val & PSR_PS)? 1 : 0;

#if !defined (TARGET_SPARC64)

    env->psret = (val & PSR_ET)? 1 : 0;

#endif

    set_cwp(val & PSR_CWP);

    env->cc_op = CC_OP_FLAGS;

}
 and probability:0.4375
code:void dsputil_init_ppc(void)

{

    // Common optimisations whether Altivec or not



    // ... pending ...



#if HAVE_ALTIVEC

    if (has_altivec()) {

        // Altivec specific optimisations

        pix_abs16x16 = pix_abs16x16_altivec;

        pix_abs8x8 = pix_abs8x8_altivec;

        pix_sum = pix_sum_altivec;

        diff_pixels = diff_pixels_altivec;

        get_pixels = get_pixels_altivec;

    } else

#endif

    {

        // Non-AltiVec PPC optimisations



        // ... pending ...

    }

}
 and probability:0.0
code:int qcow2_check_metadata_overlap(BlockDriverState *bs, int ign, int64_t offset,

                                 int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    int chk = s->overlap_check & ~ign;

    int i, j;



    if (!size) {

        return 0;

    }



    if (chk & QCOW2_OL_MAIN_HEADER) {

        if (offset < s->cluster_size) {

            return QCOW2_OL_MAIN_HEADER;

        }

    }



    /* align range to test to cluster boundaries */

    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);

    offset = start_of_cluster(s, offset);



    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {

        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {

            return QCOW2_OL_ACTIVE_L1;

        }

    }



    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {

        if (overlaps_with(s->refcount_table_offset,

            s->refcount_table_size * sizeof(uint64_t))) {

            return QCOW2_OL_REFCOUNT_TABLE;

        }

    }



    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {

        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {

            return QCOW2_OL_SNAPSHOT_TABLE;

        }

    }



    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {

        for (i = 0; i < s->nb_snapshots; i++) {

            if (s->snapshots[i].l1_size &&

                overlaps_with(s->snapshots[i].l1_table_offset,

                s->snapshots[i].l1_size * sizeof(uint64_t))) {

                return QCOW2_OL_INACTIVE_L1;

            }

        }

    }



    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {

        for (i = 0; i < s->l1_size; i++) {

            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&

                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,

                s->cluster_size)) {

                return QCOW2_OL_ACTIVE_L2;

            }

        }

    }



    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {

        for (i = 0; i < s->refcount_table_size; i++) {

            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&

                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,

                s->cluster_size)) {

                return QCOW2_OL_REFCOUNT_BLOCK;

            }

        }

    }



    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {

        for (i = 0; i < s->nb_snapshots; i++) {

            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;

            uint32_t l1_sz  = s->snapshots[i].l1_size;

            uint64_t l1_sz2 = l1_sz * sizeof(uint64_t);

            uint64_t *l1 = g_malloc(l1_sz2);

            int ret;



            ret = bdrv_pread(bs->file, l1_ofs, l1, l1_sz2);

            if (ret < 0) {

                g_free(l1);

                return ret;

            }



            for (j = 0; j < l1_sz; j++) {

                uint64_t l2_ofs = be64_to_cpu(l1[j]) & L1E_OFFSET_MASK;

                if (l2_ofs && overlaps_with(l2_ofs, s->cluster_size)) {

                    g_free(l1);

                    return QCOW2_OL_INACTIVE_L2;

                }

            }



            g_free(l1);

        }

    }



    return 0;

}
 and probability:0.4166666666666667
code:static char *sdp_write_media_attributes(char *buff, int size, AVCodecContext *c, int payload_type, AVFormatContext *fmt)

{

    char *config = NULL;



    switch (c->codec_id) {

        case AV_CODEC_ID_H264: {

            int mode = 1;

            if (fmt && fmt->oformat && fmt->oformat->priv_class &&

                av_opt_flag_is_set(fmt->priv_data, "rtpflags", "h264_mode0"))

                mode = 0;

            if (c->extradata_size) {

                config = extradata2psets(c);

            }

            av_strlcatf(buff, size, "a=rtpmap:%d H264/90000\r\n"

                                    "a=fmtp:%d packetization-mode=%d%s\r\n",

                                     payload_type,

                                     payload_type, mode, config ? config : "");

            break;

        }

        case AV_CODEC_ID_H263:

        case AV_CODEC_ID_H263P:

            /* a=framesize is required by 3GPP TS 26.234 (PSS). It

             * actually specifies the maximum video size, but we only know

             * the current size. This is required for playback on Android

             * stagefright and on Samsung bada. */

            if (!fmt || !fmt->oformat->priv_class ||

                !av_opt_flag_is_set(fmt->priv_data, "rtpflags", "rfc2190") ||

                c->codec_id == AV_CODEC_ID_H263P)

            av_strlcatf(buff, size, "a=rtpmap:%d H263-2000/90000\r\n"

                                    "a=framesize:%d %d-%d\r\n",

                                    payload_type,

                                    payload_type, c->width, c->height);

            break;

        case AV_CODEC_ID_HEVC:

            if (c->extradata_size)

                av_log(NULL, AV_LOG_WARNING, "HEVC extradata not currently "

                                             "passed properly through SDP\n");

            av_strlcatf(buff, size, "a=rtpmap:%d H265/90000\r\n", payload_type);

            break;

        case AV_CODEC_ID_MPEG4:

            if (c->extradata_size) {

                config = extradata2config(c);

            }

            av_strlcatf(buff, size, "a=rtpmap:%d MP4V-ES/90000\r\n"

                                    "a=fmtp:%d profile-level-id=1%s\r\n",

                                     payload_type,

                                     payload_type, config ? config : "");

            break;

        case AV_CODEC_ID_AAC:

            if (fmt && fmt->oformat->priv_class &&

                av_opt_flag_is_set(fmt->priv_data, "rtpflags", "latm")) {

                config = latm_context2config(c);

                if (!config)

                    return NULL;

                av_strlcatf(buff, size, "a=rtpmap:%d MP4A-LATM/%d/%d\r\n"

                                        "a=fmtp:%d profile-level-id=%d;cpresent=0;config=%s\r\n",

                                         payload_type, c->sample_rate, c->channels,

                                         payload_type, latm_context2profilelevel(c), config);

            } else {

                if (c->extradata_size) {

                    config = extradata2config(c);

                } else {

                    /* FIXME: maybe we can forge config information based on the

                     *        codec parameters...

                     */

                    av_log(c, AV_LOG_ERROR, "AAC with no global headers is currently not supported.\n");

                    return NULL;

                }

                if (!config) {

                    return NULL;

                }

                av_strlcatf(buff, size, "a=rtpmap:%d MPEG4-GENERIC/%d/%d\r\n"

                                        "a=fmtp:%d profile-level-id=1;"

                                        "mode=AAC-hbr;sizelength=13;indexlength=3;"

                                        "indexdeltalength=3%s\r\n",

                                         payload_type, c->sample_rate, c->channels,

                                         payload_type, config);

            }

            break;

        case AV_CODEC_ID_PCM_S16BE:

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d L16/%d/%d\r\n",

                                         payload_type,

                                         c->sample_rate, c->channels);

            break;

        case AV_CODEC_ID_PCM_MULAW:

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d PCMU/%d/%d\r\n",

                                         payload_type,

                                         c->sample_rate, c->channels);

            break;

        case AV_CODEC_ID_PCM_ALAW:

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d PCMA/%d/%d\r\n",

                                         payload_type,

                                         c->sample_rate, c->channels);

            break;

        case AV_CODEC_ID_AMR_NB:

            av_strlcatf(buff, size, "a=rtpmap:%d AMR/%d/%d\r\n"

                                    "a=fmtp:%d octet-align=1\r\n",

                                     payload_type, c->sample_rate, c->channels,

                                     payload_type);

            break;

        case AV_CODEC_ID_AMR_WB:

            av_strlcatf(buff, size, "a=rtpmap:%d AMR-WB/%d/%d\r\n"

                                    "a=fmtp:%d octet-align=1\r\n",

                                     payload_type, c->sample_rate, c->channels,

                                     payload_type);

            break;

        case AV_CODEC_ID_VORBIS:

            if (c->extradata_size)

                config = xiph_extradata2config(c);

            else

                av_log(c, AV_LOG_ERROR, "Vorbis configuration info missing\n");

            if (!config)

                return NULL;



            av_strlcatf(buff, size, "a=rtpmap:%d vorbis/%d/%d\r\n"

                                    "a=fmtp:%d configuration=%s\r\n",

                                    payload_type, c->sample_rate, c->channels,

                                    payload_type, config);

            break;

        case AV_CODEC_ID_THEORA: {

            const char *pix_fmt;

            switch (c->pix_fmt) {

            case AV_PIX_FMT_YUV420P:

                pix_fmt = "YCbCr-4:2:0";

                break;

            case AV_PIX_FMT_YUV422P:

                pix_fmt = "YCbCr-4:2:2";

                break;

            case AV_PIX_FMT_YUV444P:

                pix_fmt = "YCbCr-4:4:4";

                break;

            default:

                av_log(c, AV_LOG_ERROR, "Unsupported pixel format.\n");

                return NULL;

            }



            if (c->extradata_size)

                config = xiph_extradata2config(c);

            else

                av_log(c, AV_LOG_ERROR, "Theora configuation info missing\n");

            if (!config)

                return NULL;



            av_strlcatf(buff, size, "a=rtpmap:%d theora/90000\r\n"

                                    "a=fmtp:%d delivery-method=inline; "

                                    "width=%d; height=%d; sampling=%s; "

                                    "configuration=%s\r\n",

                                    payload_type, payload_type,

                                    c->width, c->height, pix_fmt, config);

            break;

        }

        case AV_CODEC_ID_VP8:

            av_strlcatf(buff, size, "a=rtpmap:%d VP8/90000\r\n",

                                     payload_type);

            break;

        case AV_CODEC_ID_MJPEG:

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d JPEG/90000\r\n",

                                         payload_type);

            break;

        case AV_CODEC_ID_ADPCM_G722:

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d G722/%d/%d\r\n",

                                         payload_type,

                                         8000, c->channels);

            break;

        case AV_CODEC_ID_ADPCM_G726: {

            if (payload_type >= RTP_PT_PRIVATE)

                av_strlcatf(buff, size, "a=rtpmap:%d G726-%d/%d\r\n",

                                         payload_type,

                                         c->bits_per_coded_sample*8,

                                         c->sample_rate);

            break;

        }

        case AV_CODEC_ID_ILBC:

            av_strlcatf(buff, size, "a=rtpmap:%d iLBC/%d\r\n"

                                    "a=fmtp:%d mode=%d\r\n",

                                     payload_type, c->sample_rate,

                                     payload_type, c->block_align == 38 ? 20 : 30);

            break;

        case AV_CODEC_ID_SPEEX:

            av_strlcatf(buff, size, "a=rtpmap:%d speex/%d\r\n",

                                     payload_type, c->sample_rate);

            break;

        case AV_CODEC_ID_OPUS:

            /* The opus RTP draft says that all opus streams MUST be declared

               as stereo, to avoid negotiation failures. The actual number of

               channels can change on a packet-by-packet basis. The number of

               channels a receiver prefers to receive or a sender plans to send

               can be declared via fmtp parameters (both default to mono), but

               receivers MUST be able to receive and process stereo packets. */

            av_strlcatf(buff, size, "a=rtpmap:%d opus/48000/2\r\n",

                                     payload_type);

            if (c->channels == 2) {

                av_strlcatf(buff, size, "a=fmtp:%d sprop-stereo:1\r\n",

                                         payload_type);

            }

            break;

        default:

            /* Nothing special to do here... */

            break;

    }



    av_free(config);



    return buff;

}
 and probability:0.1568627450980392
code:static void compute_status(HTTPContext *c)

{

    HTTPContext *c1;

    FFStream *stream;

    char *p;

    time_t ti;

    int i, len;

    AVIOContext *pb;



    if (avio_open_dyn_buf(&pb) < 0) {

        /* XXX: return an error ? */

        c->buffer_ptr = c->buffer;

        c->buffer_end = c->buffer;

        return;

    }



    avio_printf(pb, "HTTP/1.0 200 OK\r\n");

    avio_printf(pb, "Content-type: %s\r\n", "text/html");

    avio_printf(pb, "Pragma: no-cache\r\n");

    avio_printf(pb, "\r\n");



    avio_printf(pb, "<html><head><title>%s Status</title>\n", program_name);

    if (c->stream->feed_filename[0])

        avio_printf(pb, "<link rel=\"shortcut icon\" href=\"%s\">\n", c->stream->feed_filename);

    avio_printf(pb, "</head>\n<body>");

    avio_printf(pb, "<h1>%s Status</h1>\n", program_name);

    /* format status */

    avio_printf(pb, "<h2>Available Streams</h2>\n");

    avio_printf(pb, "<table cellspacing=0 cellpadding=4>\n");

    avio_printf(pb, "<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\n");

    stream = first_stream;

    while (stream != NULL) {

        char sfilename[1024];

        char *eosf;



        if (stream->feed != stream) {

            av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);

            eosf = sfilename + strlen(sfilename);

            if (eosf - sfilename >= 4) {

                if (strcmp(eosf - 4, ".asf") == 0)

                    strcpy(eosf - 4, ".asx");

                else if (strcmp(eosf - 3, ".rm") == 0)

                    strcpy(eosf - 3, ".ram");

                else if (stream->fmt && !strcmp(stream->fmt->name, "rtp")) {

                    /* generate a sample RTSP director if

                       unicast. Generate an SDP redirector if

                       multicast */

                    eosf = strrchr(sfilename, '.');

                    if (!eosf)

                        eosf = sfilename + strlen(sfilename);

                    if (stream->is_multicast)

                        strcpy(eosf, ".sdp");

                    else

                        strcpy(eosf, ".rtsp");

                }

            }



            avio_printf(pb, "<tr><td><a href=\"/%s\">%s</a> ",

                         sfilename, stream->filename);

            avio_printf(pb, "<td align=right> %d <td align=right> ",

                        stream->conns_served);

            fmt_bytecount(pb, stream->bytes_served);

            switch(stream->stream_type) {

            case STREAM_TYPE_LIVE: {

                    int audio_bit_rate = 0;

                    int video_bit_rate = 0;

                    const char *audio_codec_name = "";

                    const char *video_codec_name = "";

                    const char *audio_codec_name_extra = "";

                    const char *video_codec_name_extra = "";



                    for(i=0;i<stream->nb_streams;i++) {

                        AVStream *st = stream->streams[i];

                        AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);

                        switch(st->codec->codec_type) {

                        case AVMEDIA_TYPE_AUDIO:

                            audio_bit_rate += st->codec->bit_rate;

                            if (codec) {

                                if (*audio_codec_name)

                                    audio_codec_name_extra = "...";

                                audio_codec_name = codec->name;

                            }

                            break;

                        case AVMEDIA_TYPE_VIDEO:

                            video_bit_rate += st->codec->bit_rate;

                            if (codec) {

                                if (*video_codec_name)

                                    video_codec_name_extra = "...";

                                video_codec_name = codec->name;

                            }

                            break;

                        case AVMEDIA_TYPE_DATA:

                            video_bit_rate += st->codec->bit_rate;

                            break;

                        default:

                            abort();

                        }

                    }

                    avio_printf(pb, "<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s",

                                 stream->fmt->name,

                                 stream->bandwidth,

                                 video_bit_rate / 1000, video_codec_name, video_codec_name_extra,

                                 audio_bit_rate / 1000, audio_codec_name, audio_codec_name_extra);

                    if (stream->feed)

                        avio_printf(pb, "<td>%s", stream->feed->filename);

                    else

                        avio_printf(pb, "<td>%s", stream->feed_filename);

                    avio_printf(pb, "\n");

                }

                break;

            default:

                avio_printf(pb, "<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\n");

                break;

            }

        }

        stream = stream->next;

    }

    avio_printf(pb, "</table>\n");



    stream = first_stream;

    while (stream != NULL) {

        if (stream->feed == stream) {

            avio_printf(pb, "<h2>Feed %s</h2>", stream->filename);

            if (stream->pid) {

                avio_printf(pb, "Running as pid %d.\n", stream->pid);



#if defined(linux) && !defined(CONFIG_NOCUTILS)

                {

                    FILE *pid_stat;

                    char ps_cmd[64];



                    /* This is somewhat linux specific I guess */

                    snprintf(ps_cmd, sizeof(ps_cmd),

                             "ps -o \"%%cpu,cputime\" --no-headers %d",

                             stream->pid);



                    pid_stat = popen(ps_cmd, "r");

                    if (pid_stat) {

                        char cpuperc[10];

                        char cpuused[64];



                        if (fscanf(pid_stat, "%10s %64s", cpuperc,

                                   cpuused) == 2) {

                            avio_printf(pb, "Currently using %s%% of the cpu. Total time used %s.\n",

                                         cpuperc, cpuused);

                        }

                        fclose(pid_stat);

                    }

                }

#endif



                avio_printf(pb, "<p>");

            }

            avio_printf(pb, "<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\n");



            for (i = 0; i < stream->nb_streams; i++) {

                AVStream *st = stream->streams[i];

                AVCodec *codec = avcodec_find_encoder(st->codec->codec_id);

                const char *type = "unknown";

                char parameters[64];



                parameters[0] = 0;



                switch(st->codec->codec_type) {

                case AVMEDIA_TYPE_AUDIO:

                    type = "audio";

                    snprintf(parameters, sizeof(parameters), "%d channel(s), %d Hz", st->codec->channels, st->codec->sample_rate);

                    break;

                case AVMEDIA_TYPE_VIDEO:

                    type = "video";

                    snprintf(parameters, sizeof(parameters), "%dx%d, q=%d-%d, fps=%d", st->codec->width, st->codec->height,

                                st->codec->qmin, st->codec->qmax, st->codec->time_base.den / st->codec->time_base.num);

                    break;

                default:

                    abort();

                }

                avio_printf(pb, "<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\n",

                        i, type, st->codec->bit_rate/1000, codec ? codec->name : "", parameters);

            }

            avio_printf(pb, "</table>\n");



        }

        stream = stream->next;

    }



    /* connection status */

    avio_printf(pb, "<h2>Connection Status</h2>\n");



    avio_printf(pb, "Number of connections: %d / %d<br>\n",

                 nb_connections, nb_max_connections);



    avio_printf(pb, "Bandwidth in use: %"PRIu64"k / %"PRIu64"k<br>\n",

                 current_bandwidth, max_bandwidth);



    avio_printf(pb, "<table>\n");

    avio_printf(pb, "<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\n");

    c1 = first_http_ctx;

    i = 0;

    while (c1 != NULL) {

        int bitrate;

        int j;



        bitrate = 0;

        if (c1->stream) {

            for (j = 0; j < c1->stream->nb_streams; j++) {

                if (!c1->stream->feed)

                    bitrate += c1->stream->streams[j]->codec->bit_rate;

                else if (c1->feed_streams[j] >= 0)

                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;

            }

        }



        i++;

        p = inet_ntoa(c1->from_addr.sin_addr);

        avio_printf(pb, "<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>",

                    i,

                    c1->stream ? c1->stream->filename : "",

                    c1->state == HTTPSTATE_RECEIVE_DATA ? "(input)" : "",

                    p,

                    c1->protocol,

                    http_state[c1->state]);

        fmt_bytecount(pb, bitrate);

        avio_printf(pb, "<td align=right>");

        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);

        avio_printf(pb, "<td align=right>");

        fmt_bytecount(pb, c1->data_count);

        avio_printf(pb, "\n");

        c1 = c1->next;

    }

    avio_printf(pb, "</table>\n");



    /* date */

    ti = time(NULL);

    p = ctime(&ti);

    avio_printf(pb, "<hr size=1 noshade>Generated at %s", p);

    avio_printf(pb, "</body>\n</html>\n");



    len = avio_close_dyn_buf(pb, &c->pb_buffer);

    c->buffer_ptr = c->pb_buffer;

    c->buffer_end = c->pb_buffer + len;

}
 and probability:0.33640552995391704
code:static void esp_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    ESPState *s = opaque;

    uint32_t saddr;



    saddr = (addr >> s->it_shift) & (ESP_REGS - 1);

    DPRINTF("write reg[%d]: 0x%2.2x -> 0x%2.2x\n", saddr, s->wregs[saddr],

            val);

    switch (saddr) {

    case ESP_TCLO:

    case ESP_TCMID:

        s->rregs[ESP_RSTAT] &= ~STAT_TC;

        break;

    case ESP_FIFO:

        if (s->do_cmd) {

            s->cmdbuf[s->cmdlen++] = val & 0xff;

        } else if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {

            uint8_t buf;

            buf = val & 0xff;

            s->ti_size--;

            fprintf(stderr, "esp: PIO data write not implemented\n");

        } else {

            s->ti_size++;

            s->ti_buf[s->ti_wptr++] = val & 0xff;

        }

        break;

    case ESP_CMD:

        s->rregs[saddr] = val;

        if (val & CMD_DMA) {

            s->dma = 1;

            /* Reload DMA counter.  */

            s->rregs[ESP_TCLO] = s->wregs[ESP_TCLO];

            s->rregs[ESP_TCMID] = s->wregs[ESP_TCMID];

        } else {

            s->dma = 0;

        }

        switch(val & CMD_CMD) {

        case CMD_NOP:

            DPRINTF("NOP (%2.2x)\n", val);

            break;

        case CMD_FLUSH:

            DPRINTF("Flush FIFO (%2.2x)\n", val);

            //s->ti_size = 0;

            s->rregs[ESP_RINTR] = INTR_FC;

            s->rregs[ESP_RSEQ] = 0;

            s->rregs[ESP_RFLAGS] = 0;

            break;

        case CMD_RESET:

            DPRINTF("Chip reset (%2.2x)\n", val);

            esp_reset(s);

            break;

        case CMD_BUSRESET:

            DPRINTF("Bus reset (%2.2x)\n", val);

            s->rregs[ESP_RINTR] = INTR_RST;

            if (!(s->wregs[ESP_CFG1] & CFG1_RESREPT)) {

                esp_raise_irq(s);

            }

            break;

        case CMD_TI:

            handle_ti(s);

            break;

        case CMD_ICCS:

            DPRINTF("Initiator Command Complete Sequence (%2.2x)\n", val);

            write_response(s);

            break;

        case CMD_MSGACC:

            DPRINTF("Message Accepted (%2.2x)\n", val);

            write_response(s);

            s->rregs[ESP_RINTR] = INTR_DC;

            s->rregs[ESP_RSEQ] = 0;

            break;

        case CMD_SATN:

            DPRINTF("Set ATN (%2.2x)\n", val);

            break;

        case CMD_SELATN:

            DPRINTF("Set ATN (%2.2x)\n", val);

            handle_satn(s);

            break;

        case CMD_SELATNS:

            DPRINTF("Set ATN & stop (%2.2x)\n", val);

            handle_satn_stop(s);

            break;

        case CMD_ENSEL:

            DPRINTF("Enable selection (%2.2x)\n", val);

            break;

        default:

            DPRINTF("Unhandled ESP command (%2.2x)\n", val);

            break;

        }

        break;

    case ESP_WBUSID ... ESP_WSYNO:

        break;

    case ESP_CFG1:

        s->rregs[saddr] = val;

        break;

    case ESP_WCCF ... ESP_WTEST:

        break;

    case ESP_CFG2:

        s->rregs[saddr] = val & CFG2_MASK;

        break;

    case ESP_CFG3 ... ESP_RES4:

        s->rregs[saddr] = val;

        break;

    default:

        break;

    }

    s->wregs[saddr] = val;

}
 and probability:0.2336448598130841
code:int ff_flac_decode_frame_header(AVCodecContext *avctx, GetBitContext *gb,

                                FLACFrameInfo *fi)

{

    int bs_code, sr_code, bps_code;



    /* frame sync code */

    skip_bits(gb, 16);



    /* block size and sample rate codes */

    bs_code = get_bits(gb, 4);

    sr_code = get_bits(gb, 4);



    /* channels and decorrelation */

    fi->ch_mode = get_bits(gb, 4);

    if (fi->ch_mode < FLAC_MAX_CHANNELS) {

        fi->channels = fi->ch_mode + 1;

        fi->ch_mode = FLAC_CHMODE_INDEPENDENT;

    } else if (fi->ch_mode <= FLAC_CHMODE_MID_SIDE) {

        fi->channels = 2;

    } else {

        av_log(avctx, AV_LOG_ERROR, "invalid channel mode: %d\n", fi->ch_mode);

        return -1;

    }



    /* bits per sample */

    bps_code = get_bits(gb, 3);

    if (bps_code == 3 || bps_code == 7) {

        av_log(avctx, AV_LOG_ERROR, "invalid sample size code (%d)\n",

               bps_code);

        return -1;

    }

    fi->bps = sample_size_table[bps_code];



    /* reserved bit */

    if (get_bits1(gb)) {

        av_log(avctx, AV_LOG_ERROR, "broken stream, invalid padding\n");

        return -1;

    }



    /* sample or frame count */

    if (get_utf8(gb) < 0) {

        av_log(avctx, AV_LOG_ERROR, "utf8 fscked\n");

        return -1;

    }



    /* blocksize */

    if (bs_code == 0) {

        av_log(avctx, AV_LOG_ERROR, "reserved blocksize code: 0\n");

        return -1;

    } else if (bs_code == 6) {

        fi->blocksize = get_bits(gb, 8) + 1;

    } else if (bs_code == 7) {

        fi->blocksize = get_bits(gb, 16) + 1;

    } else {

        fi->blocksize = ff_flac_blocksize_table[bs_code];

    }



    /* sample rate */

    if (sr_code < 12) {

        fi->samplerate = ff_flac_sample_rate_table[sr_code];

    } else if (sr_code == 12) {

        fi->samplerate = get_bits(gb, 8) * 1000;

    } else if (sr_code == 13) {

        fi->samplerate = get_bits(gb, 16);

    } else if (sr_code == 14) {

        fi->samplerate = get_bits(gb, 16) * 10;

    } else {

        av_log(avctx, AV_LOG_ERROR, "illegal sample rate code %d\n",

               sr_code);

        return -1;

    }



    /* header CRC-8 check */

    skip_bits(gb, 8);

    if (av_crc(av_crc_get_table(AV_CRC_8_ATM), 0, gb->buffer,

               get_bits_count(gb)/8)) {

        av_log(avctx, AV_LOG_ERROR, "header crc mismatch\n");

        return -1;

    }



    return 0;

}
 and probability:0.2361111111111111
code:static int64_t mkv_write_seekhead(AVIOContext *pb, MatroskaMuxContext *mkv)

{

    AVIOContext *dyn_cp;

    mkv_seekhead *seekhead = mkv->main_seekhead;

    ebml_master metaseek, seekentry;

    int64_t currentpos;

    int i;



    currentpos = avio_tell(pb);



    if (seekhead->reserved_size > 0) {

        if (avio_seek(pb, seekhead->filepos, SEEK_SET) < 0) {

            currentpos = -1;

            goto fail;

        }

    }



    if (start_ebml_master_crc32(pb, &dyn_cp, &metaseek, MATROSKA_ID_SEEKHEAD,

                                seekhead->reserved_size) < 0) {

        currentpos = -1;

        goto fail;

    }



    for (i = 0; i < seekhead->num_entries; i++) {

        mkv_seekhead_entry *entry = &seekhead->entries[i];



        seekentry = start_ebml_master(dyn_cp, MATROSKA_ID_SEEKENTRY, MAX_SEEKENTRY_SIZE);



        put_ebml_id(dyn_cp, MATROSKA_ID_SEEKID);

        put_ebml_num(dyn_cp, ebml_id_size(entry->elementid), 0);

        put_ebml_id(dyn_cp, entry->elementid);



        put_ebml_uint(dyn_cp, MATROSKA_ID_SEEKPOSITION, entry->segmentpos);

        end_ebml_master(dyn_cp, seekentry);

    }

    end_ebml_master_crc32(pb, &dyn_cp, mkv, metaseek);



    if (seekhead->reserved_size > 0) {

        uint64_t remaining = seekhead->filepos + seekhead->reserved_size - avio_tell(pb);

        put_ebml_void(pb, remaining);

        avio_seek(pb, currentpos, SEEK_SET);



        currentpos = seekhead->filepos;

    }

fail:

    av_freep(&mkv->main_seekhead->entries);

    av_freep(&mkv->main_seekhead);



    return currentpos;

}
 and probability:0.35
code:static int read_decoding_params(MLPDecodeContext *m, GetBitContext *gbp,

                                unsigned int substr)

{

    SubStream *s = &m->substream[substr];

    unsigned int ch;



    if (s->param_presence_flags & PARAM_PRESENCE)

    if (get_bits1(gbp))

        s->param_presence_flags = get_bits(gbp, 8);



    if (s->param_presence_flags & PARAM_BLOCKSIZE)

        if (get_bits1(gbp)) {

            s->blocksize = get_bits(gbp, 9);

            if (s->blocksize > MAX_BLOCKSIZE) {

                av_log(m->avctx, AV_LOG_ERROR, "block size too large\n");

                s->blocksize = 0;

                return -1;

            }

        }



    if (s->param_presence_flags & PARAM_MATRIX)

        if (get_bits1(gbp)) {

            if (read_matrix_params(m, s, gbp) < 0)

                return -1;

        }



    if (s->param_presence_flags & PARAM_OUTSHIFT)

        if (get_bits1(gbp))

            for (ch = 0; ch <= s->max_matrix_channel; ch++) {

                s->output_shift[ch] = get_sbits(gbp, 4);

                dprintf(m->avctx, "output shift[%d] = %d\n",

                        ch, s->output_shift[ch]);

            }



    if (s->param_presence_flags & PARAM_QUANTSTEP)

        if (get_bits1(gbp))

            for (ch = 0; ch <= s->max_channel; ch++) {

                ChannelParams *cp = &m->channel_params[ch];



                s->quant_step_size[ch] = get_bits(gbp, 4);



                cp->sign_huff_offset = calculate_sign_huff(m, substr, ch);

            }



    for (ch = s->min_channel; ch <= s->max_channel; ch++)

        if (get_bits1(gbp)) {

            if (read_channel_params(m, substr, gbp, ch) < 0)

                return -1;

        }



    return 0;

}
 and probability:0.46511627906976744
code:static uint64_t pxa2xx_pic_mem_read(void *opaque, hwaddr offset,

                                    unsigned size)

{

    PXA2xxPICState *s = (PXA2xxPICState *) opaque;



    switch (offset) {

    case ICIP:	/* IRQ Pending register */

        return s->int_pending[0] & ~s->is_fiq[0] & s->int_enabled[0];

    case ICIP2:	/* IRQ Pending register 2 */

        return s->int_pending[1] & ~s->is_fiq[1] & s->int_enabled[1];

    case ICMR:	/* Mask register */

        return s->int_enabled[0];

    case ICMR2:	/* Mask register 2 */

        return s->int_enabled[1];

    case ICLR:	/* Level register */

        return s->is_fiq[0];

    case ICLR2:	/* Level register 2 */

        return s->is_fiq[1];

    case ICCR:	/* Idle mask */

        return (s->int_idle == 0);

    case ICFP:	/* FIQ Pending register */

        return s->int_pending[0] & s->is_fiq[0] & s->int_enabled[0];

    case ICFP2:	/* FIQ Pending register 2 */

        return s->int_pending[1] & s->is_fiq[1] & s->int_enabled[1];

    case ICPR:	/* Pending register */

        return s->int_pending[0];

    case ICPR2:	/* Pending register 2 */

        return s->int_pending[1];

    case IPR0  ... IPR31:

        return s->priority[0  + ((offset - IPR0 ) >> 2)];

    case IPR32 ... IPR39:

        return s->priority[32 + ((offset - IPR32) >> 2)];

    case ICHP:	/* Highest Priority register */

        return pxa2xx_pic_highest(s);

    default:

        printf("%s: Bad register offset " REG_FMT "\n", __FUNCTION__, offset);

        return 0;

    }

}
 and probability:0.34210526315789475
code:static inline void gen_op_addl_A0_seg(DisasContext *s, int reg)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUX86State, segs[reg].base));

    if (CODE64(s)) {

        tcg_gen_ext32u_tl(cpu_A0, cpu_A0);

        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);

    } else {

        tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_tmp0);

        tcg_gen_ext32u_tl(cpu_A0, cpu_A0);

    }

}
 and probability:0.09090909090909091
code:void vm_start(void)

{

    if (!vm_running) {

        cpu_enable_ticks();

        vm_running = 1;

        vm_state_notify(1, 0);

        qemu_rearm_alarm_timer(alarm_timer);

        resume_all_vcpus();

    }

}
 and probability:0.0
code:static int raw_pread(BlockDriverState *bs, int64_t offset,

                     uint8_t *buf, int count)

{

    BDRVRawState *s = bs->opaque;

    int size, ret, shift, sum;



    sum = 0;



    if (s->aligned_buf != NULL)  {



        if (offset & 0x1ff) {

            /* align offset on a 512 bytes boundary */



            shift = offset & 0x1ff;

            size = (shift + count + 0x1ff) & ~0x1ff;

            if (size > ALIGNED_BUFFER_SIZE)

                size = ALIGNED_BUFFER_SIZE;

            ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, size);

            if (ret < 0)

                return ret;



            size = 512 - shift;

            if (size > count)

                size = count;

            memcpy(buf, s->aligned_buf + shift, size);



            buf += size;

            offset += size;

            count -= size;

            sum += size;



            if (count == 0)

                return sum;

        }

        if (count & 0x1ff || (uintptr_t) buf & 0x1ff) {



            /* read on aligned buffer */



            while (count) {



                size = (count + 0x1ff) & ~0x1ff;

                if (size > ALIGNED_BUFFER_SIZE)

                    size = ALIGNED_BUFFER_SIZE;



                ret = raw_pread_aligned(bs, offset, s->aligned_buf, size);

                if (ret < 0) {

                    return ret;

                } else if (ret == 0) {

                    fprintf(stderr, "raw_pread: read beyond end of file\n");

                    abort();

                }



                size = ret;

                if (size > count)

                    size = count;



                memcpy(buf, s->aligned_buf, size);



                buf += size;

                offset += size;

                count -= size;

                sum += size;

            }



            return sum;

        }

    }



    return raw_pread_aligned(bs, offset, buf, count) + sum;

}
 and probability:0.3333333333333333
code:address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,

                                 hwaddr *plen, bool resolve_subpage)

{

    MemoryRegionSection *section;

    Int128 diff, diff_page;



    section = address_space_lookup_region(d, addr, resolve_subpage);

    /* Compute offset within MemoryRegionSection */

    addr -= section->offset_within_address_space;



    /* Compute offset within MemoryRegion */

    *xlat = addr + section->offset_within_region;



    diff_page = int128_make64(((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr);

    diff = int128_sub(section->mr->size, int128_make64(addr));

    diff = int128_min(diff, diff_page);

    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));

    return section;

}
 and probability:0.4375
code:void checkasm_report(const char *name, ...)

{

    static int prev_checked, prev_failed, max_length;



    if (state.num_checked > prev_checked) {

        print_cpu_name();



        if (*name) {

            int pad_length = max_length;

            va_list arg;



            fprintf(stderr, " - ");

            va_start(arg, name);

            pad_length -= vfprintf(stderr, name, arg);

            va_end(arg);

            fprintf(stderr, "%*c", FFMAX(pad_length, 0) + 2, '[');

        } else

            fprintf(stderr, " - %-*s [", max_length, state.current_func->name);



        if (state.num_failed == prev_failed)

            color_printf(COLOR_GREEN, "OK");

        else

            color_printf(COLOR_RED, "FAILED");

        fprintf(stderr, "]\n");



        prev_checked = state.num_checked;

        prev_failed  = state.num_failed;

    } else if (!state.cpu_flag) {

        int length;



        /* Calculate the amount of padding required to make the output vertically aligned */

        if (*name) {

            va_list arg;

            va_start(arg, name);

            length = vsnprintf(NULL, 0, name, arg);

            va_end(arg);

        } else

            length = strlen(state.current_func->name);



        if (length > max_length)

            max_length = length;

    }

}
 and probability:0.16666666666666666
code:static int rtp_new_av_stream(HTTPContext *c,

                             int stream_index, struct sockaddr_in *dest_addr,

                             HTTPContext *rtsp_c)

{

    AVFormatContext *ctx;

    AVStream *st;

    char *ipaddr;

    URLContext *h = NULL;

    uint8_t *dummy_buf;

    int max_packet_size;



    /* now we can open the relevant output stream */

    ctx = avformat_alloc_context();

    if (!ctx)

        return -1;

    ctx->oformat = av_guess_format("rtp", NULL, NULL);



    st = av_mallocz(sizeof(AVStream));

    if (!st)

        goto fail;

    ctx->nb_streams = 1;

    ctx->streams[0] = st;



    if (!c->stream->feed ||

        c->stream->feed == c->stream)

        memcpy(st, c->stream->streams[stream_index], sizeof(AVStream));

    else

        memcpy(st,

               c->stream->feed->streams[c->stream->feed_streams[stream_index]],

               sizeof(AVStream));

    st->priv_data = NULL;



    /* build destination RTP address */

    ipaddr = inet_ntoa(dest_addr->sin_addr);



    switch(c->rtp_protocol) {

    case RTSP_LOWER_TRANSPORT_UDP:

    case RTSP_LOWER_TRANSPORT_UDP_MULTICAST:

        /* RTP/UDP case */



        /* XXX: also pass as parameter to function ? */

        if (c->stream->is_multicast) {

            int ttl;

            ttl = c->stream->multicast_ttl;

            if (!ttl)

                ttl = 16;

            snprintf(ctx->filename, sizeof(ctx->filename),

                     "rtp://%s:%d?multicast=1&ttl=%d",

                     ipaddr, ntohs(dest_addr->sin_port), ttl);

        } else {

            snprintf(ctx->filename, sizeof(ctx->filename),

                     "rtp://%s:%d", ipaddr, ntohs(dest_addr->sin_port));

        }



        if (url_open(&h, ctx->filename, URL_WRONLY) < 0)

            goto fail;

        c->rtp_handles[stream_index] = h;

        max_packet_size = url_get_max_packet_size(h);

        break;

    case RTSP_LOWER_TRANSPORT_TCP:

        /* RTP/TCP case */

        c->rtsp_c = rtsp_c;

        max_packet_size = RTSP_TCP_MAX_PACKET_SIZE;

        break;

    default:

        goto fail;

    }



    http_log("%s:%d - - \"PLAY %s/streamid=%d %s\"\n",

             ipaddr, ntohs(dest_addr->sin_port),

             c->stream->filename, stream_index, c->protocol);



    /* normally, no packets should be output here, but the packet size may be checked */

    if (url_open_dyn_packet_buf(&ctx->pb, max_packet_size) < 0) {

        /* XXX: close stream */

        goto fail;

    }

    av_set_parameters(ctx, NULL);

    if (av_write_header(ctx) < 0) {

    fail:

        if (h)

            url_close(h);

        av_free(ctx);

        return -1;

    }

    avio_close_dyn_buf(ctx->pb, &dummy_buf);

    av_free(dummy_buf);



    c->rtp_ctx[stream_index] = ctx;

    return 0;

}
 and probability:0.2962962962962963
code:float32 HELPER(ucf64_muls)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_mul(a, b, &env->ucf64.fp_status);

}
 and probability:0.25
code:static void qemu_chr_parse_serial(QemuOpts *opts, ChardevBackend *backend,

                                  Error **errp)

{

    const char *device = qemu_opt_get(opts, "path");



    if (device == NULL) {

        error_setg(errp, "chardev: serial/tty: no device path given");

        return;

    }

    backend->serial = g_new0(ChardevHostdev, 1);

    backend->serial->device = g_strdup(device);

}
 and probability:0.18181818181818182
code:static void *rcu_update_perf_test(void *arg)

{

    long long n_updates_local = 0;



    rcu_register_thread();



    *(struct rcu_reader_data **)arg = &rcu_reader;

    atomic_inc(&nthreadsrunning);

    while (goflag == GOFLAG_INIT) {

        g_usleep(1000);

    }

    while (goflag == GOFLAG_RUN) {

        synchronize_rcu();

        n_updates_local++;

    }

    atomic_add(&n_updates, n_updates_local);



    rcu_unregister_thread();

    return NULL;

}
 and probability:0.11764705882352941
code:static int tpm_passthrough_unix_transfer(TPMPassthruState *tpm_pt,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_pt,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
 and probability:0.4444444444444444
code:static void lsi_transfer_data(SCSIRequest *req, uint32_t len)

{

    LSIState *s = DO_UPCAST(LSIState, dev.qdev, req->bus->qbus.parent);

    int out;



    if (s->waiting == 1 || !s->current || req->hba_private != s->current ||

        (lsi_irq_on_rsl(s) && !(s->scntl1 & LSI_SCNTL1_CON))) {

        if (lsi_queue_req(s, req, len)) {

            return;

        }

    }



    out = (s->sstat1 & PHASE_MASK) == PHASE_DO;



    /* host adapter (re)connected */

    DPRINTF("Data ready tag=0x%x len=%d\n", req->tag, len);

    s->current->dma_len = len;

    s->command_complete = 1;

    if (s->waiting) {

        if (s->waiting == 1 || s->dbc == 0) {

            lsi_resume_script(s);

        } else {

            lsi_do_dma(s, out);

        }

    }

}
 and probability:0.391304347826087
code:void tlb_set_page(CPUArchState *env, target_ulong vaddr,

                  hwaddr paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    section = phys_page_find(address_space_memory.dispatch, paddr >> TARGET_PAGE_BITS);

#if defined(DEBUG_TLB)

    printf("tlb_set_page: vaddr=" TARGET_FMT_lx " paddr=0x" TARGET_FMT_plx

           " prot=%x idx=%d pd=0x%08lx\n",

           vaddr, paddr, prot, mmu_idx, pd);

#endif



    address = vaddr;

    if (!memory_region_is_ram(section->mr) && !memory_region_is_romd(section->mr)) {

        /* IO memory case */

        address |= TLB_MMIO;

        addend = 0;

    } else {

        /* TLB_MMIO for rom/romd handled below */

        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)

        + memory_region_section_addr(section, paddr);

    }



    code_address = address;

    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,

                                            &address);



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->iotlb[mmu_idx][index] = iotlb - vaddr;

    te = &env->tlb_table[mmu_idx][index];

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((memory_region_is_ram(section->mr) && section->readonly)

            || memory_region_is_romd(section->mr)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if (memory_region_is_ram(section->mr)

                   && !cpu_physical_memory_is_dirty(

                           section->mr->ram_addr

                           + memory_region_section_addr(section, paddr))) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
 and probability:0.27692307692307694
code:void memory_region_set_address(MemoryRegion *mr, hwaddr addr)

{

    MemoryRegion *parent = mr->parent;

    int priority = mr->priority;

    bool may_overlap = mr->may_overlap;



    if (addr == mr->addr || !parent) {

        mr->addr = addr;

        return;

    }



    memory_region_transaction_begin();

    memory_region_ref(mr);

    memory_region_del_subregion(parent, mr);

    if (may_overlap) {

        memory_region_add_subregion_overlap(parent, addr, mr, priority);

    } else {

        memory_region_add_subregion(parent, addr, mr);

    }

    memory_region_unref(mr);

    memory_region_transaction_commit();

}
 and probability:0.25
code:void put_signed_pixels_clamped_mmx(const DCTELEM *block, uint8_t *pixels, int line_size)

{

    int i;

    unsigned char __align8 vector128[8] =

      { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 };



    movq_m2r(*vector128, mm1);

    for (i = 0; i < 8; i++) {

        movq_m2r(*(block), mm0);

        packsswb_m2r(*(block + 4), mm0);

        block += 8;

        paddb_r2r(mm1, mm0);

        movq_r2m(mm0, *pixels);

        pixels += line_size;

    }

}
 and probability:0.4666666666666667
code:static void gd_mouse_mode_change(Notifier *notify, void *data)

{

    gd_update_cursor(container_of(notify, GtkDisplayState, mouse_mode_notifier),

                     FALSE);

}
 and probability:0.0
code:static void loop_filter(H264Context *h, int start_x, int end_x){

    MpegEncContext * const s = &h->s;

    uint8_t  *dest_y, *dest_cb, *dest_cr;

    int linesize, uvlinesize, mb_x, mb_y;

    const int end_mb_y= s->mb_y + FRAME_MBAFF;

    const int old_slice_type= h->slice_type;

    const int pixel_shift = h->pixel_shift;



    if(h->deblocking_filter) {

        for(mb_x= start_x; mb_x<end_x; mb_x++){

            for(mb_y=end_mb_y - FRAME_MBAFF; mb_y<= end_mb_y; mb_y++){

                int mb_xy, mb_type;

                mb_xy = h->mb_xy = mb_x + mb_y*s->mb_stride;

                h->slice_num= h->slice_table[mb_xy];

                mb_type= s->current_picture.mb_type[mb_xy];

                h->list_count= h->list_counts[mb_xy];



                if(FRAME_MBAFF)

                    h->mb_mbaff = h->mb_field_decoding_flag = !!IS_INTERLACED(mb_type);



                s->mb_x= mb_x;

                s->mb_y= mb_y;

                dest_y  = s->current_picture.data[0] + ((mb_x << pixel_shift) + mb_y * s->linesize  ) * 16;

                dest_cb = s->current_picture.data[1] + ((mb_x << pixel_shift) + mb_y * s->uvlinesize) * 8;

                dest_cr = s->current_picture.data[2] + ((mb_x << pixel_shift) + mb_y * s->uvlinesize) * 8;

                    //FIXME simplify above



                if (MB_FIELD) {

                    linesize   = h->mb_linesize   = s->linesize * 2;

                    uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;

                    if(mb_y&1){ //FIXME move out of this function?

                        dest_y -= s->linesize*15;

                        dest_cb-= s->uvlinesize*7;

                        dest_cr-= s->uvlinesize*7;

                    }

                } else {

                    linesize   = h->mb_linesize   = s->linesize;

                    uvlinesize = h->mb_uvlinesize = s->uvlinesize;

                }

                backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0);

                if(fill_filter_caches(h, mb_type))

                    continue;

                h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);

                h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);



                if (FRAME_MBAFF) {

                    ff_h264_filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);

                } else {

                    ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);

                }

            }

        }

    }

    h->slice_type= old_slice_type;

    s->mb_x= 0;

    s->mb_y= end_mb_y - FRAME_MBAFF;

    h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);

    h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);

}
 and probability:0.5740740740740741
code:static int to_integer(char *p, int len)

{

    int ret;

    char *q = av_malloc(sizeof(char) * len);

    if (!q) return -1;

    strncpy(q, p, len);

    ret = atoi(q);

    av_free(q);

    return ret;

}
 and probability:0.2
code:void checkasm_check_blend(void)

{

    uint8_t *top1 = av_malloc(BUF_SIZE);

    uint8_t *top2 = av_malloc(BUF_SIZE);

    uint8_t *bot1 = av_malloc(BUF_SIZE);

    uint8_t *bot2 = av_malloc(BUF_SIZE);

    uint8_t *dst1 = av_malloc(BUF_SIZE);

    uint8_t *dst2 = av_malloc(BUF_SIZE);

    FilterParams param = {

        .opacity = 1.0,

    };



#define check_and_report(name, val)               \

    param.mode = val;                             \

    ff_blend_init(&param, 0);                     \

    if (check_func(param.blend, #name))           \

        check_blend_func();



    check_and_report(addition, BLEND_ADDITION)

    check_and_report(addition128, BLEND_ADDITION128)

    check_and_report(and, BLEND_AND)

    check_and_report(average, BLEND_AVERAGE)

    check_and_report(darken, BLEND_DARKEN)

    check_and_report(difference128, BLEND_DIFFERENCE128)

    check_and_report(hardmix, BLEND_HARDMIX)

    check_and_report(lighten, BLEND_LIGHTEN)

    check_and_report(multiply, BLEND_MULTIPLY)

    check_and_report(or, BLEND_OR)

    check_and_report(phoenix, BLEND_PHOENIX)

    check_and_report(screen, BLEND_SCREEN)

    check_and_report(subtract, BLEND_SUBTRACT)

    check_and_report(xor, BLEND_XOR)

    check_and_report(difference, BLEND_DIFFERENCE)

    check_and_report(extremity, BLEND_EXTREMITY)

    check_and_report(negation, BLEND_NEGATION)



    report("8bit");



    av_freep(&top1);

    av_freep(&top2);

    av_freep(&bot1);

    av_freep(&bot2);

    av_freep(&dst1);

    av_freep(&dst2);

}
 and probability:0.0
code:qemu_irq *armv7m_init(int flash_size, int sram_size,

                      const char *kernel_filename, const char *cpu_model)

{

    CPUState *env;

    DeviceState *nvic;

    /* FIXME: make this local state.  */

    static qemu_irq pic[64];

    qemu_irq *cpu_pic;

    uint32_t pc;

    int image_size;

    uint64_t entry;

    uint64_t lowaddr;

    int i;

    int big_endian;



    flash_size *= 1024;

    sram_size *= 1024;



    if (!cpu_model)

	cpu_model = "cortex-m3";

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, "Unable to find CPU definition\n");

        exit(1);

    }



#if 0

    /* > 32Mb SRAM gets complicated because it overlaps the bitband area.

       We don't have proper commandline options, so allocate half of memory

       as SRAM, up to a maximum of 32Mb, and the rest as code.  */

    if (ram_size > (512 + 32) * 1024 * 1024)

        ram_size = (512 + 32) * 1024 * 1024;

    sram_size = (ram_size / 2) & TARGET_PAGE_MASK;

    if (sram_size > 32 * 1024 * 1024)

        sram_size = 32 * 1024 * 1024;

    code_size = ram_size - sram_size;

#endif



    /* Flash programming is done via the SCU, so pretend it is ROM.  */

    cpu_register_physical_memory(0, flash_size,

                                 qemu_ram_alloc(flash_size) | IO_MEM_ROM);

    cpu_register_physical_memory(0x20000000, sram_size,

                                 qemu_ram_alloc(sram_size) | IO_MEM_RAM);

    armv7m_bitband_init();



    nvic = qdev_create(NULL, "armv7m_nvic");

    env->v7m.nvic = nvic;

    qdev_init(nvic);

    cpu_pic = arm_pic_init_cpu(env);

    sysbus_connect_irq(sysbus_from_qdev(nvic), 0, cpu_pic[ARM_PIC_CPU_IRQ]);

    for (i = 0; i < 64; i++) {

        pic[i] = qdev_get_gpio_in(nvic, i);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    big_endian = 1;

#else

    big_endian = 0;

#endif



    image_size = load_elf(kernel_filename, 0, &entry, &lowaddr, NULL,

                          big_endian, ELF_MACHINE, 1);

    if (image_size < 0) {

        image_size = load_image_targphys(kernel_filename, 0, flash_size);

	lowaddr = 0;

    }

    if (image_size < 0) {

        fprintf(stderr, "qemu: could not load kernel '%s'\n",

                kernel_filename);

        exit(1);

    }



    /* If the image was loaded at address zero then assume it is a

       regular ROM image and perform the normal CPU reset sequence.

       Otherwise jump directly to the entry point.  */

    if (lowaddr == 0) {

	env->regs[13] = ldl_phys(0);

	pc = ldl_phys(4);

    } else {

	pc = entry;

    }

    env->thumb = pc & 1;

    env->regs[15] = pc & ~1;



    /* Hack to map an additional page of ram at the top of the address

       space.  This stops qemu complaining about executing code outside RAM

       when returning from an exception.  */

    cpu_register_physical_memory(0xfffff000, 0x1000,

                                 qemu_ram_alloc(0x1000) | IO_MEM_RAM);



    return pic;

}
 and probability:0.15853658536585366
code:static int svq3_decode_frame(AVCodecContext *avctx,

                             void *data, int *data_size,

                             AVPacket *avpkt)

{

    SVQ3Context *svq3 = avctx->priv_data;

    H264Context *h = &svq3->h;

    MpegEncContext *s = &h->s;

    int buf_size = avpkt->size;

    int m, mb_type, left;

    uint8_t *buf;



    /* special case for last picture */

    if (buf_size == 0) {

        if (s->next_picture_ptr && !s->low_delay) {

            *(AVFrame *) data = *(AVFrame *) &s->next_picture;

            s->next_picture_ptr = NULL;

            *data_size = sizeof(AVFrame);

        }

        return 0;

    }



    s->mb_x = s->mb_y = h->mb_xy = 0;



    if (svq3->watermark_key) {

        svq3->buf = av_fast_realloc(svq3->buf, &svq3->buf_size,

                                    buf_size+FF_INPUT_BUFFER_PADDING_SIZE);

        if (!svq3->buf)

            return AVERROR(ENOMEM);

        memcpy(svq3->buf, avpkt->data, buf_size);

        buf = svq3->buf;

    } else {

        buf = avpkt->data;

    }



    init_get_bits(&s->gb, buf, 8*buf_size);



    if (svq3_decode_slice_header(avctx))

        return -1;



    s->pict_type = h->slice_type;

    s->picture_number = h->slice_num;



    if (avctx->debug&FF_DEBUG_PICT_INFO){

        av_log(h->s.avctx, AV_LOG_DEBUG, "%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n",

               av_get_picture_type_char(s->pict_type), svq3->halfpel_flag, svq3->thirdpel_flag,

               s->adaptive_quant, s->qscale, h->slice_num);

    }



    /* for skipping the frame */

    s->current_picture.pict_type = s->pict_type;

    s->current_picture.key_frame = (s->pict_type == AV_PICTURE_TYPE_I);



    /* Skip B-frames if we do not have reference frames. */

    if (s->last_picture_ptr == NULL && s->pict_type == AV_PICTURE_TYPE_B)

        return 0;

    if (  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B)

        ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I)

        || avctx->skip_frame >= AVDISCARD_ALL)

        return 0;



    if (s->next_p_frame_damaged) {

        if (s->pict_type == AV_PICTURE_TYPE_B)

            return 0;

        else

            s->next_p_frame_damaged = 0;

    }



    if (ff_h264_frame_start(h) < 0)

        return -1;



    if (s->pict_type == AV_PICTURE_TYPE_B) {

        h->frame_num_offset = (h->slice_num - h->prev_frame_num);



        if (h->frame_num_offset < 0) {

            h->frame_num_offset += 256;

        }

        if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) {

            av_log(h->s.avctx, AV_LOG_ERROR, "error in B-frame picture id\n");

            return -1;

        }

    } else {

        h->prev_frame_num = h->frame_num;

        h->frame_num = h->slice_num;

        h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num);



        if (h->prev_frame_num_offset < 0) {

            h->prev_frame_num_offset += 256;

        }

    }



    for (m = 0; m < 2; m++){

        int i;

        for (i = 0; i < 4; i++){

            int j;

            for (j = -1; j < 4; j++)

                h->ref_cache[m][scan8[0] + 8*i + j]= 1;

            if (i < 3)

                h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE;

        }

    }



    for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {

        for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) {

            h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;



            if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&

                ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {



                skip_bits(&s->gb, svq3->next_slice_index - get_bits_count(&s->gb));

                s->gb.size_in_bits = 8*buf_size;



                if (svq3_decode_slice_header(avctx))

                    return -1;



                /* TODO: support s->mb_skip_run */

            }



            mb_type = svq3_get_ue_golomb(&s->gb);



            if (s->pict_type == AV_PICTURE_TYPE_I) {

                mb_type += 8;

            } else if (s->pict_type == AV_PICTURE_TYPE_B && mb_type >= 4) {

                mb_type += 4;

            }

            if (mb_type > 33 || svq3_decode_mb(svq3, mb_type)) {

                av_log(h->s.avctx, AV_LOG_ERROR, "error while decoding MB %d %d\n", s->mb_x, s->mb_y);

                return -1;

            }



            if (mb_type != 0) {

                ff_h264_hl_decode_mb (h);

            }



            if (s->pict_type != AV_PICTURE_TYPE_B && !s->low_delay) {

                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =

                    (s->pict_type == AV_PICTURE_TYPE_P && mb_type < 8) ? (mb_type - 1) : -1;

            }

        }



        ff_draw_horiz_band(s, 16*s->mb_y, 16);

    }



    left = buf_size*8 - get_bits_count(&s->gb);



    if (s->mb_y != s->mb_height || s->mb_x != s->mb_width) {

        av_log(avctx, AV_LOG_INFO, "frame num %d incomplete pic x %d y %d left %d\n", avctx->frame_number, s->mb_y, s->mb_x, left);

        //av_hex_dump(stderr, buf+buf_size-8, 8);

    }



    if (left < 0) {

        av_log(avctx, AV_LOG_ERROR, "frame num %d left %d\n", avctx->frame_number, left);

        return -1;

    }



    MPV_frame_end(s);



    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

        *(AVFrame *) data = *(AVFrame *) &s->current_picture;

    } else {

        *(AVFrame *) data = *(AVFrame *) &s->last_picture;

    }



    /* Do not output the last pic after seeking. */

    if (s->last_picture_ptr || s->low_delay) {

        *data_size = sizeof(AVFrame);

    }



    return buf_size;

}
 and probability:0.5401459854014599
code:int mpeg4_decode_video_packet_header(MpegEncContext *s)

{

    int mb_num_bits= av_log2(s->mb_num - 1) + 1;

    int header_extension=0, mb_num, len;



    /* is there enough space left for a video packet + header */

    if( get_bits_count(&s->gb) > s->gb.size_in_bits-20) return -1;



    for(len=0; len<32; len++){

        if(get_bits1(&s->gb)) break;

    }



    if(len!=ff_mpeg4_get_video_packet_prefix_length(s)){

        av_log(s->avctx, AV_LOG_ERROR, "marker does not match f_code\n");

        return -1;

    }



    if(s->shape != RECT_SHAPE){

        header_extension= get_bits1(&s->gb);

        //FIXME more stuff here

    }



    mb_num= get_bits(&s->gb, mb_num_bits);

    if(mb_num>=s->mb_num){

        av_log(s->avctx, AV_LOG_ERROR, "illegal mb_num in video packet (%d %d) \n", mb_num, s->mb_num);

        return -1;

    }



    s->mb_x= mb_num % s->mb_width;

    s->mb_y= mb_num / s->mb_width;



    if(s->shape != BIN_ONLY_SHAPE){

        int qscale= get_bits(&s->gb, s->quant_precision);

        if(qscale)

            s->chroma_qscale=s->qscale= qscale;

    }



    if(s->shape == RECT_SHAPE){

        header_extension= get_bits1(&s->gb);

    }

    if(header_extension){

        int time_incr=0;



        while (get_bits1(&s->gb) != 0)

            time_incr++;



        check_marker(&s->gb, "before time_increment in video packed header");

        skip_bits(&s->gb, s->time_increment_bits); /* time_increment */

        check_marker(&s->gb, "before vop_coding_type in video packed header");



        skip_bits(&s->gb, 2); /* vop coding type */

        //FIXME not rect stuff here



        if(s->shape != BIN_ONLY_SHAPE){

            skip_bits(&s->gb, 3); /* intra dc vlc threshold */

//FIXME don't just ignore everything

            if(s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE){

                mpeg4_decode_sprite_trajectory(s, &s->gb);

                av_log(s->avctx, AV_LOG_ERROR, "untested\n");

            }



            //FIXME reduced res stuff here



            if (s->pict_type != AV_PICTURE_TYPE_I) {

                int f_code = get_bits(&s->gb, 3);       /* fcode_for */

                if(f_code==0){

                    av_log(s->avctx, AV_LOG_ERROR, "Error, video packet header damaged (f_code=0)\n");

                }

            }

            if (s->pict_type == AV_PICTURE_TYPE_B) {

                int b_code = get_bits(&s->gb, 3);

                if(b_code==0){

                    av_log(s->avctx, AV_LOG_ERROR, "Error, video packet header damaged (b_code=0)\n");

                }

            }

        }

    }

    //FIXME new-pred stuff



    return 0;

}
 and probability:0.5151515151515151
code:static void opt_video_rc_override_string(char *arg)

{

    video_rc_override_string = arg;

}
 and probability:0.0
code:av_cold int ff_dvvideo_init(AVCodecContext *avctx)

{

    DVVideoContext *s = avctx->priv_data;

    DSPContext dsp;

    static int done = 0;

    int i, j;



    if (!done) {

        VLC dv_vlc;

        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];

        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];

        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];

        int16_t  new_dv_vlc_level[NB_DV_VLC*2];



        done = 1;



        /* it's faster to include sign bit in a generic VLC parsing scheme */

        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {

            new_dv_vlc_bits[j]  = dv_vlc_bits[i];

            new_dv_vlc_len[j]   = dv_vlc_len[i];

            new_dv_vlc_run[j]   = dv_vlc_run[i];

            new_dv_vlc_level[j] = dv_vlc_level[i];



            if (dv_vlc_level[i]) {

                new_dv_vlc_bits[j] <<= 1;

                new_dv_vlc_len[j]++;



                j++;

                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;

                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;

                new_dv_vlc_run[j]   =  dv_vlc_run[i];

                new_dv_vlc_level[j] = -dv_vlc_level[i];

            }

        }



        /* NOTE: as a trick, we use the fact the no codes are unused

           to accelerate the parsing of partial codes */

        init_vlc(&dv_vlc, TEX_VLC_BITS, j,

                 new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);

        assert(dv_vlc.table_size == 1184);



        for (i = 0; i < dv_vlc.table_size; i++){

            int code = dv_vlc.table[i][0];

            int len  = dv_vlc.table[i][1];

            int level, run;



            if (len < 0){ //more bits needed

                run   = 0;

                level = code;

            } else {

                run   = new_dv_vlc_run  [code] + 1;

                level = new_dv_vlc_level[code];

            }

            ff_dv_rl_vlc[i].len   = len;

            ff_dv_rl_vlc[i].level = level;

            ff_dv_rl_vlc[i].run   = run;

        }

        ff_free_vlc(&dv_vlc);

    }



    /* Generic DSP setup */


    ff_dsputil_init(&dsp, avctx);

    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);

    s->get_pixels = dsp.get_pixels;

    s->ildct_cmp = dsp.ildct_cmp[5];



    /* 88DCT setup */

    s->fdct[0]     = dsp.fdct;

    s->idct_put[0] = dsp.idct_put;

    for (i = 0; i < 64; i++)

       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];



    /* 248DCT setup */

    s->fdct[1]     = dsp.fdct248;

    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP

    if (avctx->lowres){

        for (i = 0; i < 64; i++){

            int j = ff_zigzag248_direct[i];

            s->dv_zigzag[1][i] = dsp.idct_permutation[(j & 7) + (j & 8) * 4 + (j & 48) / 2];

        }

    }else

        memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);



    avctx->coded_frame = &s->picture;

    s->avctx = avctx;

    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;



    return 0;

} and probability:0.5657894736842105
code:static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc,

				   int flags, int canMMX2BeUsed, int16_t *hLumFilter,

				   int16_t *hLumFilterPos, int hLumFilterSize, void *funnyYCode, 

				   int srcFormat, uint8_t *formatConvBuffer)

{

    if(srcFormat==IMGFMT_YUY2)

    {

	RENAME(yuy2ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_BGR32)

    {

	RENAME(bgr32ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_BGR24)

    {

	RENAME(bgr24ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_BGR16)

    {

	RENAME(bgr16ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_BGR15)

    {

	RENAME(bgr15ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_RGB32)

    {

	RENAME(rgb32ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }

    else if(srcFormat==IMGFMT_RGB24)

    {

	RENAME(rgb24ToY)(formatConvBuffer, src, srcW);

	src= formatConvBuffer;

    }



#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(!(flags&SWS_FAST_BILINEAR) || (!canMMX2BeUsed))

#else

    if(!(flags&SWS_FAST_BILINEAR))

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			"pxor %%mm7, %%mm7		\n\t"

			"pxor %%mm2, %%mm2		\n\t" // 2*xalpha

			"movd %5, %%mm6			\n\t" // xInc&0xFFFF

			"punpcklwd %%mm6, %%mm6		\n\t"

			"punpcklwd %%mm6, %%mm6		\n\t"

			"movq %%mm6, %%mm2		\n\t"

			"psllq $16, %%mm2		\n\t"

			"paddw %%mm6, %%mm2		\n\t"

			"psllq $16, %%mm2		\n\t"

			"paddw %%mm6, %%mm2		\n\t"

			"psllq $16, %%mm2		\n\t" //0,t,2t,3t		t=xInc&0xFF

			"movq %%mm2, %%mm4		\n\t"

			"movd %4, %%mm6			\n\t" //(xInc*4)&0xFFFF

			"punpcklwd %%mm6, %%mm6		\n\t"

			"punpcklwd %%mm6, %%mm6		\n\t"

			"xorl %%eax, %%eax		\n\t" // i

			"movl %0, %%esi			\n\t" // src

			"movl %1, %%edi			\n\t" // buf1

			"movl %3, %%edx			\n\t" // (xInc*4)>>16

			"xorl %%ecx, %%ecx		\n\t"

			"xorl %%ebx, %%ebx		\n\t"

			"movw %4, %%bx			\n\t" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH" 1024(%%esi)		\n\t"\

			PREFETCH" 1056(%%esi)		\n\t"\

			PREFETCH" 1088(%%esi)		\n\t"\

			"call *%6			\n\t"\

			"movq %%mm4, %%mm2		\n\t"\

			"xorl %%ecx, %%ecx		\n\t"



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: "m" (src), "m" (dst), "m" (dstWidth), "m" ((xInc*4)>>16),

			"m" ((xInc*4)&0xFFFF), "m" (xInc&0xFFFF), "m" (funnyYCode)

			: "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		"xorl %%eax, %%eax		\n\t" // i

		"xorl %%ebx, %%ebx		\n\t" // xx

		"xorl %%ecx, %%ecx		\n\t" // 2*xalpha

		".balign 16			\n\t"

		"1:				\n\t"

		"movzbl  (%0, %%ebx), %%edi	\n\t" //src[xx]

		"movzbl 1(%0, %%ebx), %%esi	\n\t" //src[xx+1]

		"subl %%edi, %%esi		\n\t" //src[xx+1] - src[xx]

		"imull %%ecx, %%esi		\n\t" //(src[xx+1] - src[xx])*2*xalpha

		"shll $16, %%edi		\n\t"

		"addl %%edi, %%esi		\n\t" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		"movl %1, %%edi			\n\t"

		"shrl $9, %%esi			\n\t"

		"movw %%si, (%%edi, %%eax, 2)	\n\t"

		"addw %4, %%cx			\n\t" //2*xalpha += xInc&0xFF

		"adcl %3, %%ebx			\n\t" //xx+= xInc>>8 + carry



		"movzbl (%0, %%ebx), %%edi	\n\t" //src[xx]

		"movzbl 1(%0, %%ebx), %%esi	\n\t" //src[xx+1]

		"subl %%edi, %%esi		\n\t" //src[xx+1] - src[xx]

		"imull %%ecx, %%esi		\n\t" //(src[xx+1] - src[xx])*2*xalpha

		"shll $16, %%edi		\n\t"

		"addl %%edi, %%esi		\n\t" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		"movl %1, %%edi			\n\t"

		"shrl $9, %%esi			\n\t"

		"movw %%si, 2(%%edi, %%eax, 2)	\n\t"

		"addw %4, %%cx			\n\t" //2*xalpha += xInc&0xFF

		"adcl %3, %%ebx			\n\t" //xx+= xInc>>8 + carry





		"addl $2, %%eax			\n\t"

		"cmpl %2, %%eax			\n\t"

		" jb 1b				\n\t"





		:: "r" (src), "m" (dst), "m" (dstWidth), "m" (xInc>>16), "m" (xInc&0xFFFF)

		: "%eax", "%ebx", "%ecx", "%edi", "%esi"

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
 and probability:0.03896103896103896
code:int32 float128_to_int32_round_to_zero( float128 a STATUS_PARAM )

{

    flag aSign;

    int32 aExp, shiftCount;

    uint64_t aSig0, aSig1, savedASig;

    int32 z;



    aSig1 = extractFloat128Frac1( a );

    aSig0 = extractFloat128Frac0( a );

    aExp = extractFloat128Exp( a );

    aSign = extractFloat128Sign( a );

    aSig0 |= ( aSig1 != 0 );

    if ( 0x401E < aExp ) {

        if ( ( aExp == 0x7FFF ) && aSig0 ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FFF ) {

        if ( aExp || aSig0 ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig0 |= LIT64( 0x0001000000000000 );

    shiftCount = 0x402F - aExp;

    savedASig = aSig0;

    aSig0 >>= shiftCount;

    z = aSig0;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig0<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
 and probability:0.02857142857142857
code:static int decode_ihdr_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    if (length != 13)

        return AVERROR_INVALIDDATA;



    if (s->state & PNG_IDAT) {

        av_log(avctx, AV_LOG_ERROR, "IHDR after IDAT\n");

        return AVERROR_INVALIDDATA;




    if (s->state & PNG_IHDR) {

        av_log(avctx, AV_LOG_ERROR, "Multiple IHDR\n");

        return AVERROR_INVALIDDATA;




    s->width  = s->cur_w = bytestream2_get_be32(&s->gb);

    s->height = s->cur_h = bytestream2_get_be32(&s->gb);

    if (av_image_check_size(s->width, s->height, 0, avctx)) {

        s->cur_w = s->cur_h = s->width = s->height = 0;

        av_log(avctx, AV_LOG_ERROR, "Invalid image size\n");

        return AVERROR_INVALIDDATA;


    s->bit_depth        = bytestream2_get_byte(&s->gb);






    s->color_type       = bytestream2_get_byte(&s->gb);

    s->compression_type = bytestream2_get_byte(&s->gb);

    s->filter_type      = bytestream2_get_byte(&s->gb);

    s->interlace_type   = bytestream2_get_byte(&s->gb);

    bytestream2_skip(&s->gb, 4); /* crc */

    s->state |= PNG_IHDR;

    if (avctx->debug & FF_DEBUG_PICT_INFO)

        av_log(avctx, AV_LOG_DEBUG, "width=%d height=%d depth=%d color_type=%d "

                "compression_type=%d filter_type=%d interlace_type=%d\n",

                s->width, s->height, s->bit_depth, s->color_type,

                s->compression_type, s->filter_type, s->interlace_type);



    return 0;

error:

    s->cur_w = s->cur_h = s->width = s->height = 0;

    s->bit_depth = 8;

    return AVERROR_INVALIDDATA;
 and probability:0.5294117647058824
code:int page_unprotect(target_ulong address, uintptr_t pc)

{

    unsigned int prot;

    bool current_tb_invalidated;

    PageDesc *p;

    target_ulong host_start, host_end, addr;



    /* Technically this isn't safe inside a signal handler.  However we

       know this only ever happens in a synchronous SEGV handler, so in

       practice it seems to be ok.  */

    mmap_lock();



    p = page_find(address >> TARGET_PAGE_BITS);

    if (!p) {

        mmap_unlock();

        return 0;

    }



    /* if the page was really writable, then we change its

       protection back to writable */

    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {

        host_start = address & qemu_host_page_mask;

        host_end = host_start + qemu_host_page_size;



        prot = 0;

        current_tb_invalidated = false;

        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {

            p = page_find(addr >> TARGET_PAGE_BITS);

            p->flags |= PAGE_WRITE;

            prot |= p->flags;



            /* and since the content will be modified, we must invalidate

               the corresponding translated code. */

            current_tb_invalidated |= tb_invalidate_phys_page(addr, pc);

#ifdef CONFIG_USER_ONLY

            if (DEBUG_TB_CHECK_GATE) {

                tb_invalidate_check(addr);

            }

#endif

        }

        mprotect((void *)g2h(host_start), qemu_host_page_size,

                 prot & PAGE_BITS);



        mmap_unlock();

        /* If current TB was invalidated return to main loop */

        return current_tb_invalidated ? 2 : 1;

    }

    mmap_unlock();

    return 0;

}
 and probability:0.11363636363636363
code:static void v9fs_readlink(void *opaque)

{

    V9fsPDU *pdu = opaque;

    size_t offset = 7;

    V9fsString target;

    int32_t fid;

    int err = 0;

    V9fsFidState *fidp;



    pdu_unmarshal(pdu, offset, "d", &fid);


    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    v9fs_string_init(&target);

    err = v9fs_co_readlink(pdu, &fidp->path, &target);

    if (err < 0) {

        goto out;

    }

    offset += pdu_marshal(pdu, offset, "s", &target);

    err = offset;

    v9fs_string_free(&target);

out:

    put_fid(pdu, fidp);

out_nofid:

    trace_v9fs_readlink_return(pdu->tag, pdu->id, target.data);

    complete_pdu(pdu->s, pdu, err);

} and probability:0.14285714285714285
code:int kvm_init(MachineClass *mc)

{

    static const char upgrade_note[] =

        "Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\n"

        "(see http://sourceforge.net/projects/kvm).\n";

    struct {

        const char *name;

        int num;

    } num_cpus[] = {

        { "SMP",          smp_cpus },

        { "hotpluggable", max_cpus },

        { NULL, }

    }, *nc = num_cpus;

    int soft_vcpus_limit, hard_vcpus_limit;

    KVMState *s;

    const KVMCapabilityInfo *missing_cap;

    int ret;

    int i, type = 0;

    const char *kvm_type;



    s = g_malloc0(sizeof(KVMState));



    /*

     * On systems where the kernel can support different base page

     * sizes, host page size may be different from TARGET_PAGE_SIZE,

     * even with KVM.  TARGET_PAGE_SIZE is assumed to be the minimum

     * page size for the system though.

     */

    assert(TARGET_PAGE_SIZE <= getpagesize());

    page_size_init();



#ifdef KVM_CAP_SET_GUEST_DEBUG

    QTAILQ_INIT(&s->kvm_sw_breakpoints);

#endif

    s->vmfd = -1;

    s->fd = qemu_open("/dev/kvm", O_RDWR);

    if (s->fd == -1) {

        fprintf(stderr, "Could not access KVM kernel module: %m\n");

        ret = -errno;

        goto err;

    }



    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);

    if (ret < KVM_API_VERSION) {

        if (ret > 0) {

            ret = -EINVAL;

        }

        fprintf(stderr, "kvm version too old\n");

        goto err;

    }



    if (ret > KVM_API_VERSION) {

        ret = -EINVAL;

        fprintf(stderr, "kvm version not supported\n");

        goto err;

    }



    s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);



    /* If unspecified, use the default value */

    if (!s->nr_slots) {

        s->nr_slots = 32;

    }



    s->slots = g_malloc0(s->nr_slots * sizeof(KVMSlot));



    for (i = 0; i < s->nr_slots; i++) {

        s->slots[i].slot = i;

    }



    /* check the vcpu limits */

    soft_vcpus_limit = kvm_recommended_vcpus(s);

    hard_vcpus_limit = kvm_max_vcpus(s);



    while (nc->name) {

        if (nc->num > soft_vcpus_limit) {

            fprintf(stderr,

                    "Warning: Number of %s cpus requested (%d) exceeds "

                    "the recommended cpus supported by KVM (%d)\n",

                    nc->name, nc->num, soft_vcpus_limit);



            if (nc->num > hard_vcpus_limit) {

                fprintf(stderr, "Number of %s cpus requested (%d) exceeds "

                        "the maximum cpus supported by KVM (%d)\n",

                        nc->name, nc->num, hard_vcpus_limit);

                exit(1);

            }

        }

        nc++;

    }



    kvm_type = qemu_opt_get(qemu_get_machine_opts(), "kvm-type");

    if (mc->kvm_type) {

        type = mc->kvm_type(kvm_type);

    } else if (kvm_type) {

        fprintf(stderr, "Invalid argument kvm-type=%s\n", kvm_type);

        goto err;

    }



    do {

        ret = kvm_ioctl(s, KVM_CREATE_VM, type);

    } while (ret == -EINTR);



    if (ret < 0) {

        fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret,

                strerror(-ret));



#ifdef TARGET_S390X

        fprintf(stderr, "Please add the 'switch_amode' kernel parameter to "

                        "your host kernel command line\n");

#endif

        goto err;

    }



    s->vmfd = ret;

    missing_cap = kvm_check_extension_list(s, kvm_required_capabilites);

    if (!missing_cap) {

        missing_cap =

            kvm_check_extension_list(s, kvm_arch_required_capabilities);

    }

    if (missing_cap) {

        ret = -EINVAL;

        fprintf(stderr, "kvm does not support %s\n%s",

                missing_cap->name, upgrade_note);

        goto err;

    }



    s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);



    s->broken_set_mem_region = 1;

    ret = kvm_check_extension(s, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);

    if (ret > 0) {

        s->broken_set_mem_region = 0;

    }



#ifdef KVM_CAP_VCPU_EVENTS

    s->vcpu_events = kvm_check_extension(s, KVM_CAP_VCPU_EVENTS);

#endif



    s->robust_singlestep =

        kvm_check_extension(s, KVM_CAP_X86_ROBUST_SINGLESTEP);



#ifdef KVM_CAP_DEBUGREGS

    s->debugregs = kvm_check_extension(s, KVM_CAP_DEBUGREGS);

#endif



#ifdef KVM_CAP_XSAVE

    s->xsave = kvm_check_extension(s, KVM_CAP_XSAVE);

#endif



#ifdef KVM_CAP_XCRS

    s->xcrs = kvm_check_extension(s, KVM_CAP_XCRS);

#endif



#ifdef KVM_CAP_PIT_STATE2

    s->pit_state2 = kvm_check_extension(s, KVM_CAP_PIT_STATE2);

#endif



#ifdef KVM_CAP_IRQ_ROUTING

    s->direct_msi = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);

#endif



    s->intx_set_mask = kvm_check_extension(s, KVM_CAP_PCI_2_3);



    s->irq_set_ioctl = KVM_IRQ_LINE;

    if (kvm_check_extension(s, KVM_CAP_IRQ_INJECT_STATUS)) {

        s->irq_set_ioctl = KVM_IRQ_LINE_STATUS;

    }



#ifdef KVM_CAP_READONLY_MEM

    kvm_readonly_mem_allowed =

        (kvm_check_extension(s, KVM_CAP_READONLY_MEM) > 0);

#endif



    ret = kvm_arch_init(s);

    if (ret < 0) {

        goto err;

    }



    ret = kvm_irqchip_create(s);

    if (ret < 0) {

        goto err;

    }



    kvm_state = s;

    memory_listener_register(&kvm_memory_listener, &address_space_memory);

    memory_listener_register(&kvm_io_listener, &address_space_io);



    s->many_ioeventfds = kvm_check_many_ioeventfds();



    cpu_interrupt_handler = kvm_handle_interrupt;



    return 0;



err:

    if (s->vmfd >= 0) {

        close(s->vmfd);

    }

    if (s->fd != -1) {

        close(s->fd);

    }

    g_free(s->slots);

    g_free(s);



    return ret;

}
 and probability:0.23076923076923078
code:static void openpic_msi_write(void *opaque, hwaddr addr, uint64_t val,

                              unsigned size)

{

    OpenPICState *opp = opaque;

    int idx = opp->irq_msi;

    int srs, ibs;



    DPRINTF("%s: addr " TARGET_FMT_plx " <= %08x\n", __func__, addr, val);

    if (addr & 0xF) {

        return;

    }



    switch (addr) {

    case MSIIR_OFFSET:

        srs = val >> MSIIR_SRS_SHIFT;

        idx += srs;

        ibs = (val & MSIIR_IBS_MASK) >> MSIIR_IBS_SHIFT;

        opp->msi[srs].msir |= 1 << ibs;

        openpic_set_irq(opp, idx, 1);

        break;

    default:

        /* most registers are read-only, thus ignored */

        break;

    }

}
 and probability:0.13043478260869565
code:static int eval_refl(const int16_t *coefs, int *refl, RA144Context *ractx)

{

    int retval = 0;

    int b, c, i;

    unsigned int u;

    int buffer1[10];

    int buffer2[10];

    int *bp1 = buffer1;

    int *bp2 = buffer2;



    for (i=0; i < 10; i++)

        buffer2[i] = coefs[i];



    u = refl[9] = bp2[9];



    if (u + 0x1000 > 0x1fff) {

        av_log(ractx, AV_LOG_ERROR, "Overflow. Broken sample?\n");

        return 0;

    }



    for (c=8; c >= 0; c--) {

        if (u == 0x1000)

            u++;



        if (u == 0xfffff000)

            u--;



        b = 0x1000-((u * u) >> 12);



        if (b == 0)

            b++;



        for (u=0; u<=c; u++)

            bp1[u] = ((bp2[u] - ((refl[c+1] * bp2[c-u]) >> 12)) * (0x1000000 / b)) >> 12;



        refl[c] = u = bp1[c];



        if ((u + 0x1000) > 0x1fff)

            retval = 1;



        FFSWAP(int *, bp1, bp2);

    }

    return retval;

}
 and probability:0.3939393939393939
code:static void vfio_disable_interrupts(VFIOPCIDevice *vdev)

{

    switch (vdev->interrupt) {

    case VFIO_INT_INTx:

        vfio_disable_intx(vdev);

        break;

    case VFIO_INT_MSI:

        vfio_disable_msi(vdev);

        break;

    case VFIO_INT_MSIX:

        vfio_disable_msix(vdev);

        break;

    }

}
 and probability:0.07142857142857142
code:static inline int get_ue_code(GetBitContext *gb, int order)

{

    if (order) {

        int ret = get_ue_golomb(gb) << order;

        return ret + get_bits(gb, order);

    }

    return get_ue_golomb(gb);

}
 and probability:0.125
code:int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)

{

    int i, nb_samples1;

    short *bufin[2];

    short *bufout[2];

    short *buftmp2[2], *buftmp3[2];

    short *output_bak = NULL;

    int lenout;



    if (s->input_channels == s->output_channels && s->ratio == 1.0 && 0) {

        /* nothing to do */

        memcpy(output, input, nb_samples * s->input_channels * sizeof(short));

        return nb_samples;

    }



    if (s->sample_fmt[0] != SAMPLE_FMT_S16) {

        int istride[1] = { s->sample_size[0] };

        int ostride[1] = { 2 };

        const void *ibuf[1] = { input };

        void       *obuf[1];

        unsigned input_size = nb_samples*s->input_channels*s->sample_size[0];



        if (!s->buffer_size[0] || s->buffer_size[0] < input_size) {

            av_free(s->buffer[0]);

            s->buffer_size[0] = input_size;

            s->buffer[0] = av_malloc(s->buffer_size[0]);

            if (!s->buffer[0]) {

                av_log(s, AV_LOG_ERROR, "Could not allocate buffer\n");

                return 0;

            }

        }



        obuf[0] = s->buffer[0];



        if (av_audio_convert(s->convert_ctx[0], obuf, ostride,

                             ibuf, istride, nb_samples*s->input_channels) < 0) {

            av_log(s, AV_LOG_ERROR, "Audio sample format conversion failed\n");

            return 0;

        }



        input  = s->buffer[0];

    }



    lenout= 4*nb_samples * s->ratio + 16;



    if (s->sample_fmt[1] != SAMPLE_FMT_S16) {

        output_bak = output;



        if (!s->buffer_size[1] || s->buffer_size[1] < lenout) {

            av_free(s->buffer[1]);

            s->buffer_size[1] = lenout;

            s->buffer[1] = av_malloc(s->buffer_size[1]);

            if (!s->buffer[1]) {

                av_log(s, AV_LOG_ERROR, "Could not allocate buffer\n");

                return 0;

            }

        }



        output = s->buffer[1];

    }



    /* XXX: move those malloc to resample init code */

    for(i=0; i<s->filter_channels; i++){

        bufin[i]= av_malloc( (nb_samples + s->temp_len) * sizeof(short) );

        memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));

        buftmp2[i] = bufin[i] + s->temp_len;

    }



    /* make some zoom to avoid round pb */

    bufout[0]= av_malloc( lenout * sizeof(short) );

    bufout[1]= av_malloc( lenout * sizeof(short) );



    if (s->input_channels == 2 &&

        s->output_channels == 1) {

        buftmp3[0] = output;

        stereo_to_mono(buftmp2[0], input, nb_samples);

    } else if (s->output_channels >= 2 && s->input_channels == 1) {

        buftmp3[0] = bufout[0];

        memcpy(buftmp2[0], input, nb_samples*sizeof(short));

    } else if (s->output_channels >= 2) {

        buftmp3[0] = bufout[0];

        buftmp3[1] = bufout[1];

        stereo_split(buftmp2[0], buftmp2[1], input, nb_samples);

    } else {

        buftmp3[0] = output;

        memcpy(buftmp2[0], input, nb_samples*sizeof(short));

    }



    nb_samples += s->temp_len;



    /* resample each channel */

    nb_samples1 = 0; /* avoid warning */

    for(i=0;i<s->filter_channels;i++) {

        int consumed;

        int is_last= i+1 == s->filter_channels;



        nb_samples1 = av_resample(s->resample_context, buftmp3[i], bufin[i], &consumed, nb_samples, lenout, is_last);

        s->temp_len= nb_samples - consumed;

        s->temp[i]= av_realloc(s->temp[i], s->temp_len*sizeof(short));

        memcpy(s->temp[i], bufin[i] + consumed, s->temp_len*sizeof(short));

    }



    if (s->output_channels == 2 && s->input_channels == 1) {

        mono_to_stereo(output, buftmp3[0], nb_samples1);

    } else if (s->output_channels == 2) {

        stereo_mux(output, buftmp3[0], buftmp3[1], nb_samples1);

    } else if (s->output_channels == 6) {

        ac3_5p1_mux(output, buftmp3[0], buftmp3[1], nb_samples1);

    }



    if (s->sample_fmt[1] != SAMPLE_FMT_S16) {

        int istride[1] = { 2 };

        int ostride[1] = { s->sample_size[1] };

        const void *ibuf[1] = { output };

        void       *obuf[1] = { output_bak };



        if (av_audio_convert(s->convert_ctx[1], obuf, ostride,

                             ibuf, istride, nb_samples1*s->output_channels) < 0) {

            av_log(s, AV_LOG_ERROR, "Audio sample format convertion failed\n");

            return 0;

        }

    }



    for(i=0; i<s->filter_channels; i++)

        av_free(bufin[i]);



    av_free(bufout[0]);

    av_free(bufout[1]);

    return nb_samples1;

}
 and probability:0.5688073394495413
code:int ff_h264_decode_extradata(H264Context *h)

{

    AVCodecContext *avctx = h->s.avctx;



    if (avctx->extradata[0] == 1) {

        int i, cnt, nalsize;

        unsigned char *p = avctx->extradata;



        h->is_avc = 1;



        if (avctx->extradata_size < 7) {

            av_log(avctx, AV_LOG_ERROR, "avcC too short\n");

            return -1;

        }

        /* sps and pps in the avcC always have length coded with 2 bytes,

         * so put a fake nal_length_size = 2 while parsing them */

        h->nal_length_size = 2;

        // Decode sps from avcC

        cnt = *(p + 5) & 0x1f; // Number of sps

        p  += 6;

        for (i = 0; i < cnt; i++) {

            nalsize = AV_RB16(p) + 2;

            if (p - avctx->extradata + nalsize > avctx->extradata_size)

                return -1;

            if (decode_nal_units(h, p, nalsize) < 0) {

                av_log(avctx, AV_LOG_ERROR,

                       "Decoding sps %d from avcC failed\n", i);

                return -1;

            }

            p += nalsize;

        }

        // Decode pps from avcC

        cnt = *(p++); // Number of pps

        for (i = 0; i < cnt; i++) {

            nalsize = AV_RB16(p) + 2;

            if (p - avctx->extradata + nalsize > avctx->extradata_size)

                return -1;

            if (decode_nal_units(h, p, nalsize) < 0) {

                av_log(avctx, AV_LOG_ERROR,

                       "Decoding pps %d from avcC failed\n", i);

                return -1;

            }

            p += nalsize;

        }

        // Now store right nal length size, that will be used to parse all other nals

        h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;

    } else {

        h->is_avc = 0;

        if (decode_nal_units(h, avctx->extradata, avctx->extradata_size) < 0)

            return -1;

    }

    return 0;

}
 and probability:0.4
code:void video_encode_example(const char *filename)

{

    AVCodec *codec;

    AVCodecContext *c= NULL;

    int i, out_size, size, x, y, outbuf_size;

    FILE *f;

    AVFrame *picture;

    uint8_t *outbuf, *picture_buf;



    printf("Video encoding\n");



    /* find the mpeg1 video encoder */

    codec = avcodec_find_encoder(CODEC_ID_MPEG1VIDEO);

    if (!codec) {

        fprintf(stderr, "codec not found\n");

        exit(1);

    }



    c= avcodec_alloc_context();

    picture= avcodec_alloc_frame();

    

    /* put sample parameters */

    c->bit_rate = 400000;

    /* resolution must be a multiple of two */

    c->width = 352;  

    c->height = 288;

    /* frames per second */

    c->frame_rate = 25;  

    c->frame_rate_base= 1;

    c->gop_size = 10; /* emit one intra frame every ten frames */

    c->max_b_frames=1;



    /* open it */

    if (avcodec_open(c, codec) < 0) {

        fprintf(stderr, "could not open codec\n");

        exit(1);

    }

    

    /* the codec gives us the frame size, in samples */



    f = fopen(filename, "w");

    if (!f) {

        fprintf(stderr, "could not open %s\n", filename);

        exit(1);

    }

    

    /* alloc image and output buffer */

    outbuf_size = 100000;

    outbuf = malloc(outbuf_size);

    size = c->width * c->height;

    picture_buf = malloc((size * 3) / 2); /* size for YUV 420 */

    

    picture->data[0] = picture_buf;

    picture->data[1] = picture->data[0] + size;

    picture->data[2] = picture->data[1] + size / 4;

    picture->linesize[0] = c->width;

    picture->linesize[1] = c->width / 2;

    picture->linesize[2] = c->width / 2;



    /* encode 1 second of video */

    for(i=0;i<25;i++) {

        fflush(stdout);

        /* prepare a dummy image */

        /* Y */

        for(y=0;y<c->height;y++) {

            for(x=0;x<c->width;x++) {

                picture->data[0][y * picture->linesize[0] + x] = x + y + i * 3;

            }

        }



        /* Cb and Cr */

        for(y=0;y<c->height/2;y++) {

            for(x=0;x<c->width/2;x++) {

                picture->data[1][y * picture->linesize[1] + x] = 128 + y + i * 2;

                picture->data[2][y * picture->linesize[2] + x] = 64 + x + i * 5;

            }

        }



        /* encode the image */

        out_size = avcodec_encode_video(c, outbuf, outbuf_size, picture);

        printf("encoding frame %3d (size=%5d)\n", i, out_size);

        fwrite(outbuf, 1, out_size, f);

    }



    /* get the delayed frames */

    for(; out_size; i++) {

        fflush(stdout);

        

        out_size = avcodec_encode_video(c, outbuf, outbuf_size, NULL);

        printf("write frame %3d (size=%5d)\n", i, out_size);

        fwrite(outbuf, 1, out_size, f);

    }



    /* add sequence end code to have a real mpeg file */

    outbuf[0] = 0x00;

    outbuf[1] = 0x00;

    outbuf[2] = 0x01;

    outbuf[3] = 0xb7;

    fwrite(outbuf, 1, 4, f);

    fclose(f);

    free(picture_buf);

    free(outbuf);



    avcodec_close(c);

    free(c);

    free(picture);

    printf("\n");

}
 and probability:0.358695652173913
code:static void socket_outgoing_migration(Object *src,

                                      Error *err,

                                      gpointer opaque)

{

    MigrationState *s = opaque;

    QIOChannel *sioc = QIO_CHANNEL(src);



    if (err) {

        trace_migration_socket_outgoing_error(error_get_pretty(err));

        s->to_dst_file = NULL;

        migrate_fd_error(s, err);

    } else {

        trace_migration_socket_outgoing_connected();

        migration_set_outgoing_channel(s, sioc);

    }

    object_unref(src);

}
 and probability:0.0625
code:static void apic_common_class_init(ObjectClass *klass, void *data)

{

    ICCDeviceClass *idc = ICC_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->vmsd = &vmstate_apic_common;

    dc->reset = apic_reset_common;

    dc->no_user = 1;

    dc->props = apic_properties_common;

    idc->init = apic_init_common;

}
 and probability:0.5
code:static void do_unassigned_access(target_ulong addr, int is_write, int is_exec,

                          int is_asi, int size)

#else

void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

#endif

{

    CPUState *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



#ifdef DEBUG_UNASSIGNED

    printf("Unassigned mem access to " TARGET_FMT_plx " from " TARGET_FMT_lx

           "\n", addr, env->pc);

#endif



    if (is_exec)

        raise_exception(TT_CODE_ACCESS);

    else

        raise_exception(TT_DATA_ACCESS);



    env = saved_env;

}
 and probability:0.045454545454545456
code:int qemu_fsdev_add(QemuOpts *opts)

{

    int i;

    struct FsDriverListEntry *fsle;

    const char *fsdev_id = qemu_opts_id(opts);

    const char *fsdriver = qemu_opt_get(opts, "fsdriver");

    const char *writeout = qemu_opt_get(opts, "writeout");

    bool ro = qemu_opt_get_bool(opts, "readonly", 0);



    if (!fsdev_id) {

        fprintf(stderr, "fsdev: No id specified\n");

        return -1;

    }



    if (fsdriver) {

        for (i = 0; i < ARRAY_SIZE(FsDrivers); i++) {

            if (strcmp(FsDrivers[i].name, fsdriver) == 0) {

                break;

            }

        }



        if (i == ARRAY_SIZE(FsDrivers)) {

            fprintf(stderr, "fsdev: fsdriver %s not found\n", fsdriver);

            return -1;

        }

    } else {

        fprintf(stderr, "fsdev: No fsdriver specified\n");

        return -1;

    }



    fsle = g_malloc0(sizeof(*fsle));

    fsle->fse.fsdev_id = g_strdup(fsdev_id);

    fsle->fse.ops = FsDrivers[i].ops;

    if (writeout) {

        if (!strcmp(writeout, "immediate")) {

            fsle->fse.export_flags |= V9FS_IMMEDIATE_WRITEOUT;

        }

    }

    if (ro) {

        fsle->fse.export_flags |= V9FS_RDONLY;

    } else {

        fsle->fse.export_flags &= ~V9FS_RDONLY;

    }



    if (fsle->fse.ops->parse_opts) {

        if (fsle->fse.ops->parse_opts(opts, &fsle->fse)) {



            return -1;

        }

    }



    QTAILQ_INSERT_TAIL(&fsdriver_entries, fsle, next);

    return 0;

} and probability:0.2127659574468085
code:void OPPROTO op_set_Rc0 (void)

{

    env->crf[0] = T0 | xer_ov;

    RETURN();

}
 and probability:0.2
code:static int av_read_frame_internal(AVFormatContext *s, AVPacket *pkt)

{

    AVStream *st;

    int len, ret;



    for(;;) {

        /* select current input stream component */

        st = s->cur_st;

        if (st) {

            if (!st->parser) {

                /* no parsing needed: we just output the packet as is */

                /* raw data support */

                *pkt = s->cur_pkt;

                compute_pkt_fields(s, st, NULL, pkt);

                s->cur_st = NULL;

                return 0;

            } else if (s->cur_len > 0) {

                /* we use the MPEG semantics: the pts and dts in a

                   packet are given from the first frame beginning in

                   it */

                if (!st->got_frame) {

                    st->cur_frame_pts = s->cur_pkt.pts;

                    st->cur_frame_dts = s->cur_pkt.dts;

                    s->cur_pkt.pts = AV_NOPTS_VALUE;

                    s->cur_pkt.dts = AV_NOPTS_VALUE;

                    st->got_frame = 1;

                }

                len = av_parser_parse(st->parser, &st->codec, &pkt->data, &pkt->size, 

                                      s->cur_ptr, s->cur_len);

                /* increment read pointer */

                s->cur_ptr += len;

                s->cur_len -= len;

                

                /* return packet if any */

                if (pkt->size) {

                    pkt->duration = 0;

                    pkt->stream_index = st->index;

                    pkt->pts = st->cur_frame_pts;

                    pkt->dts = st->cur_frame_dts;

                    pkt->destruct = av_destruct_packet_nofree;

                    compute_pkt_fields(s, st, st->parser, pkt);

                    st->got_frame = 0;

                    return 0;

                }

            } else {

                s->cur_st = NULL;

            }

        } else {

            /* free previous packet */

            if (s->cur_st && s->cur_st->parser)

                av_free_packet(&s->cur_pkt); 



            /* read next packet */

            ret = av_read_packet(s, &s->cur_pkt);

            if (ret < 0)

                return ret;



            /* convert the packet time stamp units and handle wrapping */

            s->cur_pkt.pts = convert_timestamp_units(s, 

                                               &s->last_pkt_pts, &s->last_pkt_pts_frac,

                                               &s->last_pkt_stream_pts,

                                               s->cur_pkt.pts);

            s->cur_pkt.dts = convert_timestamp_units(s, 

                                               &s->last_pkt_dts,  &s->last_pkt_dts_frac,

                                               &s->last_pkt_stream_dts,

                                               s->cur_pkt.dts);

#if 0

            if (s->cur_pkt.stream_index == 1) {

                if (s->cur_pkt.pts != AV_NOPTS_VALUE) 

                    printf("PACKET pts=%0.3f\n", 

                           (double)s->cur_pkt.pts / AV_TIME_BASE);

                if (s->cur_pkt.dts != AV_NOPTS_VALUE) 

                    printf("PACKET dts=%0.3f\n", 

                           (double)s->cur_pkt.dts / AV_TIME_BASE);

            }

#endif

            

            /* duration field */

            if (s->cur_pkt.duration != 0) {

                s->cur_pkt.duration = ((int64_t)s->cur_pkt.duration * AV_TIME_BASE * s->pts_num) / 

                    s->pts_den;

            }



            st = s->streams[s->cur_pkt.stream_index];

            s->cur_st = st;

            s->cur_ptr = s->cur_pkt.data;

            s->cur_len = s->cur_pkt.size;

            if (st->need_parsing && !st->parser) {

                st->parser = av_parser_init(st->codec.codec_id);

                if (!st->parser) {

                    /* no parser available : just output the raw packets */

                    st->need_parsing = 0;

                }

            }

        }

    }

}
 and probability:0.5604395604395604
code:static void monitor_data_destroy(Monitor *mon)

{








    QDECREF(mon->outbuf);

    qemu_mutex_destroy(&mon->out_lock);
 and probability:0.5
code:static void qio_channel_websock_encode(QIOChannelWebsock *ioc)

{

    size_t header_size;

    union {

        char buf[QIO_CHANNEL_WEBSOCK_HEADER_LEN_64_BIT];

        QIOChannelWebsockHeader ws;

    } header;



    if (!ioc->rawoutput.offset) {

        return;

    }



    header.ws.b0 = (1 << QIO_CHANNEL_WEBSOCK_HEADER_SHIFT_FIN) |

        (QIO_CHANNEL_WEBSOCK_OPCODE_BINARY_FRAME &

         QIO_CHANNEL_WEBSOCK_HEADER_FIELD_OPCODE);

    if (ioc->rawoutput.offset <

        QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_THRESHOLD_7_BIT) {

        header.ws.b1 = (uint8_t)ioc->rawoutput.offset;

        header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_7_BIT;

    } else if (ioc->rawoutput.offset <

               QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_THRESHOLD_16_BIT) {

        header.ws.b1 = QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_MAGIC_16_BIT;

        header.ws.u.s16.l16 = cpu_to_be16((uint16_t)ioc->rawoutput.offset);

        header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_16_BIT;

    } else {

        header.ws.b1 = QIO_CHANNEL_WEBSOCK_PAYLOAD_LEN_MAGIC_64_BIT;

        header.ws.u.s64.l64 = cpu_to_be64(ioc->rawoutput.offset);

        header_size = QIO_CHANNEL_WEBSOCK_HEADER_LEN_64_BIT;

    }

    header_size -= QIO_CHANNEL_WEBSOCK_HEADER_LEN_MASK;



    buffer_reserve(&ioc->encoutput, header_size + ioc->rawoutput.offset);

    buffer_append(&ioc->encoutput, header.buf, header_size);

    buffer_append(&ioc->encoutput, ioc->rawoutput.buffer,

                  ioc->rawoutput.offset);

    buffer_reset(&ioc->rawoutput);

}
 and probability:0.35294117647058826
code:static void process_frame(AVFilterLink *inlink, AVFilterBufferRef *buf)

{

    AVFilterContext *ctx  = inlink->dst;

    ConcatContext *cat    = ctx->priv;

    unsigned in_no = FF_INLINK_IDX(inlink);



    if (in_no < cat->cur_idx) {

        av_log(ctx, AV_LOG_ERROR, "Frame after EOF on input %s\n",

               ctx->input_pads[in_no].name);

        avfilter_unref_buffer(buf);

    } if (in_no >= cat->cur_idx + ctx->nb_outputs) {

        ff_bufqueue_add(ctx, &cat->in[in_no].queue, buf);

    } else {

        push_frame(ctx, in_no, buf);

    }

}
 and probability:0.4
code:static int make_ydt15_entry(int p2, int p1, int16_t *ydt)

#else

static int make_ydt15_entry(int p1, int p2, int16_t *ydt)

#endif

{

    int lo, hi;



    lo = ydt[p1];

    lo += (lo * 32) + (lo * 1024);

    hi = ydt[p2];

    hi += (hi * 32) + (hi * 1024);

    return (lo + (hi * (1 << 16))) * 2;

}
 and probability:0.4166666666666667
code:static void coroutine_fn v9fs_xattrwalk(void *opaque)

{

    int64_t size;

    V9fsString name;

    ssize_t err = 0;

    size_t offset = 7;

    int32_t fid, newfid;

    V9fsFidState *file_fidp;

    V9fsFidState *xattr_fidp = NULL;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    v9fs_string_init(&name);

    err = pdu_unmarshal(pdu, offset, "dds", &fid, &newfid, &name);

    if (err < 0) {

        goto out_nofid;

    }

    trace_v9fs_xattrwalk(pdu->tag, pdu->id, fid, newfid, name.data);



    file_fidp = get_fid(pdu, fid);

    if (file_fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    xattr_fidp = alloc_fid(s, newfid);

    if (xattr_fidp == NULL) {

        err = -EINVAL;

        goto out;

    }

    v9fs_path_copy(&xattr_fidp->path, &file_fidp->path);

    if (!v9fs_string_size(&name)) {

        /*

         * listxattr request. Get the size first

         */

        size = v9fs_co_llistxattr(pdu, &xattr_fidp->path, NULL, 0);

        if (size < 0) {

            err = size;

            clunk_fid(s, xattr_fidp->fid);

            goto out;

        }

        /*

         * Read the xattr value

         */

        xattr_fidp->fs.xattr.len = size;

        xattr_fidp->fid_type = P9_FID_XATTR;

        xattr_fidp->fs.xattr.xattrwalk_fid = true;

        if (size) {

            xattr_fidp->fs.xattr.value = g_malloc(size);

            err = v9fs_co_llistxattr(pdu, &xattr_fidp->path,

                                     xattr_fidp->fs.xattr.value,

                                     xattr_fidp->fs.xattr.len);

            if (err < 0) {

                clunk_fid(s, xattr_fidp->fid);

                goto out;

            }

        }

        err = pdu_marshal(pdu, offset, "q", size);

        if (err < 0) {

            goto out;

        }

        err += offset;

    } else {

        /*

         * specific xattr fid. We check for xattr

         * presence also collect the xattr size

         */

        size = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,

                                 &name, NULL, 0);

        if (size < 0) {

            err = size;

            clunk_fid(s, xattr_fidp->fid);

            goto out;

        }

        /*

         * Read the xattr value

         */

        xattr_fidp->fs.xattr.len = size;

        xattr_fidp->fid_type = P9_FID_XATTR;

        xattr_fidp->fs.xattr.xattrwalk_fid = true;

        if (size) {

            xattr_fidp->fs.xattr.value = g_malloc(size);

            err = v9fs_co_lgetxattr(pdu, &xattr_fidp->path,

                                    &name, xattr_fidp->fs.xattr.value,

                                    xattr_fidp->fs.xattr.len);

            if (err < 0) {

                clunk_fid(s, xattr_fidp->fid);

                goto out;

            }

        }

        err = pdu_marshal(pdu, offset, "q", size);

        if (err < 0) {

            goto out;

        }

        err += offset;

    }

    trace_v9fs_xattrwalk_return(pdu->tag, pdu->id, size);

out:

    put_fid(pdu, file_fidp);

    if (xattr_fidp) {

        put_fid(pdu, xattr_fidp);

    }

out_nofid:

    pdu_complete(pdu, err);

    v9fs_string_free(&name);

}
 and probability:0.2524271844660194
code:static void gen_slbmfev(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    gen_helper_load_slb_vsid(cpu_gpr[rS(ctx->opcode)], cpu_env,

                             cpu_gpr[rB(ctx->opcode)]);

#endif

}
 and probability:0.23076923076923078
code:void vga_common_init(VGACommonState *s, Object *obj, bool global_vmstate)

{

    int i, j, v, b;



    for(i = 0;i < 256; i++) {

        v = 0;

        for(j = 0; j < 8; j++) {

            v |= ((i >> j) & 1) << (j * 4);

        }

        expand4[i] = v;



        v = 0;

        for(j = 0; j < 4; j++) {

            v |= ((i >> (2 * j)) & 3) << (j * 4);

        }

        expand2[i] = v;

    }

    for(i = 0; i < 16; i++) {

        v = 0;

        for(j = 0; j < 4; j++) {

            b = ((i >> j) & 1);

            v |= b << (2 * j);

            v |= b << (2 * j + 1);

        }

        expand4to8[i] = v;

    }



    s->vram_size_mb = uint_clamp(s->vram_size_mb, 1, 512);

    s->vram_size_mb = pow2ceil(s->vram_size_mb);

    s->vram_size = s->vram_size_mb << 20;



    if (!s->vbe_size) {

        s->vbe_size = s->vram_size;

    }



    s->is_vbe_vmstate = 1;

    memory_region_init_ram(&s->vram, obj, "vga.vram", s->vram_size,

                           &error_abort);

    vmstate_register_ram(&s->vram, global_vmstate ? NULL : DEVICE(obj));

    xen_register_framebuffer(&s->vram);

    s->vram_ptr = memory_region_get_ram_ptr(&s->vram);

    s->get_bpp = vga_get_bpp;

    s->get_offsets = vga_get_offsets;

    s->get_resolution = vga_get_resolution;

    s->hw_ops = &vga_ops;

    switch (vga_retrace_method) {

    case VGA_RETRACE_DUMB:

        s->retrace = vga_dumb_retrace;

        s->update_retrace_info = vga_dumb_update_retrace_info;

        break;



    case VGA_RETRACE_PRECISE:

        s->retrace = vga_precise_retrace;

        s->update_retrace_info = vga_precise_update_retrace_info;

        break;

    }



    /*

     * Set default fb endian based on target, could probably be turned

     * into a device attribute set by the machine/platform to remove

     * all target endian dependencies from this file.

     */

#ifdef TARGET_WORDS_BIGENDIAN

    s->default_endian_fb = true;

#else

    s->default_endian_fb = false;

#endif

    vga_dirty_log_start(s);

}
 and probability:0.5161290322580645
code:static void dss_sp_scale_vector(int32_t *vec, int bits, int size)

{

    int i;



    if (bits < 0)

        for (i = 0; i < size; i++)

            vec[i] = vec[i] >> -bits;

    else

        for (i = 0; i < size; i++)

            vec[i] = vec[i] << bits;

}
 and probability:0.4
code:void OPPROTO op_store_msr (void)

{

    do_store_msr(env, T0);

    RETURN();

}
 and probability:0.0
code:static void rac_normalise(RangeCoder *c)

{

    for (;;) {

        c->range <<= 8;

        c->low   <<= 8;

        if (c->src < c->src_end) {

            c->low |= *c->src++;

        } else if (!c->low) {

            c->got_error = 1;

            return;

        }

        if (c->range >= RAC_BOTTOM)

            return;

    }

}
 and probability:0.4666666666666667
code:static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, int height)

{

    int64_t sad;

    int x, y;

    for (sad = y = 0; y < height; y += 8) {

        for (x = 0; x < p1_linesize; x += 8) {

            sad += sad_8x8_16(p1 + y * p1_linesize + x,

                              p1_linesize,

                              p2 + y * p2_linesize + x,

                              p2_linesize);

        }

    }

    return sad;

}
 and probability:0.2857142857142857
code:static int hds_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    HDSContext *c = s->priv_data;

    AVStream *st = s->streams[pkt->stream_index];

    OutputStream *os = &c->streams[s->streams[pkt->stream_index]->id];

    int64_t end_dts = (os->fragment_index) * c->min_frag_duration;

    int ret;



    if (st->first_dts == AV_NOPTS_VALUE)

        st->first_dts = pkt->dts;



    if ((!os->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&

        av_compare_ts(pkt->dts - st->first_dts, st->time_base,

                      end_dts, AV_TIME_BASE_Q) >= 0 &&

        pkt->flags & AV_PKT_FLAG_KEY && os->packets_written) {



        if ((ret = hds_flush(s, os, 0, pkt->dts)) < 0)

            return ret;

    }



    // Note, these fragment start timestamps, that represent a whole

    // OutputStream, assume all streams in it have the same time base.

    if (!os->packets_written)

        os->frag_start_ts = pkt->dts;

    os->last_ts = pkt->dts;



    os->packets_written++;

    return ff_write_chained(os->ctx, pkt->stream_index - os->first_stream, pkt, s);

}
 and probability:0.625
code:static int gif_read_extension(GifState *s)

{

    int ext_code, ext_len, gce_flags, gce_transparent_index;



    /* There must be at least 2 bytes:

     * 1 for extension label and 1 for extension length. */

    if (bytestream2_get_bytes_left(&s->gb) < 2)

        return AVERROR_INVALIDDATA;



    ext_code = bytestream2_get_byteu(&s->gb);

    ext_len = bytestream2_get_byteu(&s->gb);



    av_dlog(s->avctx, "ext_code=0x%x len=%d\n", ext_code, ext_len);



    switch(ext_code) {

    case GIF_GCE_EXT_LABEL:

        if (ext_len != 4)

            goto discard_ext;



        /* We need at least 5 bytes more: 4 is for extension body

         * and 1 for next block size. */

        if (bytestream2_get_bytes_left(&s->gb) < 5)

            return AVERROR_INVALIDDATA;



        gce_flags = bytestream2_get_byteu(&s->gb);

        bytestream2_skipu(&s->gb, 2);    // delay during which the frame is shown

        gce_transparent_index = bytestream2_get_byteu(&s->gb);

        if (gce_flags & 0x01)

            s->transparent_color_index = gce_transparent_index;

        else

            s->transparent_color_index = -1;

        s->gce_disposal = (gce_flags >> 2) & 0x7;



        av_dlog(s->avctx, "gce_flags=%x tcolor=%d disposal=%d\n",

               gce_flags,

               s->transparent_color_index, s->gce_disposal);



        if (s->gce_disposal > 3) {

            s->gce_disposal = GCE_DISPOSAL_NONE;

            av_dlog(s->avctx, "invalid value in gce_disposal (%d). Using default value of 0.\n", ext_len);

        }



        ext_len = bytestream2_get_byteu(&s->gb);

        break;

    }



    /* NOTE: many extension blocks can come after */

 discard_ext:

    while (ext_len != 0) {

        /* There must be at least ext_len bytes and 1 for next block size byte. */

        if (bytestream2_get_bytes_left(&s->gb) < ext_len + 1)

            return AVERROR_INVALIDDATA;



        bytestream2_skipu(&s->gb, ext_len);

        ext_len = bytestream2_get_byteu(&s->gb);



        av_dlog(s->avctx, "ext_len1=%d\n", ext_len);

    }

    return 0;

}
 and probability:0.4375
code:yuv2rgb_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
 and probability:0.6071428571428571
code:static inline void mix_3f_to_stereo(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++) {

        output[1][i] += output[2][i];

        output[2][i] += output[3][i];

    }

    memset(output[3], 0, sizeof(output[3]));

}
 and probability:0.5
code:static void decode_sigpass(Jpeg2000T1Context *t1, int width, int height,

                           int bpno, int bandno, int bpass_csty_symbol,

                           int vert_causal_ctx_csty_symbol)

{

    int mask = 3 << (bpno - 1), y0, x, y;



    for (y0 = 0; y0 < height; y0 += 4)

        for (x = 0; x < width; x++)

            for (y = y0; y < height && y < y0 + 4; y++) {

                if ((t1->flags[y+1][x+1] & JPEG2000_T1_SIG_NB)

                && !(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))) {

                    int flags_mask = -1;

                    if (vert_causal_ctx_csty_symbol && y == y0 + 3)

                        flags_mask &= ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE);

                    if (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1] & flags_mask, bandno))) {

                        int xorbit, ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);

                        if (bpass_csty_symbol)

                             t1->data[y][x] = ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ? -mask : mask;

                        else

                             t1->data[y][x] = (ff_mqc_decode(&t1->mqc, t1->mqc.cx_states + ctxno) ^ xorbit) ?

                                               -mask : mask;



                        ff_jpeg2000_set_significance(t1, x, y,

                                                     t1->data[y][x] < 0);

                    }

                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_VIS;

                }

            }

}
 and probability:0.48148148148148145
code:void ff_fix_long_p_mvs(MpegEncContext * s)

{

    const int f_code= s->f_code;

    int y;

    UINT8 * fcode_tab= s->fcode_tab;



    /* clip / convert to intra 16x16 type MVs */

    for(y=0; y<s->mb_height; y++){

        int x;

        int xy= (y+1)* (s->mb_width+2)+1;

        int i= y*s->mb_width;

        for(x=0; x<s->mb_width; x++){

            if(s->mb_type[i]&MB_TYPE_INTER){

                if(   fcode_tab[s->p_mv_table[xy][0] + MAX_MV] > f_code

                   || fcode_tab[s->p_mv_table[xy][0] + MAX_MV] == 0

                   || fcode_tab[s->p_mv_table[xy][1] + MAX_MV] > f_code

                   || fcode_tab[s->p_mv_table[xy][1] + MAX_MV] == 0 ){

                    s->mb_type[i] &= ~MB_TYPE_INTER;

                    s->mb_type[i] |= MB_TYPE_INTRA;

                    s->p_mv_table[xy][0] = 0;

                    s->p_mv_table[xy][1] = 0;

                }

            }

            xy++;

            i++;

        }

    }



    if(s->flags&CODEC_FLAG_4MV){

        const int wrap= 2+ s->mb_width*2;



        /* clip / convert to intra 8x8 type MVs */

        for(y=0; y<s->mb_height; y++){

            int xy= (y*2 + 1)*wrap + 1;

            int i= y*s->mb_width;

            int x;



            for(x=0; x<s->mb_width; x++){

                if(s->mb_type[i]&MB_TYPE_INTER4V){

                    int block;

                    for(block=0; block<4; block++){

                        int off= (block& 1) + (block>>1)*wrap;

                        int mx= s->motion_val[ xy + off ][0];

                        int my= s->motion_val[ xy + off ][1];



                        if(   fcode_tab[mx + MAX_MV] > f_code

                           || fcode_tab[mx + MAX_MV] == 0

                           || fcode_tab[my + MAX_MV] > f_code

                           || fcode_tab[my + MAX_MV] == 0 ){

                            s->mb_type[i] &= ~MB_TYPE_INTER4V;

                            s->mb_type[i] |= MB_TYPE_INTRA;

                        }

                    }

                    xy+=2;

                    i++;

                }

            }

        }

    }

}
 and probability:0.6545454545454545
code:static av_cold int pcm_dvd_decode_init(AVCodecContext *avctx)

{

    PCMDVDContext *s = avctx->priv_data;



    /* Invalid header to force parsing of the first header */

    s->last_header = -1;

    /* reserve space for 8 channels, 3 bytes/sample, 4 samples/block */

    if (!(s->extra_samples = av_malloc(8 * 3 * 4)))

        return AVERROR(ENOMEM);

    s->extra_sample_count = 0;



    return 0;

}
 and probability:0.36363636363636365
code:void ff_h264_v_lpf_chroma_inter_msa(uint8_t *data, int img_width,

                                    int alpha, int beta, int8_t *tc)

{

    uint8_t bs0 = 1;

    uint8_t bs1 = 1;

    uint8_t bs2 = 1;

    uint8_t bs3 = 1;



    if (tc[0] < 0)

        bs0 = 0;

    if (tc[1] < 0)

        bs1 = 0;

    if (tc[2] < 0)

        bs2 = 0;

    if (tc[3] < 0)

        bs3 = 0;



    avc_loopfilter_cb_or_cr_inter_edge_hor_msa(data,

                                               bs0, bs1, bs2, bs3,

                                               tc[0], tc[1], tc[2], tc[3],

                                               alpha, beta,

                                               img_width);

}
 and probability:0.23809523809523808
code:static AVFrame *get_palette_frame(AVFilterContext *ctx)

{

    AVFrame *out;

    PaletteGenContext *s = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    double ratio;

    int box_id = 0;

    struct range_box *box;



    /* reference only the used colors from histogram */

    s->refs = load_color_refs(s->histogram, s->nb_refs);

    if (!s->refs) {

        av_log(ctx, AV_LOG_ERROR, "Unable to allocate references for %d different colors\n", s->nb_refs);

        return NULL;

    }



    /* create the palette frame */

    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);

    if (!out)

        return NULL;

    out->pts = 0;



    /* set first box for 0..nb_refs */

    box = &s->boxes[box_id];

    box->len = s->nb_refs;

    box->sorted_by = -1;

    box->color = get_avg_color(s->refs, box);

    box->variance = -1;

    s->nb_boxes = 1;



    while (box && box->len > 1) {

        int i, rr, gr, br, longest;

        uint64_t median, box_weight = 0;



        /* compute the box weight (sum all the weights of the colors in the

         * range) and its boundings */

        uint8_t min[3] = {0xff, 0xff, 0xff};

        uint8_t max[3] = {0x00, 0x00, 0x00};

        for (i = box->start; i < box->start + box->len; i++) {

            const struct color_ref *ref = s->refs[i];

            const uint32_t rgb = ref->color;

            const uint8_t r = rgb >> 16 & 0xff, g = rgb >> 8 & 0xff, b = rgb & 0xff;

            min[0] = FFMIN(r, min[0]), max[0] = FFMAX(r, max[0]);

            min[1] = FFMIN(g, min[1]), max[1] = FFMAX(g, max[1]);

            min[2] = FFMIN(b, min[2]), max[2] = FFMAX(b, max[2]);

            box_weight += ref->count;

        }



        /* define the axis to sort by according to the widest range of colors */

        rr = max[0] - min[0];

        gr = max[1] - min[1];

        br = max[2] - min[2];

        longest = 1; // pick green by default (the color the eye is the most sensitive to)

        if (br >= rr && br >= gr) longest = 2;

        if (rr >= gr && rr >= br) longest = 0;

        if (gr >= rr && gr >= br) longest = 1; // prefer green again



        av_dlog(ctx, "box #%02X [%6d..%-6d] (%6d) w:%-6"PRIu64" ranges:[%2x %2x %2x] sort by %c (already sorted:%c) ",

                box_id, box->start, box->start + box->len - 1, box->len, box_weight,

                rr, gr, br, "rgb"[longest], box->sorted_by == longest ? 'y':'n');



        /* sort the range by its longest axis if it's not already sorted */

        if (box->sorted_by != longest) {

            cmp_func cmpf = cmp_funcs[longest];

            AV_QSORT(&s->refs[box->start], box->len, const struct color_ref *, cmpf);

            box->sorted_by = longest;

        }



        /* locate the median where to split */

        median = (box_weight + 1) >> 1;

        box_weight = 0;

        /* if you have 2 boxes, the maximum is actually #0: you must have at

         * least 1 color on each side of the split, hence the -2 */

        for (i = box->start; i < box->start + box->len - 2; i++) {

            box_weight += s->refs[i]->count;

            if (box_weight > median)

                break;

        }

        av_dlog(ctx, "split @ i=%-6d with w=%-6"PRIu64" (target=%6"PRIu64")\n", i, box_weight, median);

        split_box(s, box, i);



        box_id = get_next_box_id_to_split(s);

        box = box_id >= 0 ? &s->boxes[box_id] : NULL;

    }



    ratio = set_colorquant_ratio_meta(out, s->nb_boxes, s->nb_refs);

    av_log(ctx, AV_LOG_INFO, "%d%s colors generated out of %d colors; ratio=%f\n",

           s->nb_boxes, s->reserve_transparent ? "(+1)" : "", s->nb_refs, ratio);



    qsort(s->boxes, s->nb_boxes, sizeof(*s->boxes), cmp_color);



    write_palette(ctx, out);



    return out;

}
 and probability:0.4567901234567901
code:static void sun4uv_init(MemoryRegion *address_space_mem,

                        MachineState *machine,

                        const struct hwdef *hwdef)

{

    SPARCCPU *cpu;

    M48t59State *nvram;

    unsigned int i;

    uint64_t initrd_addr, initrd_size, kernel_addr, kernel_size, kernel_entry;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    ISABus *isa_bus;

    qemu_irq *ivec_irqs, *pbm_irqs;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    DriveInfo *fd[MAX_FD];

    FWCfgState *fw_cfg;



    /* init CPUs */

    cpu = cpu_devinit(machine->cpu_model, hwdef);



    /* set up devices */

    ram_init(0, machine->ram_size);



    prom_init(hwdef->prom_addr, bios_name);



    ivec_irqs = qemu_allocate_irqs(cpu_set_ivec_irq, cpu, IVEC_MAX);

    pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, ivec_irqs, &pci_bus2,

                           &pci_bus3, &pbm_irqs);

    pci_vga_init(pci_bus);



    // XXX Should be pci_bus3

    isa_bus = pci_ebus_init(pci_bus, -1, pbm_irqs);



    i = 0;

    if (hwdef->console_serial_base) {

        serial_mm_init(address_space_mem, hwdef->console_serial_base, 0,

                       NULL, 115200, serial_hds[i], DEVICE_BIG_ENDIAN);

        i++;

    }

    for(; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            serial_isa_init(isa_bus, i, serial_hds[i]);

        }

    }



    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {

        if (parallel_hds[i]) {

            parallel_init(isa_bus, i, parallel_hds[i]);

        }

    }



    for(i = 0; i < nb_nics; i++)

        pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);



    ide_drive_get(hd, MAX_IDE_BUS);



    pci_cmd646_ide_init(pci_bus, hd, 1);



    isa_create_simple(isa_bus, "i8042");

    for(i = 0; i < MAX_FD; i++) {

        fd[i] = drive_get(IF_FLOPPY, 0, i);

    }

    fdctrl_init_isa(isa_bus, fd);

    nvram = m48t59_init_isa(isa_bus, 0x0074, NVRAM_SIZE, 59);



    initrd_size = 0;

    initrd_addr = 0;

    kernel_size = sun4u_load_kernel(machine->kernel_filename,

                                    machine->initrd_filename,

                                    ram_size, &initrd_size, &initrd_addr,

                                    &kernel_addr, &kernel_entry);



    sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", machine->ram_size,

                           machine->boot_order,

                           kernel_addr, kernel_size,

                           machine->kernel_cmdline,

                           initrd_addr, initrd_size,

                           /* XXX: need an option to load a NVRAM image */

                           0,

                           graphic_width, graphic_height, graphic_depth,

                           (uint8_t *)&nd_table[0].macaddr);



    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);

    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_entry);

    fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (machine->kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,

                       strlen(machine->kernel_cmdline) + 1);

        fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);

    }

    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);

    fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);



    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_DEPTH, graphic_depth);



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
 and probability:0.3409090909090909
code:static int dss_read_metadata_date(AVFormatContext *s, unsigned int offset,

                                  const char *key)

{

    AVIOContext *pb = s->pb;

    char datetime[64], string[DSS_TIME_SIZE + 1] = { 0 };

    int y, month, d, h, minute, sec;

    int ret;



    avio_seek(pb, offset, SEEK_SET);



    ret = avio_read(s->pb, string, DSS_TIME_SIZE);

    if (ret < DSS_TIME_SIZE)

        return ret < 0 ? ret : AVERROR_EOF;



    sscanf(string, "%2d%2d%2d%2d%2d%2d", &y, &month, &d, &h, &minute, &sec);

    /* We deal with a two-digit year here, so set the default date to 2000

     * and hope it will never be used in the next century. */

    snprintf(datetime, sizeof(datetime), "%.4d-%.2d-%.2dT%.2d:%.2d:%.2d",

             y + 2000, month, d, h, minute, sec);

    return av_dict_set(&s->metadata, key, datetime, 0);

}
 and probability:0.2777777777777778
code:static void fdctrl_start_transfer(FDCtrl *fdctrl, int direction)

{

    FDrive *cur_drv;

    uint8_t kh, kt, ks;



    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);

    cur_drv = get_cur_drv(fdctrl);

    kt = fdctrl->fifo[2];

    kh = fdctrl->fifo[3];

    ks = fdctrl->fifo[4];

    FLOPPY_DPRINTF("Start transfer at %d %d %02x %02x (%d)\n",

                   GET_CUR_DRV(fdctrl), kh, kt, ks,

                   fd_sector_calc(kh, kt, ks, cur_drv->last_sect,

                                  NUM_SIDES(cur_drv)));

    switch (fd_seek(cur_drv, kh, kt, ks, fdctrl->config & FD_CONFIG_EIS)) {

    case 2:

        /* sect too big */

        fdctrl_stop_transfer(fdctrl, FD_SR0_ABNTERM, 0x00, 0x00);

        fdctrl->fifo[3] = kt;

        fdctrl->fifo[4] = kh;

        fdctrl->fifo[5] = ks;

        return;

    case 3:

        /* track too big */

        fdctrl_stop_transfer(fdctrl, FD_SR0_ABNTERM, FD_SR1_EC, 0x00);

        fdctrl->fifo[3] = kt;

        fdctrl->fifo[4] = kh;

        fdctrl->fifo[5] = ks;

        return;

    case 4:

        /* No seek enabled */

        fdctrl_stop_transfer(fdctrl, FD_SR0_ABNTERM, 0x00, 0x00);

        fdctrl->fifo[3] = kt;

        fdctrl->fifo[4] = kh;

        fdctrl->fifo[5] = ks;

        return;

    case 1:

        fdctrl->status0 |= FD_SR0_SEEK;

        break;

    default:

        break;

    }



    /* Check the data rate. If the programmed data rate does not match

     * the currently inserted medium, the operation has to fail. */

    if (fdctrl->check_media_rate &&

        (fdctrl->dsr & FD_DSR_DRATEMASK) != cur_drv->media_rate) {

        FLOPPY_DPRINTF("data rate mismatch (fdc=%d, media=%d)\n",

                       fdctrl->dsr & FD_DSR_DRATEMASK, cur_drv->media_rate);

        fdctrl_stop_transfer(fdctrl, FD_SR0_ABNTERM, FD_SR1_MA, 0x00);

        fdctrl->fifo[3] = kt;

        fdctrl->fifo[4] = kh;

        fdctrl->fifo[5] = ks;

        return;

    }



    /* Set the FIFO state */

    fdctrl->data_dir = direction;

    fdctrl->data_pos = 0;

    fdctrl->msr |= FD_MSR_CMDBUSY;

    if (fdctrl->fifo[0] & 0x80)

        fdctrl->data_state |= FD_STATE_MULTI;

    else

        fdctrl->data_state &= ~FD_STATE_MULTI;

    if (fdctrl->fifo[5] == 00) {

        fdctrl->data_len = fdctrl->fifo[8];

    } else {

        int tmp;

        fdctrl->data_len = 128 << (fdctrl->fifo[5] > 7 ? 7 : fdctrl->fifo[5]);

        tmp = (fdctrl->fifo[6] - ks + 1);

        if (fdctrl->fifo[0] & 0x80)

            tmp += fdctrl->fifo[6];

        fdctrl->data_len *= tmp;

    }

    fdctrl->eot = fdctrl->fifo[6];

    if (fdctrl->dor & FD_DOR_DMAEN) {

        int dma_mode;

        /* DMA transfer are enabled. Check if DMA channel is well programmed */

        dma_mode = DMA_get_channel_mode(fdctrl->dma_chann);

        dma_mode = (dma_mode >> 2) & 3;

        FLOPPY_DPRINTF("dma_mode=%d direction=%d (%d - %d)\n",

                       dma_mode, direction,

                       (128 << fdctrl->fifo[5]) *

                       (cur_drv->last_sect - ks + 1), fdctrl->data_len);

        if (((direction == FD_DIR_SCANE || direction == FD_DIR_SCANL ||

              direction == FD_DIR_SCANH) && dma_mode == 0) ||

            (direction == FD_DIR_WRITE && dma_mode == 2) ||

            (direction == FD_DIR_READ && dma_mode == 1)) {

            /* No access is allowed until DMA transfer has completed */

            fdctrl->msr &= ~FD_MSR_RQM;

            /* Now, we just have to wait for the DMA controller to

             * recall us...

             */

            DMA_hold_DREQ(fdctrl->dma_chann);

            DMA_schedule(fdctrl->dma_chann);

            return;

        } else {

            FLOPPY_DPRINTF("bad dma_mode=%d direction=%d\n", dma_mode,

                           direction);

        }

    }

    FLOPPY_DPRINTF("start non-DMA transfer\n");

    fdctrl->msr |= FD_MSR_NONDMA;

    if (direction != FD_DIR_WRITE)

        fdctrl->msr |= FD_MSR_DIO;

    /* IO based transfer: calculate len */

    fdctrl_raise_irq(fdctrl);

}
 and probability:0.42857142857142855
code:static int mxf_write_footer(AVFormatContext *s)
{
    MXFContext *mxf = s->priv_data;
    AVIOContext *pb = s->pb;
    int err = 0;
    mxf->duration = mxf->last_indexed_edit_unit + mxf->edit_units_count;
    mxf_write_klv_fill(s);
    mxf->footer_partition_offset = avio_tell(pb);
    if (mxf->edit_unit_byte_count && s->oformat != &ff_mxf_opatom_muxer) { // no need to repeat index
        if ((err = mxf_write_partition(s, 0, 0, footer_partition_key, 0)) < 0)
    } else {
        if ((err = mxf_write_partition(s, 0, 2, footer_partition_key, 0)) < 0)
        mxf_write_klv_fill(s);
        mxf_write_index_table_segment(s);
    mxf_write_klv_fill(s);
    mxf_write_random_index_pack(s);
    if (s->pb->seekable) {
        if (s->oformat == &ff_mxf_opatom_muxer){
            /* rewrite body partition to update lengths */
            avio_seek(pb, mxf->body_partition_offset[0], SEEK_SET);
            if ((err = mxf_write_opatom_body_partition(s)) < 0)
        avio_seek(pb, 0, SEEK_SET);
        if (mxf->edit_unit_byte_count && s->oformat != &ff_mxf_opatom_muxer) {
            if ((err = mxf_write_partition(s, 1, 2, header_closed_partition_key, 1)) < 0)
            mxf_write_klv_fill(s);
            mxf_write_index_table_segment(s);
        } else {
            if ((err = mxf_write_partition(s, 0, 0, header_closed_partition_key, 1)) < 0)
end:
    ff_audio_interleave_close(s);
    av_freep(&mxf->index_entries);
    av_freep(&mxf->body_partition_offset);
    av_freep(&mxf->timecode_track->priv_data);
    av_freep(&mxf->timecode_track);
    mxf_free(s);
    return err < 0 ? err : 0; and probability:0.3611111111111111
code:static int inet_listen_saddr(InetSocketAddress *saddr,

                             int port_offset,

                             bool update_addr,

                             Error **errp)

{

    struct addrinfo ai,*res,*e;

    char port[33];

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int rc, port_min, port_max, p;

    int slisten = 0;

    int saved_errno = 0;

    bool socket_created = false;

    Error *err = NULL;



    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    if (saddr->has_numeric && saddr->numeric) {

        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;

    }

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return -1;

    }



    if (saddr->host == NULL) {

        error_setg(errp, "host not specified");

        return -1;

    }

    if (saddr->port != NULL) {

        pstrcpy(port, sizeof(port), saddr->port);

    } else {

        port[0] = '\0';

    }



    /* lookup */

    if (port_offset) {

        unsigned long long baseport;

        if (strlen(port) == 0) {

            error_setg(errp, "port not specified");

            return -1;

        }

        if (parse_uint_full(port, &baseport, 10) < 0) {

            error_setg(errp, "can't convert to a number: %s", port);

            return -1;

        }

        if (baseport > 65535 ||

            baseport + port_offset > 65535) {

            error_setg(errp, "port %s out of range", port);

            return -1;

        }

        snprintf(port, sizeof(port), "%d", (int)baseport + port_offset);

    }

    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,

                     strlen(port) ? port : NULL, &ai, &res);

    if (rc != 0) {

        error_setg(errp, "address resolution failed for %s:%s: %s",

                   saddr->host, port, gai_strerror(rc));

        return -1;

    }



    /* create socket + bind/listen */

    for (e = res; e != NULL; e = e->ai_next) {

        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,

		        uaddr,INET6_ADDRSTRLEN,uport,32,

		        NI_NUMERICHOST | NI_NUMERICSERV);



        slisten = create_fast_reuse_socket(e);

        if (slisten < 0) {

            continue;

        }



        socket_created = true;

        port_min = inet_getport(e);

        port_max = saddr->has_to ? saddr->to + port_offset : port_min;

        for (p = port_min; p <= port_max; p++) {

            inet_setport(e, p);

            rc = try_bind(slisten, saddr, e);

            if (rc) {

                if (errno == EADDRINUSE) {

                    continue;

                } else {

                    error_setg_errno(errp, errno, "Failed to bind socket");

                    goto listen_failed;

                }

            }

            if (!listen(slisten, 1)) {

                goto listen_ok;

            }

            if (errno != EADDRINUSE) {

                error_setg_errno(errp, errno, "Failed to listen on socket");

                goto listen_failed;

            }

            /* Someone else managed to bind to the same port and beat us

             * to listen on it! Socket semantics does not allow us to

             * recover from this situation, so we need to recreate the

             * socket to allow bind attempts for subsequent ports:

             */

            closesocket(slisten);

            slisten = create_fast_reuse_socket(e);

            if (slisten < 0) {

                error_setg_errno(errp, errno,

                                 "Failed to recreate failed listening socket");

                goto listen_failed;

            }

        }

    }

    error_setg_errno(errp, errno,

                     socket_created ?

                     "Failed to find an available port" :

                     "Failed to create a socket");

listen_failed:

    saved_errno = errno;

    if (slisten >= 0) {

        closesocket(slisten);

    }

    freeaddrinfo(res);

    errno = saved_errno;

    return -1;



listen_ok:

    if (update_addr) {

        g_free(saddr->host);

        saddr->host = g_strdup(uaddr);

        g_free(saddr->port);

        saddr->port = g_strdup_printf("%d",

                                      inet_getport(e) - port_offset);

        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;

        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;

    }

    freeaddrinfo(res);

    return slisten;

}
 and probability:0.1796875
code:static void *circular_buffer_task( void *_URLContext)

{

    URLContext *h = _URLContext;

    UDPContext *s = h->priv_data;

    int old_cancelstate;



    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancelstate);

    ff_socket_nonblock(s->udp_fd, 0);

    while(1) {

        int left;

        int len;



        /* How much do we have left to the end of the buffer */

        /* Whats the minimum we can read so that we dont comletely fill the buffer */

        left = av_fifo_space(s->fifo);



        /* Blocking operations are always cancellation points;

           see "General Information" / "Thread Cancelation Overview"

           in Single Unix. */

        pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &old_cancelstate);

        len = recv(s->udp_fd, s->tmp+4, sizeof(s->tmp)-4, 0);

        pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancelstate);

        if (len < 0) {

            if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) {

                s->circular_buffer_error = AVERROR(EIO);

                goto end;

            }

            continue;

        }

        AV_WL32(s->tmp, len);

        if(left < len + 4) {

            /* No Space left */

            if (s->overrun_nonfatal) {

                av_log(h, AV_LOG_WARNING, "Circular buffer overrun. "

                        "Surviving due to overrun_nonfatal option\n");

                continue;

            } else {

                av_log(h, AV_LOG_ERROR, "Circular buffer overrun. "

                        "To avoid, increase fifo_size URL option. "

                        "To survive in such case, use overrun_nonfatal option\n");

                s->circular_buffer_error = AVERROR(EIO);

                goto end;

            }

        }

        pthread_mutex_lock(&s->mutex);

        av_fifo_generic_write(s->fifo, s->tmp, len+4, NULL);

        pthread_cond_signal(&s->cond);

        pthread_mutex_unlock(&s->mutex);

    }



end:

    pthread_mutex_lock(&s->mutex);

    pthread_cond_signal(&s->cond);

    pthread_mutex_unlock(&s->mutex);

    return NULL;

}
 and probability:0.3076923076923077
code:static void FUNCC(pred8x8l_horizontal)(uint8_t *_src, int has_topleft, int has_topright, int _stride)

{

    pixel *src = (pixel*)_src;

    int stride = _stride/sizeof(pixel);



    PREDICT_8x8_LOAD_LEFT;

#define ROW(y) ((pixel4*)(src+y*stride))[0] =\

               ((pixel4*)(src+y*stride))[1] = PIXEL_SPLAT_X4(l##y)

    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);

#undef ROW

}
 and probability:0.2
code:static int g726_init(AVCodecContext * avctx)

{

    AVG726Context* c = (AVG726Context*)avctx->priv_data;

    

    if (avctx->sample_rate != 8000 || avctx->channels != 1 ||

        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&

	 avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {

        av_log(avctx, AV_LOG_ERROR, "G726: unsupported audio format\n");

	return -1;

    }

    g726_reset(&c->c, avctx->bit_rate);

    c->code_size = c->c.tbls->bits;

    c->bit_buffer = 0;

    c->bits_left = 0;



    return 0;

}
 and probability:0.5333333333333333
code:static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)

{

    MpegEncContext *s = &ctx->m;

    char buf[256];

    int i;

    int e;

    int ver = 0, build = 0, ver2 = 0, ver3 = 0;

    char last;



    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {

        if (show_bits(gb, 23) == 0)

            break;

        buf[i] = get_bits(gb, 8);

    }

    buf[i] = 0;



    /* divx detection */

    e = sscanf(buf, "DivX%dBuild%d%c", &ver, &build, &last);

    if (e < 2)

        e = sscanf(buf, "DivX%db%d%c", &ver, &build, &last);

    if (e >= 2) {

        ctx->divx_version = ver;

        ctx->divx_build   = build;

        s->divx_packed  = e == 3 && last == 'p';

    }



    /* libavcodec detection */

    e = sscanf(buf, "FFmpe%*[^b]b%d", &build) + 3;

    if (e != 4)

        e = sscanf(buf, "FFmpeg v%d.%d.%d / libavcodec build: %d", &ver, &ver2, &ver3, &build);

    if (e != 4) {

        e = sscanf(buf, "Lavc%d.%d.%d", &ver, &ver2, &ver3) + 1;

        if (e > 1) {

            if (ver > 0xFF || ver2 > 0xFF || ver3 > 0xFF) {

                av_log(s->avctx, AV_LOG_WARNING,

                     "Unknown Lavc version string encountered, %d.%d.%d; "

                     "clamping sub-version values to 8-bits.\n",

                     ver, ver2, ver3);

            }

            build = ((ver & 0xFF) << 16) + ((ver2 & 0xFF) << 8) + (ver3 & 0xFF);

        }

    }

    if (e != 4) {

        if (strcmp(buf, "ffmpeg") == 0)

            ctx->lavc_build = 4600;

    }

    if (e == 4)

        ctx->lavc_build = build;



    /* Xvid detection */

    e = sscanf(buf, "XviD%d", &build);

    if (e == 1)

        ctx->xvid_build = build;



    return 0;

}
 and probability:0.27450980392156865
code:int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,

                      AVCodecContext *codec, int size)

{

    int id;



    if (size < 14)

        return AVERROR_INVALIDDATA;



    id                 = avio_rl16(pb);

    codec->codec_type  = AVMEDIA_TYPE_AUDIO;

    codec->channels    = avio_rl16(pb);

    codec->sample_rate = avio_rl32(pb);

    codec->bit_rate    = avio_rl32(pb) * 8;

    codec->block_align = avio_rl16(pb);

    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */

        codec->bits_per_coded_sample = 8;

    } else

        codec->bits_per_coded_sample = avio_rl16(pb);

    if (id == 0xFFFE) {

        codec->codec_tag = 0;

    } else {

        codec->codec_tag = id;

        codec->codec_id  = ff_wav_codec_get_id(id,

                                               codec->bits_per_coded_sample);

    }

    if (size >= 18) {  /* We're obviously dealing with WAVEFORMATEX */

        int cbSize = avio_rl16(pb); /* cbSize */

        size  -= 18;

        cbSize = FFMIN(size, cbSize);

        if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */

            parse_waveformatex(pb, codec);

            cbSize -= 22;

            size   -= 22;

        }

        codec->extradata_size = cbSize;

        if (cbSize > 0) {

            av_free(codec->extradata);

            codec->extradata = av_mallocz(codec->extradata_size +

                                          FF_INPUT_BUFFER_PADDING_SIZE);

            if (!codec->extradata)

                return AVERROR(ENOMEM);

            avio_read(pb, codec->extradata, codec->extradata_size);

            size -= cbSize;

        }



        /* It is possible for the chunk to contain garbage at the end */

        if (size > 0)

            avio_skip(pb, size);

    }

    if (codec->sample_rate <= 0) {

        av_log(s, AV_LOG_ERROR,

               "Invalid sample rate: %d\n", codec->sample_rate);

        return AVERROR_INVALIDDATA;

    }

    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {

        /* Channels and sample_rate values are those prior to applying SBR

         * and/or PS. */

        codec->channels    = 0;

        codec->sample_rate = 0;

    }

    /* override bits_per_coded_sample for G.726 */

    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726)

        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;



    return 0;

}
 and probability:0.43548387096774194
code:static int mkv_write_packet_internal(AVFormatContext *s, AVPacket *pkt, int add_cue)

{

    MatroskaMuxContext *mkv = s->priv_data;

    AVIOContext *pb         = s->pb;

    AVCodecParameters *par  = s->streams[pkt->stream_index]->codecpar;

    int keyframe            = !!(pkt->flags & AV_PKT_FLAG_KEY);

    int duration            = pkt->duration;

    int ret;

    int64_t ts = mkv->tracks[pkt->stream_index].write_dts ? pkt->dts : pkt->pts;

    int64_t relative_packet_pos;

    int dash_tracknum = mkv->is_dash ? mkv->dash_track_number : pkt->stream_index + 1;



    if (ts == AV_NOPTS_VALUE) {

        av_log(s, AV_LOG_ERROR, "Can't write packet with unknown timestamp\n");

        return AVERROR(EINVAL);

    }

    ts += mkv->tracks[pkt->stream_index].ts_offset;



    if (mkv->cluster_pos != -1) {

        int64_t cluster_time = ts - mkv->cluster_pts + mkv->tracks[pkt->stream_index].ts_offset;

        if ((int16_t)cluster_time != cluster_time) {

            av_log(s, AV_LOG_WARNING, "Starting new cluster due to timestamp\n");

            mkv_start_new_cluster(s, pkt);

        }

    }



    if (mkv->cluster_pos == -1) {

        mkv->cluster_pos = avio_tell(s->pb);

        ret = start_ebml_master_crc32(s->pb, &mkv->dyn_bc, &mkv->cluster, MATROSKA_ID_CLUSTER, 0);

        if (ret < 0)

            return ret;

        put_ebml_uint(mkv->dyn_bc, MATROSKA_ID_CLUSTERTIMECODE, FFMAX(0, ts));

        mkv->cluster_pts = FFMAX(0, ts);

    }

    pb = mkv->dyn_bc;



    relative_packet_pos = avio_tell(s->pb) - mkv->cluster.pos + avio_tell(pb);



    if (par->codec_type != AVMEDIA_TYPE_SUBTITLE) {

        mkv_write_block(s, pb, MATROSKA_ID_SIMPLEBLOCK, pkt, keyframe);

        if (s->pb->seekable && (par->codec_type == AVMEDIA_TYPE_VIDEO && keyframe || add_cue)) {

            ret = mkv_add_cuepoint(mkv->cues, pkt->stream_index, dash_tracknum, ts, mkv->cluster_pos, relative_packet_pos, -1);

            if (ret < 0) return ret;

        }

    } else {

        if (par->codec_id == AV_CODEC_ID_WEBVTT) {

            duration = mkv_write_vtt_blocks(s, pb, pkt);

        } else {

            ebml_master blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,

                                                       mkv_blockgroup_size(pkt->size));



#if FF_API_CONVERGENCE_DURATION

FF_DISABLE_DEPRECATION_WARNINGS

            /* For backward compatibility, prefer convergence_duration. */

            if (pkt->convergence_duration > 0) {

                duration = pkt->convergence_duration;

            }

FF_ENABLE_DEPRECATION_WARNINGS

#endif

            /* All subtitle blocks are considered to be keyframes. */

            mkv_write_block(s, pb, MATROSKA_ID_BLOCK, pkt, 1);

            put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);

            end_ebml_master(pb, blockgroup);

        }



        if (s->pb->seekable) {

            ret = mkv_add_cuepoint(mkv->cues, pkt->stream_index, dash_tracknum, ts,

                                   mkv->cluster_pos, relative_packet_pos, duration);

            if (ret < 0)

                return ret;

        }

    }



    mkv->duration = FFMAX(mkv->duration, ts + duration);



    if (mkv->stream_durations)

        mkv->stream_durations[pkt->stream_index] =

            FFMAX(mkv->stream_durations[pkt->stream_index], ts + duration);



    return 0;

}
 and probability:0.4225352112676056
code:static av_cold int XAVS_init(AVCodecContext *avctx)

{

    XavsContext *x4 = avctx->priv_data;



    x4->sei_size = 0;

    xavs_param_default(&x4->params);



    x4->params.pf_log               = XAVS_log;

    x4->params.p_log_private        = avctx;

    x4->params.i_keyint_max         = avctx->gop_size;

    if (avctx->bit_rate) {

        x4->params.rc.i_bitrate   = avctx->bit_rate / 1000;

        x4->params.rc.i_rc_method = XAVS_RC_ABR;

    }

    x4->params.rc.i_vbv_buffer_size = avctx->rc_buffer_size / 1000;

    x4->params.rc.i_vbv_max_bitrate = avctx->rc_max_rate    / 1000;

    x4->params.rc.b_stat_write      = avctx->flags & AV_CODEC_FLAG_PASS1;

    if (avctx->flags & AV_CODEC_FLAG_PASS2) {

        x4->params.rc.b_stat_read = 1;

    } else {

        if (x4->crf >= 0) {

            x4->params.rc.i_rc_method   = XAVS_RC_CRF;

            x4->params.rc.f_rf_constant = x4->crf;

        } else if (x4->cqp >= 0) {

            x4->params.rc.i_rc_method   = XAVS_RC_CQP;

            x4->params.rc.i_qp_constant = x4->cqp;

        }

    }



    if (x4->aud >= 0)

        x4->params.b_aud                      = x4->aud;

    if (x4->mbtree >= 0)

        x4->params.rc.b_mb_tree               = x4->mbtree;

    if (x4->direct_pred >= 0)

        x4->params.analyse.i_direct_mv_pred   = x4->direct_pred;

    if (x4->fast_pskip >= 0)

        x4->params.analyse.b_fast_pskip       = x4->fast_pskip;

    if (x4->motion_est >= 0)

        x4->params.analyse.i_me_method        = x4->motion_est;

    if (x4->mixed_refs >= 0)

        x4->params.analyse.b_mixed_references = x4->mixed_refs;

    if (x4->b_bias != INT_MIN)

        x4->params.i_bframe_bias              = x4->b_bias;

    if (x4->cplxblur >= 0)

        x4->params.rc.f_complexity_blur = x4->cplxblur;



#if FF_API_MOTION_EST

FF_DISABLE_DEPRECATION_WARNINGS

    if (x4->motion_est < 0) {

        switch (avctx->me_method) {

        case  ME_EPZS:

            x4->params.analyse.i_me_method = XAVS_ME_DIA;

            break;

        case  ME_HEX:

            x4->params.analyse.i_me_method = XAVS_ME_HEX;

            break;

        case  ME_UMH:

            x4->params.analyse.i_me_method = XAVS_ME_UMH;

            break;

        case  ME_FULL:

            x4->params.analyse.i_me_method = XAVS_ME_ESA;

            break;

        case  ME_TESA:

            x4->params.analyse.i_me_method = XAVS_ME_TESA;

            break;

        default:

            x4->params.analyse.i_me_method = XAVS_ME_HEX;

        }

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    x4->params.i_bframe          = avctx->max_b_frames;

    /* cabac is not included in AVS JiZhun Profile */

    x4->params.b_cabac           = 0;



    x4->params.i_bframe_adaptive = avctx->b_frame_strategy;



    avctx->has_b_frames          = !!avctx->max_b_frames;



    /* AVS doesn't allow B picture as reference */

    /* The max allowed reference frame number of B is 2 */

    x4->params.i_keyint_min      = avctx->keyint_min;

    if (x4->params.i_keyint_min > x4->params.i_keyint_max)

        x4->params.i_keyint_min = x4->params.i_keyint_max;



    x4->params.i_scenecut_threshold        = avctx->scenechange_threshold;



   // x4->params.b_deblocking_filter       = avctx->flags & AV_CODEC_FLAG_LOOP_FILTER;



    x4->params.rc.i_qp_min                 = avctx->qmin;

    x4->params.rc.i_qp_max                 = avctx->qmax;

    x4->params.rc.i_qp_step                = avctx->max_qdiff;



    x4->params.rc.f_qcompress       = avctx->qcompress; /* 0.0 => cbr, 1.0 => constant qp */

    x4->params.rc.f_qblur           = avctx->qblur;     /* temporally blur quants */



    x4->params.i_frame_reference    = avctx->refs;



    x4->params.i_width              = avctx->width;

    x4->params.i_height             = avctx->height;

    x4->params.vui.i_sar_width      = avctx->sample_aspect_ratio.num;

    x4->params.vui.i_sar_height     = avctx->sample_aspect_ratio.den;

    /* This is only used for counting the fps */

    x4->params.i_fps_num            = avctx->time_base.den;

    x4->params.i_fps_den            = avctx->time_base.num;

    x4->params.analyse.inter        = XAVS_ANALYSE_I8x8 |XAVS_ANALYSE_PSUB16x16| XAVS_ANALYSE_BSUB16x16;



    x4->params.analyse.i_me_range = avctx->me_range;

    x4->params.analyse.i_subpel_refine    = avctx->me_subpel_quality;



    x4->params.analyse.b_chroma_me        = avctx->me_cmp & FF_CMP_CHROMA;

    /* AVS P2 only enables 8x8 transform */

    x4->params.analyse.b_transform_8x8    = 1; //avctx->flags2 & AV_CODEC_FLAG2_8X8DCT;



    x4->params.analyse.i_trellis          = avctx->trellis;

    x4->params.analyse.i_noise_reduction  = avctx->noise_reduction;



    if (avctx->level > 0)

        x4->params.i_level_idc = avctx->level;



    if (avctx->bit_rate > 0)

        x4->params.rc.f_rate_tolerance =

            (float)avctx->bit_rate_tolerance / avctx->bit_rate;



    if ((avctx->rc_buffer_size) &&

        (avctx->rc_initial_buffer_occupancy <= avctx->rc_buffer_size)) {

        x4->params.rc.f_vbv_buffer_init =

            (float)avctx->rc_initial_buffer_occupancy / avctx->rc_buffer_size;

    } else

        x4->params.rc.f_vbv_buffer_init = 0.9;



    /* TAG:do we have MB tree RC method */

    /* what is the RC method we are now using? Default NO */

    x4->params.rc.f_ip_factor             = 1 / fabs(avctx->i_quant_factor);

    x4->params.rc.f_pb_factor             = avctx->b_quant_factor;

    x4->params.analyse.i_chroma_qp_offset = avctx->chromaoffset;



    x4->params.analyse.b_psnr = avctx->flags & AV_CODEC_FLAG_PSNR;

    x4->params.i_log_level    = XAVS_LOG_DEBUG;

    x4->params.i_threads      = avctx->thread_count;

    x4->params.b_interlaced   = avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT;



    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)

        x4->params.b_repeat_headers = 0;



    x4->enc = xavs_encoder_open(&x4->params);

    if (!x4->enc)

        return -1;



    if (!(x4->pts_buffer = av_mallocz((avctx->max_b_frames+1) * sizeof(*x4->pts_buffer))))

        return AVERROR(ENOMEM);



    /* TAG: Do we have GLOBAL HEADER in AVS */

    /* We Have PPS and SPS in AVS */

    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {

        xavs_nal_t *nal;

        int nnal, s, i, size;

        uint8_t *p;



        s = xavs_encoder_headers(x4->enc, &nal, &nnal);



        avctx->extradata = p = av_malloc(s);

        for (i = 0; i < nnal; i++) {

            /* Don't put the SEI in extradata. */

            if (nal[i].i_type == NAL_SEI) {

                x4->sei = av_malloc( 5 + nal[i].i_payload * 4 / 3 );

                if (xavs_nal_encode(x4->sei, &x4->sei_size, 1, nal + i) < 0)

                    return -1;



                continue;

            }

            size = xavs_nal_encode(p, &s, 1, nal + i);

            if (size < 0)

                return -1;

            p += size;

        }

        avctx->extradata_size = p - avctx->extradata;

    }

    return 0;

}
 and probability:0.6710526315789473
code:static int film_read_close(AVFormatContext *s)

{

    FilmDemuxContext *film = s->priv_data;



    av_freep(&film->sample_table);

    av_freep(&film->stereo_buffer);



    return 0;

}
 and probability:0.42857142857142855
code:static av_cold int png_enc_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
 and probability:0.2
code:int opt_opencl_bench(void *optctx, const char *opt, const char *arg)

{

    int i, j, nb_devices = 0, count = 0;

    int64_t score = 0;

    AVOpenCLDeviceList *device_list;

    AVOpenCLDeviceNode *device_node = NULL;

    OpenCLDeviceBenchmark *devices = NULL;

    cl_platform_id platform;



    av_opencl_get_device_list(&device_list);

    for (i = 0; i < device_list->platform_num; i++)

        nb_devices += device_list->platform_node[i]->device_num;

    if (!nb_devices) {

        av_log(NULL, AV_LOG_ERROR, "No OpenCL device detected!\n");

        return AVERROR(EINVAL);

    }

    if (!(devices = av_malloc_array(nb_devices, sizeof(OpenCLDeviceBenchmark)))) {

        av_log(NULL, AV_LOG_ERROR, "Could not allocate buffer\n");

        return AVERROR(ENOMEM);

    }



    for (i = 0; i < device_list->platform_num; i++) {

        for (j = 0; j < device_list->platform_node[i]->device_num; j++) {

            device_node = device_list->platform_node[i]->device_node[j];

            platform = device_list->platform_node[i]->platform_id;

            score = av_opencl_benchmark(device_node, platform, run_opencl_bench);

            if (score > 0) {

                devices[count].platform_idx = i;

                devices[count].device_idx = j;

                devices[count].runtime = score;

                av_strlcpy(devices[count].device_name, device_node->device_name,

                           sizeof(devices[count].device_name));

                count++;

            }

        }

    }

    qsort(devices, count, sizeof(OpenCLDeviceBenchmark), compare_ocl_device_desc);

    fprintf(stderr, "platform_idx\tdevice_idx\tdevice_name\truntime\n");

    for (i = 0; i < count; i++)

        fprintf(stdout, "%d\t%d\t%s\t%"PRId64"\n",

                devices[i].platform_idx, devices[i].device_idx,

                devices[i].device_name, devices[i].runtime);



    av_opencl_free_device_list(&device_list);

    av_free(devices);

    return 0;

}
 and probability:0.3409090909090909
code:void ppc_tlb_invalidate_one (CPUPPCState *env, target_ulong addr)

{

#if !defined(FLUSH_ALL_TLBS)

    addr &= TARGET_PAGE_MASK;

    switch (env->mmu_model) {

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

        ppc6xx_tlb_invalidate_virt(env, addr, 0);

        if (env->id_tlbs == 1)

            ppc6xx_tlb_invalidate_virt(env, addr, 1);

        break;

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_SOFT_4xx_Z:

        ppc4xx_tlb_invalidate_virt(env, addr, env->spr[SPR_40x_PID]);

        break;

    case POWERPC_MMU_REAL_4xx:

        cpu_abort(env, "No TLB for PowerPC 4xx in real mode\n");

        break;

    case POWERPC_MMU_BOOKE:

        /* XXX: TODO */

        cpu_abort(env, "MMU model not implemented\n");

        break;

    case POWERPC_MMU_BOOKE_FSL:

        /* XXX: TODO */

        cpu_abort(env, "MMU model not implemented\n");

        break;

    case POWERPC_MMU_32B:

    case POWERPC_MMU_601:

        /* tlbie invalidate TLBs for all segments */

        addr &= ~((target_ulong)-1 << 28);

        /* XXX: this case should be optimized,

         * giving a mask to tlb_flush_page

         */

        tlb_flush_page(env, addr | (0x0 << 28));

        tlb_flush_page(env, addr | (0x1 << 28));

        tlb_flush_page(env, addr | (0x2 << 28));

        tlb_flush_page(env, addr | (0x3 << 28));

        tlb_flush_page(env, addr | (0x4 << 28));

        tlb_flush_page(env, addr | (0x5 << 28));

        tlb_flush_page(env, addr | (0x6 << 28));

        tlb_flush_page(env, addr | (0x7 << 28));

        tlb_flush_page(env, addr | (0x8 << 28));

        tlb_flush_page(env, addr | (0x9 << 28));

        tlb_flush_page(env, addr | (0xA << 28));

        tlb_flush_page(env, addr | (0xB << 28));

        tlb_flush_page(env, addr | (0xC << 28));

        tlb_flush_page(env, addr | (0xD << 28));

        tlb_flush_page(env, addr | (0xE << 28));

        tlb_flush_page(env, addr | (0xF << 28));

        break;

#if defined(TARGET_PPC64)

    case POWERPC_MMU_64B:

        /* tlbie invalidate TLBs for all segments */

        /* XXX: given the fact that there are too many segments to invalidate,

         *      and we still don't have a tlb_flush_mask(env, n, mask) in Qemu,

         *      we just invalidate all TLBs

         */

        tlb_flush(env, 1);

        break;

#endif /* defined(TARGET_PPC64) */

    default:

        /* XXX: TODO */

        cpu_abort(env, "Unknown MMU model\n");

        break;

    }

#else

    ppc_tlb_invalidate_all(env);

#endif

}
 and probability:0.057971014492753624
code:static void test_visitor_in_fail_list(TestInputVisitorData *data,
                                      const void *unused)
{
    int64_t i64 = -1;
    Error *err = NULL;
    Visitor *v;
    /* Unvisited list tail */
    v = visitor_input_test_init(data, "[ 1, 2, 3 ]");
    visit_type_int(v, NULL, &i64, &error_abort);
    g_assert_cmpint(i64, ==, 1);
    visit_type_int(v, NULL, &i64, &error_abort);
    g_assert_cmpint(i64, ==, 2);
    visit_check_list(v, &err);
} and probability:0.0
code:int stpcifc_service_call(S390CPU *cpu, uint8_t r1, uint64_t fiba, uint8_t ar)

{

    CPUS390XState *env = &cpu->env;

    uint32_t fh;

    ZpciFib fib;

    S390PCIBusDevice *pbdev;

    uint32_t data;

    uint64_t cc = ZPCI_PCI_LS_OK;



    if (env->psw.mask & PSW_MASK_PSTATE) {

        program_interrupt(env, PGM_PRIVILEGED, 6);

        return 0;

    }



    fh = env->regs[r1] >> 32;



    if (fiba & 0x7) {

        program_interrupt(env, PGM_SPECIFICATION, 6);

        return 0;

    }



    pbdev = s390_pci_find_dev_by_fh(fh);

    if (!pbdev) {

        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);

        return 0;

    }



    memset(&fib, 0, sizeof(fib));



    switch (pbdev->state) {

    case ZPCI_FS_RESERVED:

    case ZPCI_FS_STANDBY:

        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);

        return 0;

    case ZPCI_FS_DISABLED:

        if (fh & FH_MASK_ENABLE) {

            setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);

            return 0;

        }

        goto out;

    /* BLOCKED bit is set to one coincident with the setting of ERROR bit.

     * FH Enabled bit is set to one in states of ENABLED, BLOCKED or ERROR. */

    case ZPCI_FS_ERROR:

        fib.fc |= 0x20;

    case ZPCI_FS_BLOCKED:

        fib.fc |= 0x40;

    case ZPCI_FS_ENABLED:

        fib.fc |= 0x80;

        if (pbdev->iommu_enabled) {

            fib.fc |= 0x10;

        }

        if (!(fh & FH_MASK_ENABLE)) {

            env->regs[r1] |= 1ULL << 63;

        }

        break;

    case ZPCI_FS_PERMANENT_ERROR:

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(env, r1, ZPCI_STPCIFC_ST_PERM_ERROR);

        return 0;

    }



    stq_p(&fib.pba, pbdev->pba);

    stq_p(&fib.pal, pbdev->pal);

    stq_p(&fib.iota, pbdev->g_iota);

    stq_p(&fib.aibv, pbdev->routes.adapter.ind_addr);

    stq_p(&fib.aisb, pbdev->routes.adapter.summary_addr);

    stq_p(&fib.fmb_addr, pbdev->fmb_addr);



    data = ((uint32_t)pbdev->isc << 28) | ((uint32_t)pbdev->noi << 16) |

           ((uint32_t)pbdev->routes.adapter.ind_offset << 8) |

           ((uint32_t)pbdev->sum << 7) | pbdev->routes.adapter.summary_offset;

    stl_p(&fib.data, data);



out:

    if (s390_cpu_virt_mem_write(cpu, fiba, ar, (uint8_t *)&fib, sizeof(fib))) {

        return 0;

    }



    setcc(cpu, cc);

    return 0;

}
 and probability:0.2112676056338028
code:static void mips_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    MIPSCPU *cpu = MIPS_CPU(obj);

    CPUMIPSState *env = &cpu->env;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    if (tcg_enabled()) {

        mips_tcg_init();

    }

}
 and probability:0.18181818181818182
code:static av_cold int omx_try_load(OMXContext *s, void *logctx,

                                const char *libname, const char *prefix)

{

    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);

    if (!s->lib) {

        av_log(logctx, AV_LOG_WARNING, "%s not found\n", libname);

        return AVERROR_ENCODER_NOT_FOUND;

    }

    s->ptr_Init                = dlsym_prefixed(s->lib, "OMX_Init", prefix);

    s->ptr_Deinit              = dlsym_prefixed(s->lib, "OMX_Deinit", prefix);

    s->ptr_ComponentNameEnum   = dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);

    s->ptr_GetHandle           = dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);

    s->ptr_FreeHandle          = dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);

    s->ptr_GetComponentsOfRole = dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);

    s->ptr_GetRolesOfComponent = dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);

    if (!s->ptr_Init || !s->ptr_Deinit || !s->ptr_ComponentNameEnum ||

        !s->ptr_GetHandle || !s->ptr_FreeHandle ||

        !s->ptr_GetComponentsOfRole || !s->ptr_GetRolesOfComponent) {

        av_log(logctx, AV_LOG_WARNING, "Not all functions found in %s\n", libname);

        dlclose(s->lib);

        s->lib = NULL;

        return AVERROR_ENCODER_NOT_FOUND;

    }

    return 0;

}
 and probability:0.56
code:static void encode_cblk(Jpeg2000EncoderContext *s, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, Jpeg2000Tile *tile,

                        int width, int height, int bandpos, int lev)

{

    int pass_t = 2, passno, x, y, max=0, nmsedec, bpno;

    int64_t wmsedec = 0;



    memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));



    for (y = 0; y < height; y++){

        for (x = 0; x < width; x++){

            if (t1->data[(y) * t1->stride + x] < 0){

                t1->flags[(y+1) * t1->stride + x+1] |= JPEG2000_T1_SGN;

                t1->data[(y) * t1->stride + x] = -t1->data[(y) * t1->stride + x];

            }

            max = FFMAX(max, t1->data[(y) * t1->stride + x]);

        }

    }



    if (max == 0){

        cblk->nonzerobits = 0;

        bpno = 0;

    } else{

        cblk->nonzerobits = av_log2(max) + 1 - NMSEDEC_FRACBITS;

        bpno = cblk->nonzerobits - 1;

    }



    ff_mqc_initenc(&t1->mqc, cblk->data);



    for (passno = 0; bpno >= 0; passno++){

        nmsedec=0;



        switch(pass_t){

            case 0: encode_sigpass(t1, width, height, bandpos, &nmsedec, bpno);

                    break;

            case 1: encode_refpass(t1, width, height, &nmsedec, bpno);

                    break;

            case 2: encode_clnpass(t1, width, height, bandpos, &nmsedec, bpno);

                    break;

        }



        cblk->passes[passno].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno].flushed, &cblk->passes[passno].flushed_len);

        wmsedec += (int64_t)nmsedec << (2*bpno);

        cblk->passes[passno].disto = wmsedec;



        if (++pass_t == 3){

            pass_t = 0;

            bpno--;

        }

    }

    cblk->npasses = passno;

    cblk->ninclpasses = passno;



    cblk->passes[passno-1].rate = ff_mqc_flush_to(&t1->mqc, cblk->passes[passno-1].flushed, &cblk->passes[passno-1].flushed_len);

}
 and probability:0.4444444444444444
code:static void gic_dist_writeb(void *opaque, hwaddr offset,

                            uint32_t value, MemTxAttrs attrs)

{

    GICState *s = (GICState *)opaque;

    int irq;

    int i;

    int cpu;



    cpu = gic_get_current_cpu(s);

    if (offset < 0x100) {

        if (offset == 0) {

            if (s->security_extn && !attrs.secure) {

                /* NS version is just an alias of the S version's bit 1 */

                s->ctlr = deposit32(s->ctlr, 1, 1, value);

            } else if (gic_has_groups(s)) {

                s->ctlr = value & (GICD_CTLR_EN_GRP0 | GICD_CTLR_EN_GRP1);

            } else {

                s->ctlr = value & GICD_CTLR_EN_GRP0;

            }

            DPRINTF("Distributor: Group0 %sabled; Group 1 %sabled\n",

                    s->ctlr & GICD_CTLR_EN_GRP0 ? "En" : "Dis",

                    s->ctlr & GICD_CTLR_EN_GRP1 ? "En" : "Dis");

        } else if (offset < 4) {

            /* ignored.  */

        } else if (offset >= 0x80) {

            /* Interrupt Group Registers: RAZ/WI for NS access to secure

             * GIC, or for GICs without groups.

             */

            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {

                /* Every byte offset holds 8 group status bits */

                irq = (offset - 0x80) * 8 + GIC_BASE_IRQ;

                if (irq >= s->num_irq) {

                    goto bad_reg;

                }

                for (i = 0; i < 8; i++) {

                    /* Group bits are banked for private interrupts */

                    int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;

                    if (value & (1 << i)) {

                        /* Group1 (Non-secure) */

                        GIC_SET_GROUP(irq + i, cm);

                    } else {

                        /* Group0 (Secure) */

                        GIC_CLEAR_GROUP(irq + i, cm);

                    }

                }

            }

        } else {

            goto bad_reg;

        }

    } else if (offset < 0x180) {

        /* Interrupt Set Enable.  */

        irq = (offset - 0x100) * 8 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        if (irq < GIC_NR_SGIS) {

            value = 0xff;

        }



        for (i = 0; i < 8; i++) {

            if (value & (1 << i)) {

                int mask =

                    (irq < GIC_INTERNAL) ? (1 << cpu) : GIC_TARGET(irq + i);

                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;



                if (!GIC_TEST_ENABLED(irq + i, cm)) {

                    DPRINTF("Enabled IRQ %d\n", irq + i);


                }

                GIC_SET_ENABLED(irq + i, cm);

                /* If a raised level triggered IRQ enabled then mark

                   is as pending.  */

                if (GIC_TEST_LEVEL(irq + i, mask)

                        && !GIC_TEST_EDGE_TRIGGER(irq + i)) {

                    DPRINTF("Set %d pending mask %x\n", irq + i, mask);

                    GIC_SET_PENDING(irq + i, mask);

                }

            }

        }

    } else if (offset < 0x200) {

        /* Interrupt Clear Enable.  */

        irq = (offset - 0x180) * 8 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        if (irq < GIC_NR_SGIS) {

            value = 0;

        }



        for (i = 0; i < 8; i++) {

            if (value & (1 << i)) {

                int cm = (irq < GIC_INTERNAL) ? (1 << cpu) : ALL_CPU_MASK;



                if (GIC_TEST_ENABLED(irq + i, cm)) {

                    DPRINTF("Disabled IRQ %d\n", irq + i);

                    trace_gic_disable_irq(irq + i);

                }

                GIC_CLEAR_ENABLED(irq + i, cm);

            }

        }

    } else if (offset < 0x280) {

        /* Interrupt Set Pending.  */

        irq = (offset - 0x200) * 8 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        if (irq < GIC_NR_SGIS) {

            value = 0;

        }



        for (i = 0; i < 8; i++) {

            if (value & (1 << i)) {

                GIC_SET_PENDING(irq + i, GIC_TARGET(irq + i));

            }

        }

    } else if (offset < 0x300) {

        /* Interrupt Clear Pending.  */

        irq = (offset - 0x280) * 8 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        if (irq < GIC_NR_SGIS) {

            value = 0;

        }



        for (i = 0; i < 8; i++) {

            /* ??? This currently clears the pending bit for all CPUs, even

               for per-CPU interrupts.  It's unclear whether this is the

               corect behavior.  */

            if (value & (1 << i)) {

                GIC_CLEAR_PENDING(irq + i, ALL_CPU_MASK);

            }

        }

    } else if (offset < 0x400) {

        /* Interrupt Active.  */

        goto bad_reg;

    } else if (offset < 0x800) {

        /* Interrupt Priority.  */

        irq = (offset - 0x400) + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        gic_set_priority(s, cpu, irq, value, attrs);

    } else if (offset < 0xc00) {

        /* Interrupt CPU Target. RAZ/WI on uniprocessor GICs, with the

         * annoying exception of the 11MPCore's GIC.

         */

        if (s->num_cpu != 1 || s->revision == REV_11MPCORE) {

            irq = (offset - 0x800) + GIC_BASE_IRQ;

            if (irq >= s->num_irq) {

                goto bad_reg;

            }

            if (irq < 29) {

                value = 0;

            } else if (irq < GIC_INTERNAL) {

                value = ALL_CPU_MASK;

            }

            s->irq_target[irq] = value & ALL_CPU_MASK;

        }

    } else if (offset < 0xf00) {

        /* Interrupt Configuration.  */

        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;

        if (irq >= s->num_irq)

            goto bad_reg;

        if (irq < GIC_NR_SGIS)

            value |= 0xaa;

        for (i = 0; i < 4; i++) {

            if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

                if (value & (1 << (i * 2))) {

                    GIC_SET_MODEL(irq + i);

                } else {

                    GIC_CLEAR_MODEL(irq + i);

                }

            }

            if (value & (2 << (i * 2))) {

                GIC_SET_EDGE_TRIGGER(irq + i);

            } else {

                GIC_CLEAR_EDGE_TRIGGER(irq + i);

            }

        }

    } else if (offset < 0xf10) {

        /* 0xf00 is only handled for 32-bit writes.  */

        goto bad_reg;

    } else if (offset < 0xf20) {

        /* GICD_CPENDSGIRn */

        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

            goto bad_reg;

        }

        irq = (offset - 0xf10);



        s->sgi_pending[irq][cpu] &= ~value;

        if (s->sgi_pending[irq][cpu] == 0) {

            GIC_CLEAR_PENDING(irq, 1 << cpu);

        }

    } else if (offset < 0xf30) {

        /* GICD_SPENDSGIRn */

        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

            goto bad_reg;

        }

        irq = (offset - 0xf20);



        GIC_SET_PENDING(irq, 1 << cpu);

        s->sgi_pending[irq][cpu] |= value;

    } else {

        goto bad_reg;

    }

    gic_update(s);

    return;

bad_reg:

    qemu_log_mask(LOG_GUEST_ERROR,

                  "gic_dist_writeb: Bad offset %x\n", (int)offset);

} and probability:0.3096446700507614
code:static int gif_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)
{
    GifState *s = avctx->priv_data;
    AVFrame *picture = data;
    int ret;
    bytestream2_init(&s->gb, avpkt->data, avpkt->size);
    s->picture.pts          = avpkt->pts;
    s->picture.pkt_pts      = avpkt->pts;
    s->picture.pkt_dts      = avpkt->dts;
    s->picture.pkt_duration = avpkt->duration;
    if (avpkt->size >= 6) {
        s->keyframe = memcmp(avpkt->data, gif87a_sig, 6) == 0 ||
                      memcmp(avpkt->data, gif89a_sig, 6) == 0;
    } else {
        s->keyframe = 0;
    if (s->keyframe) {
        s->keyframe_ok = 0;
        if ((ret = gif_read_header1(s)) < 0)
            return ret;
        if ((ret = av_image_check_size(s->screen_width, s->screen_height, 0, avctx)) < 0)
            return ret;
        avcodec_set_dimensions(avctx, s->screen_width, s->screen_height);
        if (s->picture.data[0])
            avctx->release_buffer(avctx, &s->picture);
        if ((ret = ff_get_buffer(avctx, &s->picture)) < 0) {
            av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");
            return ret;
        s->picture.pict_type = AV_PICTURE_TYPE_I;
        s->picture.key_frame = 1;
    } else {
        if ((ret = avctx->reget_buffer(avctx, &s->picture)) < 0) {
            av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n");
            return ret;
        s->picture.pict_type = AV_PICTURE_TYPE_P;
        s->picture.key_frame = 0;
    ret = gif_parse_next_image(s, got_frame);
    if (ret < 0)
        return ret;
    else if (*got_frame)
        *picture = s->picture;
    return avpkt->size; and probability:0.6097560975609756
code:static GSList *gd_vc_init(GtkDisplayState *s, VirtualConsole *vc, int index, GSList *group,

                          GtkWidget *view_menu)

{

#if defined(CONFIG_VTE)

    const char *label;

    char buffer[32];

    char path[32];

#if VTE_CHECK_VERSION(0, 26, 0)

    VtePty *pty;

#endif

    GIOChannel *chan;

    GtkWidget *scrolled_window;

    GtkAdjustment *vadjustment;

    int master_fd, slave_fd;



    snprintf(buffer, sizeof(buffer), "vc%d", index);

    snprintf(path, sizeof(path), "<QEMU>/View/VC%d", index);



    vc->chr = vcs[index];



    if (vc->chr->label) {

        label = vc->chr->label;

    } else {

        label = buffer;

    }



    vc->menu_item = gtk_radio_menu_item_new_with_mnemonic(group, label);

    group = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(vc->menu_item));

    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(vc->menu_item), path);

    gtk_accel_map_add_entry(path, GDK_KEY_2 + index, HOTKEY_MODIFIERS);



    vc->terminal = vte_terminal_new();



    master_fd = qemu_openpty_raw(&slave_fd, NULL);

    g_assert(master_fd != -1);



#if VTE_CHECK_VERSION(0, 26, 0)

    pty = vte_pty_new_foreign(master_fd, NULL);

    vte_terminal_set_pty_object(VTE_TERMINAL(vc->terminal), pty);

#else

    vte_terminal_set_pty(VTE_TERMINAL(vc->terminal), master_fd);

#endif



    vte_terminal_set_scrollback_lines(VTE_TERMINAL(vc->terminal), -1);



#if VTE_CHECK_VERSION(0, 28, 0) && GTK_CHECK_VERSION(3, 0, 0)

    vadjustment = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(vc->terminal));

#else

    vadjustment = vte_terminal_get_adjustment(VTE_TERMINAL(vc->terminal));

#endif



    scrolled_window = gtk_scrolled_window_new(NULL, vadjustment);

    gtk_container_add(GTK_CONTAINER(scrolled_window), vc->terminal);



    vte_terminal_set_size(VTE_TERMINAL(vc->terminal), 80, 25);



    vc->fd = slave_fd;

    vc->chr->opaque = vc;

    vc->scrolled_window = scrolled_window;



    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(vc->scrolled_window),

                                   GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);



    gtk_notebook_append_page(GTK_NOTEBOOK(s->notebook), scrolled_window, gtk_label_new(label));

    g_signal_connect(vc->menu_item, "activate",

                     G_CALLBACK(gd_menu_switch_vc), s);



    gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), vc->menu_item);



    qemu_chr_be_generic_open(vc->chr);

    if (vc->chr->init) {

        vc->chr->init(vc->chr);

    }



    chan = g_io_channel_unix_new(vc->fd);

    g_io_add_watch(chan, G_IO_IN, gd_vc_in, vc);



#endif /* CONFIG_VTE */

    return group;

}
 and probability:0.41935483870967744
code:static int parse_packet(AVFormatContext *s, AVPacket *pkt, int stream_index)

{

    AVPacket out_pkt = { 0 }, flush_pkt = { 0 };

    AVStream *st = s->streams[stream_index];

    uint8_t *data = pkt ? pkt->data : NULL;

    int size      = pkt ? pkt->size : 0;

    int ret = 0, got_output = 0;



    if (!pkt) {

        av_init_packet(&flush_pkt);

        pkt        = &flush_pkt;

        got_output = 1;

    } else if (!size && st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) {

        // preserve 0-size sync packets

        compute_pkt_fields(s, st, st->parser, pkt, AV_NOPTS_VALUE, AV_NOPTS_VALUE);

    }



    while (size > 0 || (pkt == &flush_pkt && got_output)) {

        int len;

        int64_t next_pts = pkt->pts;

        int64_t next_dts = pkt->dts;



        av_init_packet(&out_pkt);

        len = av_parser_parse2(st->parser, st->codec,

                               &out_pkt.data, &out_pkt.size, data, size,

                               pkt->pts, pkt->dts, pkt->pos);



        pkt->pts = pkt->dts = AV_NOPTS_VALUE;

        pkt->pos = -1;

        /* increment read pointer */

        data += len;

        size -= len;



        got_output = !!out_pkt.size;



        if (!out_pkt.size)

            continue;



        if (pkt->side_data) {

            out_pkt.side_data       = pkt->side_data;

            out_pkt.side_data_elems = pkt->side_data_elems;

            pkt->side_data          = NULL;

            pkt->side_data_elems    = 0;

        }



        /* set the duration */

        out_pkt.duration = (st->parser->flags & PARSER_FLAG_COMPLETE_FRAMES) ? pkt->duration : 0;

        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (st->codec->sample_rate > 0) {

                out_pkt.duration =

                    av_rescale_q_rnd(st->parser->duration,

                                     (AVRational) { 1, st->codec->sample_rate },

                                     st->time_base,

                                     AV_ROUND_DOWN);

            }

        }



        out_pkt.stream_index = st->index;

        out_pkt.pts          = st->parser->pts;

        out_pkt.dts          = st->parser->dts;

        out_pkt.pos          = st->parser->pos;



        if (st->need_parsing == AVSTREAM_PARSE_FULL_RAW)

            out_pkt.pos = st->parser->frame_offset;



        if (st->parser->key_frame == 1 ||

            (st->parser->key_frame == -1 &&

             st->parser->pict_type == AV_PICTURE_TYPE_I))

            out_pkt.flags |= AV_PKT_FLAG_KEY;



        if (st->parser->key_frame == -1 && st->parser->pict_type ==AV_PICTURE_TYPE_NONE && (pkt->flags&AV_PKT_FLAG_KEY))

            out_pkt.flags |= AV_PKT_FLAG_KEY;



        compute_pkt_fields(s, st, st->parser, &out_pkt, next_dts, next_pts);



        if ((ret = add_to_pktbuf(&s->internal->parse_queue, &out_pkt,

                                 &s->internal->parse_queue_end,

                                 1))) {

            av_packet_unref(&out_pkt);

            goto fail;

        }

    }



    /* end of the stream => close and free the parser */

    if (pkt == &flush_pkt) {

        av_parser_close(st->parser);

        st->parser = NULL;

    }



fail:

    av_packet_unref(pkt);

    return ret;

}
 and probability:0.5064935064935064
code:int ff_frame_thread_init(AVCodecContext *avctx)

{

    int thread_count = avctx->thread_count;

    const AVCodec *codec = avctx->codec;

    AVCodecContext *src = avctx;

    FrameThreadContext *fctx;

    int i, err = 0;



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (!thread_count) {

        int nb_cpus = av_cpu_count();

        av_log(avctx, AV_LOG_DEBUG, "detected %d logical cores\n", nb_cpus);

        // use number of cores + 1 as thread count if there is more than one

        if (nb_cpus > 1)

            thread_count = avctx->thread_count = FFMIN(nb_cpus + 1, MAX_AUTO_THREADS);

        else

            thread_count = avctx->thread_count = 1;

    }



    if (thread_count <= 1) {

        avctx->active_thread_type = 0;

        return 0;

    }



    avctx->internal->thread_ctx = fctx = av_mallocz(sizeof(FrameThreadContext));



    fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count);

    pthread_mutex_init(&fctx->buffer_mutex, NULL);

    fctx->delaying = 1;



    for (i = 0; i < thread_count; i++) {

        AVCodecContext *copy = av_malloc(sizeof(AVCodecContext));

        PerThreadContext *p  = &fctx->threads[i];



        pthread_mutex_init(&p->mutex, NULL);

        pthread_mutex_init(&p->progress_mutex, NULL);

        pthread_cond_init(&p->input_cond, NULL);

        pthread_cond_init(&p->progress_cond, NULL);

        pthread_cond_init(&p->output_cond, NULL);



        p->frame = av_frame_alloc();

        if (!p->frame) {


            err = AVERROR(ENOMEM);

            goto error;

        }



        p->parent = fctx;

        p->avctx  = copy;



        if (!copy) {

            err = AVERROR(ENOMEM);

            goto error;

        }



        *copy = *src;



        copy->internal = av_malloc(sizeof(AVCodecInternal));

        if (!copy->internal) {

            err = AVERROR(ENOMEM);

            goto error;

        }

        *copy->internal = *src->internal;

        copy->internal->thread_ctx = p;

        copy->internal->pkt = &p->avpkt;



        if (!i) {

            src = copy;



            if (codec->init)

                err = codec->init(copy);



            update_context_from_thread(avctx, copy, 1);

        } else {

            copy->priv_data = av_malloc(codec->priv_data_size);

            if (!copy->priv_data) {

                err = AVERROR(ENOMEM);

                goto error;

            }

            memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);

            copy->internal->is_copy = 1;



            if (codec->init_thread_copy)

                err = codec->init_thread_copy(copy);

        }



        if (err) goto error;



        if (!pthread_create(&p->thread, NULL, frame_worker_thread, p))

            p->thread_init = 1;

    }



    return 0;



error:

    ff_frame_thread_free(avctx, i+1);



    return err;

} and probability:0.4625
code:CPUState *cpu_generic_init(const char *typename, const char *cpu_model)

{

    /* TODO: all callers of cpu_generic_init() need to be converted to

     * call cpu_parse_features() only once, before calling cpu_generic_init().

     */

    const char *cpu_type = cpu_parse_cpu_model(typename, cpu_model);



    if (cpu_type) {

        return cpu_create(cpu_type);

    }

    return NULL;

}
 and probability:0.0
code:static int handle_metadata(RTMPContext *rt, RTMPPacket *pkt)

{

    int ret, old_flv_size, type;

    const uint8_t *next;

    uint8_t *p;

    uint32_t size;

    uint32_t ts, cts, pts = 0;



    old_flv_size = update_offset(rt, pkt->size);



    if ((ret = av_reallocp(&rt->flv_data, rt->flv_size)) < 0) {

        rt->flv_size = rt->flv_off = 0;

        return ret;

    }



    next = pkt->data;

    p    = rt->flv_data + old_flv_size;



    /* copy data while rewriting timestamps */

    ts = pkt->timestamp;



    while (next - pkt->data < pkt->size - RTMP_HEADER) {

        type = bytestream_get_byte(&next);

        size = bytestream_get_be24(&next);

        cts  = bytestream_get_be24(&next);

        cts |= bytestream_get_byte(&next) << 24;

        if (!pts)

            pts = cts;

        ts += cts - pts;

        pts = cts;

        bytestream_put_byte(&p, type);

        bytestream_put_be24(&p, size);

        bytestream_put_be24(&p, ts);

        bytestream_put_byte(&p, ts >> 24);

        memcpy(p, next, size + 3 + 4);

        next += size + 3 + 4;

        p    += size + 3 + 4;

    }

    memcpy(p, next, RTMP_HEADER);



    return 0;

}
 and probability:0.3055555555555556
code:static void gen_sub_carry(TCGv dest, TCGv t0, TCGv t1)

{

    TCGv tmp;

    tcg_gen_sub_i32(dest, t0, t1);

    tmp = load_cpu_field(CF);

    tcg_gen_add_i32(dest, dest, tmp);

    tcg_gen_subi_i32(dest, dest, 1);

    dead_tmp(tmp);

}
 and probability:0.0
code:static void gen_dstst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }



}
 and probability:0.125
code:static MMSSCPacketType get_tcp_server_response(MMSTContext *mmst)

{

    int read_result;

    MMSSCPacketType packet_type= -1;

    MMSContext *mms = &mmst->mms;

    for(;;) {

        read_result = url_read_complete(mms->mms_hd, mms->in_buffer, 8);

        if (read_result != 8) {

            if(read_result < 0) {

                av_log(NULL, AV_LOG_ERROR,

                       "Error reading packet header: %d (%s)\n",

                       read_result, strerror(read_result));

                packet_type = SC_PKT_CANCEL;

            } else {

                av_log(NULL, AV_LOG_ERROR,

                       "The server closed the connection\n");

                packet_type = SC_PKT_NO_DATA;

            }

            return packet_type;

        }



        // handle command packet.

        if(AV_RL32(mms->in_buffer + 4)==0xb00bface) {

            int length_remaining, hr;



            mmst->incoming_flags= mms->in_buffer[3];

            read_result= url_read_complete(mms->mms_hd, mms->in_buffer+8, 4);

            if(read_result != 4) {

                av_log(NULL, AV_LOG_ERROR,

                       "Reading command packet length failed: %d (%s)\n",

                       read_result,

                       read_result < 0 ? strerror(read_result) :

                           "The server closed the connection");

                return read_result < 0 ? read_result : AVERROR_IO;

            }



            length_remaining= AV_RL32(mms->in_buffer+8) + 4;

            av_dlog(NULL, "Length remaining is %d\n", length_remaining);

            // read the rest of the packet.

            if (length_remaining < 0

                || length_remaining > sizeof(mms->in_buffer) - 12) {

                av_log(NULL, AV_LOG_ERROR,

                       "Incoming packet length %d exceeds bufsize %zu\n",

                       length_remaining, sizeof(mms->in_buffer) - 12);

                return AVERROR_INVALIDDATA;

            }

            read_result = url_read_complete(mms->mms_hd, mms->in_buffer + 12,

                                            length_remaining) ;

            if (read_result != length_remaining) {

                av_log(NULL, AV_LOG_ERROR,

                       "Reading pkt data (length=%d) failed: %d (%s)\n",

                       length_remaining, read_result,

                       read_result < 0 ? strerror(read_result) :

                           "The server closed the connection");

                return read_result < 0 ? read_result : AVERROR_IO;

            }

            packet_type= AV_RL16(mms->in_buffer+36);

            hr = AV_RL32(mms->in_buffer + 40);

            if (hr) {

                av_log(NULL, AV_LOG_ERROR,

                       "Server sent a message with packet type 0x%x and error status code 0x%08x\n", packet_type, hr);

                return AVERROR_UNKNOWN;

            }

        } else {

            int length_remaining;

            int packet_id_type;

            int tmp;



            // note we cache the first 8 bytes,

            // then fill up the buffer with the others

            tmp                       = AV_RL16(mms->in_buffer + 6);

            length_remaining          = (tmp - 8) & 0xffff;

            mmst->incoming_packet_seq = AV_RL32(mms->in_buffer);

            packet_id_type            = mms->in_buffer[4];

            mmst->incoming_flags      = mms->in_buffer[5];



            if (length_remaining < 0

                || length_remaining > sizeof(mms->in_buffer) - 8) {

                av_log(NULL, AV_LOG_ERROR,

                       "Data length %d is invalid or too large (max=%zu)\n",

                       length_remaining, sizeof(mms->in_buffer));

                return AVERROR_INVALIDDATA;

            }

            mms->remaining_in_len    = length_remaining;

            mms->read_in_ptr         = mms->in_buffer;

            read_result= url_read_complete(mms->mms_hd, mms->in_buffer, length_remaining);

            if(read_result != length_remaining) {

                av_log(NULL, AV_LOG_ERROR,

                       "Failed to read packet data of size %d: %d (%s)\n",

                       length_remaining, read_result,

                       read_result < 0 ? strerror(read_result) :

                           "The server closed the connection");

                return read_result < 0 ? read_result : AVERROR_IO;

            }



            // if we successfully read everything.

            if(packet_id_type == mmst->header_packet_id) {

                packet_type = SC_PKT_ASF_HEADER;

                // Store the asf header

                if(!mms->header_parsed) {

                    void *p = av_realloc(mms->asf_header,

                                  mms->asf_header_size + mms->remaining_in_len);

                    if (!p) {

                        av_freep(&mms->asf_header);

                        return AVERROR(ENOMEM);

                    }

                    mms->asf_header = p;

                    memcpy(mms->asf_header + mms->asf_header_size,

                           mms->read_in_ptr, mms->remaining_in_len);

                    mms->asf_header_size += mms->remaining_in_len;

                }

                // 0x04 means asf header is sent in multiple packets.

                if (mmst->incoming_flags == 0x04)

                    continue;

            } else if(packet_id_type == mmst->packet_id) {

                packet_type = SC_PKT_ASF_MEDIA;

            } else {

                av_dlog(NULL, "packet id type %d is old.", packet_id_type);

                continue;

            }

        }



        // preprocess some packet type

        if(packet_type == SC_PKT_KEEPALIVE) {

            send_keepalive_packet(mmst);

            continue;

        } else if(packet_type == SC_PKT_STREAM_CHANGING) {

            handle_packet_stream_changing_type(mmst);

        } else if(packet_type == SC_PKT_ASF_MEDIA) {

            pad_media_packet(mms);

        }

        return packet_type;

    }

}
 and probability:0.25196850393700787
code:static void invalid_dict_comma(void)

{

    QObject *obj = qobject_from_json("{'abc':32,}", NULL);

    g_assert(obj == NULL);

}
 and probability:0.0
code:static void type_initialize(TypeImpl *ti)

{

    TypeImpl *parent;



    if (ti->class) {

        return;

    }



    ti->class_size = type_class_get_size(ti);

    ti->instance_size = type_object_get_size(ti);



    ti->class = g_malloc0(ti->class_size);



    parent = type_get_parent(ti);

    if (parent) {

        type_initialize(parent);

        GSList *e;

        int i;



        g_assert(parent->class_size <= ti->class_size);

        memcpy(ti->class, parent->class, parent->class_size);

        ti->class->interfaces = NULL;



        for (e = parent->class->interfaces; e; e = e->next) {

            ObjectClass *iface = e->data;

            type_initialize_interface(ti, object_class_get_name(iface));

        }



        for (i = 0; i < ti->num_interfaces; i++) {

            TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);

            for (e = ti->class->interfaces; e; e = e->next) {

                TypeImpl *target_type = OBJECT_CLASS(e->data)->type;



                if (type_is_ancestor(target_type, t)) {

                    break;

                }

            }



            if (e) {

                continue;

            }



            type_initialize_interface(ti, ti->interfaces[i].typename);

        }

    }



    ti->class->type = ti;



    while (parent) {

        if (parent->class_base_init) {

            parent->class_base_init(ti->class, ti->class_data);

        }

        parent = type_get_parent(parent);

    }



    if (ti->class_init) {

        ti->class_init(ti->class, ti->class_data);

    }





}
 and probability:0.41304347826086957
code:static av_cold int decode_close_mp3on4(AVCodecContext * avctx)
{
    MP3On4DecodeContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->frames; i++)
        av_freep(&s->mp3decctx[i]);
    return 0;
} and probability:0.375
code:static inline void encode_vlc_codeword(PutBitContext *pb, unsigned codebook, int val)

{

    unsigned int rice_order, exp_order, switch_bits, switch_val;

    int exponent;



    /* number of prefix bits to switch between Rice and expGolomb */

    switch_bits = (codebook & 3) + 1;

    rice_order  =  codebook >> 5;       /* rice code order */

    exp_order   = (codebook >> 2) & 7;  /* exp golomb code order */



    switch_val  = switch_bits << rice_order;



    if (val >= switch_val) {

        val -= switch_val - (1 << exp_order);

        exponent = av_log2(val);



        put_bits(pb, exponent - exp_order + switch_bits, 0);

        put_bits(pb, 1, 1);

        put_bits(pb, exponent, val);

    } else {

        exponent = val >> rice_order;



        if (exponent)

            put_bits(pb, exponent, 0);

        put_bits(pb, 1, 1);

        if (rice_order)

            put_sbits(pb, rice_order, val);

    }

}
 and probability:0.125
code:static int decoder_decode_frame(Decoder *d, void *fframe) {

    int got_frame = 0;

    AVFrame *frame = fframe;



    d->flushed = 0;



    do {

        int ret = -1;



        if (d->queue->abort_request)

            return -1;



        if (!d->packet_pending || d->queue->serial != d->pkt_serial) {

            AVPacket pkt;

            do {

                if (d->queue->nb_packets == 0)

                    SDL_CondSignal(d->empty_queue_cond);

                if (packet_queue_get(d->queue, &pkt, 1, &d->pkt_serial) < 0)

                    return -1;

                if (pkt.data == flush_pkt.data) {

                    avcodec_flush_buffers(d->avctx);

                    d->finished = 0;

                    d->flushed = 1;

                    d->next_pts = d->start_pts;

                    d->next_pts_tb = d->start_pts_tb;

                }

            } while (pkt.data == flush_pkt.data || d->queue->serial != d->pkt_serial);

            av_free_packet(&d->pkt);

            d->pkt_temp = d->pkt = pkt;

            d->packet_pending = 1;

        }



        switch (d->avctx->codec_type) {

            case AVMEDIA_TYPE_VIDEO:

                ret = avcodec_decode_video2(d->avctx, frame, &got_frame, &d->pkt_temp);

                if (got_frame) {

                    if (decoder_reorder_pts == -1) {

                        frame->pts = av_frame_get_best_effort_timestamp(frame);

                    } else if (decoder_reorder_pts) {

                        frame->pts = frame->pkt_pts;

                    } else {

                        frame->pts = frame->pkt_dts;

                    }

                }

                break;

            case AVMEDIA_TYPE_AUDIO:

                ret = avcodec_decode_audio4(d->avctx, frame, &got_frame, &d->pkt_temp);

                if (got_frame) {

                    AVRational tb = (AVRational){1, frame->sample_rate};

                    if (frame->pts != AV_NOPTS_VALUE)

                        frame->pts = av_rescale_q(frame->pts, d->avctx->time_base, tb);

                    else if (frame->pkt_pts != AV_NOPTS_VALUE)

                        frame->pts = av_rescale_q(frame->pkt_pts, av_codec_get_pkt_timebase(d->avctx), tb);

                    else if (d->next_pts != AV_NOPTS_VALUE)

                        frame->pts = av_rescale_q(d->next_pts, d->next_pts_tb, tb);

                    if (frame->pts != AV_NOPTS_VALUE) {

                        d->next_pts = frame->pts + frame->nb_samples;

                        d->next_pts_tb = tb;

                    }

                }

                break;

            case AVMEDIA_TYPE_SUBTITLE:

                ret = avcodec_decode_subtitle2(d->avctx, fframe, &got_frame, &d->pkt_temp);

                break;

        }



        if (ret < 0) {

            d->packet_pending = 0;

        } else {

            d->pkt_temp.dts =

            d->pkt_temp.pts = AV_NOPTS_VALUE;

            if (d->pkt_temp.data) {

                if (d->avctx->codec_type != AVMEDIA_TYPE_AUDIO)

                    ret = d->pkt_temp.size;

                d->pkt_temp.data += ret;

                d->pkt_temp.size -= ret;

                if (d->pkt_temp.size <= 0)

                    d->packet_pending = 0;

            } else {

                if (!got_frame) {

                    d->packet_pending = 0;

                    d->finished = d->pkt_serial;

                }

            }

        }

    } while (!got_frame && !d->finished);



    return got_frame;

}
 and probability:0.5487804878048781
code:static void boston_mach_init(MachineState *machine)

{

    DeviceState *dev;

    BostonState *s;

    Error *err = NULL;

    const char *cpu_model;

    MemoryRegion *flash, *ddr, *ddr_low_alias, *lcd, *platreg;

    MemoryRegion *sys_mem = get_system_memory();

    XilinxPCIEHost *pcie2;

    PCIDevice *ahci;

    DriveInfo *hd[6];

    Chardev *chr;

    int fw_size, fit_err;

    bool is_64b;



    if ((machine->ram_size % G_BYTE) ||

        (machine->ram_size > (2 * G_BYTE))) {

        error_report("Memory size must be 1GB or 2GB");

        exit(1);

    }



    cpu_model = machine->cpu_model ?: "I6400";



    dev = qdev_create(NULL, TYPE_MIPS_BOSTON);

    qdev_init_nofail(dev);



    s = BOSTON(dev);

    s->mach = machine;

    s->cps = g_new0(MIPSCPSState, 1);



    if (!cpu_supports_cps_smp(cpu_model)) {

        error_report("Boston requires CPUs which support CPS");

        exit(1);

    }



    is_64b = cpu_supports_isa(cpu_model, ISA_MIPS64);



    object_initialize(s->cps, sizeof(MIPSCPSState), TYPE_MIPS_CPS);

    qdev_set_parent_bus(DEVICE(s->cps), sysbus_get_default());



    object_property_set_str(OBJECT(s->cps), cpu_model, "cpu-model", &err);

    object_property_set_int(OBJECT(s->cps), smp_cpus, "num-vp", &err);

    object_property_set_bool(OBJECT(s->cps), true, "realized", &err);



    if (err != NULL) {

        error_report("%s", error_get_pretty(err));

        exit(1);

    }



    sysbus_mmio_map_overlap(SYS_BUS_DEVICE(s->cps), 0, 0, 1);



    flash =  g_new(MemoryRegion, 1);

    memory_region_init_rom_device(flash, NULL, &boston_flash_ops, s,

                                  "boston.flash", 128 * M_BYTE, &err);

    memory_region_add_subregion_overlap(sys_mem, 0x18000000, flash, 0);



    ddr = g_new(MemoryRegion, 1);

    memory_region_allocate_system_memory(ddr, NULL, "boston.ddr",

                                         machine->ram_size);

    memory_region_add_subregion_overlap(sys_mem, 0x80000000, ddr, 0);



    ddr_low_alias = g_new(MemoryRegion, 1);

    memory_region_init_alias(ddr_low_alias, NULL, "boston_low.ddr",

                             ddr, 0, MIN(machine->ram_size, (256 * M_BYTE)));

    memory_region_add_subregion_overlap(sys_mem, 0, ddr_low_alias, 0);



    xilinx_pcie_init(sys_mem, 0,

                     0x10000000, 32 * M_BYTE,

                     0x40000000, 1 * G_BYTE,

                     get_cps_irq(s->cps, 2), false);



    xilinx_pcie_init(sys_mem, 1,

                     0x12000000, 32 * M_BYTE,

                     0x20000000, 512 * M_BYTE,

                     get_cps_irq(s->cps, 1), false);



    pcie2 = xilinx_pcie_init(sys_mem, 2,

                             0x14000000, 32 * M_BYTE,

                             0x16000000, 1 * M_BYTE,

                             get_cps_irq(s->cps, 0), true);



    platreg = g_new(MemoryRegion, 1);

    memory_region_init_io(platreg, NULL, &boston_platreg_ops, s,

                          "boston-platregs", 0x1000);

    memory_region_add_subregion_overlap(sys_mem, 0x17ffd000, platreg, 0);



    if (!serial_hds[0]) {

        serial_hds[0] = qemu_chr_new("serial0", "null");

    }



    s->uart = serial_mm_init(sys_mem, 0x17ffe000, 2,

                             get_cps_irq(s->cps, 3), 10000000,

                             serial_hds[0], DEVICE_NATIVE_ENDIAN);



    lcd = g_new(MemoryRegion, 1);

    memory_region_init_io(lcd, NULL, &boston_lcd_ops, s, "boston-lcd", 0x8);

    memory_region_add_subregion_overlap(sys_mem, 0x17fff000, lcd, 0);



    chr = qemu_chr_new("lcd", "vc:320x240");

    qemu_chr_fe_init(&s->lcd_display, chr, NULL);

    qemu_chr_fe_set_handlers(&s->lcd_display, NULL, NULL,

                             boston_lcd_event, s, NULL, true);



    ahci = pci_create_simple_multifunction(&PCI_BRIDGE(&pcie2->root)->sec_bus,

                                           PCI_DEVFN(0, 0),

                                           true, TYPE_ICH9_AHCI);

    g_assert(ARRAY_SIZE(hd) == ICH_AHCI(ahci)->ahci.ports);

    ide_drive_get(hd, ICH_AHCI(ahci)->ahci.ports);

    ahci_ide_create_devs(ahci, hd);



    if (machine->firmware) {

        fw_size = load_image_targphys(machine->firmware,

                                      0x1fc00000, 4 * M_BYTE);

        if (fw_size == -1) {

            error_printf("unable to load firmware image '%s'\n",

                          machine->firmware);

            exit(1);

        }

    } else if (machine->kernel_filename) {

        fit_err = load_fit(&boston_fit_loader, machine->kernel_filename, s);

        if (fit_err) {

            error_printf("unable to load FIT image\n");

            exit(1);

        }



        gen_firmware(memory_region_get_ram_ptr(flash) + 0x7c00000,

                     s->kernel_entry, s->fdt_base, is_64b);

    } else if (!qtest_enabled()) {

        error_printf("Please provide either a -kernel or -bios argument\n");

        exit(1);

    }

}
 and probability:0.37962962962962965
code:static int cng_decode_frame(AVCodecContext *avctx, void *data,
                            int *got_frame_ptr, AVPacket *avpkt)
{
    AVFrame *frame = data;
    CNGContext *p = avctx->priv_data;
    int buf_size  = avpkt->size;
    int ret, i;
    int16_t *buf_out;
    float e = 1.0;
    float scaling;
    if (avpkt->size) {
        int dbov = -avpkt->data[0];
        p->target_energy = 1081109975 * ff_exp10(dbov / 10.0) * 0.75;
        memset(p->target_refl_coef, 0, p->order * sizeof(*p->target_refl_coef));
        for (i = 0; i < FFMIN(avpkt->size - 1, p->order); i++) {
            p->target_refl_coef[i] = (avpkt->data[1 + i] - 127) / 128.0;
    if (p->inited) {
        p->energy = p->energy / 2 + p->target_energy / 2;
        for (i = 0; i < p->order; i++)
            p->refl_coef[i] = 0.6 *p->refl_coef[i] + 0.4 * p->target_refl_coef[i];
    } else {
        p->energy = p->target_energy;
        memcpy(p->refl_coef, p->target_refl_coef, p->order * sizeof(*p->refl_coef));
        p->inited = 1;
    make_lpc_coefs(p->lpc_coef, p->refl_coef, p->order);
    for (i = 0; i < p->order; i++)
        e *= 1.0 - p->refl_coef[i]*p->refl_coef[i];
    scaling = sqrt(e * p->energy / 1081109975);
    for (i = 0; i < avctx->frame_size; i++) {
        int r = (av_lfg_get(&p->lfg) & 0xffff) - 0x8000;
        p->excitation[i] = scaling * r;
    ff_celp_lp_synthesis_filterf(p->filter_out + p->order, p->lpc_coef,
                                 p->excitation, avctx->frame_size, p->order);
    frame->nb_samples = avctx->frame_size;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    buf_out = (int16_t *)frame->data[0];
    for (i = 0; i < avctx->frame_size; i++)
        buf_out[i] = p->filter_out[i + p->order];
    memcpy(p->filter_out, p->filter_out + avctx->frame_size,
           p->order * sizeof(*p->filter_out));
    *got_frame_ptr = 1;
    return buf_size; and probability:0.7209302325581395
code:static int vfio_pci_hot_reset_multi(VFIOPCIDevice *vdev)

{

    return vfio_pci_hot_reset(vdev, false);

}
 and probability:0.0
code:void qerror_print(QError *qerror)

{

    QString *qstring = qerror_human(qerror);

    loc_push_restore(&qerror->loc);

    error_report("%s", qstring_get_str(qstring));

    loc_pop(&qerror->loc);

    QDECREF(qstring);

}
 and probability:0.25
code:static int is_async_return(const QObject *data)

{

    if (data && qobject_type(data) == QTYPE_QDICT) {

        return qdict_haskey(qobject_to_qdict(data), "__mon_async");

    }



    return 0;

}
 and probability:0.0
code:static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)

{

    int e, b, k, n;



    float (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;

    float (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;

    float (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;

    float (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;

    int8_t *opd_hist = ps->opd_hist;

    int8_t *ipd_hist = ps->ipd_hist;

    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;

    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;

    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;

    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;

    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;

    const float (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;



    //Remapping

    if (ps->num_env_old) {

        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));

        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));

        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));

        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));

        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));

        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));

        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));

        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));

    }



    if (is34) {

        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);

        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);

        if (ps->enable_ipdopd) {

            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);

            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);

        }

        if (!ps->is34bands_old) {

            map_val_20_to_34(H11[0][0]);

            map_val_20_to_34(H11[1][0]);

            map_val_20_to_34(H12[0][0]);

            map_val_20_to_34(H12[1][0]);

            map_val_20_to_34(H21[0][0]);

            map_val_20_to_34(H21[1][0]);

            map_val_20_to_34(H22[0][0]);

            map_val_20_to_34(H22[1][0]);

            ipdopd_reset(ipd_hist, opd_hist);

        }

    } else {

        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);

        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);

        if (ps->enable_ipdopd) {

            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);

            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);

        }

        if (ps->is34bands_old) {

            map_val_34_to_20(H11[0][0]);

            map_val_34_to_20(H11[1][0]);

            map_val_34_to_20(H12[0][0]);

            map_val_34_to_20(H12[1][0]);

            map_val_34_to_20(H21[0][0]);

            map_val_34_to_20(H21[1][0]);

            map_val_34_to_20(H22[0][0]);

            map_val_34_to_20(H22[1][0]);

            ipdopd_reset(ipd_hist, opd_hist);

        }

    }



    //Mixing

    for (e = 0; e < ps->num_env; e++) {

        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {

            float h11, h12, h21, h22;

            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];

            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];

            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];

            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];

            if (!PS_BASELINE && ps->enable_ipdopd && b < ps->nr_ipdopd_par) {

                //The spec say says to only run this smoother when enable_ipdopd

                //is set but the reference decoder appears to run it constantly

                float h11i, h12i, h21i, h22i;

                float ipd_adj_re, ipd_adj_im;

                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];

                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];

                float opd_re = pd_re_smooth[opd_idx];

                float opd_im = pd_im_smooth[opd_idx];

                float ipd_re = pd_re_smooth[ipd_idx];

                float ipd_im = pd_im_smooth[ipd_idx];

                opd_hist[b] = opd_idx & 0x3F;

                ipd_hist[b] = ipd_idx & 0x3F;



                ipd_adj_re = opd_re*ipd_re + opd_im*ipd_im;

                ipd_adj_im = opd_im*ipd_re - opd_re*ipd_im;

                h11i = h11 * opd_im;

                h11  = h11 * opd_re;

                h12i = h12 * ipd_adj_im;

                h12  = h12 * ipd_adj_re;

                h21i = h21 * opd_im;

                h21  = h21 * opd_re;

                h22i = h22 * ipd_adj_im;

                h22  = h22 * ipd_adj_re;

                H11[1][e+1][b] = h11i;

                H12[1][e+1][b] = h12i;

                H21[1][e+1][b] = h21i;

                H22[1][e+1][b] = h22i;

            }

            H11[0][e+1][b] = h11;

            H12[0][e+1][b] = h12;

            H21[0][e+1][b] = h21;

            H22[0][e+1][b] = h22;

        }

        for (k = 0; k < NR_BANDS[is34]; k++) {

            float h11r, h12r, h21r, h22r;

            float h11i, h12i, h21i, h22i;

            float h11r_step, h12r_step, h21r_step, h22r_step;

            float h11i_step, h12i_step, h21i_step, h22i_step;

            int start = ps->border_position[e];

            int stop  = ps->border_position[e+1];

            float width = 1.f / (stop - start);

            b = k_to_i[k];

            h11r = H11[0][e][b];

            h12r = H12[0][e][b];

            h21r = H21[0][e][b];

            h22r = H22[0][e][b];

            if (!PS_BASELINE && ps->enable_ipdopd) {

            //Is this necessary? ps_04_new seems unchanged

            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {

                h11i = -H11[1][e][b];

                h12i = -H12[1][e][b];

                h21i = -H21[1][e][b];

                h22i = -H22[1][e][b];

            } else {

                h11i = H11[1][e][b];

                h12i = H12[1][e][b];

                h21i = H21[1][e][b];

                h22i = H22[1][e][b];

            }

            }

            //Interpolation

            h11r_step = (H11[0][e+1][b] - h11r) * width;

            h12r_step = (H12[0][e+1][b] - h12r) * width;

            h21r_step = (H21[0][e+1][b] - h21r) * width;

            h22r_step = (H22[0][e+1][b] - h22r) * width;

            if (!PS_BASELINE && ps->enable_ipdopd) {

                h11i_step = (H11[1][e+1][b] - h11i) * width;

                h12i_step = (H12[1][e+1][b] - h12i) * width;

                h21i_step = (H21[1][e+1][b] - h21i) * width;

                h22i_step = (H22[1][e+1][b] - h22i) * width;

            }

            for (n = start + 1; n <= stop; n++) {

                //l is s, r is d

                float l_re = l[k][n][0];

                float l_im = l[k][n][1];

                float r_re = r[k][n][0];

                float r_im = r[k][n][1];

                h11r += h11r_step;

                h12r += h12r_step;

                h21r += h21r_step;

                h22r += h22r_step;

                if (!PS_BASELINE && ps->enable_ipdopd) {

                    h11i += h11i_step;

                    h12i += h12i_step;

                    h21i += h21i_step;

                    h22i += h22i_step;



                    l[k][n][0] = h11r*l_re + h21r*r_re - h11i*l_im - h21i*r_im;

                    l[k][n][1] = h11r*l_im + h21r*r_im + h11i*l_re + h21i*r_re;

                    r[k][n][0] = h12r*l_re + h22r*r_re - h12i*l_im - h22i*r_im;

                    r[k][n][1] = h12r*l_im + h22r*r_im + h12i*l_re + h22i*r_re;

                } else {

                    l[k][n][0] = h11r*l_re + h21r*r_re;

                    l[k][n][1] = h11r*l_im + h21r*r_im;

                    r[k][n][0] = h12r*l_re + h22r*r_re;

                    r[k][n][1] = h12r*l_im + h22r*r_im;

                }

            }

        }

    }

}
 and probability:0.72
code:static int monitor_read_password(Monitor *mon, ReadLineFunc *readline_func,

                                 void *opaque)

{

    if (mon->rs) {

        readline_start(mon->rs, "Password: ", 1, readline_func, opaque);

        /* prompt is printed on return from the command handler */

        return 0;

    } else {

        monitor_printf(mon, "terminal does not support password prompting\n");

        return -ENOTTY;

    }

}
 and probability:0.16666666666666666
code:static inline void gen_efdnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
 and probability:0.3076923076923077
code:int vhost_dev_init(struct vhost_dev *hdev, void *opaque,

                   VhostBackendType backend_type)

{

    uint64_t features;

    int i, r;



    if (vhost_set_backend_type(hdev, backend_type) < 0) {

        close((uintptr_t)opaque);

        return -1;

    }



    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {

        close((uintptr_t)opaque);

        return -errno;

    }



    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);

    if (r < 0) {

        goto fail;

    }



    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);

    if (r < 0) {

        goto fail;

    }



    for (i = 0; i < hdev->nvqs; ++i) {

        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);

        if (r < 0) {

            goto fail_vq;

        }

    }

    hdev->features = features;



    hdev->memory_listener = (MemoryListener) {

        .begin = vhost_begin,

        .commit = vhost_commit,

        .region_add = vhost_region_add,

        .region_del = vhost_region_del,

        .region_nop = vhost_region_nop,

        .log_start = vhost_log_start,

        .log_stop = vhost_log_stop,

        .log_sync = vhost_log_sync,

        .log_global_start = vhost_log_global_start,

        .log_global_stop = vhost_log_global_stop,

        .eventfd_add = vhost_eventfd_add,

        .eventfd_del = vhost_eventfd_del,

        .priority = 10

    };

    hdev->migration_blocker = NULL;

    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {

        error_setg(&hdev->migration_blocker,

                   "Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.");

        migrate_add_blocker(hdev->migration_blocker);

    }

    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));

    hdev->n_mem_sections = 0;

    hdev->mem_sections = NULL;

    hdev->log = NULL;

    hdev->log_size = 0;

    hdev->log_enabled = false;

    hdev->started = false;

    hdev->memory_changed = false;

    memory_listener_register(&hdev->memory_listener, &address_space_memory);

    return 0;

fail_vq:

    while (--i >= 0) {

        vhost_virtqueue_cleanup(hdev->vqs + i);

    }

fail:

    r = -errno;

    hdev->vhost_ops->vhost_backend_cleanup(hdev);

    return r;

}
 and probability:0.3382352941176471
code:static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,

                       tcg_target_long arg2)

{

    uint8_t *old_code_ptr = s->code_ptr;

    if (type == TCG_TYPE_I32) {

        tcg_out_op_t(s, INDEX_op_ld_i32);

        tcg_out_r(s, ret);

        tcg_out_r(s, arg1);

        tcg_out32(s, arg2);

    } else {

        assert(type == TCG_TYPE_I64);

#if TCG_TARGET_REG_BITS == 64

        tcg_out_op_t(s, INDEX_op_ld_i64);

        tcg_out_r(s, ret);

        tcg_out_r(s, arg1);

        assert(arg2 == (uint32_t)arg2);

        tcg_out32(s, arg2);

#else

        TODO();

#endif

    }

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
 and probability:0.08695652173913043
code:static int tight_send_framebuffer_update(VncState *vs, int x, int y,

                                         int w, int h)

{

    int max_rows;



    if (vs->clientds.pf.bytes_per_pixel == 4 && vs->clientds.pf.rmax == 0xFF &&

        vs->clientds.pf.bmax == 0xFF && vs->clientds.pf.gmax == 0xFF) {

        vs->tight.pixel24 = true;

    } else {

        vs->tight.pixel24 = false;

    }



    if (vs->tight.quality != -1) {

        double freq = vnc_update_freq(vs, x, y, w, h);



        if (freq > tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {

            return send_rect_simple(vs, x, y, w, h, false);

        }

    }



    if (w * h < VNC_TIGHT_MIN_SPLIT_RECT_SIZE) {

        return send_rect_simple(vs, x, y, w, h, true);

    }



    /* Calculate maximum number of rows in one non-solid rectangle. */



    max_rows = tight_conf[vs->tight.compression].max_rect_size;

    max_rows /= MIN(tight_conf[vs->tight.compression].max_rect_width, w);



    return find_large_solid_color_rect(vs, x, y, w, h, max_rows);

}
 and probability:0.375
code:void helper_booke206_tlbwe(CPUPPCState *env)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    uint32_t tlbncfg, tlbn;

    ppcmas_tlb_t *tlb;

    uint32_t size_tlb, size_ps;

    target_ulong mask;





    switch (env->spr[SPR_BOOKE_MAS0] & MAS0_WQ_MASK) {

    case MAS0_WQ_ALWAYS:

        /* good to go, write that entry */

        break;

    case MAS0_WQ_COND:

        /* XXX check if reserved */

        if (0) {

            return;

        }

        break;

    case MAS0_WQ_CLR_RSRV:

        /* XXX clear entry */

        return;

    default:

        /* no idea what to do */

        return;

    }



    if (((env->spr[SPR_BOOKE_MAS0] & MAS0_ATSEL) == MAS0_ATSEL_LRAT) &&

        !msr_gs) {

        /* XXX we don't support direct LRAT setting yet */

        fprintf(stderr, "cpu: don't support LRAT setting yet\n");

        return;

    }



    tlbn = (env->spr[SPR_BOOKE_MAS0] & MAS0_TLBSEL_MASK) >> MAS0_TLBSEL_SHIFT;

    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    tlb = booke206_cur_tlb(env);



    if (!tlb) {

        raise_exception_err_ra(env, POWERPC_EXCP_PROGRAM,

                               POWERPC_EXCP_INVAL |

                               POWERPC_EXCP_INVAL_INVAL, GETPC());

    }



    /* check that we support the targeted size */

    size_tlb = (env->spr[SPR_BOOKE_MAS1] & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    size_ps = booke206_tlbnps(env, tlbn);

    if ((env->spr[SPR_BOOKE_MAS1] & MAS1_VALID) && (tlbncfg & TLBnCFG_AVAIL) &&

        !(size_ps & (1 << size_tlb))) {

        raise_exception_err_ra(env, POWERPC_EXCP_PROGRAM,

                               POWERPC_EXCP_INVAL |

                               POWERPC_EXCP_INVAL_INVAL, GETPC());

    }



    if (msr_gs) {

        cpu_abort(CPU(cpu), "missing HV implementation\n");

    }

    tlb->mas7_3 = ((uint64_t)env->spr[SPR_BOOKE_MAS7] << 32) |

        env->spr[SPR_BOOKE_MAS3];

    tlb->mas1 = env->spr[SPR_BOOKE_MAS1];



    if ((env->spr[SPR_MMUCFG] & MMUCFG_MAVN) == MMUCFG_MAVN_V2) {

        /* For TLB which has a fixed size TSIZE is ignored with MAV2 */

        booke206_fixed_size_tlbn(env, tlbn, tlb);

    } else {

        if (!(tlbncfg & TLBnCFG_AVAIL)) {

            /* force !AVAIL TLB entries to correct page size */

            tlb->mas1 &= ~MAS1_TSIZE_MASK;

            /* XXX can be configured in MMUCSR0 */

            tlb->mas1 |= (tlbncfg & TLBnCFG_MINSIZE) >> 12;

        }

    }



    /* Make a mask from TLB size to discard invalid bits in EPN field */

    mask = ~(booke206_tlb_to_page_size(env, tlb) - 1);

    /* Add a mask for page attributes */

    mask |= MAS2_ACM | MAS2_VLE | MAS2_W | MAS2_I | MAS2_M | MAS2_G | MAS2_E;



    if (!msr_cm) {

        /* Executing a tlbwe instruction in 32-bit mode will set

         * bits 0:31 of the TLB EPN field to zero.

         */

        mask &= 0xffffffff;

    }



    tlb->mas2 = env->spr[SPR_BOOKE_MAS2] & mask;



    if (!(tlbncfg & TLBnCFG_IPROT)) {

        /* no IPROT supported by TLB */

        tlb->mas1 &= ~MAS1_IPROT;

    }



    if (booke206_tlb_to_page_size(env, tlb) == TARGET_PAGE_SIZE) {

        tlb_flush_page(CPU(cpu), tlb->mas2 & MAS2_EPN_MASK);

    } else {

        tlb_flush(CPU(cpu));

    }

}
 and probability:0.18823529411764706
code:static uint32_t qpi_mem_readl(void *opaque, target_phys_addr_t addr)

{

    CPUState *env;



    env = cpu_single_env;

    if (!env)

        return 0;

    return env->eflags & (IF_MASK | IOPL_MASK);

}
 and probability:0.125
code:static void test_visitor_out_number(TestOutputVisitorData *data,

                                    const void *unused)

{

    double value = 3.14;

    QObject *obj;



    visit_type_number(data->ov, NULL, &value, &error_abort);



    obj = visitor_get(data);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);

    g_assert(qfloat_get_double(qobject_to_qfloat(obj)) == value);

}
 and probability:0.1
code:static int find_pte32(CPUPPCState *env, struct mmu_ctx_hash32 *ctx,

                      target_ulong eaddr, int h, int rwx, int target_page_bits)

{

    hwaddr pteg_off;

    target_ulong pte0, pte1;

    int i, good = -1;

    int ret, r;



    ret = -1; /* No entry found */

    pteg_off = get_pteg_offset32(env, ctx->hash[h]);

    for (i = 0; i < HPTES_PER_GROUP; i++) {

        pte0 = ppc_hash32_load_hpte0(env, pteg_off + i*HASH_PTE_SIZE_32);

        pte1 = ppc_hash32_load_hpte1(env, pteg_off + i*HASH_PTE_SIZE_32);

        r = pte_check_hash32(ctx, pte0, pte1, h, rwx);

        LOG_MMU("Load pte from %08" HWADDR_PRIx " => " TARGET_FMT_lx " "

                TARGET_FMT_lx " %d %d %d " TARGET_FMT_lx "\n",

                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,

                (int)((pte0 >> 6) & 1), ctx->ptem);

        switch (r) {

        case -3:

            /* PTE inconsistency */

            return -1;

        case -2:

            /* Access violation */

            ret = -2;

            good = i;

            break;

        case -1:

        default:

            /* No PTE match */

            break;

        case 0:

            /* access granted */

            /* XXX: we should go on looping to check all PTEs consistency

             *      but if we can speed-up the whole thing as the

             *      result would be undefined if PTEs are not consistent.

             */

            ret = 0;

            good = i;

            goto done;

        }

    }

    if (good != -1) {

    done:

        LOG_MMU("found PTE at addr %08" HWADDR_PRIx " prot=%01x ret=%d\n",

                ctx->raddr, ctx->prot, ret);

        /* Update page flags */

        pte1 = ctx->raddr;

        if (ppc_hash32_pte_update_flags(ctx, &pte1, ret, rwx) == 1) {

            ppc_hash32_store_hpte1(env, pteg_off + good * HASH_PTE_SIZE_32,

                                   pte1);

        }

    }



    /* We have a TLB that saves 4K pages, so let's

     * split a huge page to 4k chunks */

    if (target_page_bits != TARGET_PAGE_BITS) {

        ctx->raddr |= (eaddr & ((1 << target_page_bits) - 1))

                      & TARGET_PAGE_MASK;

    }

    return ret;

}
 and probability:0.16666666666666666
code:int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);

    AVPicture dummy_pict;

    int ret;



    if (!desc)

        return AVERROR(EINVAL);

    if ((ret = av_image_check_size(width, height, 0, NULL)) < 0)

        return ret;

    if (desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)

        // do not include palette for these pseudo-paletted formats

        return width * height;

    return avpicture_fill(&dummy_pict, NULL, pix_fmt, width, height);

}
 and probability:0.14285714285714285
code:uint32_t HELPER(testblock)(CPUS390XState *env, uint64_t real_addr)

{

    uintptr_t ra = GETPC();

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int i;



    real_addr = wrap_address(env, real_addr) & TARGET_PAGE_MASK;



    /* Check low-address protection */

    if ((env->cregs[0] & CR0_LOWPROT) && real_addr < 0x2000) {

        cpu_restore_state(cs, ra);

        program_interrupt(env, PGM_PROTECTION, 4);

        return 1;

    }



    for (i = 0; i < TARGET_PAGE_SIZE; i += 8) {

        cpu_stq_real_ra(env, real_addr + i, 0, ra);

    }



    return 0;

}
 and probability:0.17647058823529413
code:static void block_dirty_bitmap_add_prepare(BlkActionState *common,

                                           Error **errp)

{

    Error *local_err = NULL;

    BlockDirtyBitmapAdd *action;

    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,

                                             common, common);



    if (action_check_completion_mode(common, errp) < 0) {

        return;

    }



    action = common->action->u.block_dirty_bitmap_add;

    /* AIO context taken and released within qmp_block_dirty_bitmap_add */

    qmp_block_dirty_bitmap_add(action->node, action->name,

                               action->has_granularity, action->granularity,

                               &local_err);



    if (!local_err) {

        state->prepared = true;

    } else {

        error_propagate(errp, local_err);

    }

}
 and probability:0.19047619047619047
code:int32_t scsi_req_enqueue(SCSIRequest *req, uint8_t *buf)

{

    int32_t rc;



    assert(!req->enqueued);

    scsi_req_ref(req);

    req->enqueued = true;

    QTAILQ_INSERT_TAIL(&req->dev->requests, req, next);



    scsi_req_ref(req);

    rc = req->ops->send_command(req, buf);

    scsi_req_unref(req);

    return rc;

}
 and probability:0.3333333333333333
code:static int sd_parse_uri(BDRVSheepdogState *s, const char *filename,

                        char *vdi, uint32_t *snapid, char *tag)

{

    URI *uri;

    QueryParams *qp = NULL;

    int ret = 0;



    uri = uri_parse(filename);

    if (!uri) {

        return -EINVAL;

    }



    /* transport */

    if (!strcmp(uri->scheme, "sheepdog")) {

        s->is_unix = false;

    } else if (!strcmp(uri->scheme, "sheepdog+tcp")) {

        s->is_unix = false;

    } else if (!strcmp(uri->scheme, "sheepdog+unix")) {

        s->is_unix = true;

    } else {

        ret = -EINVAL;

        goto out;

    }



    if (uri->path == NULL || !strcmp(uri->path, "/")) {

        ret = -EINVAL;

        goto out;

    }

    pstrcpy(vdi, SD_MAX_VDI_LEN, uri->path + 1);



    qp = query_params_parse(uri->query);

    if (qp->n > 1 || (s->is_unix && !qp->n) || (!s->is_unix && qp->n)) {

        ret = -EINVAL;

        goto out;

    }



    if (s->is_unix) {

        /* sheepdog+unix:///vdiname?socket=path */

        if (uri->server || uri->port || strcmp(qp->p[0].name, "socket")) {

            ret = -EINVAL;

            goto out;

        }

        s->host_spec = g_strdup(qp->p[0].value);

    } else {

        /* sheepdog[+tcp]://[host:port]/vdiname */

        s->host_spec = g_strdup_printf("%s:%d", uri->server ?: SD_DEFAULT_ADDR,

                                       uri->port ?: SD_DEFAULT_PORT);

    }



    /* snapshot tag */

    if (uri->fragment) {

        *snapid = strtoul(uri->fragment, NULL, 10);

        if (*snapid == 0) {

            pstrcpy(tag, SD_MAX_VDI_TAG_LEN, uri->fragment);

        }

    } else {

        *snapid = CURRENT_VDI_ID; /* search current vdi */

    }



out:

    if (qp) {

        query_params_free(qp);

    }

    uri_free(uri);

    return ret;

}
 and probability:0.3389830508474576
code:static void rtas_ibm_query_interrupt_source_number(sPAPREnvironment *spapr,

                                                   uint32_t token,

                                                   uint32_t nargs,

                                                   target_ulong args,

                                                   uint32_t nret,

                                                   target_ulong rets)

{

    uint32_t config_addr = rtas_ld(args, 0);

    uint64_t buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);

    unsigned int intr_src_num = -1, ioa_intr_num = rtas_ld(args, 3);

    int ndev;

    sPAPRPHBState *phb = NULL;



    /* Fins sPAPRPHBState */

    phb = find_phb(spapr, buid);

    if (!phb) {

        rtas_st(rets, 0, -3); /* Parameter error */

        return;

    }



    /* Find device descriptor and start IRQ */

    ndev = spapr_msicfg_find(phb, config_addr, false);

    if (ndev < 0) {

        trace_spapr_pci_msi("MSI has not been enabled", -1, config_addr);

        rtas_st(rets, 0, -1); /* Hardware error */

        return;

    }



    intr_src_num = phb->msi_table[ndev].irq + ioa_intr_num;

    trace_spapr_pci_rtas_ibm_query_interrupt_source_number(ioa_intr_num,

                                                           intr_src_num);



    rtas_st(rets, 0, 0);

    rtas_st(rets, 1, intr_src_num);

    rtas_st(rets, 2, 1);/* 0 == level; 1 == edge */

}
 and probability:0.03125
code:static void mpic_irq_raise(openpic_t *mpp, int n_CPU, IRQ_src_t *src)

{

    int n_ci = IDR_CI0 - n_CPU;



    if(test_bit(&src->ide, n_ci)) {

        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_CINT]);

    }

    else {

        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);

    }

}
 and probability:0.4
code:static void tc6393xb_gpio_handler_update(TC6393xbState *s)

{

    uint32_t level, diff;

    int bit;



    level = s->gpio_level & s->gpio_dir;



    for (diff = s->prev_level ^ level; diff; diff ^= 1 << bit) {

        bit = ffs(diff) - 1;

        qemu_set_irq(s->handler[bit], (level >> bit) & 1);

    }



    s->prev_level = level;

}
 and probability:0.45454545454545453
code:static void spapr_cpu_core_realize(DeviceState *dev, Error **errp)

{

    /* We don't use SPAPR_MACHINE() in order to exit gracefully if the user

     * tries to add a sPAPR CPU core to a non-pseries machine.

     */

    sPAPRMachineState *spapr =

        (sPAPRMachineState *) object_dynamic_cast(qdev_get_machine(),

                                                  TYPE_SPAPR_MACHINE);

    sPAPRCPUCore *sc = SPAPR_CPU_CORE(OBJECT(dev));

    sPAPRCPUCoreClass *scc = SPAPR_CPU_CORE_GET_CLASS(OBJECT(dev));

    CPUCore *cc = CPU_CORE(OBJECT(dev));

    size_t size;

    Error *local_err = NULL;

    void *obj;

    int i, j;



    if (!spapr) {

        error_setg(errp, TYPE_SPAPR_CPU_CORE " needs a pseries machine");

        return;

    }



    size = object_type_get_instance_size(scc->cpu_type);

    sc->threads = g_malloc0(size * cc->nr_threads);

    for (i = 0; i < cc->nr_threads; i++) {

        char id[32];

        CPUState *cs;

        PowerPCCPU *cpu;



        obj = sc->threads + i * size;



        object_initialize(obj, size, scc->cpu_type);

        cs = CPU(obj);

        cpu = POWERPC_CPU(cs);

        cs->cpu_index = cc->core_id + i;

        cpu->vcpu_id = (cc->core_id * spapr->vsmt / smp_threads) + i;

        if (kvm_enabled() && !kvm_vcpu_id_is_valid(cpu->vcpu_id)) {

            error_setg(&local_err, "Can't create CPU with id %d in KVM",

                       cpu->vcpu_id);

            error_append_hint(&local_err, "Adjust the number of cpus to %d "

                              "or try to raise the number of threads per core\n",

                              cpu->vcpu_id * smp_threads / spapr->vsmt);

            goto err;

        }





        /* Set NUMA node for the threads belonged to core  */

        cpu->node_id = sc->node_id;



        snprintf(id, sizeof(id), "thread[%d]", i);

        object_property_add_child(OBJECT(sc), id, obj, &local_err);

        if (local_err) {

            goto err;

        }

        object_unref(obj);

    }



    for (j = 0; j < cc->nr_threads; j++) {

        obj = sc->threads + j * size;



        spapr_cpu_core_realize_child(obj, spapr, &local_err);

        if (local_err) {

            goto err;

        }

    }

    return;



err:

    while (--i >= 0) {

        obj = sc->threads + i * size;

        object_unparent(obj);

    }

    g_free(sc->threads);

    error_propagate(errp, local_err);

}
 and probability:0.25
code:static int unpack_block_qpis(Vp3DecodeContext *s, GetBitContext *gb)

{

    int qpi, i, j, bit, run_length, blocks_decoded, num_blocks_at_qpi;

    int num_blocks = s->total_num_coded_frags;



    for (qpi = 0; qpi < s->nqps-1 && num_blocks > 0; qpi++) {

        i = blocks_decoded = num_blocks_at_qpi = 0;



        bit = get_bits1(gb);



        do {

            run_length = get_vlc2(gb, s->superblock_run_length_vlc.table, 6, 2) + 1;

            if (run_length == 34)

                run_length += get_bits(gb, 12);

            blocks_decoded += run_length;



            if (!bit)

                num_blocks_at_qpi += run_length;



            for (j = 0; j < run_length; i++) {

                if (i >= s->total_num_coded_frags)

                    return -1;



                if (s->all_fragments[s->coded_fragment_list[0][i]].qpi == qpi) {

                    s->all_fragments[s->coded_fragment_list[0][i]].qpi += bit;

                    j++;

                }

            }



            if (run_length == MAXIMUM_LONG_BIT_RUN)

                bit = get_bits1(gb);

            else

                bit ^= 1;

        } while (blocks_decoded < num_blocks);



        num_blocks -= num_blocks_at_qpi;

    }



    return 0;

}
 and probability:0.3870967741935484
code:static int coroutine_fn sd_co_flush_to_disk(BlockDriverState *bs)

{

    BDRVSheepdogState *s = bs->opaque;

    SheepdogAIOCB *acb;

    AIOReq *aio_req;



    if (s->cache_flags != SD_FLAG_CMD_CACHE) {

        return 0;

    }



    acb = sd_aio_setup(bs, NULL, 0, 0);

    acb->aiocb_type = AIOCB_FLUSH_CACHE;

    acb->aio_done_func = sd_finish_aiocb;



    aio_req = alloc_aio_req(s, acb, vid_to_vdi_oid(s->inode.vdi_id),

                            0, 0, 0, 0, 0);

    QLIST_INSERT_HEAD(&s->inflight_aio_head, aio_req, aio_siblings);

    add_aio_request(s, aio_req, NULL, 0, false, acb->aiocb_type);



    qemu_coroutine_yield();

    return acb->ret;

}
 and probability:0.4444444444444444
code:void qemu_notify_event(void)

{

    CPUState *env = cpu_single_env;



    qemu_event_increment ();

    if (env) {

        cpu_exit(env);

    }

    if (next_cpu && env != next_cpu) {

        cpu_exit(next_cpu);

    }

    exit_request = 1;

}
 and probability:0.0
code:static void tcg_out_qemu_ld(TCGContext* s, TCGReg data_reg, TCGReg addr_reg,

                            TCGMemOpIdx oi)

{

    TCGMemOp opc = get_memop(oi);

#ifdef CONFIG_SOFTMMU

    unsigned mem_index = get_mmuidx(oi);

    tcg_insn_unit *label_ptr;

    TCGReg base_reg;



    base_reg = tcg_out_tlb_read(s, addr_reg, opc, mem_index, 1);



    label_ptr = s->code_ptr + 1;

    tcg_out_insn(s, RI, BRC, S390_CC_NE, 0);



    tcg_out_qemu_ld_direct(s, opc, data_reg, base_reg, TCG_REG_R2, 0);



    add_qemu_ldst_label(s, 1, oi, data_reg, addr_reg, s->code_ptr, label_ptr);

#else

    TCGReg index_reg;

    tcg_target_long disp;



    tcg_prepare_user_ldst(s, &addr_reg, &index_reg, &disp);

    tcg_out_qemu_ld_direct(s, opc, data_reg, addr_reg, index_reg, disp);

#endif

}
 and probability:0.1
code:char *qdist_pr_plain(const struct qdist *dist, size_t n)

{

    struct qdist binned;

    char *ret;



    if (dist->n == 0) {

        return NULL;

    }

    qdist_bin__internal(&binned, dist, n);

    ret = qdist_pr_internal(&binned);

    qdist_destroy(&binned);

    return ret;

}
 and probability:0.08333333333333333
code:static int dvvideo_encode_frame(AVCodecContext *c, uint8_t *buf, int buf_size,

                                void *data)

{

    DVVideoContext *s = c->priv_data;



    s->sys = dv_codec_profile(c);

    if (!s->sys)

        return -1;

    if(buf_size < s->sys->frame_size)

        return -1;



    c->pix_fmt = s->sys->pix_fmt;

    s->picture = *((AVFrame *)data);

    s->picture.key_frame = 1;

    s->picture.pict_type = FF_I_TYPE;



    s->buf = buf;

    c->execute(c, dv_encode_mt, (void**)&s->dv_anchor[0], NULL,

               s->sys->difseg_size * 27);



    emms_c();

    return s->sys->frame_size;

}
 and probability:0.631578947368421
code:static int mov_read_esds(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];

    int tag, len;



    get_be32(pb); /* version + flags */

    len = mp4_read_descr(c, pb, &tag);

    if (tag == MP4ESDescrTag) {

        get_be16(pb); /* ID */

        get_byte(pb); /* priority */

    } else

        get_be16(pb); /* ID */



    len = mp4_read_descr(c, pb, &tag);

    if (tag == MP4DecConfigDescrTag) {

        int object_type_id = get_byte(pb);

        get_byte(pb); /* stream type */

        get_be24(pb); /* buffer size db */

        get_be32(pb); /* max bitrate */

        get_be32(pb); /* avg bitrate */



        st->codec->codec_id= codec_get_id(ff_mp4_obj_type, object_type_id);

        dprintf(c->fc, "esds object type id %d\n", object_type_id);

        len = mp4_read_descr(c, pb, &tag);

        if (tag == MP4DecSpecificDescrTag) {

            dprintf(c->fc, "Specific MPEG4 header len=%d\n", len);



            st->codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);

            if (!st->codec->extradata)

                return AVERROR(ENOMEM);

            get_buffer(pb, st->codec->extradata, len);

            st->codec->extradata_size = len;

            /* from mplayer */

            if ((*st->codec->extradata >> 3) == 29) {

                st->codec->codec_id = CODEC_ID_MP3ON4;

            }

        }

    }

    return 0;

} and probability:0.2777777777777778
code:static void audio_run_in (AudioState *s)

{

    HWVoiceIn *hw = NULL;



    while ((hw = audio_pcm_hw_find_any_enabled_in (hw))) {

        SWVoiceIn *sw;

        int captured, min;



        captured = hw->pcm_ops->run_in (hw);



        min = audio_pcm_hw_find_min_in (hw);

        hw->total_samples_captured += captured - min;

        hw->ts_helper += captured;



        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {

            sw->total_hw_samples_acquired -= min;



            if (sw->active) {

                int avail;



                avail = audio_get_avail (sw);

                if (avail > 0) {

                    sw->callback.fn (sw->callback.opaque, avail);

                }

            }

        }

    }

}
 and probability:0.3181818181818182
code:static int avs_read_packet(AVFormatContext * s, AVPacket * pkt)

{

    AvsFormat *avs = s->priv_data;

    int sub_type = 0, size = 0;

    AvsBlockType type = AVS_NONE;

    int palette_size = 0;

    uint8_t palette[4 + 3 * 256];

    int ret;



    if (avs->remaining_audio_size > 0)

        if (avs_read_audio_packet(s, pkt) > 0)

            return 0;



    while (1) {

        if (avs->remaining_frame_size <= 0) {

            if (!avio_rl16(s->pb))    /* found EOF */

                return AVERROR(EIO);

            avs->remaining_frame_size = avio_rl16(s->pb) - 4;

        }



        while (avs->remaining_frame_size > 0) {

            sub_type = avio_r8(s->pb);

            type = avio_r8(s->pb);

            size = avio_rl16(s->pb);

            if (size < 4)


            avs->remaining_frame_size -= size;



            switch (type) {

            case AVS_PALETTE:



                ret = avio_read(s->pb, palette, size - 4);

                if (ret < size - 4)

                    return AVERROR(EIO);

                palette_size = size;

                break;



            case AVS_VIDEO:

                if (!avs->st_video) {

                    avs->st_video = av_new_stream(s, AVS_VIDEO);

                    if (avs->st_video == NULL)

                        return AVERROR(ENOMEM);

                    avs->st_video->codec->codec_type = AVMEDIA_TYPE_VIDEO;

                    avs->st_video->codec->codec_id = CODEC_ID_AVS;

                    avs->st_video->codec->width = avs->width;

                    avs->st_video->codec->height = avs->height;

                    avs->st_video->codec->bits_per_coded_sample=avs->bits_per_sample;

                    avs->st_video->nb_frames = avs->nb_frames;

                    avs->st_video->codec->time_base = (AVRational) {

                    1, avs->fps};

                }

                return avs_read_video_packet(s, pkt, type, sub_type, size,

                                             palette, palette_size);



            case AVS_AUDIO:

                if (!avs->st_audio) {

                    avs->st_audio = av_new_stream(s, AVS_AUDIO);

                    if (avs->st_audio == NULL)

                        return AVERROR(ENOMEM);

                    avs->st_audio->codec->codec_type = AVMEDIA_TYPE_AUDIO;

                }

                avs->remaining_audio_size = size - 4;

                size = avs_read_audio_packet(s, pkt);

                if (size != 0)

                    return size;

                break;



            default:

                avio_skip(s->pb, size - 4);

            }

        }

    }

} and probability:0.46875
code:void HELPER(simcall)(CPUXtensaState *env)

{

    uint32_t *regs = env->regs;



    switch (regs[2]) {

    case TARGET_SYS_exit:

        qemu_log("exit(%d) simcall\n", regs[3]);

        exit(regs[3]);

        break;



    case TARGET_SYS_read:

    case TARGET_SYS_write:

        {

            bool is_write = regs[2] == TARGET_SYS_write;

            uint32_t fd = regs[3];

            uint32_t vaddr = regs[4];

            uint32_t len = regs[5];



            while (len > 0) {

                target_phys_addr_t paddr =

                    cpu_get_phys_page_debug(env, vaddr);

                uint32_t page_left =

                    TARGET_PAGE_SIZE - (vaddr & (TARGET_PAGE_SIZE - 1));

                uint32_t io_sz = page_left < len ? page_left : len;

                target_phys_addr_t sz = io_sz;

                void *buf = cpu_physical_memory_map(paddr, &sz, is_write);



                if (buf) {

                    vaddr += io_sz;

                    len -= io_sz;

                    regs[2] = is_write ?

                        write(fd, buf, io_sz) :

                        read(fd, buf, io_sz);

                    regs[3] = errno;

                    cpu_physical_memory_unmap(buf, sz, is_write, sz);

                    if (regs[2] == -1) {

                        break;

                    }

                } else {


                    regs[3] = EINVAL;

                    break;

                }

            }

        }

        break;



    case TARGET_SYS_open:

        {

            char name[1024];

            int rc;

            int i;



            for (i = 0; i < ARRAY_SIZE(name); ++i) {

                rc = cpu_memory_rw_debug(

                        env, regs[3] + i, (uint8_t *)name + i, 1, 0);

                if (rc != 0 || name[i] == 0) {

                    break;

                }

            }



            if (rc == 0 && i < ARRAY_SIZE(name)) {

                regs[2] = open(name, regs[4], regs[5]);

                regs[3] = errno;

            } else {


                regs[3] = EINVAL;

            }

        }

        break;



    case TARGET_SYS_close:

        if (regs[3] < 3) {

            regs[2] = regs[3] = 0;

        } else {

            regs[2] = close(regs[3]);

            regs[3] = errno;

        }

        break;



    case TARGET_SYS_lseek:

        regs[2] = lseek(regs[3], (off_t)(int32_t)regs[4], regs[5]);

        regs[3] = errno;

        break;



    case TARGET_SYS_select_one:

        {

            uint32_t fd = regs[3];

            uint32_t rq = regs[4];

            uint32_t target_tv = regs[5];

            uint32_t target_tvv[2];



            struct timeval tv = {0};

            fd_set fdset;



            FD_ZERO(&fdset);

            FD_SET(fd, &fdset);



            if (target_tv) {

                cpu_memory_rw_debug(env, target_tv,

                        (uint8_t *)target_tvv, sizeof(target_tvv), 0);

                tv.tv_sec = (int32_t)tswap32(target_tvv[0]);

                tv.tv_usec = (int32_t)tswap32(target_tvv[1]);

            }

            regs[2] = select(fd + 1,

                    rq == SELECT_ONE_READ   ? &fdset : NULL,

                    rq == SELECT_ONE_WRITE  ? &fdset : NULL,

                    rq == SELECT_ONE_EXCEPT ? &fdset : NULL,

                    target_tv ? &tv : NULL);

            regs[3] = errno;

        }

        break;



    case TARGET_SYS_argc:

        regs[2] = 1;

        regs[3] = 0;

        break;



    case TARGET_SYS_argv_sz:

        regs[2] = 128;

        regs[3] = 0;

        break;



    case TARGET_SYS_argv:

        {

            struct Argv {

                uint32_t argptr[2];

                char text[120];

            } argv = {

                {0, 0},

                "test"

            };



            argv.argptr[0] = tswap32(regs[3] + offsetof(struct Argv, text));

            cpu_memory_rw_debug(

                    env, regs[3], (uint8_t *)&argv, sizeof(argv), 1);

        }

        break;



    case TARGET_SYS_memset:

        {

            uint32_t base = regs[3];

            uint32_t sz = regs[5];



            while (sz) {

                target_phys_addr_t len = sz;

                void *buf = cpu_physical_memory_map(base, &len, 1);



                if (buf && len) {

                    memset(buf, regs[4], len);

                    cpu_physical_memory_unmap(buf, len, 1, len);

                } else {

                    len = 1;

                }

                base += len;

                sz -= len;

            }

            regs[2] = regs[3];

            regs[3] = 0;

        }

        break;



    default:

        qemu_log("%s(%d): not implemented\n", __func__, regs[2]);



        break;

    }

} and probability:0.3333333333333333
code:static void decode_lpc(int32_t *coeffs, int mode, int length)

{

    int i;



    if (length < 2)

        return;



    if (mode == 1) {

        unsigned a1 = *coeffs++;

        for (i = 0; i < length - 1 >> 1; i++) {

            *coeffs   += a1;

            coeffs[1] += *coeffs;

            a1         = coeffs[1];

            coeffs    += 2;

        }

        if (length - 1 & 1)

            *coeffs += a1;

    } else if (mode == 2) {

        unsigned a1    = coeffs[1];

        unsigned a2    = a1 + *coeffs;

        coeffs[1] = a2;

        if (length > 2) {

            coeffs += 2;

            for (i = 0; i < length - 2 >> 1; i++) {

                unsigned a3    = *coeffs + a1;

                unsigned a4    = a3 + a2;

                *coeffs   = a4;

                a1        = coeffs[1] + a3;

                a2        = a1 + a4;

                coeffs[1] = a2;

                coeffs   += 2;

            }

            if (length & 1)

                *coeffs += a1 + a2;

        }

    } else if (mode == 3) {

        unsigned a1    = coeffs[1];

        unsigned a2    = a1 + *coeffs;

        coeffs[1] = a2;

        if (length > 2) {

            unsigned a3  = coeffs[2];

            unsigned a4  = a3 + a1;

            unsigned a5  = a4 + a2;

            coeffs[2] = a5;

            coeffs += 3;

            for (i = 0; i < length - 3; i++) {

                a3     += *coeffs;

                a4     += a3;

                a5     += a4;

                *coeffs = a5;

                coeffs++;

            }

        }

    }

}
 and probability:0.660377358490566
code:static void term_init(void)

{

#ifndef __MINGW32__

    struct termios tty;



    tcgetattr (0, &tty);

    oldtty = tty;



    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP

                          |INLCR|IGNCR|ICRNL|IXON);

    tty.c_oflag |= OPOST;

    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);

    tty.c_cflag &= ~(CSIZE|PARENB);

    tty.c_cflag |= CS8;

    tty.c_cc[VMIN] = 1;

    tty.c_cc[VTIME] = 0;



    tcsetattr (0, TCSANOW, &tty);

    signal(SIGQUIT, sigterm_handler); /* Quit (POSIX).  */

#endif



    signal(SIGINT , sigterm_handler); /* Interrupt (ANSI).  */

    signal(SIGTERM, sigterm_handler); /* Termination (ANSI).  */

    /*

    register a function to be called at normal program termination

    */

    atexit(term_exit);

#ifdef CONFIG_BEOS_NETSERVER

    fcntl(0, F_SETFL, fcntl(0, F_GETFL) | O_NONBLOCK);

#endif

}
 and probability:0.07407407407407407
code:static int xan_decode_frame_type0(AVCodecContext *avctx)

{

    XanContext *s = avctx->priv_data;

    uint8_t *ybuf, *prev_buf, *src = s->scratch_buffer;

    unsigned  chroma_off, corr_off;

    int cur, last;

    int i, j;

    int ret;



    chroma_off = bytestream2_get_le32(&s->gb);

    corr_off   = bytestream2_get_le32(&s->gb);



    if ((ret = xan_decode_chroma(avctx, chroma_off)) != 0)

        return ret;



    if (corr_off >= bytestream2_size(&s->gb)) {

        av_log(avctx, AV_LOG_WARNING, "Ignoring invalid correction block position\n");

        corr_off = 0;

    }

    bytestream2_seek(&s->gb, 12, SEEK_SET);

    ret = xan_unpack_luma(s, src, s->buffer_size >> 1);

    if (ret) {

        av_log(avctx, AV_LOG_ERROR, "Luma decoding failed\n");

        return ret;

    }



    ybuf = s->y_buffer;

    last = *src++;

    ybuf[0] = last << 1;

    for (j = 1; j < avctx->width - 1; j += 2) {

        cur = (last + *src++) & 0x1F;

        ybuf[j]   = last + cur;

        ybuf[j+1] = cur << 1;

        last = cur;

    }

    ybuf[j]  = last << 1;

    prev_buf = ybuf;

    ybuf += avctx->width;



    for (i = 1; i < avctx->height; i++) {

        last = ((prev_buf[0] >> 1) + *src++) & 0x1F;

        ybuf[0] = last << 1;

        for (j = 1; j < avctx->width - 1; j += 2) {

            cur = ((prev_buf[j + 1] >> 1) + *src++) & 0x1F;

            ybuf[j]   = last + cur;

            ybuf[j+1] = cur << 1;

            last = cur;

        }

        if(j < avctx->width)

            ybuf[j] = last << 1;

        prev_buf = ybuf;

        ybuf += avctx->width;

    }



    if (corr_off) {

        int dec_size;



        bytestream2_seek(&s->gb, 8 + corr_off, SEEK_SET);

        dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size);

        if (dec_size < 0)

            dec_size = 0;

        else

            dec_size = FFMIN(dec_size, s->buffer_size/2 - 1);



        for (i = 0; i < dec_size; i++)

            s->y_buffer[i*2+1] = (s->y_buffer[i*2+1] + (s->scratch_buffer[i] << 1)) & 0x3F;

    }



    src  = s->y_buffer;

    ybuf = s->pic.data[0];

    for (j = 0; j < avctx->height; j++) {

        for (i = 0; i < avctx->width; i++)

            ybuf[i] = (src[i] << 2) | (src[i] >> 3);

        src  += avctx->width;

        ybuf += s->pic.linesize[0];

    }



    return 0;

}
 and probability:0.5507246376811594
code:static int bethsoftvid_decode_frame(AVCodecContext *avctx,

                              void *data, int *data_size,

                              AVPacket *avpkt)

{

    BethsoftvidContext * vid = avctx->priv_data;

    char block_type;

    uint8_t * dst;

    uint8_t * frame_end;

    int remaining = avctx->width;          // number of bytes remaining on a line

    const int wrap_to_next_line = vid->frame.linesize[0] - avctx->width;

    int code;

    int yoffset;



    if (avctx->reget_buffer(avctx, &vid->frame)) {

        av_log(avctx, AV_LOG_ERROR, "reget_buffer() failed\n");

        return -1;

    }



    bytestream2_init(&vid->g, avpkt->data, avpkt->size);

    dst = vid->frame.data[0];

    frame_end = vid->frame.data[0] + vid->frame.linesize[0] * avctx->height;



    switch(block_type = bytestream2_get_byte(&vid->g)){

        case PALETTE_BLOCK: {

            int ret;

            *data_size = 0;

            if ((ret = set_palette(vid)) < 0) {

                av_log(avctx, AV_LOG_ERROR, "error reading palette\n");

                return ret;

            }

            return bytestream2_tell(&vid->g);

        }

        case VIDEO_YOFF_P_FRAME:

            yoffset = bytestream2_get_le16(&vid->g);

            if(yoffset >= avctx->height)

                return -1;

            dst += vid->frame.linesize[0] * yoffset;

    }



    // main code

    while((code = bytestream2_get_byte(&vid->g))){

        int length = code & 0x7f;



        // copy any bytes starting at the current position, and ending at the frame width

        while(length > remaining){

            if(code < 0x80)

                bytestream2_get_buffer(&vid->g, dst, remaining);

            else if(block_type == VIDEO_I_FRAME)

                memset(dst, bytestream2_peek_byte(&vid->g), remaining);

            length -= remaining;      // decrement the number of bytes to be copied

            dst += remaining + wrap_to_next_line;    // skip over extra bytes at end of frame

            remaining = avctx->width;

            if(dst == frame_end)

                goto end;

        }



        // copy any remaining bytes after / if line overflows

        if(code < 0x80)

            bytestream2_get_buffer(&vid->g, dst, length);

        else if(block_type == VIDEO_I_FRAME)

            memset(dst, bytestream2_get_byte(&vid->g), length);

        remaining -= length;

        dst += length;

    }

    end:



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = vid->frame;



    return avpkt->size;

}
 and probability:0.4126984126984127
code:static void decode_delta_d(uint8_t *dst,

                           const uint8_t *buf, const uint8_t *buf_end,

                           int w, int flag, int bpp, int dst_size)

{

    int planepitch = FFALIGN(w, 16) >> 3;

    int pitch = planepitch * bpp;

    int planepitch_byte = (w + 7) / 8;

    unsigned entries, ofssrc;

    GetByteContext gb, ptrs;

    PutByteContext pb;

    int k;



    if (buf_end - buf <= 4 * bpp)

        return;



    bytestream2_init_writer(&pb, dst, dst_size);

    bytestream2_init(&ptrs, buf, bpp * 4);



    for (k = 0; k < bpp; k++) {

        ofssrc = bytestream2_get_be32(&ptrs);



        if (!ofssrc)

            continue;



        if (ofssrc >= buf_end - buf)

            continue;



        bytestream2_init(&gb, buf + ofssrc, buf_end - (buf + ofssrc));



        entries = bytestream2_get_be32(&gb);

        while (entries) {

            int32_t opcode  = bytestream2_get_be32(&gb);

            unsigned offset = bytestream2_get_be32(&gb);



            bytestream2_seek_p(&pb, (offset / planepitch_byte) * pitch + (offset % planepitch_byte) + k * planepitch, SEEK_SET);

            if (opcode >= 0) {

                uint32_t x = bytestream2_get_be32(&gb);

                while (opcode && bytestream2_get_bytes_left_p(&pb) > 0) {

                    bytestream2_put_be32(&pb, x);

                    bytestream2_skip_p(&pb, pitch - 4);

                    opcode--;

                }

            } else {

                opcode = -opcode;

                while (opcode && bytestream2_get_bytes_left(&gb) > 0) {

                    bytestream2_put_be32(&pb, bytestream2_get_be32(&gb));

                    bytestream2_skip_p(&pb, pitch - 4);

                    opcode--;

                }

            }

            entries--;

        }

    }

}
 and probability:0.2826086956521739
code:static void avc_luma_hv_qrt_and_aver_dst_8x8_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    uint32_t loop_cnt;

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src_vt0, src_vt1, src_vt2, src_vt3;

    v16i8 src_vt4, src_vt5, src_vt6, src_vt7, src_vt8;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;

    v8i16 vert_out0, vert_out1, vert_out2, vert_out3;

    v8i16 out0, out1, out2, out3;



    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);



    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_d((v2i64) src_vt0, 1, (v2i64) src_vt1);

    src_vt1 = (v16i8) __msa_insve_d((v2i64) src_vt1, 1, (v2i64) src_vt2);

    src_vt2 = (v16i8) __msa_insve_d((v2i64) src_vt2, 1, (v2i64) src_vt3);

    src_vt3 = (v16i8) __msa_insve_d((v2i64) src_vt3, 1, (v2i64) src_vt4);



    XORI_B4_128_SB(src_vt0, src_vt1, src_vt2, src_vt3);



    for (loop_cnt = 2; loop_cnt--;) {

        LD_SB4(src_x, src_stride, src_hz0, src_hz1, src_hz2, src_hz3);

        XORI_B4_128_SB(src_hz0, src_hz1, src_hz2, src_hz3);

        src_x += (4 * src_stride);



        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);

        hz_out0 = AVC_HORZ_FILTER_SH(src_hz0, mask0, mask1, mask2);

        hz_out1 = AVC_HORZ_FILTER_SH(src_hz1, mask0, mask1, mask2);

        hz_out2 = AVC_HORZ_FILTER_SH(src_hz2, mask0, mask1, mask2);

        hz_out3 = AVC_HORZ_FILTER_SH(src_hz3, mask0, mask1, mask2);

        SRARI_H4_SH(hz_out0, hz_out1, hz_out2, hz_out3, 5);

        SAT_SH4_SH(hz_out0, hz_out1, hz_out2, hz_out3, 7);

        LD_SB4(src_y, src_stride, src_vt5, src_vt6, src_vt7, src_vt8);

        src_y += (4 * src_stride);



        src_vt4 = (v16i8) __msa_insve_d((v2i64) src_vt4, 1, (v2i64) src_vt5);

        src_vt5 = (v16i8) __msa_insve_d((v2i64) src_vt5, 1, (v2i64) src_vt6);

        src_vt6 = (v16i8) __msa_insve_d((v2i64) src_vt6, 1, (v2i64) src_vt7);

        src_vt7 = (v16i8) __msa_insve_d((v2i64) src_vt7, 1, (v2i64) src_vt8);



        XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);

        AVC_CALC_DPADD_B_6PIX_2COEFF_SH(src_vt0, src_vt1, src_vt2, src_vt3,

                                        src_vt4, src_vt5, vert_out0, vert_out1);

        AVC_CALC_DPADD_B_6PIX_2COEFF_SH(src_vt2, src_vt3, src_vt4, src_vt5,

                                        src_vt6, src_vt7, vert_out2, vert_out3);

        SRARI_H4_SH(vert_out0, vert_out1, vert_out2, vert_out3, 5);

        SAT_SH4_SH(vert_out0, vert_out1, vert_out2, vert_out3, 7);



        out0 = __msa_srari_h((hz_out0 + vert_out0), 1);

        out1 = __msa_srari_h((hz_out1 + vert_out1), 1);

        out2 = __msa_srari_h((hz_out2 + vert_out2), 1);

        out3 = __msa_srari_h((hz_out3 + vert_out3), 1);



        SAT_SH4_SH(out0, out1, out2, out3, 7);

        ILVR_D2_UB(dst1, dst0, dst3, dst2, dst0, dst1);

        CONVERT_UB_AVG_ST8x4_UB(out0, out1, out2, out3, dst0, dst1,

                                dst, dst_stride);

        dst += (4 * dst_stride);



        src_vt0 = src_vt4;

        src_vt1 = src_vt5;

        src_vt2 = src_vt6;

        src_vt3 = src_vt7;

        src_vt4 = src_vt8;

    }

}
 and probability:0.15873015873015872
code:static void hScale8To19_c(SwsContext *c, int16_t *_dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>3, (1<<19)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
 and probability:0.2777777777777778
code:static void cpu_notify_map_clients_locked(void)

{

    MapClient *client;



    while (!QLIST_EMPTY(&map_client_list)) {

        client = QLIST_FIRST(&map_client_list);

        client->callback(client->opaque);

        cpu_unregister_map_client(client);

    }

}
 and probability:0.1111111111111111
code:int show_bsfs(void *optctx, const char *opt, const char *arg)

{

    AVBitStreamFilter *bsf = NULL;



    printf("Bitstream filters:\n");

    while ((bsf = av_bitstream_filter_next(bsf)))

        printf("%s\n", bsf->name);

    printf("\n");

    return 0;

}
 and probability:0.1111111111111111
code:static inline int decode_vui_parameters(H264Context *h, SPS *sps){

    MpegEncContext * const s = &h->s;

    int aspect_ratio_info_present_flag;

    unsigned int aspect_ratio_idc;



    aspect_ratio_info_present_flag= get_bits1(&s->gb);



    if( aspect_ratio_info_present_flag ) {

        aspect_ratio_idc= get_bits(&s->gb, 8);

        if( aspect_ratio_idc == EXTENDED_SAR ) {

            sps->sar.num= get_bits(&s->gb, 16);

            sps->sar.den= get_bits(&s->gb, 16);

        }else if(aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)){

            sps->sar=  pixel_aspect[aspect_ratio_idc];

        }else{

            av_log(h->s.avctx, AV_LOG_ERROR, "illegal aspect ratio\n");

            return -1;

        }

    }else{

        sps->sar.num=

        sps->sar.den= 0;

    }

//            s->avctx->aspect_ratio= sar_width*s->width / (float)(s->height*sar_height);



    if(get_bits1(&s->gb)){      /* overscan_info_present_flag */

        get_bits1(&s->gb);      /* overscan_appropriate_flag */

    }



    sps->video_signal_type_present_flag = get_bits1(&s->gb);

    if(sps->video_signal_type_present_flag){

        get_bits(&s->gb, 3);    /* video_format */

        sps->full_range = get_bits1(&s->gb); /* video_full_range_flag */



        sps->colour_description_present_flag = get_bits1(&s->gb);

        if(sps->colour_description_present_flag){

            sps->color_primaries = get_bits(&s->gb, 8); /* colour_primaries */

            sps->color_trc       = get_bits(&s->gb, 8); /* transfer_characteristics */

            sps->colorspace      = get_bits(&s->gb, 8); /* matrix_coefficients */

            if (sps->color_primaries >= AVCOL_PRI_NB)

                sps->color_primaries  = AVCOL_PRI_UNSPECIFIED;

            if (sps->color_trc >= AVCOL_TRC_NB)

                sps->color_trc  = AVCOL_TRC_UNSPECIFIED;

            if (sps->colorspace >= AVCOL_SPC_NB)

                sps->colorspace  = AVCOL_SPC_UNSPECIFIED;

        }

    }



    if(get_bits1(&s->gb)){      /* chroma_location_info_present_flag */

        s->avctx->chroma_sample_location = get_ue_golomb(&s->gb)+1;  /* chroma_sample_location_type_top_field */

        get_ue_golomb(&s->gb);  /* chroma_sample_location_type_bottom_field */

    }



    sps->timing_info_present_flag = get_bits1(&s->gb);

    if(sps->timing_info_present_flag){

        sps->num_units_in_tick = get_bits_long(&s->gb, 32);

        sps->time_scale = get_bits_long(&s->gb, 32);

        if(!sps->num_units_in_tick || !sps->time_scale){

            av_log(h->s.avctx, AV_LOG_ERROR, "time_scale/num_units_in_tick invalid or unsupported (%d/%d)\n", sps->time_scale, sps->num_units_in_tick);

            return -1;

        }

        sps->fixed_frame_rate_flag = get_bits1(&s->gb);

    }



    sps->nal_hrd_parameters_present_flag = get_bits1(&s->gb);

    if(sps->nal_hrd_parameters_present_flag)

        if(decode_hrd_parameters(h, sps) < 0)

            return -1;

    sps->vcl_hrd_parameters_present_flag = get_bits1(&s->gb);

    if(sps->vcl_hrd_parameters_present_flag)

        if(decode_hrd_parameters(h, sps) < 0)

            return -1;

    if(sps->nal_hrd_parameters_present_flag || sps->vcl_hrd_parameters_present_flag)

        get_bits1(&s->gb);     /* low_delay_hrd_flag */

    sps->pic_struct_present_flag = get_bits1(&s->gb);



    sps->bitstream_restriction_flag = get_bits1(&s->gb);

    if(sps->bitstream_restriction_flag){

        get_bits1(&s->gb);     /* motion_vectors_over_pic_boundaries_flag */

        get_ue_golomb(&s->gb); /* max_bytes_per_pic_denom */

        get_ue_golomb(&s->gb); /* max_bits_per_mb_denom */

        get_ue_golomb(&s->gb); /* log2_max_mv_length_horizontal */

        get_ue_golomb(&s->gb); /* log2_max_mv_length_vertical */

        sps->num_reorder_frames= get_ue_golomb(&s->gb);

        get_ue_golomb(&s->gb); /*max_dec_frame_buffering*/



        if (get_bits_left(&s->gb) < 0) {

            av_log(h->s.avctx, AV_LOG_ERROR, "Overread VUI by %d bits\n", -get_bits_left(&s->gb));

            sps->num_reorder_frames=0;

            sps->bitstream_restriction_flag= 0;

        }



        if(sps->num_reorder_frames > 16U /*max_dec_frame_buffering || max_dec_frame_buffering > 16*/){

            av_log(h->s.avctx, AV_LOG_ERROR, "illegal num_reorder_frames %d\n", sps->num_reorder_frames);

            return -1;

        }

    }



    return 0;

}
 and probability:0.6666666666666666
code:void migration_set_incoming_channel(MigrationState *s,

                                    QIOChannel *ioc)

{

    QEMUFile *f = qemu_fopen_channel_input(ioc);



    process_incoming_migration(f);

}
 and probability:0.0
code:static int buffered_rate_limit(void *opaque)

{

    MigrationState *s = opaque;

    int ret;



    ret = qemu_file_get_error(s->file);

    if (ret) {

        return ret;

    }



    if (s->bytes_xfer > s->xfer_limit) {

        return 1;

    }



    return 0;

}
 and probability:0.15384615384615385
code:static const unsigned char *seq_decode_op2(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)

{

    int i;



    for (i = 0; i < 8; i++) {

        memcpy(dst, src, 8);

        src += 8;

        dst += seq->frame.linesize[0];

    }



    return src;

}
 and probability:0.3
code:int opt_default(void *optctx, const char *opt, const char *arg)

{

    const AVOption *o;

    int consumed = 0;

    char opt_stripped[128];

    const char *p;

    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class();

    const av_unused AVClass *rc_class;

    const AVClass *sc, *swr_class;



    if (!strcmp(opt, "debug") || !strcmp(opt, "fdebug"))

        av_log_set_level(AV_LOG_DEBUG);



    if (!(p = strchr(opt, ':')))

        p = opt + strlen(opt);

    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));



    if ((o = av_opt_find(&cc, opt_stripped, NULL, 0,

                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||

        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&

         (o = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ)))) {

        av_dict_set(&codec_opts, opt, arg, FLAGS);

        consumed = 1;

    }

    if ((o = av_opt_find(&fc, opt, NULL, 0,

                              AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {

        av_dict_set(&format_opts, opt, arg, FLAGS);

        if(consumed)

            av_log(NULL, AV_LOG_VERBOSE, "Routing %s to codec and muxer layer\n", opt);

        consumed = 1;

    }

#if CONFIG_SWSCALE

    sc = sws_get_class();

    if (!consumed && av_opt_find(&sc, opt, NULL, 0,

                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) {

        // XXX we only support sws_flags, not arbitrary sws options

        int ret = av_opt_set(sws_opts, opt, arg, 0);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR, "Error setting option %s.\n", opt);

            return ret;

        }

        consumed = 1;

    }

#endif

#if CONFIG_SWRESAMPLE

    swr_class = swr_get_class();

    if (!consumed && av_opt_find(&swr_class, opt, NULL, 0,

                               AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) {

        int ret = av_opt_set(swr_opts, opt, arg, 0);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR, "Error setting option %s.\n", opt);

            return ret;

        }

        consumed = 1;

    }

#endif

#if CONFIG_AVRESAMPLE

    rc_class = avresample_get_class();

    if (av_opt_find(&rc_class, opt, NULL, 0,

                    AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) {

        av_dict_set(&resample_opts, opt, arg, FLAGS);

        consumed = 1;

    }

#endif



    if (consumed)

        return 0;

    return AVERROR_OPTION_NOT_FOUND;

}
 and probability:0.06153846153846154
code:static void event_test_emit(test_QAPIEvent event, QDict *d, Error **errp)

{

    QObject *obj;

    QDict *t;

    int64_t s, ms;



    /* Verify that we have timestamp, then remove it to compare other fields */

    obj = qdict_get(d, "timestamp");

    g_assert(obj);

    t = qobject_to_qdict(obj);

    g_assert(t);

    obj = qdict_get(t, "seconds");

    g_assert(obj && qobject_type(obj) == QTYPE_QINT);

    s = qint_get_int(qobject_to_qint(obj));

    obj = qdict_get(t, "microseconds");

    g_assert(obj && qobject_type(obj) == QTYPE_QINT);

    ms = qint_get_int(qobject_to_qint(obj));

    if (s == -1) {

        g_assert(ms == -1);

    } else {

        g_assert(ms >= 0 && ms <= 999999);

    }

    g_assert(qdict_size(t) == 2);



    qdict_del(d, "timestamp");



    g_assert(qdict_cmp_simple(d, test_event_data->expect));



}
 and probability:0.04
code:void ff_put_h264_qpel8_mc20_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hz_8w_msa(src - 2, stride, dst, stride, 8);

}
 and probability:0.2
code:static void ini_print_object_header(const char *name)

{

    int i;

    PrintElement *el = octx.prefix + octx.level -1;



    if (el->nb_elems)

        avio_printf(probe_out, "\n");



    avio_printf(probe_out, "[");



    for (i = 1; i < octx.level; i++) {

        el = octx.prefix + i;

        avio_printf(probe_out, "%s.", el->name);

        if (el->index >= 0)

            avio_printf(probe_out, "%"PRId64".", el->index);

    }



    avio_printf(probe_out, "%s", name);

    if (el && el->type == ARRAY)

        avio_printf(probe_out, ".%"PRId64"", el->nb_elems);

    avio_printf(probe_out, "]\n");

}
 and probability:0.5
code:int avformat_queue_attached_pictures(AVFormatContext *s)

{

    int i;

    for (i = 0; i < s->nb_streams; i++)

        if (s->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC &&

            s->streams[i]->discard < AVDISCARD_ALL) {

            AVPacket copy = s->streams[i]->attached_pic;

            if (copy.size <= 0)

                return AVERROR(EINVAL);

            copy.buf = av_buffer_ref(copy.buf);

            if (!copy.buf)

                return AVERROR(ENOMEM);



            add_to_pktbuf(&s->raw_packet_buffer, &copy,

                          &s->raw_packet_buffer_end);

        }

    return 0;

}
 and probability:0.35294117647058826
code:static inline void mix_dualmono_to_mono(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++)

        output[1][i] += output[2][i];

    memset(output[2], 0, sizeof(output[2]));

}
 and probability:0.5
